import {
  DefaultValueAccessor,
  FormsModule,
  NG_VALIDATORS,
  NG_VALUE_ACCESSOR,
  NgControl,
  NgControlStatus,
  NgModel,
  RadioControlValueAccessor,
  ReactiveFormsModule
} from "./chunk-YIDS42L6.js";
import {
  AnimationBuilder,
  ButtonComponent,
  ComponentMessages,
  IconComponent,
  IconWrapperComponent,
  IconsService,
  KENDO_BUTTON,
  L10N_PREFIX,
  LocalizationService,
  MessageService,
  PopupService,
  RTL,
  animate,
  cancelIcon,
  caretAltDownIcon,
  caretAltExpandIcon,
  caretAltLeftIcon,
  caretAltRightIcon,
  caretAltToLeftIcon,
  caretAltToRightIcon,
  caretAltUpIcon,
  checkIcon,
  chevronLeftIcon,
  chevronRightIcon,
  document_default,
  dropletSlashIcon,
  dropletSliderIcon,
  exclamationCircleIcon,
  hyperlinkOpenIcon,
  insertBottomIcon,
  insertMiddleIcon,
  insertTopIcon,
  keyframes,
  offset_default,
  paletteIcon,
  plusIcon,
  position_with_scroll_default,
  scrollPosition,
  searchIcon,
  starIcon,
  starOutlineIcon,
  state,
  style,
  transition,
  trigger,
  validatePackage,
  windowIcon,
  windowMinimizeIcon,
  windowRestoreIcon,
  windowViewport,
  xCircleIcon,
  xIcon
} from "./chunk-JGSDV6WC.js";
import {
  Draggable,
  DraggableDirective,
  EventsOutsideAngularDirective,
  KENDO_ADORNMENTS,
  KENDO_TOGGLEBUTTONTABSTOP,
  KendoInput,
  Keys,
  MultiTabStop,
  PrefixTemplateDirective,
  PreventableEvent,
  ResizeBatchService,
  ResizeSensorComponent,
  SeparatorComponent,
  SuffixTemplateDirective,
  TemplateContextDirective,
  ToggleButtonTabStopDirective,
  WatermarkOverlayComponent,
  anyChanged,
  areObjectsEqual,
  browser,
  closest,
  closestInScope,
  contains,
  findFocusableChild,
  focusableSelector,
  getter,
  guid,
  hasObservers,
  isChanged,
  isControlRequired,
  isDocumentAvailable,
  isFocusable,
  isObjectPresent,
  isPresent,
  isSafari,
  mobileOS,
  parseAttributes,
  parseCSSClassNames,
  parseInlineStyles,
  pointers,
  removeHTMLAttributes,
  setHTMLAttributes,
  setter,
  shouldShowValidationUI,
  touchEnabled
} from "./chunk-FLKCPCPR.js";
import {
  AsyncPipe,
  NgClass,
  NgForOf,
  NgIf,
  NgStyle,
  NgSwitch,
  NgSwitchCase,
  NgSwitchDefault,
  NgTemplateOutlet
} from "./chunk-SB3LWG5D.js";
import {
  BehaviorSubject,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ComponentFactoryResolver$1,
  ContentChild,
  ContentChildren,
  Directive,
  EMPTY,
  ElementRef,
  EventEmitter,
  Host,
  HostBinding,
  HostListener,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  KeyValueDiffers,
  LOCALE_ID,
  NgModule,
  NgZone,
  Optional,
  Output,
  Pipe,
  Renderer2,
  ReplaySubject,
  SkipSelf,
  Subject,
  Subscription,
  TemplateRef,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  __async,
  __export,
  __spreadProps,
  __spreadValues,
  auditTime,
  catchError,
  concatMap,
  debounceTime,
  delay,
  filter,
  finalize,
  forwardRef,
  fromEvent,
  inject,
  interval,
  isDevMode,
  map,
  merge,
  of,
  partition,
  setClassMetadata,
  share,
  skip,
  skipWhile,
  startWith,
  switchMap,
  take,
  takeUntil,
  tap,
  throttleTime,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassProp,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵi18nApply,
  ɵɵi18nAttributes,
  ɵɵi18nExp,
  ɵɵinject,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnamespaceSVG,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpropertyInterpolate,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵpureFunction4,
  ɵɵpureFunction5,
  ɵɵpureFunction7,
  ɵɵpureFunctionV,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵresetView,
  ɵɵrestoreView,
  ɵɵsanitizeUrl,
  ɵɵstyleMap,
  ɵɵstyleProp,
  ɵɵsyntheticHostProperty,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtextInterpolate2,
  ɵɵtextInterpolate5,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-ATASIFFF.js";

// node_modules/@progress/kendo-draggable-common/dist/es/algorithms/intersect.js
var getRatio = function(element, target) {
  var elementRect = element.getBoundingClientRect();
  var targetRect = target.getBoundingClientRect();
  var top = Math.max(targetRect.top, elementRect.top);
  var left = Math.max(targetRect.left, elementRect.left);
  var right = Math.min(targetRect.left + targetRect.width, elementRect.left + elementRect.width);
  var bottom = Math.min(targetRect.top + targetRect.height, elementRect.top + elementRect.height);
  var width = right - left;
  var height = bottom - top;
  if (left < right && top < bottom) {
    var targetArea = targetRect.width * targetRect.height;
    var entryArea = elementRect.width * elementRect.height;
    var intersectionArea = width * height;
    var intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
    return Number(intersectionRatio.toFixed(4));
  }
  return 0;
};
var intersect = function(element, candidates) {
  var max = 0;
  var result = null;
  candidates.forEach(function(candidate) {
    if (candidate && element) {
      var ration = getRatio(element, candidate);
      if (ration > max) {
        max = ration;
        result = candidate;
      }
    }
  });
  return result;
};

// node_modules/@progress/kendo-draggable-common/dist/es/utils/index.js
var detectBrowser = function() {
  var ua = window && window.navigator.userAgent;
  if (!ua) {
    return false;
  }
  var browser6 = false;
  var match2 = [];
  var browserRxs = {
    edge: /(edge)[ \/]([\w.]+)/i,
    webkit: /(chrome|crios)[ \/]([\w.]+)/i,
    safari: /(webkit)[ \/]([\w.]+)/i,
    opera: /(opera)(?:.*version|)[ \/]([\w.]+)/i,
    msie: /(msie\s|trident.*? rv:)([\w.]+)/i,
    mozilla: /(mozilla)(?:.*? rv:([\w.]+)|)/i
  };
  for (var agent in browserRxs) {
    if (browserRxs.hasOwnProperty(agent)) {
      match2 = ua.match(browserRxs[agent]);
      if (match2) {
        browser6 = {};
        browser6[agent] = true;
        browser6[match2[1].toLowerCase().split(" ")[0].split("/")[0]] = true;
        browser6.version = parseInt(document.DOCUMENT_NODE || match2[2], 10);
        break;
      }
    }
  }
  return browser6;
};
var getDocument = function(element) {
  return element ? element.ownerDocument || window.document : window.document;
};
var getWindow = function(element) {
  var document2 = getDocument(element);
  return document2 ? document2.defaultView || window : window;
};
var scrollableRoot = function(element) {
  var support3 = {
    browser: detectBrowser()
  };
  var document2 = getDocument(element);
  return support3.browser.edge || support3.browser.safari ? document2.body : document2.documentElement;
};
var isScrollable = function(el) {
  if (el && el.className && typeof el.className === "string" && el.className.indexOf("k-auto-scrollable") > -1) {
    return true;
  }
  var overflow = window.getComputedStyle(el, "overflow").overflow;
  return overflow.indexOf("auto") > -1 || overflow.indexOf("scroll") > -1;
};
var getScrollableParent = function(el) {
  var root = scrollableRoot(el);
  if (!el || el === document.body || el === document.documentElement) {
    return root;
  }
  var parent = el;
  while (parent && parent !== document.body && parent.nodeType !== Node.DOCUMENT_FRAGMENT_NODE && parent.nodeType !== Node.DOCUMENT_NODE && !isScrollable(parent)) {
    parent = parent.parentNode;
  }
  if (parent && (parent === document.body || parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE)) {
    return root;
  }
  return parent;
};
var autoScrollVelocity = function(mouseX, mouseY, rect) {
  var velocity = {
    x: 0,
    y: 0
  };
  var AUTO_SCROLL_AREA = 50;
  if (mouseX - rect.left < AUTO_SCROLL_AREA) {
    velocity.x = -(AUTO_SCROLL_AREA - (mouseX - rect.left));
  } else if (rect.right - mouseX < AUTO_SCROLL_AREA) {
    velocity.x = AUTO_SCROLL_AREA - (rect.right - mouseX);
  }
  if (mouseY - rect.top < AUTO_SCROLL_AREA) {
    velocity.y = -(AUTO_SCROLL_AREA - (mouseY - rect.top));
  } else if (rect.bottom - mouseY < AUTO_SCROLL_AREA) {
    velocity.y = AUTO_SCROLL_AREA - (rect.bottom - mouseY);
  }
  return velocity;
};
var scrollableViewPort = function(el, window2) {
  var root = scrollableRoot(el);
  if (el === root) {
    return {
      top: root.scrollTop,
      left: root.scrollLeft,
      bottom: root.scrollTop + window2.innerHeight,
      right: root.scrollLeft + window2.innerWidth
    };
  } else {
    var rect = el.getBoundingClientRect();
    return {
      bottom: rect.top + rect.height,
      right: rect.left + rect.width,
      left: rect.left,
      top: rect.top
    };
  }
};
var isPointerInsideContainer = function(x, y, container) {
  var rect = container.getBoundingClientRect();
  return rect.top <= y && rect.left <= x && y <= rect.bottom && x <= rect.right;
};

// node_modules/@progress/kendo-draggable-common/dist/es/drag-n-drop.js
var DRAG_AND_DROP_DISPATCH_ACTION;
(function(DRAG_AND_DROP_DISPATCH_ACTION2) {
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_DOWN"] = "pointerdown";
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_MOVE"] = "pointermove";
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_UP"] = "pointerup";
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_CANCEL"] = "pointercancel";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOUSE_DOWN"] = "mousedown";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOUSE_MOVE"] = "mousemove";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOUSE_UP"] = "mouseup";
  DRAG_AND_DROP_DISPATCH_ACTION2["CONTEXT_MENU"] = "contextmenu";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_START"] = "touchstart";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_MOVE"] = "touchmove";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_END"] = "touchend";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_CANCEL"] = "touchcancel";
  DRAG_AND_DROP_DISPATCH_ACTION2["SCROLL"] = "scroll";
  DRAG_AND_DROP_DISPATCH_ACTION2["START"] = "KENDO_DRAG_AND_DROP_START";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOVE"] = "KENDO_DRAG_AND_DROP_MOVE";
  DRAG_AND_DROP_DISPATCH_ACTION2["END"] = "KENDO_DRAG_AND_DROP_END";
  DRAG_AND_DROP_DISPATCH_ACTION2["CANCEL"] = "KENDO_DRAG_AND_DROP_CANCEL";
})(DRAG_AND_DROP_DISPATCH_ACTION || (DRAG_AND_DROP_DISPATCH_ACTION = {}));
var isTouchEvent = function(event) {
  return /^touch/.test(event.type);
};
var isScrollEvent = function(event) {
  return /^(scroll)/.test(event.type);
};
var normalizeEvent = function(event, state2) {
  return isTouchEvent(event) ? {
    pageX: event.changedTouches[0].pageX,
    pageY: event.changedTouches[0].pageY,
    clientX: event.changedTouches[0].clientX,
    clientY: event.changedTouches[0].clientY,
    scrollX: state2.scrollOffset.x,
    scrollY: state2.scrollOffset.y,
    offsetX: state2.offset.x,
    offsetY: state2.offset.y,
    type: event.type,
    originalEvent: event,
    isTouch: true,
    altKey: false,
    ctrlKey: false,
    shiftKey: false,
    metaKey: false
  } : isScrollEvent(event) ? {
    pageX: state2.pageOffset.x,
    pageY: state2.pageOffset.y,
    clientX: state2.clientOffset.x,
    clientY: state2.clientOffset.y,
    scrollX: state2.scrollOffset.x,
    scrollY: state2.scrollOffset.y,
    offsetX: state2.offset.x,
    offsetY: state2.offset.y,
    type: event.type,
    originalEvent: event,
    altKey: false,
    ctrlKey: false,
    shiftKey: false,
    metaKey: false
  } : {
    pageX: event.pageX,
    pageY: event.pageY,
    clientX: event.clientX,
    clientY: event.clientY,
    offsetX: event.offsetX,
    offsetY: event.offsetY,
    scrollX: state2.scrollOffset.x,
    scrollY: state2.scrollOffset.y,
    type: event.type,
    ctrlKey: event.ctrlKey,
    shiftKey: event.shiftKey,
    altKey: event.altKey,
    metaKey: event.metaKey,
    originalEvent: event
  };
};
var noop = function() {
};
var dispatchDragAndDrop = function(state2, action, callbacks) {
  if (callbacks === void 0) {
    callbacks = {};
  }
  var _a2 = callbacks.onIsPressedChange, onIsPressedChange = _a2 === void 0 ? noop : _a2, _b = callbacks.onIsScrollingChange, onIsScrollingChange = _b === void 0 ? noop : _b, _c = callbacks.onVelocityChange, onVelocityChange = _c === void 0 ? noop : _c, _d = callbacks.onOffsetChange, onOffsetChange = _d === void 0 ? noop : _d, _e = callbacks.onPageOffsetChange, onPageOffsetChange = _e === void 0 ? noop : _e, _f = callbacks.onClientOffsetChange, onClientOffsetChange = _f === void 0 ? noop : _f, _g = callbacks.onScrollOffsetChange, onScrollOffsetChange = _g === void 0 ? noop : _g, _h = callbacks.onInitialScrollOffsetChange, onInitialScrollOffsetChange = _h === void 0 ? noop : _h;
  var drag = action.payload;
  var element = drag.element;
  var hint = drag.hint;
  var autoScrollDirection = state2.autoScrollDirection;
  var overrideScrollableParent = state2.scrollableParent;
  var event = normalizeEvent(action.event, state2);
  switch (event.type) {
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_DOWN:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_DOWN && (!event.originalEvent.isPrimary || event.originalEvent.button !== 0)) {
        break;
      }
    // In rare cases where the `which` attribute is available in the mouse event
    // we check if the `left button` is explicitly clicked:
    // https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/which#return_value
    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_DOWN:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_DOWN && event.originalEvent.which && event.originalEvent.which > 1 || state2.ignoreMouse) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_START:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_START && event.originalEvent.touches.length !== 1) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.START: {
      var scrollableParent_1 = overrideScrollableParent || getScrollableParent(action.payload.element);
      onInitialScrollOffsetChange(scrollableParent_1 instanceof Window ? {
        x: scrollableParent_1.scrollX,
        y: scrollableParent_1.scrollY
      } : {
        x: scrollableParent_1.scrollLeft,
        y: scrollableParent_1.scrollTop
      });
      onClientOffsetChange({
        x: event.clientX,
        y: event.clientY
      });
      onPageOffsetChange({
        x: event.pageX,
        y: event.pageY
      });
      onOffsetChange({
        x: event.offsetX,
        y: event.offsetY
      });
      onIsPressedChange(true);
      if (drag.onPress) {
        drag.onPress(event);
      }
      break;
    }
    case DRAG_AND_DROP_DISPATCH_ACTION.SCROLL:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.SCROLL && !state2.pressed) {
        break;
      }
      var scrollableParent = overrideScrollableParent || getScrollableParent(element);
      var scrollOffset = scrollableParent instanceof Window ? {
        x: scrollableParent.scrollX,
        y: scrollableParent.scrollY
      } : {
        x: scrollableParent.scrollLeft,
        y: scrollableParent.scrollTop
      };
      event.scrollX = scrollOffset.x - state2.initialScrollOffset.x;
      event.scrollY = scrollOffset.y - state2.initialScrollOffset.y;
      onScrollOffsetChange({
        x: event.scrollX,
        y: event.scrollY
      });
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_MOVE:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_MOVE && !event.originalEvent.isPrimary) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_MOVE:
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_MOVE:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_MOVE && event.originalEvent.touches.length !== 1) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOVE: {
      if (state2.pressed) {
        if (state2.autoScroll && event.originalEvent.type !== "scroll") {
          if (element) {
            var document_1 = getDocument(element);
            var scrollableParent_2 = overrideScrollableParent || getScrollableParent(document_1.elementFromPoint(event.clientX, event.clientY));
            var newVelocity = autoScrollVelocity(event.clientX, event.clientY, scrollableViewPort(scrollableParent_2, getWindow(element)));
            onVelocityChange({
              x: autoScrollDirection && autoScrollDirection.horizontal === false ? 0 : newVelocity.x,
              y: autoScrollDirection && autoScrollDirection.vertical === false ? 0 : newVelocity.y
            });
            onIsScrollingChange(newVelocity.y !== 0 || newVelocity.x !== 0);
          }
        }
        if (!state2.drag && drag.onDragStart) {
          drag.onDragStart(event);
        }
        if (drag.onDrag) {
          drag.onDrag(event);
        }
        var dropElement_1 = intersect(hint || element, state2.drops.map(function(drop2) {
          return drop2 && drop2.element;
        }).filter(function(d) {
          return d !== (hint || element);
        }));
        var drop = state2.drops.find(function(drop2) {
          return drop2.element === dropElement_1;
        });
        if (drop && dropElement_1 && isPointerInsideContainer(event.clientX, event.clientY, overrideScrollableParent || getScrollableParent(dropElement_1)) && dropElement_1 !== element) {
          if ((state2.drop && state2.drop.element) !== dropElement_1) {
            if (state2.drop && state2.drop.onDragLeave) {
              state2.drop.onDragLeave(event);
            }
            if (drop.onDragEnter) {
              drop.onDragEnter(event);
            }
          } else {
            if (drop.onDragOver) {
              drop.onDragOver(event);
            }
          }
        } else if (state2.drop && state2.drop.onDragLeave) {
          state2.drop.onDragLeave(event);
        }
      }
      onClientOffsetChange({
        x: event.clientX,
        y: event.clientY
      });
      onPageOffsetChange({
        x: event.pageX,
        y: event.pageY
      });
      break;
    }
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_UP:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_UP && !event.originalEvent.isPrimary) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_UP:
    // the last finger has been lifted, and the user is not doing gesture.
    // there might be a better way to handle this.
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_END:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_END && event.originalEvent.touches.length !== 1) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.END: {
      onIsPressedChange(false);
      onIsScrollingChange(false);
      onScrollOffsetChange({
        x: 0,
        y: 0
      });
      if (drag.onRelease) {
        drag.onRelease(event);
      }
      if (state2.drop && state2.drop.onDrop) {
        state2.drop.onDrop(event);
      }
      if (state2.drag && drag.onDragEnd) {
        drag.onDragEnd(event);
      }
      break;
    }
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_CANCEL:
    case DRAG_AND_DROP_DISPATCH_ACTION.CONTEXT_MENU:
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_CANCEL:
    case DRAG_AND_DROP_DISPATCH_ACTION.CANCEL: {
      onIsPressedChange(false);
      onIsScrollingChange(false);
      onScrollOffsetChange({
        x: 0,
        y: 0
      });
      if (drag.onDragEnd) {
        drag.onDragEnd(event);
      }
      if (state2.drop && state2.drop.onDragLeave) {
        state2.drop.onDragLeave(event);
      }
      break;
    }
    default:
      break;
  }
};

// node_modules/@progress/kendo-draggable-common/dist/es/auto-scroll.js
var autoScroll = function(scrollableParent, vel) {
  if (!scrollableParent) {
    return;
  }
  var yIsScrollable;
  var xIsScrollable;
  var isRootNode = scrollableParent === scrollableRoot(scrollableParent);
  if (isRootNode) {
    yIsScrollable = document.body.scrollHeight > window.innerHeight;
    xIsScrollable = document.body.scrollWidth > window.innerWidth;
  } else {
    yIsScrollable = scrollableParent.offsetHeight <= scrollableParent.scrollHeight;
    xIsScrollable = scrollableParent.offsetWidth <= scrollableParent.scrollWidth;
  }
  var yDelta = scrollableParent.scrollTop + vel.y;
  var yInBounds = yIsScrollable && yDelta > 0 && yDelta < scrollableParent.scrollHeight;
  var xDelta = scrollableParent.scrollLeft + vel.x;
  var xInBounds = xIsScrollable && xDelta > 0 && xDelta < scrollableParent.scrollWidth;
  if (yInBounds) {
    scrollableParent.scrollTop += vel.y;
  } else if (yIsScrollable && yDelta < 0) {
    scrollableParent.scrollTop = 0;
  }
  if (xInBounds) {
    scrollableParent.scrollLeft += vel.x;
  } else if (xIsScrollable && xDelta < 0) {
    scrollableParent.scrollLeft = 0;
  }
};

// node_modules/@progress/kendo-angular-utils/fesm2022/progress-kendo-angular-utils.mjs
var _c0 = (a0, a1, a2) => ({
  $implicit: a0,
  index: a1,
  data: a2
});
var DragHandleDirective = class _DragHandleDirective {
  element;
  touchActionStyle = "none";
  /**
   * Specifies the cursor style of the drag handle. Accepts same values as the [CSS `cursor` property](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#values).
   *
   * @default 'move'
   */
  cursorStyle = "move";
  constructor(element) {
    this.element = element;
  }
  static ɵfac = function DragHandleDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragHandleDirective)(ɵɵdirectiveInject(ElementRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DragHandleDirective,
    selectors: [["", "kendoDragHandle", ""]],
    hostVars: 4,
    hostBindings: function DragHandleDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("touch-action", ctx.touchActionStyle)("cursor", ctx.cursorStyle);
      }
    },
    inputs: {
      cursorStyle: "cursorStyle"
    },
    exportAs: ["kendoDragHandle"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragHandleDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDragHandle]",
      exportAs: "kendoDragHandle",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    touchActionStyle: [{
      type: HostBinding,
      args: ["style.touch-action"]
    }],
    cursorStyle: [{
      type: HostBinding,
      args: ["style.cursor"]
    }, {
      type: Input
    }]
  });
})();
var packageMetadata = {
  name: "@progress/kendo-angular-utils",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 1745303852,
  version: "18.5.2",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
function isDocumentNode(container) {
  return container.nodeType === 9;
}
var getAction = (event, draggable) => {
  return {
    event,
    payload: draggable
  };
};
var dragTargetTransition = "transform .3s ease-in-out";
var isPresent2 = (value) => value !== null && value !== void 0;
function closestBySelector(element, selector) {
  if (element.closest) {
    return element.closest(selector);
  }
  const matches3 = Element.prototype.matches ? (el, sel) => el.matches(sel) : (el, sel) => el.msMatchesSelector(sel);
  let node = element;
  while (node && !isDocumentNode(node)) {
    if (matches3(node, selector)) {
      return node;
    }
    node = node.parentNode;
  }
}
var intersect2 = (element, candidates) => {
  let max = 0;
  let result = null;
  candidates.forEach((candidate) => {
    if (candidate && element) {
      const ration = getRatio2(element, candidate);
      if (ration > max) {
        max = ration;
        result = candidate;
      }
    }
  });
  return result;
};
var getRatio2 = (element, target) => {
  const elementRect = element.getBoundingClientRect();
  const targetRect = target.getBoundingClientRect();
  const top = Math.max(targetRect.top, elementRect.top);
  const left = Math.max(targetRect.left, elementRect.left);
  const right = Math.min(targetRect.left + targetRect.width, elementRect.left + elementRect.width);
  const bottom = Math.min(targetRect.top + targetRect.height, elementRect.top + elementRect.height);
  const width = right - left;
  const height = bottom - top;
  if (left < right && top < bottom) {
    const targetArea = targetRect.width * targetRect.height;
    const entryArea = elementRect.width * elementRect.height;
    const intersectionArea = width * height;
    const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
    return Number(intersectionRatio.toFixed(4));
  }
  return 0;
};
var setElementStyles = (renderer, elem, styles) => {
  const props = Object.keys(styles);
  props.forEach((p) => {
    renderer.setStyle(elem, p, styles[p]);
  });
};
var noop2 = () => {
};
var DragStateService = class _DragStateService {
  constructor() {
    this.setCallbacks();
  }
  dragTarget = null;
  dropTarget = null;
  dragTargets = [];
  dropTargets = [];
  pressed = false;
  ignoreMouse = false;
  autoScroll = true;
  isScrolling = false;
  scrollableParent = null;
  autoScrollDirection = {
    horizontal: true,
    vertical: true
  };
  initialClientOffset = {
    x: 0,
    y: 0
  };
  clientOffset = {
    x: 0,
    y: 0
  };
  initialScrollOffset = {
    x: 0,
    y: 0
  };
  scrollOffset = {
    x: 0,
    y: 0
  };
  offset = {
    x: 0,
    y: 0
  };
  pageOffset = {
    x: 0,
    y: 0
  };
  velocity = {
    x: 0,
    y: 0
  };
  dragTargetDirective;
  state;
  dragIndex = null;
  dropIndex = null;
  dragData;
  dragTargetId;
  callbacks = {};
  scrollInterval = null;
  handleDragAndDrop(action) {
    this.updateState();
    dispatchDragAndDrop(this.state, action, this.callbacks);
  }
  setPressed(pressed) {
    this.pressed = pressed;
  }
  setScrolling(isScrolling) {
    this.isScrolling = isScrolling;
    if (isScrolling) {
      const scrollableParent = getScrollableParent(document.elementFromPoint(this.clientOffset.x, this.clientOffset.y));
      window.clearInterval(this.scrollInterval);
      this.scrollInterval = window.setInterval(() => {
        autoScroll(scrollableParent, {
          x: this.velocity.x,
          y: this.velocity.y
        });
      }, 50);
    } else {
      if (this.scrollInterval) {
        window.clearInterval(this.scrollInterval);
        this.scrollInterval = null;
      }
    }
  }
  setVelocity(velocity) {
    this.velocity = velocity;
  }
  setOffset(offset) {
    this.offset = offset;
  }
  setClientOffset(clientOffset) {
    this.clientOffset = clientOffset;
  }
  setPageOffset(pageOffset) {
    this.pageOffset = pageOffset;
  }
  setInitialClientOffset(initialClientOffset) {
    this.initialClientOffset = initialClientOffset;
  }
  setScrollOffset(scrollOffset) {
    this.scrollOffset = scrollOffset;
  }
  setInitialScrollOffset(initialScrollOffset) {
    this.initialScrollOffset = initialScrollOffset;
  }
  get dragTargetPresent() {
    return isPresent2(this.dragTarget?.element);
  }
  get dropTargetPresent() {
    return isPresent2(this.dropTarget?.element);
  }
  updateState() {
    this.state = {
      drag: this.dragTarget,
      drop: this.dropTarget,
      drags: this.dragTargets,
      drops: this.dropTargets,
      pressed: this.pressed,
      ignoreMouse: this.ignoreMouse,
      autoScroll: this.autoScroll,
      isScrolling: this.isScrolling,
      scrollableParent: this.scrollableParent,
      autoScrollDirection: this.autoScrollDirection,
      initialClientOffset: this.initialClientOffset,
      clientOffset: this.clientOffset,
      initialScrollOffset: this.initialScrollOffset,
      scrollOffset: this.scrollOffset,
      offset: this.offset,
      pageOffset: this.pageOffset,
      velocity: this.velocity
    };
  }
  setCallbacks() {
    this.callbacks = {
      onVelocityChange: this.setVelocity.bind(this),
      onOffsetChange: this.setOffset.bind(this),
      onClientOffsetChange: this.setClientOffset.bind(this),
      onPageOffsetChange: this.setPageOffset.bind(this),
      onInitialClientOffsetChange: this.setInitialClientOffset.bind(this),
      onScrollOffsetChange: this.setScrollOffset.bind(this),
      onInitialScrollOffsetChange: this.setInitialScrollOffset.bind(this),
      onIsPressedChange: this.setPressed.bind(this),
      onIsScrollingChange: this.setScrolling.bind(this)
    };
  }
  ngOnDestroy() {
    if (this.scrollInterval) {
      window.clearInterval(this.scrollInterval);
      this.scrollInterval = null;
    }
  }
  static ɵfac = function DragStateService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragStateService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DragStateService,
    factory: _DragStateService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragStateService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [];
  }, null);
})();
var HintComponent = class _HintComponent {
  element;
  template;
  directive;
  targetIndex;
  contextData;
  customContext;
  pointerEvents = "none";
  constructor(element) {
    this.element = element;
  }
  static ɵfac = function HintComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HintComponent)(ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _HintComponent,
    selectors: [["kendo-draghint"]],
    hostVars: 2,
    hostBindings: function HintComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("pointer-events", ctx.pointerEvents);
      }
    },
    inputs: {
      template: "template",
      directive: "directive",
      targetIndex: "targetIndex",
      contextData: "contextData",
      customContext: "customContext"
    },
    decls: 1,
    vars: 6,
    consts: [[3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function HintComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ctx.customContext || ɵɵpureFunction3(2, _c0, ctx.directive, ctx.targetIndex, ctx.contextData));
      }
    },
    dependencies: [NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HintComponent, [{
    type: Component,
    args: [{
      selector: "kendo-draghint",
      template: `
        <ng-container
            [ngTemplateOutlet]="template"
            [ngTemplateOutletContext]="customContext || { $implicit: this.directive, index: this.targetIndex, data: this.contextData }">
        </ng-container>
    `,
      standalone: true,
      imports: [NgTemplateOutlet]
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    template: [{
      type: Input
    }],
    directive: [{
      type: Input
    }],
    targetIndex: [{
      type: Input
    }],
    contextData: [{
      type: Input
    }],
    customContext: [{
      type: Input
    }],
    pointerEvents: [{
      type: HostBinding,
      args: ["style.pointer-events"]
    }]
  });
})();
var DragTargetPressEvent = class {
  /**
   * The normalized drag event.
   */
  dragEvent;
  /**
   * The DOM element that is being dragged.
   */
  dragTarget;
  /**
   * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.
   */
  dragTargetId;
  /**
   * The index of the current drag target in the collection of drag targets (applicable for the `DragTargetContainer` directive).
   */
  dragTargetIndex;
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get normalizedEvent() {
    return this.dragEvent;
  }
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get hostElement() {
    return this.dragTarget;
  }
  /**
   * @hidden
   */
  constructor(args) {
    Object.assign(this, args);
  }
};
var DragTargetDragReadyEvent = class {
  /**
   * The normalized drag event.
   */
  dragEvent;
  /**
   * The DOM element that is being dragged.
   */
  dragTarget;
  /**
   * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.
   */
  dragTargetId;
  /**
   * The index of the current drag target in the collection of drag targets (applicable for the `DragTargetContainer` directive).
   */
  dragTargetIndex;
  /**
   * @hidden
   */
  constructor(args) {
    Object.assign(this, args);
  }
};
var DragTargetDragStartEvent = class extends PreventableEvent {
  /**
   * The normalized drag event.
   */
  dragEvent;
  /**
   * The DOM element that is being dragged.
   */
  dragTarget;
  /**
   * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.
   */
  dragTargetId;
  /**
   * The index of the current drag target in the collection of drag targets (applicable for the `DragTargetContainer` directive).
   */
  dragTargetIndex;
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get normalizedEvent() {
    return this.dragEvent;
  }
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get hostElement() {
    return this.dragTarget;
  }
  /**
   * @hidden
   */
  constructor(args) {
    super();
    Object.assign(this, args);
  }
};
var DragTargetDragEndEvent = class {
  /**
   * The normalized drag event.
   */
  dragEvent;
  /**
   * The DOM element that is being dragged.
   */
  dragTarget;
  /**
   * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.
   */
  dragTargetId;
  /**
   * The index of the current drag target in the collection of drag targets (applicable for the `DragTargetContainer` directive).
   */
  dragTargetIndex;
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get normalizedEvent() {
    return this.dragEvent;
  }
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get hostElement() {
    return this.dragTarget;
  }
  /**
   * @hidden
   */
  constructor(args) {
    Object.assign(this, args);
  }
};
var DragTargetDragEvent = class extends PreventableEvent {
  /**
   * The normalized drag event.
   */
  dragEvent;
  /**
   * The DOM element that is being dragged.
   */
  dragTarget;
  /**
   * The hint of the DragTarget.
   */
  hintElement;
  /**
   * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.
   */
  dragTargetId;
  /**
   * The index of the current drag target in the collection of drag targets (applicable for the `DragTargetContainer` directive).
   */
  dragTargetIndex;
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get normalizedEvent() {
    return this.dragEvent;
  }
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get hostElement() {
    return this.dragTarget;
  }
  /**
   * @hidden
   */
  constructor(args) {
    super();
    Object.assign(this, args);
  }
};
var DragTargetReleaseEvent = class {
  /**
   * The normalized drag event.
   */
  dragEvent;
  /**
   * The DOM element that is being dragged.
   */
  dragTarget;
  /**
   * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.
   */
  dragTargetId;
  /**
   * The index of the current drag target in the collection of drag targets (applicable for the `DragTargetContainer` directive).
   */
  dragTargetIndex;
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get normalizedEvent() {
    return this.dragEvent;
  }
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get hostElement() {
    return this.dragTarget;
  }
  /**
   * @hidden
   */
  constructor(args) {
    Object.assign(this, args);
  }
};
var isDragStartPrevented$1 = false;
var isDragPrevented$1 = false;
var DragTargetContainerDirective = class _DragTargetContainerDirective {
  wrapper;
  ngZone;
  renderer;
  service;
  viewContainer;
  cdr;
  /**
   * Defines whether a hint will be used for dragging. By default, the hint is a copy of the current drag target. ([see example]({% slug drag_hint %})).
   *
   * @default false
   */
  hint = false;
  /**
   * Specifies a selector for elements within a container which will be configured as draggable
   * ([see example]({% slug drag_target_container %})). The possible values include any
   * DOM `selector`.
   */
  set dragTargetFilter(value) {
    this._dragTargetFilter = value;
    if (!this.dragDisabled) {
      this.initializeDragTargets();
    }
  }
  get dragTargetFilter() {
    return this._dragTargetFilter;
  }
  /**
   * Specifies a selector for elements within each DragTarget which will be configured as drag handles.
   */
  dragHandle;
  /**
   * Defines the delay in milliseconds after which the drag will begin ([see example](slug:drag_target_container#toc-events)).
   *
   * @default 0
   */
  dragDelay = 0;
  /**
   * The number of pixels the pointer moves in any direction before the dragging starts ([see example]({% slug minimum_distance %})).
   *
   * @default 0
   */
  threshold = 0;
  /**
   * Defines a unique identifier for each drag target.
   * It exposes the current DragTarget HTML element and its index in the collection of drag targets as arguments.
   */
  set dragTargetId(fn) {
    if (isDevMode && typeof fn !== "function") {
      throw new Error(`dragTargetId must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this._dragTargetId = fn;
  }
  get dragTargetId() {
    return this._dragTargetId;
  }
  /**
   * Defines a callback function which returns custom data passed to the DropTarget events.
   * It exposes the current DragTarget HTML element, its `dragTargetId` and its index in the collection of drag targets as arguments.
   */
  set dragData(fn) {
    if (isDevMode && typeof fn !== "function") {
      throw new Error(`dragData must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this._dragData = fn;
  }
  get dragData() {
    return this._dragData;
  }
  /**
   * If set to true, the dragging of DragTargets within the container will be disabled.
   *
   * @default false
   */
  set dragDisabled(value) {
    this._dragDisabled = value;
    if (value) {
      this.clearPreviousTargets();
      this.removeListeners();
      if (isPresent2(this.hintElem)) {
        this.destroyHint();
      }
    } else {
      if (isPresent2(this.wrapper) || isPresent2(this.currentDragTarget)) {
        this.subscribe();
      }
      this.initializeDragTargets();
    }
  }
  get dragDisabled() {
    return this._dragDisabled;
  }
  /**
   * Specifies whether the default dragging behavior will be performed or the developer will manually handle the drag action.
   *
   * @default 'auto'
   */
  mode = "auto";
  /**
   * Specifies the cursor style of the drag targets. Accepts same values as the [CSS `cursor` property](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#values).
   *
   * @default 'move'
   */
  cursorStyle = "move";
  /**
   * @hidden
   */
  hintContext;
  /**
   * Fires when a DragTarget's `dragDelay` has passed and the user is able to drag the element.
   */
  onDragReady = new EventEmitter();
  /**
   * Fires when the user presses a DragTarget element.
   */
  onPress = new EventEmitter();
  /**
   * Fires when the dragging of a DragTarget element begins.
  */
  onDragStart = new EventEmitter();
  /**
   * Fires while the user drags a DragTarget element.
   */
  onDrag = new EventEmitter();
  /**
   * Fires when the user releases a DragTarget element after being pressed.
   */
  onRelease = new EventEmitter();
  /**
   * Fires when the dragging of a DragTarget ends and the element is released.
   */
  onDragEnd = new EventEmitter();
  /**
   * Used for notifying the DragTargetContainer that its content has changed.
   */
  notify() {
    this.cdr.detectChanges();
    this.initializeDragTargets();
  }
  currentDragTarget = null;
  dragTimeout = null;
  pressed = false;
  dragStarted = false;
  hintComponent = null;
  defaultHint = null;
  currentDragTargetElement = null;
  scrollableParent = null;
  previousDragTargets = [];
  initialPosition = {
    x: 0,
    y: 0
  };
  position = {
    x: 0,
    y: 0
  };
  positionsMap = /* @__PURE__ */ new Map();
  _dragTargetFilter = null;
  _dragDisabled = false;
  _dragData = () => null;
  _dragTargetId = () => null;
  prevUserSelect;
  get allDragTargets() {
    return this.queryHost(this.dragTargetFilter);
  }
  get dragHandles() {
    return this.isHandleSelectorValid ? this.queryHost(this.dragHandle) : null;
  }
  get hintTemplate() {
    return isPresent2(this.hint) && typeof this.hint === "object" ? this.hint.hintTemplate : null;
  }
  constructor(wrapper, ngZone, renderer, service, viewContainer, cdr) {
    this.wrapper = wrapper;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.service = service;
    this.viewContainer = viewContainer;
    this.cdr = cdr;
    validatePackage(packageMetadata);
  }
  ngAfterViewInit() {
    const isTargetPresent = isPresent2(this.wrapper) || isPresent2(this.currentDragTarget);
    if (!this.dragDisabled && isTargetPresent) {
      this.subscribe();
    }
    !this.dragDisabled && this.initializeDragTargets();
  }
  ngOnDestroy() {
    this.removeListeners();
  }
  onPointerDown(event) {
    const filterElement = closestBySelector(event.target, this.isHandleSelectorValid ? this.dragHandle : this.dragTargetFilter);
    if (this.dragTargetFilter === "" || !isPresent2(filterElement)) {
      return;
    }
    if (isPresent2(this.dragHandles) && !this.isDragHandle(event.target)) {
      return;
    }
    const action = getAction(event, this.currentDragTarget);
    this.service.handleDragAndDrop(action);
    this.subscribe();
  }
  onTouchStart(event) {
    const filterElement = closestBySelector(event.target, this.isHandleSelectorValid ? this.dragHandle : this.dragTargetFilter);
    if (this.dragTargetFilter === "" || !isPresent2(filterElement)) {
      return;
    }
    if (isPresent2(this.dragHandles) && !this.isDragHandle(event.target)) {
      return;
    }
    event.preventDefault();
    const action = getAction(event, this.currentDragTarget);
    this.service.handleDragAndDrop(action);
    this.subscribe();
  }
  onPointerMove(event) {
    const action = getAction(event, this.currentDragTarget);
    this.service.handleDragAndDrop(action);
  }
  onTouchMove(event) {
    event.preventDefault();
    const action = getAction(event, this.currentDragTarget);
    this.service.handleDragAndDrop(action);
  }
  onPointerUp(event) {
    const action = getAction(event, this.currentDragTarget);
    this.service.handleDragAndDrop(action);
    this.subscribe();
  }
  onContextMenu(event) {
    event.preventDefault();
    const action = getAction(event, this.currentDragTarget);
    this.service.handleDragAndDrop(action);
    this.subscribe();
  }
  handlePress(event) {
    if (this.dragDelay > 0) {
      this.dragTimeout = window.setTimeout(() => {
        this.pressed = true;
        this.emitZoneAwareEvent("onDragReady", event);
      }, this.dragDelay);
    } else {
      this.pressed = true;
    }
    const eventTarget = event.originalEvent.target;
    this.currentDragTargetElement = closestBySelector(eventTarget, this.dragTargetFilter);
    this.currentDragTarget.element = this.currentDragTargetElement;
    this.service.dragIndex = this.getDragIndex();
    this.scrollableParent = this.hintTemplate ? document.body : this.currentDragTargetElement ? getScrollableParent(this.currentDragTargetElement) : null;
    this.prevUserSelect = this.currentDragTargetElement.style.userSelect;
    this.renderer.setStyle(this.currentDragTargetElement, "user-select", "none");
    this.emitZoneAwareEvent("onPress", event);
  }
  handleDragStart(event) {
    if (!this.pressed) {
      if (this.dragTimeout) {
        window.clearTimeout(this.dragTimeout);
        this.dragTimeout = null;
      }
      return;
    }
    isDragStartPrevented$1 = this.emitZoneAwareEvent("onDragStart", event).isDefaultPrevented();
    if (isDragStartPrevented$1) {
      return;
    }
    this.position = this.positionsMap.has(this.currentDragTargetElement) ? this.positionsMap.get(this.currentDragTargetElement) : {
      x: 0,
      y: 0
    };
    if (this.hint) {
      this.createHint();
      if (this.mode === "auto") {
        this.renderer.setStyle(this.currentDragTargetElement, "opacity", "0.7");
      }
    } else {
      this.initialPosition = {
        x: event.clientX - this.position.x,
        y: event.clientY - this.position.y
      };
    }
    this.dragStarted = this.threshold === 0;
    this.service.dragTarget = this.currentDragTarget;
    const targetIdArgs = {
      dragTarget: this.currentDragTargetElement,
      dragTargetIndex: this.service.dragIndex
    };
    this.service.dragTargetId = this.dragTargetId(targetIdArgs);
    const targetDataArgs = Object.assign({
      dragTargetId: this.service.dragTargetId
    }, targetIdArgs);
    this.service.dragData = this.dragData(targetDataArgs);
  }
  handleDrag(event) {
    if (!this.pressed || isDragStartPrevented$1) {
      return;
    }
    const elem = this.hint ? this.hintElem : this.currentDragTargetElement;
    this.position = this.calculatePosition(elem, event);
    const thresholdNotReached = Math.abs(this.position.x) < this.threshold && Math.abs(this.position.y) < this.threshold;
    if (!this.dragStarted && thresholdNotReached) {
      return;
    }
    if (!this.dragStarted && this.threshold > 0) {
      this.dragStarted = true;
    }
    isDragPrevented$1 = this.emitZoneAwareEvent("onDrag", event).isDefaultPrevented();
    if (isDragPrevented$1) {
      return;
    }
    if (this.mode === "auto") {
      this.performDrag();
    } else {
      this.dragStarted = true;
    }
  }
  handleRelease(event) {
    if (this.dragStarted) {
      this.positionsMap.set(this.currentDragTargetElement, this.position);
    }
    if (this.dragTimeout) {
      clearTimeout(this.dragTimeout);
      this.dragTimeout = null;
    }
    this.pressed = false;
    this.prevUserSelect ? this.renderer.setStyle(this.currentDragTargetElement, "user-select", this.prevUserSelect) : this.renderer.removeStyle(this.currentDragTargetElement, "user-select");
    this.prevUserSelect = null;
    this.emitZoneAwareEvent("onRelease", event);
  }
  handleDragEnd(event) {
    if (!this.dragStarted) {
      return;
    }
    if (this.mode === "auto") {
      const isDroppedOverParentTarget = isPresent2(this.service.dropTarget) && !contains(this.service.dropTarget?.element, this.service.dragTarget?.element, true);
      const elem = this.hint ? this.hintElem : this.currentDragTargetElement;
      if (isDroppedOverParentTarget || this.service.dropTargets.length > 0 && isPresent2(elem)) {
        this.renderer.removeStyle(elem, "transform");
        setElementStyles(this.renderer, elem, {
          transition: dragTargetTransition
        });
        this.positionsMap.delete(this.currentDragTargetElement);
      }
    }
    if (this.hint && isPresent2(this.hintElem)) {
      this.destroyHint();
      if (this.mode === "auto") {
        this.renderer.removeStyle(this.currentDragTargetElement, "opacity");
      }
    }
    this.service.dragTarget = null;
    this.service.dragIndex = null;
    this.currentDragTarget.element = null;
    this.emitZoneAwareEvent("onDragEnd", event);
    if (isDragStartPrevented$1 || isDragPrevented$1) {
      return;
    }
    this.dragStarted = false;
  }
  get nativeElement() {
    return this.wrapper.nativeElement;
  }
  get hintElem() {
    return this.hintTemplate && isPresent2(this.hintComponent) ? this.hintComponent.instance.element.nativeElement : this.defaultHint;
  }
  removeListeners() {
    if (isPresent2(this.scrollableParent)) {
      this.scrollableParent.removeEventListener("scroll", this.onPointerMove);
    }
    const element = this.nativeElement;
    if (!isDocumentAvailable()) {
      return;
    }
    document.removeEventListener("pointermove", this.onPointerMove);
    document.removeEventListener("pointerup", this.onPointerUp, true);
    document.removeEventListener("pointercancel", this.onPointerUp);
    document.removeEventListener("contextmenu", this.onContextMenu);
    window.removeEventListener("touchmove", noop2);
    element.removeEventListener("touchmove", this.onTouchMove);
    element.removeEventListener("touchend", this.onPointerUp);
    document.removeEventListener("mousemove", this.onPointerMove);
    document.removeEventListener("mouseup", this.onPointerUp);
    document.removeEventListener("touchcancel", this.onPointerUp);
    element.removeEventListener("pointerdown", this.onPointerDown);
    element.removeEventListener("mousedown", this.onPointerDown);
    element.removeEventListener("touchstart", this.onTouchStart);
  }
  get supportPointerEvent() {
    return Boolean(typeof window !== "undefined" && window.PointerEvent);
  }
  subscribe() {
    this.ngZone.runOutsideAngular(() => {
      this.removeListeners();
      if (!(isDocumentAvailable() && isPresent2(this.wrapper))) {
        return;
      }
      this.onPointerMove = this.onPointerMove.bind(this);
      this.onPointerUp = this.onPointerUp.bind(this);
      this.onTouchMove = this.onTouchMove.bind(this);
      this.onContextMenu = this.onContextMenu.bind(this);
      this.onPointerDown = this.onPointerDown.bind(this);
      this.onTouchStart = this.onTouchStart.bind(this);
      const element = this.nativeElement;
      if (this.supportPointerEvent) {
        if (isPresent2(this.scrollableParent)) {
          this.scrollableParent.addEventListener("scroll", this.onPointerMove, {
            passive: true
          });
        }
        element.addEventListener("pointerdown", this.onPointerDown, {
          passive: true
        });
        if (this.pressed) {
          document.addEventListener("pointermove", this.onPointerMove);
          document.addEventListener("pointerup", this.onPointerUp, true);
          document.addEventListener("contextmenu", this.onContextMenu);
          document.addEventListener("pointercancel", this.onPointerUp, {
            passive: true
          });
        }
      } else {
        window.addEventListener("touchmove", noop2, {
          capture: false,
          passive: false
        });
        element.addEventListener("mousedown", this.onPointerDown, {
          passive: true
        });
        element.addEventListener("touchstart", this.onTouchStart, {
          passive: true
        });
        if (this.pressed) {
          document.addEventListener("mousemove", this.onPointerMove, {
            passive: true
          });
          document.addEventListener("mouseup", this.onPointerUp, {
            passive: true
          });
          element.addEventListener("touchmove", this.onTouchMove, {
            passive: true
          });
          element.addEventListener("touchend", this.onPointerUp, {
            passive: true
          });
        }
      }
    });
  }
  emitZoneAwareEvent(event, normalizedEvent) {
    const targetIdArgs = {
      dragTarget: this.currentDragTargetElement,
      dragTargetIndex: this.service.dragIndex
    };
    const eventProps = {
      dragTarget: this.currentDragTargetElement,
      dragEvent: normalizedEvent,
      dragTargetIndex: this.service.dragIndex,
      dragTargetId: this.dragTargetId(targetIdArgs)
    };
    if (this.hint && isPresent2(this.hintElem)) {
      eventProps.hintElement = this.hintElem;
    }
    let eventArgs;
    switch (event) {
      case "onDragReady":
        eventArgs = new DragTargetDragReadyEvent(eventProps);
        break;
      case "onPress":
        eventArgs = new DragTargetPressEvent(eventProps);
        break;
      case "onDragStart":
        eventArgs = new DragTargetDragStartEvent(eventProps);
        break;
      case "onDrag":
        eventArgs = new DragTargetDragEvent(eventProps);
        break;
      case "onRelease":
        eventArgs = new DragTargetReleaseEvent(eventProps);
        break;
      case "onDragEnd":
        eventArgs = new DragTargetDragEndEvent(eventProps);
        break;
      default:
        break;
    }
    this.ngZone.run(() => {
      this[event].emit(eventArgs);
    });
    return eventArgs;
  }
  createHint() {
    if (!(isDocumentAvailable() && isPresent2(this.wrapper))) {
      return;
    }
    if (isPresent2(this.hint) && typeof this.hint === "object") {
      if (isPresent2(this.hint.hintTemplate)) {
        this.createCustomHint();
      } else {
        this.createDefaultHint();
      }
    } else {
      this.createDefaultHint();
    }
    this.currentDragTarget.hint = this.hintElem;
    if (typeof this.hint === "object" && isPresent2(this.hint.appendTo)) {
      this.hint.appendTo.element.nativeElement.appendChild(this.hintElem);
    } else {
      document.body.appendChild(this.hintElem);
    }
  }
  createDefaultHint() {
    this.defaultHint = this.currentDragTargetElement.cloneNode(true);
    if (typeof this.hint === "object") {
      if (isPresent2(this.hint.hintClass)) {
        const hintClasses = parseCSSClassNames(this.hint.hintClass);
        hintClasses.forEach((className) => this.renderer.addClass(this.defaultHint, className));
      }
    }
  }
  createCustomHint() {
    if (isPresent2(this.hint.appendTo)) {
      this.hintComponent = this.hint.appendTo.createComponent(HintComponent);
    } else {
      this.hintComponent = this.viewContainer.createComponent(HintComponent);
    }
    this.hintComponent.instance.template = this.hintTemplate;
    this.hintComponent.instance.directive = this;
    this.hintComponent.instance.targetIndex = this.service.dragIndex;
    const targetDataArgs = {
      dragTarget: this.currentDragTargetElement,
      dragTargetId: this.service.dragTargetId,
      dragTargetIndex: this.service.dragIndex
    };
    this.hintComponent.instance.contextData = this.dragData(targetDataArgs);
    this.hintComponent.instance.customContext = this.hintContext;
    this.hintComponent.changeDetectorRef.detectChanges();
  }
  destroyHint() {
    if (isPresent2(this.hintTemplate)) {
      this.hintComponent.destroy();
      this.hintComponent.changeDetectorRef.detectChanges();
      this.hintComponent = null;
    } else {
      document.body.removeChild(this.defaultHint);
      this.defaultHint = null;
    }
    this.currentDragTarget.hint = null;
  }
  getDragIndex() {
    return this.allDragTargets.indexOf(this.currentDragTargetElement);
  }
  initializeDragTargets() {
    if (!isPresent2(this.allDragTargets)) {
      if (this.previousDragTargets.length > 0) {
        this.clearPreviousTargets();
      }
      return;
    }
    this.allDragTargets.forEach((dragTargetEl) => {
      const isDragTargetInitialized = this.service.dragTargets.find((dt) => dt.element === dragTargetEl);
      if (!isDragTargetInitialized) {
        this.service.dragTargets.push({
          element: dragTargetEl,
          hint: null,
          onPress: this.handlePress.bind(this),
          onRelease: this.handleRelease.bind(this),
          onDragStart: this.handleDragStart.bind(this),
          onDrag: this.handleDrag.bind(this),
          onDragEnd: this.handleDragEnd.bind(this)
        });
      }
    });
    if (this.previousDragTargets.length > 0) {
      const dragTargetsToRemove = this.previousDragTargets.filter((dt) => !this.allDragTargets.includes(dt));
      dragTargetsToRemove.forEach((dragTarget) => {
        const idx2 = this.service.dragTargets.findIndex((serviceDragTarget) => serviceDragTarget.element === dragTarget);
        if (idx2 > -1) {
          this.service.dragTargets.splice(idx2, 1);
        }
      });
    }
    this.previousDragTargets = this.allDragTargets;
    this.currentDragTarget = {
      element: null,
      hint: null,
      onPress: this.handlePress.bind(this),
      onRelease: this.handleRelease.bind(this),
      onDragStart: this.handleDragStart.bind(this),
      onDrag: this.handleDrag.bind(this),
      onDragEnd: this.handleDragEnd.bind(this)
    };
    this.setTargetStyles();
  }
  isDragHandle(el) {
    return this.dragHandles.some((dh) => contains(dh, el, true));
  }
  get isHandleSelectorValid() {
    return isPresent2(this.dragHandle) && this.dragHandle !== "";
  }
  setTargetStyles() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (isPresent2(this.dragHandle) && this.dragHandle !== "") {
      if (isPresent2(this.dragHandles) && this.dragHandles.length > 0) {
        this.dragHandles.forEach((handle) => {
          this.renderer.setStyle(handle, "cursor", this.cursorStyle);
          this.renderer.setStyle(handle, "touch-action", "none");
        });
      }
    } else {
      this.allDragTargets.forEach((target) => {
        this.renderer.setStyle(target, "cursor", this.cursorStyle);
        this.renderer.setStyle(target, "touch-action", "none");
      });
    }
  }
  queryHost(selector) {
    if (isPresent2(selector) && selector !== "") {
      return Array.from(this.nativeElement.querySelectorAll(selector));
    }
  }
  clearPreviousTargets() {
    this.previousDragTargets.forEach((dragTarget) => {
      const idx2 = this.service.dragTargets.findIndex((serviceDragTarget) => serviceDragTarget.element === dragTarget);
      if (idx2 > -1) {
        this.service.dragTargets.splice(idx2, 1);
      }
    });
    this.previousDragTargets = [];
  }
  performDrag() {
    const elem = this.hint ? this.hintElem : this.currentDragTargetElement;
    if (elem) {
      const styles = this.getStylesPerElement(elem);
      setElementStyles(this.renderer, elem, styles);
    }
  }
  calculatePosition(element, event) {
    let position = null;
    if (!isDocumentAvailable()) {
      return {
        x: 0,
        y: 0
      };
    }
    if (element === this.hintElem) {
      position = {
        x: event.clientX + window.scrollX,
        y: event.clientY + window.scrollY
      };
    } else {
      position = {
        x: event.clientX - this.initialPosition.x + event.scrollX,
        y: event.clientY - this.initialPosition.y + event.scrollY
      };
    }
    return position;
  }
  getStylesPerElement(element) {
    if (element === this.hintElem) {
      return {
        top: `${this.position.y}px`,
        left: `${this.position.x}px`,
        transition: "none",
        position: "absolute",
        zIndex: 1999
      };
    } else {
      const transform3 = `translate(${this.position.x}px, ${this.position.y}px)`;
      return {
        transform: transform3,
        transition: "none"
      };
    }
  }
  static ɵfac = function DragTargetContainerDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragTargetContainerDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DragStateService), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DragTargetContainerDirective,
    selectors: [["", "kendoDragTargetContainer", ""]],
    inputs: {
      hint: "hint",
      dragTargetFilter: "dragTargetFilter",
      dragHandle: "dragHandle",
      dragDelay: "dragDelay",
      threshold: "threshold",
      dragTargetId: "dragTargetId",
      dragData: "dragData",
      dragDisabled: "dragDisabled",
      mode: "mode",
      cursorStyle: "cursorStyle",
      hintContext: "hintContext"
    },
    outputs: {
      onDragReady: "onDragReady",
      onPress: "onPress",
      onDragStart: "onDragStart",
      onDrag: "onDrag",
      onRelease: "onRelease",
      onDragEnd: "onDragEnd"
    },
    exportAs: ["kendoDragTargetContainer"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragTargetContainerDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDragTargetContainer]",
      exportAs: "kendoDragTargetContainer",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: DragStateService
    }, {
      type: ViewContainerRef
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    hint: [{
      type: Input
    }],
    dragTargetFilter: [{
      type: Input
    }],
    dragHandle: [{
      type: Input
    }],
    dragDelay: [{
      type: Input
    }],
    threshold: [{
      type: Input
    }],
    dragTargetId: [{
      type: Input
    }],
    dragData: [{
      type: Input
    }],
    dragDisabled: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    cursorStyle: [{
      type: Input
    }],
    hintContext: [{
      type: Input
    }],
    onDragReady: [{
      type: Output
    }],
    onPress: [{
      type: Output
    }],
    onDragStart: [{
      type: Output
    }],
    onDrag: [{
      type: Output
    }],
    onRelease: [{
      type: Output
    }],
    onDragEnd: [{
      type: Output
    }]
  });
})();
var isDragStartPrevented = false;
var isDragPrevented = false;
var DragTargetDirective = class _DragTargetDirective {
  element;
  renderer;
  ngZone;
  service;
  viewContainer;
  get touchActionStyle() {
    return this.dragHandles.length > 0 ? null : "none";
  }
  /**
   * Defines whether a hint will be used for dragging. By default, the hint is a copy of the drag target. ([see example]({% slug drag_hint %})).
   *
   * @default false
   */
  hint = false;
  /**
   * The number of pixels the pointer moves in any direction before the dragging starts ([see example]({% slug minimum_distance %})). Applicable when `manualDrag` is set to `false`.
   *
   * @default 0
   */
  threshold = 0;
  /**
   * Defines the automatic container scrolling behavior when close to the edge ([see example]({% slug auto_scroll %})).
   *
   * @default true
   */
  autoScroll = true;
  /**
   * Defines a unique identifier for the dragTarget.
   */
  dragTargetId;
  /**
   * Defines the delay in milliseconds after which the drag will begin ([see example]({% slug drag_delay %})).
   *
   * @default 0
   */
  dragDelay = 0;
  /**
   * Restricts the element to be dragged horizontally or vertically only ([see example]({% slug axis_lock %})). Applicable when `mode` is set to `auto`.
   */
  restrictByAxis;
  /**
   * Specifies whether the default dragging behavior will be performed or the developer will manually handle the drag action.
   *
   * @default 'auto'
   */
  mode = "auto";
  /**
   * Defines a callback function used for attaching custom data to the dragTarget.
   * The data will be available in the events of the respective [`DropTarget`]({% slug api_utils_droptargetdirective %}) or [`DropTargetContainer`]({% slug api_utils_droptargetcontainerdirective %}) directives.
   * The current DragTarget HTML element and its `dragTargetId` will be available as arguments.
   */
  set dragData(fn) {
    if (isDevMode && typeof fn !== "function") {
      throw new Error(`dragData must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this._dragData = fn;
  }
  get dragData() {
    return this._dragData;
  }
  /**
   * Specifies the cursor style of the drag target. Accepts same values as the [CSS `cursor` property](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#values).
   *
   * @default 'move'
   */
  cursorStyle = "move";
  /**
   * Fires when the user presses the DragTarget element.
   */
  onPress = new EventEmitter();
  /**
   * Fires when the dragging of the DragTarget element begins.
   */
  onDragStart = new EventEmitter();
  /**
   * Fires while the user drags the DragTarget element.
   */
  onDrag = new EventEmitter();
  /**
   * Fires when the DragTarget's `dragDelay` has passed and the user is able to drag the element.
   */
  onDragReady = new EventEmitter();
  /**
   * Fires when the user releases the DragTarget element after being pressed.
   */
  onRelease = new EventEmitter();
  /**
   * Fires when the dragging of the DragTarget ends and the element is released.
   */
  onDragEnd = new EventEmitter();
  dragTarget = null;
  hintComponent = null;
  dragStarted = false;
  pressed = false;
  dragTimeout = null;
  initialPosition = {
    x: 0,
    y: 0
  };
  position = {
    x: 0,
    y: 0
  };
  scrollableParent = null;
  defaultHint = null;
  _dragData = () => null;
  prevUserSelect;
  get hintTemplate() {
    return isPresent2(this.hint) && typeof this.hint === "object" ? this.hint.hintTemplate : null;
  }
  get nativeElement() {
    return this.element.nativeElement;
  }
  get hintElem() {
    return this.hintTemplate && isPresent2(this.hintComponent) ? this.hintComponent.instance.element.nativeElement : this.defaultHint;
  }
  onPointerDown(event) {
    if (this.dragHandles.length && !this.isDragHandle(event.target)) {
      return;
    }
    const action = getAction(event, this.dragTarget);
    this.service.handleDragAndDrop(action);
    this.service.autoScroll = typeof this.autoScroll === "object" ? this.autoScroll.enabled !== false : this.autoScroll;
    this.service.scrollableParent = this.getAutoScrollContainer();
    this.service.autoScrollDirection = typeof this.autoScroll === "object" ? this.autoScroll.direction : {
      horizontal: true,
      vertical: true
    };
    this.attachDomHandlers();
  }
  onTouchStart(event) {
    if (this.dragHandles.length && !this.isDragHandle(event.target)) {
      return;
    }
    event.preventDefault();
    const action = getAction(event, this.dragTarget);
    this.service.handleDragAndDrop(action);
    this.service.autoScroll = typeof this.autoScroll === "object" ? this.autoScroll.enabled !== false : this.autoScroll;
    this.service.scrollableParent = this.getAutoScrollContainer();
    this.service.autoScrollDirection = typeof this.autoScroll === "object" ? this.autoScroll.direction : {
      horizontal: true,
      vertical: true
    };
    this.attachDomHandlers();
  }
  onPointerMove(event) {
    const action = getAction(event, this.dragTarget);
    this.service.handleDragAndDrop(action);
  }
  onTouchMove(event) {
    event.preventDefault();
    const action = getAction(event, this.dragTarget);
    this.service.handleDragAndDrop(action);
  }
  onPointerUp(event) {
    const action = getAction(event, this.dragTarget);
    this.service.handleDragAndDrop(action);
    this.attachDomHandlers();
  }
  onContextMenu(event) {
    event.preventDefault();
    const action = getAction(event, this.dragTarget);
    this.service.handleDragAndDrop(action);
    this.attachDomHandlers();
  }
  dragHandles;
  constructor(element, renderer, ngZone, service, viewContainer) {
    this.element = element;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.service = service;
    this.viewContainer = viewContainer;
    validatePackage(packageMetadata);
  }
  ngOnInit() {
    this.initializeDragTarget();
  }
  ngAfterContentInit() {
    if (isPresent2(this.element) || isPresent2(this.dragTarget)) {
      this.attachDomHandlers();
      if (!this.dragHandles.length) {
        this.renderer.setStyle(this.nativeElement, "cursor", this.cursorStyle);
      }
    }
    this.service.dragTargets.push(this.dragTarget);
  }
  ngOnDestroy() {
    this.removeListeners();
    const currentDragTargetIndex = this.service.dragTargets.indexOf(this.dragTarget);
    this.service.dragTargets.splice(currentDragTargetIndex, 1);
  }
  handlePress(event) {
    if (this.dragDelay > 0) {
      this.dragTimeout = window.setTimeout(() => {
        this.pressed = true;
        this.emitZoneAwareEvent("onDragReady", event);
      }, this.dragDelay);
    } else {
      this.pressed = true;
    }
    this.scrollableParent = this.dragTarget.element ? getScrollableParent(this.dragTarget.element) : null;
    this.prevUserSelect = this.dragTarget.element.style.userSelect;
    this.renderer.setStyle(this.dragTarget.element, "user-select", "none");
    this.emitZoneAwareEvent("onPress", event);
  }
  handleDragStart(event) {
    if (!this.pressed) {
      if (this.dragTimeout) {
        window.clearTimeout(this.dragTimeout);
        this.dragTimeout = null;
      }
      return;
    }
    isDragStartPrevented = this.emitZoneAwareEvent("onDragStart", event).isDefaultPrevented();
    if (isDragStartPrevented) {
      return;
    }
    if (this.hint) {
      this.createHint();
      if (this.mode === "auto") {
        this.renderer.setStyle(this.nativeElement, "opacity", "0.7");
      }
      this.initialPosition = {
        x: event.offsetX,
        y: event.offsetY
      };
    } else {
      this.initialPosition = {
        x: event.clientX - this.position.x,
        y: event.clientY - this.position.y
      };
    }
    this.dragStarted = this.threshold === 0;
    this.service.dragTarget = this.dragTarget;
    this.service.dragTargetDirective = this;
    this.service.dragData = this.dragData({
      dragTarget: this.dragTarget.element,
      dragTargetId: this.dragTargetIdResult,
      dragTargetIndex: null
    });
  }
  handleDrag(event) {
    if (!this.pressed || isDragStartPrevented) {
      return;
    }
    const elem = this.hint ? this.hintElem : this.nativeElement;
    this.position = this.calculatePosition(elem, event);
    const thresholdNotReached = Math.abs(this.position.x) < this.threshold && Math.abs(this.position.y) < this.threshold;
    if (!this.dragStarted && thresholdNotReached) {
      return;
    }
    if (!this.dragStarted && this.threshold > 0) {
      this.dragStarted = true;
    }
    isDragPrevented = this.emitZoneAwareEvent("onDrag", event).isDefaultPrevented();
    if (isDragPrevented) {
      return;
    }
    if (this.mode === "auto") {
      this.performDrag();
    } else {
      this.dragStarted = true;
    }
  }
  handleRelease(event) {
    if (this.dragTimeout) {
      clearTimeout(this.dragTimeout);
      this.dragTimeout = null;
    }
    this.pressed = false;
    this.prevUserSelect ? this.renderer.setStyle(this.dragTarget.element, "user-select", this.prevUserSelect) : this.renderer.removeStyle(this.dragTarget.element, "user-select");
    this.prevUserSelect = null;
    this.emitZoneAwareEvent("onRelease", event);
  }
  handleDragEnd(event) {
    if (this.mode === "auto") {
      const isDroppedOverParentTarget = isPresent2(this.service.dropTarget) && !contains(this.service.dropTarget?.element, this.service.dragTarget?.element, true);
      const elem = this.hint ? this.hintElem : this.nativeElement;
      if (isDroppedOverParentTarget || this.service.dropTargets.length > 0 && isPresent2(elem)) {
        this.renderer.removeStyle(elem, "transform");
        setElementStyles(this.renderer, elem, {
          transition: dragTargetTransition
        });
        this.position = {
          x: 0,
          y: 0
        };
      }
    }
    if (this.hint && isPresent2(this.hintElem)) {
      this.destroyHint();
      if (this.mode === "auto") {
        this.renderer.removeStyle(this.nativeElement, "opacity");
      }
    }
    this.service.dragTarget = null;
    this.service.dragTargetDirective = null;
    if (!this.dragStarted || isDragStartPrevented || isDragPrevented) {
      return;
    }
    this.emitZoneAwareEvent("onDragEnd", event);
    this.dragStarted = false;
  }
  initializeDragTarget() {
    this.dragTarget = {
      element: this.nativeElement,
      hint: null,
      onPress: this.handlePress.bind(this),
      onRelease: this.handleRelease.bind(this),
      onDragStart: this.handleDragStart.bind(this),
      onDrag: this.handleDrag.bind(this),
      onDragEnd: this.handleDragEnd.bind(this)
    };
  }
  get supportPointerEvent() {
    return Boolean(typeof window !== "undefined" && window.PointerEvent);
  }
  removeListeners() {
    if (isPresent2(this.scrollableParent)) {
      this.scrollableParent.removeEventListener("scroll", this.onPointerMove);
    }
    const element = this.nativeElement;
    if (!isDocumentAvailable()) {
      return;
    }
    document.removeEventListener("pointermove", this.onPointerMove);
    document.removeEventListener("pointerup", this.onPointerUp, true);
    document.removeEventListener("contextmenu", this.onContextMenu);
    document.removeEventListener("pointercancel", this.onPointerUp);
    window.removeEventListener("touchmove", noop2);
    element.removeEventListener("touchmove", this.onTouchMove);
    element.removeEventListener("touchend", this.onPointerUp);
    document.removeEventListener("mousemove", this.onPointerMove);
    document.removeEventListener("mouseup", this.onPointerUp);
    document.removeEventListener("touchcancel", this.onPointerUp);
    element.removeEventListener("pointerdown", this.onPointerDown);
    element.removeEventListener("mousedown", this.onPointerDown);
    element.removeEventListener("touchstart", this.onTouchStart);
  }
  attachDomHandlers() {
    this.ngZone.runOutsideAngular(() => {
      this.removeListeners();
      if (!(isDocumentAvailable() && isPresent2(this.element))) {
        return;
      }
      this.onPointerMove = this.onPointerMove.bind(this);
      this.onPointerUp = this.onPointerUp.bind(this);
      this.onTouchMove = this.onTouchMove.bind(this);
      this.onContextMenu = this.onContextMenu.bind(this);
      this.onPointerDown = this.onPointerDown.bind(this);
      this.onTouchStart = this.onTouchStart.bind(this);
      const element = this.nativeElement;
      if (this.supportPointerEvent) {
        if (isPresent2(this.scrollableParent)) {
          if (this.scrollableParent === document.getElementsByTagName("html")[0]) {
            this.scrollableParent = window;
          }
          this.scrollableParent.addEventListener("scroll", this.onPointerMove, {
            passive: true
          });
        }
        element.addEventListener("pointerdown", this.onPointerDown, {
          passive: true
        });
        if (this.pressed) {
          document.addEventListener("pointermove", this.onPointerMove);
          document.addEventListener("pointerup", this.onPointerUp, true);
          document.addEventListener("contextmenu", this.onContextMenu);
          document.addEventListener("pointercancel", this.onPointerUp, {
            passive: true
          });
        }
      } else {
        window.addEventListener("touchmove", noop2, {
          capture: false,
          passive: false
        });
        element.addEventListener("mousedown", this.onPointerDown, {
          passive: true
        });
        element.addEventListener("touchstart", this.onTouchStart, {
          passive: true
        });
        if (this.pressed) {
          document.addEventListener("mousemove", this.onPointerMove, {
            passive: true
          });
          document.addEventListener("mouseup", this.onPointerUp, {
            passive: true
          });
          element.addEventListener("touchmove", this.onTouchMove, {
            passive: true
          });
          element.addEventListener("touchend", this.onPointerUp, {
            passive: true
          });
        }
      }
    });
  }
  isDragHandle(el) {
    return this.dragHandles.toArray().some((dh) => contains(dh.element.nativeElement, el, true));
  }
  getAutoScrollContainer() {
    return typeof this.autoScroll === "object" && this.autoScroll.boundaryElementRef && this.autoScroll.boundaryElementRef.nativeElement ? this.autoScroll.boundaryElementRef.nativeElement : null;
  }
  createHint() {
    if (!(isDocumentAvailable() && isPresent2(this.element))) {
      return;
    }
    if (isPresent2(this.hint) && typeof this.hint === "object") {
      if (isPresent2(this.hint.hintTemplate)) {
        this.createCustomHint();
      } else {
        this.createDefaultHint();
      }
    } else {
      this.createDefaultHint();
    }
    this.dragTarget.hint = this.hintElem;
    if (typeof this.hint === "object" && isPresent2(this.hint.appendTo)) {
      this.hint.appendTo.element.nativeElement.appendChild(this.hintElem);
    } else {
      document.body.appendChild(this.hintElem);
    }
  }
  createDefaultHint() {
    this.defaultHint = this.nativeElement.cloneNode(true);
    if (typeof this.hint === "object") {
      if (isPresent2(this.hint.hintClass)) {
        const hintClasses = parseCSSClassNames(this.hint.hintClass);
        hintClasses.forEach((className) => this.renderer.addClass(this.defaultHint, className));
      }
    }
  }
  createCustomHint() {
    if (isPresent2(this.hint.appendTo)) {
      this.hintComponent = this.hint.appendTo.createComponent(HintComponent);
    } else {
      this.hintComponent = this.viewContainer.createComponent(HintComponent);
    }
    this.hintComponent.instance.template = this.hintTemplate;
    this.hintComponent.instance.directive = this;
    this.hintComponent.changeDetectorRef.detectChanges();
  }
  destroyHint() {
    if (isPresent2(this.hintTemplate)) {
      this.hintComponent.destroy();
      this.hintComponent.changeDetectorRef.detectChanges();
      this.hintComponent = null;
    } else {
      if (typeof this.hint === "object" && isPresent2(this.hint.appendTo)) {
        this.hint.appendTo.element.nativeElement.removeChild(this.defaultHint);
      } else {
        document.body.removeChild(this.defaultHint);
      }
      this.defaultHint = null;
    }
    this.dragTarget.hint = null;
  }
  emitZoneAwareEvent(event, normalizedEvent) {
    const eventProps = {
      dragTarget: this.nativeElement,
      dragEvent: normalizedEvent
    };
    if (this.hint && isPresent2(this.hintElem)) {
      eventProps.hintElement = this.hintElem;
    }
    if (this.dragTargetId && this.dragTargetId !== "") {
      eventProps.dragTargetId = this.dragTargetIdResult;
    }
    let eventArgs;
    switch (event) {
      case "onDragReady":
        eventArgs = new DragTargetDragReadyEvent(eventProps);
        break;
      case "onPress":
        eventArgs = new DragTargetPressEvent(eventProps);
        break;
      case "onDragStart":
        eventArgs = new DragTargetDragStartEvent(eventProps);
        break;
      case "onDrag":
        eventArgs = new DragTargetDragEvent(eventProps);
        break;
      case "onRelease":
        eventArgs = new DragTargetReleaseEvent(eventProps);
        break;
      case "onDragEnd":
        eventArgs = new DragTargetDragEndEvent(eventProps);
        break;
      default:
        break;
    }
    this.ngZone.run(() => {
      this[event].emit(eventArgs);
    });
    return eventArgs;
  }
  get dragTargetIdResult() {
    if (this.dragTargetId && this.dragTargetId !== "") {
      return typeof this.dragTargetId === "string" ? this.dragTargetId : this.dragTargetId({
        dragTarget: this.dragTarget.element,
        dragTargetIndex: null
      });
    }
  }
  performDrag() {
    const elem = this.hint ? this.hintElem : this.nativeElement;
    if (elem) {
      const styles = this.getStylesPerElement(elem);
      setElementStyles(this.renderer, elem, styles);
    }
  }
  calculatePosition(element, event) {
    let position = null;
    if (element === this.hintElem) {
      position = {
        x: event.clientX + window.scrollX,
        y: event.clientY + window.scrollY
      };
    } else {
      position = {
        x: event.clientX - this.initialPosition.x + event.scrollX,
        y: event.clientY - this.initialPosition.y + event.scrollY
      };
    }
    if (this.restrictByAxis === "horizontal") {
      position.y = 0;
    } else if (this.restrictByAxis === "vertical") {
      position.x = 0;
    }
    return position;
  }
  getStylesPerElement(element) {
    if (element === this.hintElem) {
      const hintCoordinates = {
        x: this.position.x - this.initialPosition.x,
        y: this.position.y - this.initialPosition.y
      };
      return {
        top: `${hintCoordinates.y}px`,
        left: `${hintCoordinates.x}px`,
        transition: "none",
        position: "absolute",
        zIndex: 1999
      };
    } else {
      const transform3 = `translate(${this.position.x}px, ${this.position.y}px)`;
      return {
        transform: transform3,
        transition: "none"
      };
    }
  }
  static ɵfac = function DragTargetDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragTargetDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(DragStateService), ɵɵdirectiveInject(ViewContainerRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DragTargetDirective,
    selectors: [["", "kendoDragTarget", ""]],
    contentQueries: function DragTargetDirective_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, DragHandleDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dragHandles = _t);
      }
    },
    hostVars: 2,
    hostBindings: function DragTargetDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("touch-action", ctx.touchActionStyle);
      }
    },
    inputs: {
      hint: "hint",
      threshold: "threshold",
      autoScroll: "autoScroll",
      dragTargetId: "dragTargetId",
      dragDelay: "dragDelay",
      restrictByAxis: "restrictByAxis",
      mode: "mode",
      dragData: "dragData",
      cursorStyle: "cursorStyle"
    },
    outputs: {
      onPress: "onPress",
      onDragStart: "onDragStart",
      onDrag: "onDrag",
      onDragReady: "onDragReady",
      onRelease: "onRelease",
      onDragEnd: "onDragEnd"
    },
    exportAs: ["kendoDragTarget"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragTargetDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDragTarget]",
      exportAs: "kendoDragTarget",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: DragStateService
    }, {
      type: ViewContainerRef
    }];
  }, {
    touchActionStyle: [{
      type: HostBinding,
      args: ["style.touch-action"]
    }],
    hint: [{
      type: Input
    }],
    threshold: [{
      type: Input
    }],
    autoScroll: [{
      type: Input
    }],
    dragTargetId: [{
      type: Input
    }],
    dragDelay: [{
      type: Input
    }],
    restrictByAxis: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    dragData: [{
      type: Input
    }],
    cursorStyle: [{
      type: Input
    }],
    onPress: [{
      type: Output
    }],
    onDragStart: [{
      type: Output
    }],
    onDrag: [{
      type: Output
    }],
    onDragReady: [{
      type: Output
    }],
    onRelease: [{
      type: Output
    }],
    onDragEnd: [{
      type: Output
    }],
    dragHandles: [{
      type: ContentChildren,
      args: [DragHandleDirective, {
        descendants: true
      }]
    }]
  });
})();
var DropTargetEvent = class {
  /**
   * The current drag target element.
   */
  dragTarget;
  /**
   * The current drop target element.
   */
  dropTarget;
  /**
   * The information related to the current drag event.
   */
  dragEvent;
  /**
   * The data passed to the `dragData` input property of the `DragTarget` or `DragTargetContainer` directive.
   */
  dragData;
  /**
   * The index of the current drop target in the collection of drop targets (applicable for the `DropTargetContainer` directive).
   */
  dropTargetIndex;
  /**
   * The hint of the DragTarget.
   */
  hintElement;
  /**
   * Left for backward compatibility for the DropTarget deprecated events.
   * @hidden
   */
  get normalizedEvent() {
    return this.dragEvent;
  }
  /**
   * Left for backward compatibility for the DropTarget deprecated events.
   * @hidden
   */
  get hostElement() {
    return this.dropTarget;
  }
  /**
   * @hidden
   */
  constructor(args) {
    Object.assign(this, args);
  }
};
var DropTargetContainerDirective = class _DropTargetContainerDirective {
  service;
  element;
  ngZone;
  cdr;
  /**
   * Specifies a selector for elements within a container which will be configured as drop targets
   * ([see example]({% slug drop_target_container %})). The possible values include any
   * DOM `selector`.
   */
  set dropTargetFilter(value) {
    this._dropTargetFilter = value;
    if (!this.dropDisabled) {
      this.initializeDropTargets();
    }
  }
  get dropTargetFilter() {
    return this._dropTargetFilter;
  }
  /**
   * Specifies whether the Drop Targets within the container will emit the corresponding events upon interaction with a Drag Target.
   */
  set dropDisabled(value) {
    this._dropDisabled = value;
    if (value) {
      this.clearPreviousTargets();
    } else {
      this.initializeDropTargets();
    }
  }
  get dropDisabled() {
    return this._dropDisabled;
  }
  /**
   * Fires when a DragTarget element enters the DropTarget.
   */
  onDragEnter = new EventEmitter();
  /**
   * Fires when a DragTarget element is being dragged over the DropTarget.
   */
  onDragOver = new EventEmitter();
  /**
   * Fires when a DragTarget element leaves the DropTarget.
   */
  onDragLeave = new EventEmitter();
  /**
   * Fires when a DragTarget element is dropped over the DropTarget.
   */
  onDrop = new EventEmitter();
  /**
   * Used for notifying the DropTargetContainer that its content has changed.
   */
  notify() {
    this.cdr.detectChanges();
    this.initializeDropTargets();
  }
  constructor(service, element, ngZone, cdr) {
    this.service = service;
    this.element = element;
    this.ngZone = ngZone;
    this.cdr = cdr;
    validatePackage(packageMetadata);
  }
  currentDropTargetElement = null;
  previousDropTargets = [];
  _dropTargetFilter = null;
  _dropDisabled = false;
  get nativeElement() {
    return this.element.nativeElement;
  }
  ngAfterViewInit() {
    !this.dropDisabled && this.initializeDropTargets();
  }
  get allDropTargets() {
    if (isPresent2(this.dropTargetFilter) && this.dropTargetFilter !== "") {
      return Array.from(this.nativeElement.querySelectorAll(this.dropTargetFilter));
    }
  }
  /**
   * @hidden
   */
  handleDragEnter(event) {
    if (!this.service.dragTargetPresent || this.service.dropTargetPresent) {
      return;
    }
    const currDragTargetElement = this.service.dragTarget.hint || this.service.dragTarget.element;
    const currDropTargetElem = intersect2(currDragTargetElement, this.allDropTargets);
    const currDropTarget = this.service.dropTargets.find((dt) => dt.element === currDropTargetElem);
    if (!isPresent2(currDropTargetElem) || !isPresent2(currDropTarget)) {
      return;
    }
    this.currentDropTargetElement = currDropTargetElem;
    this.service.dropTarget = currDropTarget;
    this.service.dropIndex = this.getDropIndex();
    this.emitZoneAwareEvent("onDragEnter", event);
  }
  /**
   * @hidden
   */
  handleDragLeave(event) {
    if (!this.service.dragTargetPresent || !this.service.dropTargetPresent) {
      return;
    }
    this.emitZoneAwareEvent("onDragLeave", event);
    this.currentDropTargetElement = null;
    this.service.dropTarget = null;
    this.service.dropIndex = null;
  }
  /**
   * @hidden
   */
  handleDragOver(event) {
    if (!this.service.dragTargetPresent || !this.service.dropTargetPresent) {
      return;
    }
    this.emitZoneAwareEvent("onDragOver", event);
  }
  /**
   * @hidden
   */
  handleDrop(event) {
    if (!this.service.dragTargetPresent || !this.service.dropTargetPresent) {
      return;
    }
    this.emitZoneAwareEvent("onDrop", event);
    this.currentDropTargetElement = null;
    this.service.dropTarget = null;
    this.service.dropIndex = null;
  }
  initializeDropTargets() {
    if (!isPresent2(this.allDropTargets)) {
      if (this.previousDropTargets.length > 0) {
        this.clearPreviousTargets();
      }
      return;
    }
    this.allDropTargets.forEach((dropTargetEl) => {
      const isDropTargetInitialized = this.service.dropTargets.find((dt) => dt.element === dropTargetEl);
      if (!isDropTargetInitialized) {
        this.service.dropTargets.push({
          element: dropTargetEl,
          onDragEnter: this.handleDragEnter.bind(this),
          onDragLeave: this.handleDragLeave.bind(this),
          onDragOver: this.handleDragOver.bind(this),
          onDrop: this.handleDrop.bind(this)
        });
      }
    });
    if (this.previousDropTargets.length > 0) {
      const dropTargetsToRemove = this.previousDropTargets.filter((dt) => !this.allDropTargets.includes(dt));
      dropTargetsToRemove.forEach((dropTarget) => {
        const idx2 = this.service.dropTargets.findIndex((serviceDropTarget) => serviceDropTarget.element === dropTarget);
        if (idx2 > -1) {
          this.service.dropTargets.splice(idx2, 1);
        }
      });
    }
    this.previousDropTargets = this.allDropTargets;
  }
  emitZoneAwareEvent(event, normalizedEvent) {
    const eventProps = {
      dragTarget: this.service.dragTarget?.element,
      dropTarget: this.currentDropTargetElement,
      dragData: this.service.dragData,
      dragEvent: normalizedEvent,
      dropTargetIndex: this.service.dropIndex
    };
    if (isPresent2(this.service.dragTarget?.hint)) {
      eventProps.hintElement = this.service.dragTarget.hint;
    }
    const eventArgs = new DropTargetEvent(eventProps);
    this.ngZone.run(() => {
      this[event].emit(eventArgs);
    });
  }
  getDropIndex() {
    return this.allDropTargets.indexOf(this.currentDropTargetElement);
  }
  clearPreviousTargets() {
    this.previousDropTargets.forEach((dropTarget) => {
      const idx2 = this.service.dropTargets.findIndex((serviceDropTarget) => serviceDropTarget.element === dropTarget);
      if (idx2 > -1) {
        this.service.dropTargets.splice(idx2, 1);
      }
    });
    this.previousDropTargets = [];
  }
  static ɵfac = function DropTargetContainerDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropTargetContainerDirective)(ɵɵdirectiveInject(DragStateService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DropTargetContainerDirective,
    selectors: [["", "kendoDropTargetContainer", ""]],
    inputs: {
      dropTargetFilter: "dropTargetFilter",
      dropDisabled: "dropDisabled"
    },
    outputs: {
      onDragEnter: "onDragEnter",
      onDragOver: "onDragOver",
      onDragLeave: "onDragLeave",
      onDrop: "onDrop"
    },
    exportAs: ["kendoDropTargetContainer"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropTargetContainerDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropTargetContainer]",
      exportAs: "kendoDropTargetContainer",
      standalone: true
    }]
  }], function() {
    return [{
      type: DragStateService
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    dropTargetFilter: [{
      type: Input
    }],
    dropDisabled: [{
      type: Input
    }],
    onDragEnter: [{
      type: Output
    }],
    onDragOver: [{
      type: Output
    }],
    onDragLeave: [{
      type: Output
    }],
    onDrop: [{
      type: Output
    }]
  });
})();
var DropTargetDirective = class _DropTargetDirective {
  service;
  element;
  ngZone;
  /**
   * Fires when a DragTarget element enters the DropTarget.
   */
  onDragEnter = new EventEmitter();
  /**
   * Fires when a DragTarget element is being dragged over the DropTarget.
   */
  onDragOver = new EventEmitter();
  /**
   * Fires when a DragTarget element leaves the DropTarget.
   */
  onDragLeave = new EventEmitter();
  /**
   * Fires when a DragTarget element is dropped over the DropTarget.
   */
  onDrop = new EventEmitter();
  constructor(service, element, ngZone) {
    this.service = service;
    this.element = element;
    this.ngZone = ngZone;
    validatePackage(packageMetadata);
  }
  dropTarget;
  ngOnInit() {
    this.initializeDropTarget();
    this.service.dropTargets.push(this.dropTarget);
  }
  ngOnDestroy() {
    const currentDropTargetIndex = this.service.dropTargets.indexOf(this.dropTarget);
    this.service.dropTargets.splice(currentDropTargetIndex, 1);
  }
  /**
   * @hidden
   */
  handleDragEnter(event) {
    if (!this.service.dragTarget) {
      return;
    }
    this.service.dropTarget = this.dropTarget;
    this.emitZoneAwareEvent("onDragEnter", event);
  }
  /**
   * @hidden
   */
  handleDragLeave(event) {
    this.service.dropTarget = null;
    if (!this.service.dragTarget) {
      return;
    }
    this.emitZoneAwareEvent("onDragLeave", event);
  }
  /**
   * @hidden
   */
  handleDragOver(event) {
    if (!this.service.dragTarget) {
      return;
    }
    this.emitZoneAwareEvent("onDragOver", event);
  }
  /**
   * @hidden
   */
  handleDrop(event) {
    this.emitZoneAwareEvent("onDrop", event);
    this.service.dropTarget = null;
  }
  initializeDropTarget() {
    this.dropTarget = {
      element: this.element.nativeElement,
      onDragEnter: this.handleDragEnter.bind(this),
      onDragLeave: this.handleDragLeave.bind(this),
      onDragOver: this.handleDragOver.bind(this),
      onDrop: this.handleDrop.bind(this)
    };
  }
  emitZoneAwareEvent(event, normalizedEvent) {
    const eventProps = {
      dropTarget: this.element.nativeElement,
      dragTarget: this.service.dragTarget?.element,
      dragEvent: normalizedEvent,
      dragData: this.service.dragData
    };
    if (isPresent2(this.service.dragTarget?.hint)) {
      eventProps.hintElement = this.service.dragTarget.element;
    }
    const eventArgs = new DropTargetEvent(eventProps);
    this.ngZone.run(() => {
      this[event].emit(eventArgs);
    });
  }
  static ɵfac = function DropTargetDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropTargetDirective)(ɵɵdirectiveInject(DragStateService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DropTargetDirective,
    selectors: [["", "kendoDropTarget", ""]],
    outputs: {
      onDragEnter: "onDragEnter",
      onDragOver: "onDragOver",
      onDragLeave: "onDragLeave",
      onDrop: "onDrop"
    },
    exportAs: ["kendoDropTarget"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropTargetDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropTarget]",
      exportAs: "kendoDropTarget",
      standalone: true
    }]
  }], function() {
    return [{
      type: DragStateService
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, {
    onDragEnter: [{
      type: Output
    }],
    onDragOver: [{
      type: Output
    }],
    onDragLeave: [{
      type: Output
    }],
    onDrop: [{
      type: Output
    }]
  });
})();
var KENDO_DRAGANDDROP = [DragTargetDirective, DragHandleDirective, DropTargetDirective, DragTargetContainerDirective, DropTargetContainerDirective, HintComponent];
var KENDO_UTILS = [...KENDO_DRAGANDDROP];
var UtilsModule = class _UtilsModule {
  static ɵfac = function UtilsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UtilsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _UtilsModule,
    imports: [DragTargetDirective, DragHandleDirective, DropTargetDirective, DragTargetContainerDirective, DropTargetContainerDirective, HintComponent],
    exports: [DragTargetDirective, DragHandleDirective, DropTargetDirective, DragTargetContainerDirective, DropTargetContainerDirective, HintComponent]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UtilsModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_UTILS],
      imports: [...KENDO_UTILS]
    }]
  }], null, null);
})();
var DragAndDropModule = class _DragAndDropModule {
  static ɵfac = function DragAndDropModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragAndDropModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DragAndDropModule,
    imports: [DragTargetDirective, DragHandleDirective, DropTargetDirective, DragTargetContainerDirective, DropTargetContainerDirective, HintComponent],
    exports: [DragTargetDirective, DragHandleDirective, DropTargetDirective, DragTargetContainerDirective, DropTargetContainerDirective, HintComponent]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragAndDropModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_DRAGANDDROP],
      imports: [...KENDO_DRAGANDDROP]
    }]
  }], null, null);
})();
var AdaptiveSettingsService = class _AdaptiveSettingsService {
  /**
   * @hidden
   */
  changes = new Subject();
  /**
   * Notifies subscribers that the adaptive settings were changed.
   *
   * @param adaptiveSettings - (Optional) A new value for the adaptive settings token.
   */
  notify(adaptiveSettings) {
    this.changes.next(adaptiveSettings);
  }
  static ɵfac = function AdaptiveSettingsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AdaptiveSettingsService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _AdaptiveSettingsService,
    factory: _AdaptiveSettingsService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AdaptiveSettingsService, [{
    type: Injectable
  }], null, null);
})();
var ADAPTIVE_SETTINGS = new InjectionToken("Kendo UI Adaptive-Settings token");
var DEFAULT_ADAPTIVE_SETTINGS = {
  small: 500,
  medium: 768
};
var AdaptiveService = class _AdaptiveService {
  _adaptiveSettings;
  /**
   * Notifies subscribers of the initial adaptive settings, and upon each call to `notify`.
   * @hidden
   */
  changes = new BehaviorSubject(this.adaptiveSettings || {
    small: 500,
    medium: 700
  });
  subs = new Subscription();
  constructor(_adaptiveSettings, adaptiveSettingsService) {
    this._adaptiveSettings = _adaptiveSettings;
    if (adaptiveSettingsService) {
      this.subs.add(adaptiveSettingsService.changes.pipe(map((adaptiveSettings) => isPresent(adaptiveSettings) ? adaptiveSettings : this._adaptiveSettings), tap((adaptiveSettings) => this._adaptiveSettings = adaptiveSettings)).subscribe((adaptiveSettings) => this.changes.next(adaptiveSettings)));
    }
    if (isPresent(this.adaptiveSettings) && !areObjectsEqual(this.adaptiveSettings, DEFAULT_ADAPTIVE_SETTINGS)) {
      this.changes.next(this.adaptiveSettings);
    }
  }
  /**
   * @hidden
   */
  get adaptiveSettings() {
    return this._adaptiveSettings;
  }
  /**
   * @hidden
   */
  get size() {
    if (!isDocumentAvailable()) {
      return;
    }
    const settings = Object.assign(DEFAULT_ADAPTIVE_SETTINGS, this.adaptiveSettings);
    if (window.innerWidth > settings.medium) {
      return "large";
    } else if (window.innerWidth > settings.small) {
      return "medium";
    } else {
      return "small";
    }
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  static ɵfac = function AdaptiveService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AdaptiveService)(ɵɵinject(ADAPTIVE_SETTINGS, 8), ɵɵinject(AdaptiveSettingsService, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _AdaptiveService,
    factory: _AdaptiveService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AdaptiveService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [ADAPTIVE_SETTINGS]
      }]
    }, {
      type: AdaptiveSettingsService,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();

// node_modules/@progress/kendo-angular-navigation/fesm2022/progress-kendo-angular-navigation.mjs
var _c02 = ["*"];
var _c1 = ["kendoActionSheetItem", ""];
var _c2 = (a0) => ({
  $implicit: a0
});
function ActionSheetItemComponent_0_ng_template_0_Template(rf, ctx) {
}
function ActionSheetItemComponent_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ActionSheetItemComponent_0_ng_template_0_Template, 0, 0, "ng-template", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.itemTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c2, ctx_r0.item));
  }
}
function ActionSheetItemComponent_ng_template_1_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 6);
    ɵɵelement(1, "kendo-icon-wrapper", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵstyleMap(ctx_r0.manageIconStyles(ctx_r0.item));
    ɵɵclassMap(ctx_r0.manageIconClasses(ctx_r0.item));
    ɵɵproperty("name", ctx_r0.item.icon)("customFontClass", ctx_r0.item.iconClass)("svgIcon", ctx_r0.item.svgIcon);
  }
}
function ActionSheetItemComponent_ng_template_1_span_2_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 11);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.item.title);
  }
}
function ActionSheetItemComponent_ng_template_1_span_2_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 12);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.item.description);
  }
}
function ActionSheetItemComponent_ng_template_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 8);
    ɵɵtemplate(1, ActionSheetItemComponent_ng_template_1_span_2_span_1_Template, 2, 1, "span", 9)(2, ActionSheetItemComponent_ng_template_1_span_2_span_2_Template, 2, 1, "span", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.item.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.item.description);
  }
}
function ActionSheetItemComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵtemplate(1, ActionSheetItemComponent_ng_template_1_span_1_Template, 2, 7, "span", 4)(2, ActionSheetItemComponent_ng_template_1_span_2_Template, 3, 2, "span", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.item.icon || ctx_r0.item.iconClass || ctx_r0.item.svgIcon);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.item.title || ctx_r0.item.description);
  }
}
var _c3 = ["kendoActionSheetList", ""];
function ActionSheetListComponent_span_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 1);
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("k-actionsheet-item", true)("k-disabled", item_r1.disabled);
    ɵɵproperty("ngClass", item_r1.cssClass)("ngStyle", item_r1.cssStyle)("itemTemplate", ctx_r1.itemTemplate)("item", item_r1);
    ɵɵattribute("aria-disabled", item_r1.disabled)("kendo-actionsheet-item-index", ctx_r1.setAttrIndex(item_r1));
  }
}
var _c4 = ["childContainer"];
function ActionSheetComponent_ng_container_0_6_ng_template_0_Template(rf, ctx) {
}
function ActionSheetComponent_ng_container_0_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ActionSheetComponent_ng_container_0_6_ng_template_0_Template, 0, 0, "ng-template", 10);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.actionSheetTemplate == null ? null : ctx_r1.actionSheetTemplate.templateRef);
  }
}
function ActionSheetComponent_ng_container_0_ng_template_7_div_0_1_ng_template_0_Template(rf, ctx) {
}
function ActionSheetComponent_ng_container_0_ng_template_7_div_0_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ActionSheetComponent_ng_container_0_ng_template_7_div_0_1_ng_template_0_Template, 0, 0, "ng-template", 10);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.headerTemplate == null ? null : ctx_r1.headerTemplate.templateRef);
  }
}
function ActionSheetComponent_ng_container_0_ng_template_7_div_0_ng_template_2_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 19);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(5);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.title);
  }
}
function ActionSheetComponent_ng_container_0_ng_template_7_div_0_ng_template_2_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 20);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(5);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.subtitle);
  }
}
function ActionSheetComponent_ng_container_0_ng_template_7_div_0_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 15)(1, "div", 16);
    ɵɵtemplate(2, ActionSheetComponent_ng_container_0_ng_template_7_div_0_ng_template_2_div_2_Template, 2, 1, "div", 17)(3, ActionSheetComponent_ng_container_0_ng_template_7_div_0_ng_template_2_div_3_Template, 2, 1, "div", 18);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵproperty("id", ctx_r1.titleId);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.subtitle);
  }
}
function ActionSheetComponent_ng_container_0_ng_template_7_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 14);
    ɵɵtemplate(1, ActionSheetComponent_ng_container_0_ng_template_7_div_0_1_Template, 1, 1, null, 9)(2, ActionSheetComponent_ng_container_0_ng_template_7_div_0_ng_template_2_Template, 4, 3, "ng-template", null, 2, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const defaultHeaderTemplate_r3 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.headerTemplate)("ngIfElse", defaultHeaderTemplate_r3);
  }
}
function ActionSheetComponent_ng_container_0_ng_template_7_div_1_1_ng_template_0_Template(rf, ctx) {
}
function ActionSheetComponent_ng_container_0_ng_template_7_div_1_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ActionSheetComponent_ng_container_0_ng_template_7_div_1_1_ng_template_0_Template, 0, 0, "ng-template", 10);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.contentTemplate == null ? null : ctx_r1.contentTemplate.templateRef);
  }
}
function ActionSheetComponent_ng_container_0_ng_template_7_div_1_ng_template_2_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 24);
    ɵɵlistener("itemClick", function ActionSheetComponent_ng_container_0_ng_template_7_div_1_ng_template_2_div_0_Template_div_itemClick_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext(5);
      return ɵɵresetView(ctx_r1.onItemClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(5);
    ɵɵproperty("groupItems", ctx_r1.topGroupItems)("allItems", ctx_r1.items)("itemTemplate", ctx_r1.itemTemplate == null ? null : ctx_r1.itemTemplate.templateRef);
  }
}
function ActionSheetComponent_ng_container_0_ng_template_7_div_1_ng_template_2_hr_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "hr", 25);
  }
}
function ActionSheetComponent_ng_container_0_ng_template_7_div_1_ng_template_2_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 24);
    ɵɵlistener("itemClick", function ActionSheetComponent_ng_container_0_ng_template_7_div_1_ng_template_2_div_2_Template_div_itemClick_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(5);
      return ɵɵresetView(ctx_r1.onItemClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(5);
    ɵɵproperty("groupItems", ctx_r1.bottomGroupItems)("allItems", ctx_r1.items)("itemTemplate", ctx_r1.itemTemplate == null ? null : ctx_r1.itemTemplate.templateRef);
  }
}
function ActionSheetComponent_ng_container_0_ng_template_7_div_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ActionSheetComponent_ng_container_0_ng_template_7_div_1_ng_template_2_div_0_Template, 1, 3, "div", 22)(1, ActionSheetComponent_ng_container_0_ng_template_7_div_1_ng_template_2_hr_1_Template, 1, 0, "hr", 23)(2, ActionSheetComponent_ng_container_0_ng_template_7_div_1_ng_template_2_div_2_Template, 1, 3, "div", 22);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("ngIf", ctx_r1.topGroupItems);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.shouldRenderSeparator);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.bottomGroupItems);
  }
}
function ActionSheetComponent_ng_container_0_ng_template_7_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 21);
    ɵɵtemplate(1, ActionSheetComponent_ng_container_0_ng_template_7_div_1_1_Template, 1, 1, null, 9)(2, ActionSheetComponent_ng_container_0_ng_template_7_div_1_ng_template_2_Template, 3, 3, "ng-template", null, 3, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const defaultContentTemplate_r6 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.contentTemplate)("ngIfElse", defaultContentTemplate_r6);
  }
}
function ActionSheetComponent_ng_container_0_ng_template_7_div_2_ng_template_1_Template(rf, ctx) {
}
function ActionSheetComponent_ng_container_0_ng_template_7_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 26);
    ɵɵtemplate(1, ActionSheetComponent_ng_container_0_ng_template_7_div_2_ng_template_1_Template, 0, 0, "ng-template", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.footerTemplate == null ? null : ctx_r1.footerTemplate.templateRef);
  }
}
function ActionSheetComponent_ng_container_0_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ActionSheetComponent_ng_container_0_ng_template_7_div_0_Template, 4, 2, "div", 11)(1, ActionSheetComponent_ng_container_0_ng_template_7_div_1_Template, 4, 2, "div", 12)(2, ActionSheetComponent_ng_container_0_ng_template_7_div_2_Template, 2, 1, "div", 13);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngIf", ctx_r1.title || ctx_r1.subtitle || ctx_r1.headerTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.items || ctx_r1.contentTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.footerTemplate);
  }
}
function ActionSheetComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 5);
    ɵɵlistener("click", function ActionSheetComponent_ng_container_0_Template_div_click_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onOverlayClick());
    });
    ɵɵelementEnd();
    ɵɵelementStart(2, "div", 6)(3, "div", 7, 0)(5, "div", 8);
    ɵɵtemplate(6, ActionSheetComponent_ng_container_0_6_Template, 1, 1, null, 9)(7, ActionSheetComponent_ng_container_0_ng_template_7_Template, 3, 3, "ng-template", null, 1, ɵɵtemplateRefExtractor);
    ɵɵelementEnd()()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const defaultTemplate_r7 = ɵɵreference(8);
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵstyleMap("bottom: 0px; width: 100%;");
    ɵɵadvance(2);
    ɵɵproperty("ngClass", ctx_r1.cssClass);
    ɵɵattribute("aria-labelledby", ctx_r1.titleId);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.actionSheetTemplate)("ngIfElse", defaultTemplate_r7);
  }
}
var _c5 = ["kendoBottomNavigationItem", ""];
function BottomNavigationItemComponent_ng_container_0_kendo_icon_wrapper_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("name", ctx_r0.item.icon)("customFontClass", ctx_r0.item.iconClass)("svgIcon", ctx_r0.item.svgIcon);
  }
}
function BottomNavigationItemComponent_ng_container_0_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.item.text);
  }
}
function BottomNavigationItemComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, BottomNavigationItemComponent_ng_container_0_kendo_icon_wrapper_1_Template, 1, 3, "kendo-icon-wrapper", 1)(2, BottomNavigationItemComponent_ng_container_0_span_2_Template, 2, 1, "span", 2);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.itemIcon);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.item.text);
  }
}
function BottomNavigationItemComponent_1_ng_template_0_Template(rf, ctx) {
}
function BottomNavigationItemComponent_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, BottomNavigationItemComponent_1_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.itemTemplate == null ? null : ctx_r0.itemTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c2, ctx_r0.item));
  }
}
function BottomNavigationComponent_ng_container_0_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 2);
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const idx_r2 = ctx.index;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("disabledComponent", ctx_r2.disabled)("item", item_r1)("index", idx_r2)("selectedIdx", ctx_r2.selectedIdx)("itemTemplate", ctx_r2.itemTemplate)("ngClass", item_r1.cssClass)("ngStyle", item_r1.cssStyle)("orientation", ctx_r2.itemFlow);
    ɵɵattribute("data-kendo-bottomnavigation-index", idx_r2);
  }
}
function BottomNavigationComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, BottomNavigationComponent_ng_container_0_span_1_Template, 1, 9, "span", 1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2.items);
  }
}
var _c6 = ["kendoBreadCrumbItem", ""];
var _c7 = [[["", "kendoBreadCrumbSeparator", ""]]];
var _c8 = ["[kendoBreadCrumbSeparator]"];
var _c9 = (a0, a1, a2, a3, a4) => ({
  "k-breadcrumb-root-link": a0,
  "k-breadcrumb-link": a1,
  "k-breadcrumb-icontext-link": a2,
  "k-breadcrumb-icon-link": a3,
  "k-disabled": a4
});
var _c10 = (a0, a1) => ({
  $implicit: a0,
  index: a1
});
function BreadCrumbItemComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function BreadCrumbItemComponent_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function BreadCrumbItemComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, BreadCrumbItemComponent_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 2);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const separator_r1 = ɵɵreference(1);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", separator_r1);
  }
}
function BreadCrumbItemComponent_ng_container_3_span_1_img_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "img", 8);
    ɵɵlistener("load", function BreadCrumbItemComponent_ng_container_3_span_1_img_1_Template_img_load_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r2.onImageLoad());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵproperty("src", ctx_r2.item.data.imageUrl, ɵɵsanitizeUrl);
  }
}
function BreadCrumbItemComponent_ng_container_3_span_1_kendo_icon_wrapper_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 9);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵproperty("name", ctx_r2.item.data.icon)("customFontClass", ctx_r2.item.data.iconClass)("svgIcon", ctx_r2.item.data.svgIcon);
  }
}
function BreadCrumbItemComponent_ng_container_3_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 4);
    ɵɵtemplate(1, BreadCrumbItemComponent_ng_container_3_span_1_img_1_Template, 1, 1, "img", 5)(2, BreadCrumbItemComponent_ng_container_3_span_1_kendo_icon_wrapper_2_Template, 1, 3, "kendo-icon-wrapper", 6);
    ɵɵelementStart(3, "span", 7);
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ɵɵpureFunction5(8, _c9, ctx_r2.item.context.isFirst, ctx_r2.index !== 0, (!!ctx_r2.item.data.icon || !!ctx_r2.item.data.svgIcon) && !!ctx_r2.item.data.text, (!!ctx_r2.item.data.icon || !!ctx_r2.item.data.svgIcon) && !ctx_r2.item.data.text, ctx_r2.disabled))("title", ctx_r2.item.data.title || "")("tabindex", ctx_r2.disabled ? -1 : 0);
    ɵɵattribute("aria-disabled", ctx_r2.disabled)("aria-current", ctx_r2.item.context.isLast ? "page" : null);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.item.data.imageUrl);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.item.data.icon || ctx_r2.item.data.iconClass || ctx_r2.item.data.svgIcon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r2.item.data.text);
  }
}
function BreadCrumbItemComponent_ng_container_3_2_ng_template_0_Template(rf, ctx) {
}
function BreadCrumbItemComponent_ng_container_3_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, BreadCrumbItemComponent_ng_container_3_2_ng_template_0_Template, 0, 0, "ng-template", 10);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r2.itemTemplate)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c10, ctx_r2.item.data, ctx_r2.index));
  }
}
function BreadCrumbItemComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, BreadCrumbItemComponent_ng_container_3_span_1_Template, 5, 14, "span", 3)(2, BreadCrumbItemComponent_ng_container_3_2_Template, 1, 5, null, 1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r2.itemTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.itemTemplate);
  }
}
function BreadCrumbItemComponent_ng_container_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function BreadCrumbItemComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, BreadCrumbItemComponent_ng_container_4_ng_container_1_Template, 1, 0, "ng-container", 2);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const separator_r1 = ɵɵreference(1);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", separator_r1);
  }
}
var _c11 = ["kendoBreadCrumbSeparator", ""];
var _c12 = ["kendoBreadCrumbList", ""];
function BreadCrumbListComponent_ng_container_0_li_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("icon", ctx_r0.separatorIcon)("svgIcon", ctx_r0.separatorSVGIcon);
  }
}
function BreadCrumbListComponent_ng_container_0_li_1_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("icon", ctx_r0.separatorIcon)("svgIcon", ctx_r0.separatorSVGIcon);
  }
}
function BreadCrumbListComponent_ng_container_0_li_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 3, 0);
    ɵɵtemplate(2, BreadCrumbListComponent_ng_container_0_li_1_span_2_Template, 1, 2, "span", 4)(3, BreadCrumbListComponent_ng_container_0_li_1_span_3_Template, 1, 2, "span", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const item_r3 = ctx_r1.$implicit;
    const i_r4 = ctx_r1.index;
    const isFirst_r5 = ctx_r1.first;
    const isLast_r6 = ctx_r1.last;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("item", item_r3)("index", i_r4)("collapseMode", ctx_r0.collapseMode)("itemTemplate", ctx_r0.itemTemplate);
    ɵɵattribute("data-kendo-breadcrumb-index", i_r4);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.collapseMode === "wrap" && !isFirst_r5);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.collapseMode !== "wrap" && !isLast_r6 && !((item_r3 == null ? null : item_r3.context.collapsed) && (ctx_r0.items[i_r4 + 1] == null ? null : ctx_r0.items[i_r4 + 1].context.collapsed)));
  }
}
function BreadCrumbListComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, BreadCrumbListComponent_ng_container_0_li_1_Template, 4, 7, "li", 2);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const isFirst_r5 = ctx.first;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !(ctx_r0.collapseMode === "wrap" && isFirst_r5) || ctx_r0.isRootItemContainer);
  }
}
var _c13 = ["resizeSensor"];
var _c14 = ["itemsContainer"];
var _c15 = (a0, a1) => ({
  "!k-flex-wrap": a0,
  "k-flex-none": a1
});
function BreadCrumbComponent_ol_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "ol", 5, 0);
    ɵɵpipe(2, "async");
    ɵɵlistener("itemClick", function BreadCrumbComponent_ol_0_Template_ol_itemClick_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.itemClick.emit($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("items", ɵɵpipeBind1(2, 5, ctx_r2.firstItem$))("itemTemplate", ctx_r2.itemTemplate == null ? null : ctx_r2.itemTemplate.templateRef)("collapseMode", ctx_r2.collapseMode)("separatorIcon", ctx_r2.separatorIcon)("separatorSVGIcon", ctx_r2.separatorSVGIcon);
  }
}
var packageMetadata2 = {
  name: "@progress/kendo-angular-navigation",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 1745303831,
  version: "18.5.2",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var DEFAULT_THEME_COLOR = "light";
var DEFAULT_POSITION = "top";
var DEFAULT_POSITION_MODE = "static";
var AppBarComponent = class _AppBarComponent {
  localizationService;
  host;
  renderer;
  hostClass = true;
  /**
   * @hidden
   */
  direction;
  /**
   * Specifies the position of the AppBar
   * ([see example]({% slug positioning_appbar %}#toc-position)).
   *
   * * The possible values are:
   * * `top` (Default)&mdash;Positions the AppBar at the top of the content.
   *    Setting the `position` property to `top` requires adding the Appbar component before the page content.
   *    The position property applies CSS `top: 0` style in [`fixed mode`](slug:api_navigation_appbarcomponent#toc-positionmode) and also adds a `box-shadow` to the bottom of the AppBar.
   *
   * * `bottom`&mdash;Positions the AppBar at the bottom of the content.
   *    Setting the `position` property to `bottom` requires adding the Appbar component after the page content.
   *   The position property applies CSS `bottom: 0` style in [`fixed mode`](slug:api_navigation_appbarcomponent#toc-positionmode) and also adds a `box-shadow ` to the top of the AppBar.
   *
   */
  set position(position) {
    const newPosition = position ? position : DEFAULT_POSITION;
    this.handleHostClasses(newPosition, this.position);
    this._position = newPosition;
  }
  get position() {
    return this._position;
  }
  /**
   * Specifies the positionMode of the AppBar
   * ([see example](slug:positioning_appbar#toc-position-mode)).
   *
   * * The possible values are:
   * * `static` (Default)&mdash;Does not position the AppBar in any special way. It is positioned according to the normal flow of the page.
   * * `sticky`&mdash;Positions the AppBar based on the user's scroll position. A sticky element toggles between static and fixed CSS [`position`](https://developer.mozilla.org/en-US/docs/Web/CSS/position) property, depending on the scroll position.
   * * `fixed`&mdash;Positions the AppBar relative to the viewport. It always stays in the same place even if the page is scrolled.
   */
  set positionMode(positionMode) {
    const newPositionMode = positionMode ? positionMode : DEFAULT_POSITION_MODE;
    this.handleHostClasses(newPositionMode, this.positionMode);
    this._positionMode = newPositionMode;
  }
  get positionMode() {
    return this._positionMode;
  }
  /**
   * Specifies the theme color of the AppBar.
   * The theme color will be applied as background color of the component.
   *
   *
   * * The possible values are:
   * * `light` (Default)&mdash;Applies coloring based on light theme color.
   * * `dark`&mdash;Applies coloring based on dark theme color.
   * * `inherit`&mdash; Applies inherited coloring value.
   * * `primary`&mdash; Applies primary coloring value.
   *
   */
  set themeColor(themeColor) {
    const newThemeColor = themeColor ? themeColor : DEFAULT_THEME_COLOR;
    this.handleHostClasses(newThemeColor, this.themeColor);
    this._themeColor = newThemeColor;
  }
  get themeColor() {
    return this._themeColor;
  }
  dynamicRTLSubscription;
  rtl = false;
  _themeColor = DEFAULT_THEME_COLOR;
  _position = DEFAULT_POSITION;
  _positionMode = DEFAULT_POSITION_MODE;
  constructor(localizationService, host, renderer) {
    this.localizationService = localizationService;
    this.host = host;
    this.renderer = renderer;
    validatePackage(packageMetadata2);
    this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.rtl = rtl;
      this.direction = this.rtl ? "rtl" : "ltr";
    });
  }
  ngAfterViewInit() {
    const stylingOptions = ["position", "positionMode", "themeColor"];
    stylingOptions.forEach((input) => {
      this.handleHostClasses(this[input]);
    });
  }
  ngOnDestroy() {
    if (this.dynamicRTLSubscription) {
      this.dynamicRTLSubscription.unsubscribe();
    }
  }
  handleHostClasses(newValue, previousValue) {
    const elem = this.host.nativeElement;
    if (previousValue && newValue === previousValue) {
      return;
    }
    if (previousValue) {
      this.renderer.removeClass(elem, `k-appbar-${previousValue}`);
    }
    if (newValue) {
      this.renderer.addClass(elem, `k-appbar-${newValue}`);
    }
  }
  static ɵfac = function AppBarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AppBarComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AppBarComponent,
    selectors: [["kendo-appbar"]],
    hostVars: 3,
    hostBindings: function AppBarComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-appbar", ctx.hostClass);
      }
    },
    inputs: {
      position: "position",
      positionMode: "positionMode",
      themeColor: "themeColor"
    },
    exportAs: ["kendoAppBar"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.appbar.component"
    }])],
    ngContentSelectors: _c02,
    decls: 1,
    vars: 0,
    template: function AppBarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AppBarComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoAppBar",
      selector: "kendo-appbar",
      template: `
        <ng-content></ng-content>
    `,
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.appbar.component"
      }],
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-appbar"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    position: [{
      type: Input
    }],
    positionMode: [{
      type: Input
    }],
    themeColor: [{
      type: Input
    }]
  });
})();
var AppBarSectionComponent = class _AppBarSectionComponent {
  hostClass = true;
  static ɵfac = function AppBarSectionComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AppBarSectionComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AppBarSectionComponent,
    selectors: [["kendo-appbar-section"]],
    hostVars: 2,
    hostBindings: function AppBarSectionComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-appbar-section", ctx.hostClass);
      }
    },
    ngContentSelectors: _c02,
    decls: 1,
    vars: 0,
    template: function AppBarSectionComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AppBarSectionComponent, [{
    type: Component,
    args: [{
      selector: "kendo-appbar-section",
      template: `
        <ng-content></ng-content>
    `,
      standalone: true
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-appbar-section"]
    }]
  });
})();
var isPresent3 = (value) => value !== null && value !== void 0;
var outerWidth = (element) => {
  const style2 = getComputedStyle(element);
  let width = parseFloat(style2.width);
  width += (parseFloat(style2.marginLeft) || 0) + (parseFloat(style2.marginRight) || 0);
  return width;
};
var getFirstAndLastFocusable = (parent) => {
  const all = getAllFocusableChildren(parent);
  const firstFocusable = all.length > 0 ? all[0] : parent;
  const lastFocusable = all.length > 0 ? all[all.length - 1] : parent;
  return [firstFocusable, lastFocusable];
};
var getAllFocusableChildren = (parent) => {
  return parent.querySelectorAll(focusableSelector);
};
var idx = 0;
var hexColorRegex = /^#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;
var getId = (prefix) => {
  return `${prefix}${++idx}`;
};
var ACTIONSHEET_ITEM_INDEX_ATTRIBUTE = "kendo-actionsheet-item-index";
var getActionSheetItemIndex = (target, targetAttr, scope) => {
  const item = closestItem$1(target, targetAttr, scope);
  if (item) {
    return itemIndex$1(item, targetAttr);
  }
};
var itemIndex$1 = (item, indexAttr) => +item.getAttribute(indexAttr);
var hasItemIndex$1 = (item, indexAttr) => isPresent3(item.getAttribute(indexAttr));
var closestItem$1 = (target, targetAttr, scope) => closestInScope(target, (el) => hasItemIndex$1(el, targetAttr), scope);
var AppBarSpacerComponent = class _AppBarSpacerComponent {
  renderer;
  element;
  hostClass = true;
  get sizedClass() {
    return isPresent3(this.width);
  }
  /**
   * Specifies the width of the AppBarSpacer.
   *
   * If not set, the AppBarSpacer will take all the available space.
   */
  width;
  constructor(renderer, element) {
    this.renderer = renderer;
    this.element = element;
  }
  ngAfterViewInit() {
    if (isPresent3(this.width)) {
      const element = this.element.nativeElement;
      this.renderer.setStyle(element, "flexBasis", this.width);
    }
  }
  static ɵfac = function AppBarSpacerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AppBarSpacerComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AppBarSpacerComponent,
    selectors: [["kendo-appbar-spacer"]],
    hostVars: 4,
    hostBindings: function AppBarSpacerComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-spacer", ctx.hostClass)("k-spacer-sized", ctx.sizedClass);
      }
    },
    inputs: {
      width: "width"
    },
    decls: 0,
    vars: 0,
    template: function AppBarSpacerComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AppBarSpacerComponent, [{
    type: Component,
    args: [{
      selector: "kendo-appbar-spacer",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-spacer"]
    }],
    sizedClass: [{
      type: HostBinding,
      args: ["class.k-spacer-sized"]
    }],
    width: [{
      type: Input
    }]
  });
})();
var ActionSheetHeaderTemplateDirective = class _ActionSheetHeaderTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ActionSheetHeaderTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ActionSheetHeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ActionSheetHeaderTemplateDirective,
    selectors: [["", "kendoActionSheetHeaderTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActionSheetHeaderTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoActionSheetHeaderTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ActionSheetItemTemplateDirective = class _ActionSheetItemTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ActionSheetItemTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ActionSheetItemTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ActionSheetItemTemplateDirective,
    selectors: [["", "kendoActionSheetItemTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActionSheetItemTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoActionSheetItemTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ActionSheetContentTemplateDirective = class _ActionSheetContentTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ActionSheetContentTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ActionSheetContentTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ActionSheetContentTemplateDirective,
    selectors: [["", "kendoActionSheetContentTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActionSheetContentTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoActionSheetContentTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ActionSheetFooterTemplateDirective = class _ActionSheetFooterTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ActionSheetFooterTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ActionSheetFooterTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ActionSheetFooterTemplateDirective,
    selectors: [["", "kendoActionSheetFooterTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActionSheetFooterTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoActionSheetFooterTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ActionSheetTemplateDirective = class _ActionSheetTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ActionSheetTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ActionSheetTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ActionSheetTemplateDirective,
    selectors: [["", "kendoActionSheetTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActionSheetTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoActionSheetTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
function slideUp(duration, height) {
  return [style({
    overflow: "hidden",
    display: "block",
    height: 0
  }), animate(`${duration}ms ease-in`, style({
    height: `${height}`
  }))];
}
function slideDown(duration, height) {
  return [style({
    overflow: "hidden",
    height: `${height}`
  }), animate(`${duration}ms ease-in`, style({
    overflow: "hidden",
    height: 0
  }))];
}
var ActionSheetItemComponent = class _ActionSheetItemComponent {
  itemTemplate;
  item;
  pointerClass = true;
  manageIconClasses(item) {
    const classes = ["k-actionsheet-item-icon"];
    const isHexColor = isPresent3(item.iconColor) && hexColorRegex.test(item.iconColor);
    const isThemeColor = isPresent3(item.iconColor) && item.iconColor !== "" && !isHexColor;
    if (isThemeColor) {
      classes.push(`k-text-${item.iconColor}`);
    }
    return classes.join(" ");
  }
  manageIconStyles(item) {
    const isHexColor = isPresent3(item.iconColor) && hexColorRegex.test(item.iconColor);
    const isSizeSet = isPresent3(item.iconSize) && item.iconSize !== "";
    const styles = {};
    if (isHexColor) {
      styles.color = item.iconColor;
    }
    if (isSizeSet) {
      styles.fontSize = item.iconSize;
    }
    return styles;
  }
  static ɵfac = function ActionSheetItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ActionSheetItemComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ActionSheetItemComponent,
    selectors: [["", "kendoActionSheetItem", ""]],
    hostVars: 2,
    hostBindings: function ActionSheetItemComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-cursor-pointer", ctx.pointerClass);
      }
    },
    inputs: {
      itemTemplate: "itemTemplate",
      item: "item"
    },
    attrs: _c1,
    decls: 3,
    vars: 2,
    consts: [["defaultTemplate", ""], [4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-actionsheet-action"], ["class", "k-icon-wrap", 4, "ngIf"], ["class", "k-actionsheet-item-text", 4, "ngIf"], [1, "k-icon-wrap"], [3, "name", "customFontClass", "svgIcon"], [1, "k-actionsheet-item-text"], ["class", "k-actionsheet-item-title", 4, "ngIf"], ["class", "k-actionsheet-item-description", 4, "ngIf"], [1, "k-actionsheet-item-title"], [1, "k-actionsheet-item-description"]],
    template: function ActionSheetItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, ActionSheetItemComponent_0_Template, 1, 4, null, 1)(1, ActionSheetItemComponent_ng_template_1_Template, 3, 2, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const defaultTemplate_r2 = ɵɵreference(2);
        ɵɵproperty("ngIf", ctx.itemTemplate)("ngIfElse", defaultTemplate_r2);
      }
    },
    dependencies: [NgIf, NgTemplateOutlet, IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActionSheetItemComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoActionSheetItem]",
      template: `
        <ng-template *ngIf="itemTemplate; else defaultTemplate"
            [ngTemplateOutlet]="itemTemplate"
            [ngTemplateOutletContext]="{
                $implicit: item
            }">
        </ng-template>
        <ng-template #defaultTemplate>
            <span class="k-actionsheet-action">
                <span *ngIf="item.icon || item.iconClass || item.svgIcon" class="k-icon-wrap">
                    <kendo-icon-wrapper
                        [name]="item.icon"
                        [customFontClass]="item.iconClass"
                        [class]="manageIconClasses(item)"
                        [svgIcon]="item.svgIcon"
                        [style]="manageIconStyles(item)"
                    >
                    </kendo-icon-wrapper>
                </span>
                <span *ngIf="item.title || item.description" class="k-actionsheet-item-text">
                    <span *ngIf="item.title" class="k-actionsheet-item-title">{{item.title}}</span>
                    <span *ngIf="item.description" class="k-actionsheet-item-description">{{item.description}}</span>
                </span>
            </span>
        </ng-template>
    `,
      standalone: true,
      imports: [NgIf, NgTemplateOutlet, IconWrapperComponent]
    }]
  }], null, {
    itemTemplate: [{
      type: Input
    }],
    item: [{
      type: Input
    }],
    pointerClass: [{
      type: HostBinding,
      args: ["class.k-cursor-pointer"]
    }]
  });
})();
var ActionSheetListComponent = class _ActionSheetListComponent {
  renderer;
  ngZone;
  element;
  groupItems = [];
  allItems = [];
  itemTemplate;
  itemClick = new EventEmitter();
  subscriptions = new Subscription();
  constructor(renderer, ngZone, element) {
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.element = element;
  }
  ngAfterViewInit() {
    this.initDomEvents();
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  initDomEvents() {
    if (!this.element) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      const nativeElement = this.element.nativeElement;
      this.subscriptions.add(this.renderer.listen(nativeElement, "click", this.clickHandler.bind(this)));
    });
  }
  clickHandler(e) {
    const itemIndex2 = getActionSheetItemIndex(e.target, ACTIONSHEET_ITEM_INDEX_ATTRIBUTE, this.element.nativeElement);
    const item = this.allItems[itemIndex2];
    if (!item) {
      return;
    }
    if (item.disabled) {
      e.preventDefault();
      return;
    }
    this.ngZone.run(() => {
      this.itemClick.emit({
        item,
        originalEvent: e
      });
    });
  }
  setAttrIndex(item) {
    return this.allItems.indexOf(item);
  }
  static ɵfac = function ActionSheetListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ActionSheetListComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ActionSheetListComponent,
    selectors: [["", "kendoActionSheetList", ""]],
    inputs: {
      groupItems: "groupItems",
      allItems: "allItems",
      itemTemplate: "itemTemplate"
    },
    outputs: {
      itemClick: "itemClick"
    },
    attrs: _c3,
    decls: 1,
    vars: 1,
    consts: [["kendoActionSheetItem", "", "tabindex", "0", "role", "button", 3, "k-actionsheet-item", "k-disabled", "ngClass", "ngStyle", "itemTemplate", "item", 4, "ngFor", "ngForOf"], ["kendoActionSheetItem", "", "tabindex", "0", "role", "button", 3, "ngClass", "ngStyle", "itemTemplate", "item"]],
    template: function ActionSheetListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, ActionSheetListComponent_span_0_Template, 1, 10, "span", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngForOf", ctx.groupItems);
      }
    },
    dependencies: [NgForOf, ActionSheetItemComponent, NgClass, NgStyle],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActionSheetListComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoActionSheetList]",
      template: `
            <span *ngFor="let item of groupItems" kendoActionSheetItem
                tabindex="0"
                role="button"
                [attr.aria-disabled]="item.disabled"
                [class.k-actionsheet-item]="true"
                [attr.${ACTIONSHEET_ITEM_INDEX_ATTRIBUTE}]="setAttrIndex(item)"
                [class.k-disabled]="item.disabled"
                [ngClass]="item.cssClass"
                [ngStyle]="item.cssStyle"
                [itemTemplate]="itemTemplate"
                [item]="item">
            </span>
    `,
      standalone: true,
      imports: [NgForOf, ActionSheetItemComponent, NgClass, NgStyle]
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: ElementRef
    }];
  }, {
    groupItems: [{
      type: Input
    }],
    allItems: [{
      type: Input
    }],
    itemTemplate: [{
      type: Input
    }],
    itemClick: [{
      type: Output
    }]
  });
})();
var DEFAULT_ANIMATION_CONFIG = {
  duration: 300
};
var ActionSheetComponent = class _ActionSheetComponent {
  element;
  ngZone;
  renderer;
  localizationService;
  builder;
  cdr;
  /**
   * @hidden
   */
  get hostClass() {
    return this.expanded;
  }
  /**
   * @hidden
   */
  direction;
  /**
   * Specifies the text that is rendered as title.
   */
  title;
  /**
   * Specifies the text that is rendered under the title.
   */
  subtitle;
  /**
   * The collection of items that will be rendered in the ActionSheet.
   */
  items;
  /**
   * The CSS classes that will be rendered on the inner ActionSheet element.
   * Supports the type of values that are supported by [ngClass](link:site.data.urls.angular['ngclassapi']).
   */
  cssClass;
  /**
   * Configures the ActionSheet opening and closing animations ([see example]({% slug animations_actionsheet %})).
   * By default the animations are turned off. The default animations' duration is `300ms`.
   *
   * @default true
   */
  animation = true;
  /**
   * Specifies the state of the ActionSheet.
   *
   * @default false
   */
  expanded = false;
  /**
   * Sets the `aria-labelledby` attribute of the ActionSheet wrapper element.
   * Use this option when the built-in header element is replaced through the [`ActionSheetHeaderTemplate`]({% slug api_navigation_actionsheetheadertemplatedirective %})
   * or [`ActionSheetContentTemplate`]({% slug api_navigation_actionsheetcontenttemplatedirective %}).
   *
   */
  titleId = getId("k-actionsheet-title");
  /**
   * Fires when the `expanded` property of the component is updated.
   * Used to provide a two-way binding for the `expanded` property.
   */
  expandedChange = new EventEmitter();
  /**
   * Fires when the ActionSheet is expanded and its animation is complete.
   */
  expand = new EventEmitter();
  /**
   * Fires when the ActionSheet is collapsed and its animation is complete.
   */
  collapse = new EventEmitter();
  /**
   * Fires when an ActionSheet item is clicked.
   */
  itemClick = new EventEmitter();
  /**
   * Fires when the modal overlay is clicked.
   */
  overlayClick = new EventEmitter();
  /**
   * @hidden
   */
  childContainer;
  /**
   * @hidden
   */
  actionSheetTemplate;
  /**
   * @hidden
   */
  headerTemplate;
  /**
   * @hidden
   */
  contentTemplate;
  /**
   * @hidden
   */
  itemTemplate;
  /**
   * @hidden
   */
  footerTemplate;
  dynamicRTLSubscription;
  rtl = false;
  domSubs = new Subscription();
  player;
  animationEnd = new EventEmitter();
  constructor(element, ngZone, renderer, localizationService, builder, cdr) {
    this.element = element;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.localizationService = localizationService;
    this.builder = builder;
    this.cdr = cdr;
    validatePackage(packageMetadata2);
    this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.rtl = rtl;
      this.direction = this.rtl ? "rtl" : "ltr";
    });
  }
  ngAfterViewInit() {
    this.initDomEvents();
    this.setCssVariables();
  }
  ngOnChanges(changes) {
    if (changes["expanded"] && this.expanded) {
      this.setExpanded(true);
    }
  }
  ngOnDestroy() {
    this.domSubs.unsubscribe();
    if (this.dynamicRTLSubscription) {
      this.dynamicRTLSubscription.unsubscribe();
    }
    if (this.player) {
      this.player.destroy();
    }
  }
  /**
   * Toggles the visibility of the ActionSheet.
   *
   * @param expanded? - Boolean. Specifies if the ActionSheet will be expanded or collapsed.
   */
  toggle(expanded2) {
    const previous = this.expanded;
    const current = isPresent(expanded2) ? expanded2 : !previous;
    if (current === previous) {
      return;
    }
    if (current === true) {
      this.setExpanded(true);
    } else if (current === false && !this.animation) {
      this.setExpanded(false);
    }
    if (this.animation) {
      this.animationEnd.pipe(take(1)).subscribe(() => {
        this.onAnimationEnd(current);
      });
      this.playAnimation(current);
    } else {
      this[current ? "expand" : "collapse"].emit();
    }
  }
  /**
   * @hidden
   */
  get topGroupItems() {
    return this.items?.filter((item) => !item.group || item.group === "top");
  }
  /**
   * @hidden
   */
  get bottomGroupItems() {
    return this.items?.filter((item) => item.group === "bottom");
  }
  /**
   * @hidden
   */
  onItemClick(ev) {
    this.itemClick.emit(ev);
  }
  /**
   * @hidden
   */
  onOverlayClick() {
    this.overlayClick.emit();
  }
  /**
   * @hidden
   */
  get shouldRenderSeparator() {
    return this.topGroupItems?.length > 0 && this.bottomGroupItems?.length > 0;
  }
  initDomEvents() {
    if (!this.element) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      this.domSubs.add(this.renderer.listen(this.element.nativeElement, "keydown", (ev) => {
        this.onKeyDown(ev);
      }));
    });
  }
  setCssVariables() {
    if (!this.element || !isDocumentAvailable()) {
      return;
    }
    this.element.nativeElement.style.setProperty("--kendo-actionsheet-height", "auto");
    this.element.nativeElement.style.setProperty("--kendo-actionsheet-max-height", "none");
  }
  onKeyDown(event) {
    const target = event.target;
    if (event.keyCode === Keys.Tab) {
      this.ngZone.run(() => {
        this.keepFocusWithinComponent(target, event);
      });
    }
    if (event.keyCode === Keys.Escape) {
      this.ngZone.run(() => {
        this.overlayClick.emit();
      });
    }
    if (event.keyCode === Keys.Enter) {
      this.ngZone.run(() => {
        this.triggerItemClick(target, event);
      });
    }
  }
  handleInitialFocus() {
    const [firstFocusable] = getFirstAndLastFocusable(this.element.nativeElement);
    if (firstFocusable) {
      firstFocusable.focus();
    }
  }
  keepFocusWithinComponent(target, event) {
    const wrapper = this.element.nativeElement;
    const [firstFocusable, lastFocusable] = getFirstAndLastFocusable(wrapper);
    const tabAfterLastFocusable = !event.shiftKey && target === lastFocusable;
    const shiftTabAfterFirstFocusable = event.shiftKey && target === firstFocusable;
    if (tabAfterLastFocusable) {
      event.preventDefault();
      firstFocusable.focus();
    }
    if (shiftTabAfterFirstFocusable) {
      event.preventDefault();
      lastFocusable.focus();
    }
  }
  triggerItemClick(target, event) {
    const itemIndex2 = getActionSheetItemIndex(target, ACTIONSHEET_ITEM_INDEX_ATTRIBUTE, this.element.nativeElement);
    const item = isPresent(itemIndex2) ? this.items[itemIndex2] : null;
    if (!item || item.disabled) {
      return;
    }
    this.itemClick.emit({
      item,
      originalEvent: event
    });
  }
  setExpanded(value) {
    this.expanded = value;
    this.expandedChange.emit(value);
    if (this.expanded) {
      this.cdr.detectChanges();
      this.handleInitialFocus();
    }
  }
  onAnimationEnd(currentExpanded) {
    if (currentExpanded) {
      this.expand.emit();
    } else {
      this.setExpanded(false);
      this.collapse.emit();
    }
  }
  playAnimation(expanded2) {
    const duration = typeof this.animation !== "boolean" && this.animation.duration ? this.animation.duration : DEFAULT_ANIMATION_CONFIG.duration;
    const contentHeight = getComputedStyle(this.childContainer.nativeElement).height;
    const animation = expanded2 ? slideUp(duration, contentHeight) : slideDown(duration, contentHeight);
    const factory = this.builder.build(animation);
    this.player = factory.create(this.childContainer.nativeElement);
    this.player.onDone(() => {
      if (this.player) {
        this.animationEnd.emit();
        this.player.destroy();
        this.player = null;
      }
    });
    this.player.play();
  }
  static ɵfac = function ActionSheetComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ActionSheetComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(AnimationBuilder), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ActionSheetComponent,
    selectors: [["kendo-actionsheet"]],
    contentQueries: function ActionSheetComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ActionSheetTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, ActionSheetHeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, ActionSheetContentTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, ActionSheetItemTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, ActionSheetFooterTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheetTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
      }
    },
    viewQuery: function ActionSheetComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c4, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childContainer = _t.first);
      }
    },
    hostVars: 3,
    hostBindings: function ActionSheetComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-actionsheet-container", ctx.hostClass);
      }
    },
    inputs: {
      title: "title",
      subtitle: "subtitle",
      items: "items",
      cssClass: "cssClass",
      animation: "animation",
      expanded: "expanded",
      titleId: "titleId"
    },
    outputs: {
      expandedChange: "expandedChange",
      expand: "expand",
      collapse: "collapse",
      itemClick: "itemClick",
      overlayClick: "overlayClick"
    },
    exportAs: ["kendoActionSheet"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.actionsheet.component"
    }]), ɵɵNgOnChangesFeature],
    decls: 1,
    vars: 1,
    consts: [["childContainer", ""], ["defaultTemplate", ""], ["defaultHeaderTemplate", ""], ["defaultContentTemplate", ""], [4, "ngIf"], [1, "k-overlay", 3, "click"], [1, "k-animation-container", "k-animation-container-shown"], [1, "k-child-animation-container"], ["role", "dialog", "aria-modal", "true", 1, "k-actionsheet", "k-actionsheet-bottom", 3, "ngClass"], [4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet"], ["class", "k-actionsheet-titlebar", 4, "ngIf"], ["class", "k-actionsheet-content", 4, "ngIf"], ["class", "k-actionsheet-footer", 4, "ngIf"], [1, "k-actionsheet-titlebar"], [1, "k-actionsheet-titlebar-group", "k-hbox"], [1, "k-actionsheet-title", 3, "id"], ["class", "k-text-center", 4, "ngIf"], ["class", "k-actionsheet-subtitle k-text-center", 4, "ngIf"], [1, "k-text-center"], [1, "k-actionsheet-subtitle", "k-text-center"], [1, "k-actionsheet-content"], ["kendoActionSheetList", "", "class", "k-list-ul", "role", "group", 3, "groupItems", "allItems", "itemTemplate", "itemClick", 4, "ngIf"], ["class", "k-hr", 4, "ngIf"], ["kendoActionSheetList", "", "role", "group", 1, "k-list-ul", 3, "itemClick", "groupItems", "allItems", "itemTemplate"], [1, "k-hr"], [1, "k-actionsheet-footer"]],
    template: function ActionSheetComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, ActionSheetComponent_ng_container_0_Template, 9, 6, "ng-container", 4);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.expanded);
      }
    },
    dependencies: [NgIf, NgClass, NgTemplateOutlet, ActionSheetListComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActionSheetComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoActionSheet",
      selector: "kendo-actionsheet",
      template: `
        <ng-container *ngIf="expanded">
            <div class="k-overlay" (click)="onOverlayClick()"></div>
            <div class="k-animation-container k-animation-container-shown">
                <div #childContainer class="k-child-animation-container" [style]="'bottom: 0px; width: 100%;'">
                    <div class="k-actionsheet k-actionsheet-bottom"
                        [ngClass]="cssClass"
                        role="dialog"
                        aria-modal="true"
                        [attr.aria-labelledby]="titleId">

                        <ng-template *ngIf="actionSheetTemplate; else defaultTemplate"
                            [ngTemplateOutlet]="actionSheetTemplate?.templateRef">
                        </ng-template>

                        <ng-template #defaultTemplate>
                            <div *ngIf="title || subtitle || headerTemplate" class="k-actionsheet-titlebar">
                                <ng-template *ngIf="headerTemplate; else defaultHeaderTemplate"
                                    [ngTemplateOutlet]="headerTemplate?.templateRef">
                                </ng-template>

                                <ng-template #defaultHeaderTemplate>
                                    <div class="k-actionsheet-titlebar-group k-hbox">
                                        <div class="k-actionsheet-title" [id]="titleId">
                                            <div *ngIf="title" class="k-text-center">{{title}}</div>
                                            <div *ngIf="subtitle" class="k-actionsheet-subtitle k-text-center">{{subtitle}}</div>
                                        </div>
                                    </div>
                                </ng-template>
                            </div>

                            <div *ngIf="items || contentTemplate" class="k-actionsheet-content">
                                <ng-template *ngIf="contentTemplate; else defaultContentTemplate"
                                    [ngTemplateOutlet]="contentTemplate?.templateRef">
                                </ng-template>
                                <ng-template #defaultContentTemplate>
                                    <div *ngIf="topGroupItems" kendoActionSheetList
                                        class="k-list-ul"
                                        role="group"
                                        [groupItems]="topGroupItems"
                                        [allItems]="items"
                                        [itemTemplate]="itemTemplate?.templateRef"
                                        (itemClick)="onItemClick($event)">
                                    </div>
            
                                    <hr *ngIf="shouldRenderSeparator" class="k-hr"/>
            
                                    <div *ngIf="bottomGroupItems" kendoActionSheetList
                                        class="k-list-ul"
                                        role="group"
                                        [groupItems]="bottomGroupItems"
                                        [allItems]="items"
                                        [itemTemplate]="itemTemplate?.templateRef"
                                        (itemClick)="onItemClick($event)">
                                    </div>
                                </ng-template>
                            </div>
                            <div  *ngIf="footerTemplate" class="k-actionsheet-footer">
                                <ng-template
                                    [ngTemplateOutlet]="footerTemplate?.templateRef">
                                </ng-template>
                            </div>
                        </ng-template>
                    </div>
                </div>
            </div>
        </ng-container>
    `,
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.actionsheet.component"
      }],
      standalone: true,
      imports: [NgIf, NgClass, NgTemplateOutlet, ActionSheetListComponent]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: LocalizationService
    }, {
      type: AnimationBuilder
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-actionsheet-container"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    title: [{
      type: Input
    }],
    subtitle: [{
      type: Input
    }],
    items: [{
      type: Input
    }],
    cssClass: [{
      type: Input
    }],
    animation: [{
      type: Input
    }],
    expanded: [{
      type: Input
    }],
    titleId: [{
      type: Input
    }],
    expandedChange: [{
      type: Output
    }],
    expand: [{
      type: Output
    }],
    collapse: [{
      type: Output
    }],
    itemClick: [{
      type: Output
    }],
    overlayClick: [{
      type: Output
    }],
    childContainer: [{
      type: ViewChild,
      args: ["childContainer"]
    }],
    actionSheetTemplate: [{
      type: ContentChild,
      args: [ActionSheetTemplateDirective]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [ActionSheetHeaderTemplateDirective]
    }],
    contentTemplate: [{
      type: ContentChild,
      args: [ActionSheetContentTemplateDirective]
    }],
    itemTemplate: [{
      type: ContentChild,
      args: [ActionSheetItemTemplateDirective]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [ActionSheetFooterTemplateDirective]
    }]
  });
})();
var PreventableEvent2 = class {
  prevented = false;
  /**
   * Prevents the default action for a specified event.
   * In this way, the source component suppresses
   * the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * Returns `true` if the event was prevented
   * by any of its subscribers.
   *
   * @returns `true` if the default action was prevented.
   * Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
  /**
   * @hidden
   */
  constructor(args) {
    Object.assign(this, args);
  }
};
var BottomNavigationSelectEvent = class extends PreventableEvent2 {
  /**
   * The index of the selected item in the `items` collection.
   */
  index;
  /**
   * The selected BottomNavigation item.
   */
  item;
  /**
   * The DOM event that triggered the selection.
   */
  originalEvent;
  /**
   * The BottomNavigation that triggered the event.
   */
  sender;
  /**
   * @hidden
   */
  constructor(args) {
    super();
    Object.assign(this, args);
  }
};
var BottomNavigationItemTemplateDirective = class _BottomNavigationItemTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function BottomNavigationItemTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BottomNavigationItemTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _BottomNavigationItemTemplateDirective,
    selectors: [["", "kendoBottomNavigationItemTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BottomNavigationItemTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoBottomNavigationItemTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var closestInScope2 = (target, targetAttr, predicate, scope) => {
  while (target && target !== scope && !predicate(target, targetAttr)) {
    target = target.parentNode;
  }
  if (target !== scope) {
    return target;
  }
};
var hasItemIndex = (item, indexAttr) => isPresent3(item.getAttribute(indexAttr));
var itemIndex = (item, indexAttr) => +item.getAttribute(indexAttr);
var closestItem = (target, targetAttr, scope) => closestInScope2(target, targetAttr, hasItemIndex, scope);
var BOTTOMNAVIGATION_ITEM_INDEX = "data-kendo-bottomnavigation-index";
var colors = ["primary", "secondary", "tertiary", "info", "success", "warning", "error", "dark", "light", "inverse"];
var BottomNavigationItemComponent = class _BottomNavigationItemComponent {
  itemTemplate;
  item;
  index;
  disabledComponent;
  selectedIdx;
  orientation;
  get disabledClass() {
    return this.item.disabled;
  }
  get label() {
    return this.item.text ? this.item.text : null;
  }
  get tabindex() {
    return this.item.tabIndex ? this.item.tabIndex : 0;
  }
  get selectedClass() {
    return this.selectedIdx ? this.selectedIdx === this.index : this.item.selected;
  }
  get itemIcon() {
    return Boolean(this.item.icon || this.item.iconClass || this.item.svgIcon);
  }
  get iconClasses() {
    const kendoIcon = this.item.icon ? `k-icon k-i-${this.item.icon}` : "";
    const customIcon = this.item.iconClass ? this.item.iconClass : "";
    return `${kendoIcon} ${customIcon}`;
  }
  static ɵfac = function BottomNavigationItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BottomNavigationItemComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _BottomNavigationItemComponent,
    selectors: [["", "kendoBottomNavigationItem", ""]],
    hostVars: 8,
    hostBindings: function BottomNavigationItemComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-disabled", ctx.disabledClass)("aria-label", ctx.label)("tabindex", ctx.tabindex)("aria-current", ctx.selectedClass);
        ɵɵclassProp("k-disabled", ctx.disabledClass)("k-selected", ctx.selectedClass);
      }
    },
    inputs: {
      itemTemplate: "itemTemplate",
      item: "item",
      index: "index",
      disabledComponent: "disabledComponent",
      selectedIdx: "selectedIdx",
      orientation: "orientation"
    },
    attrs: _c5,
    decls: 2,
    vars: 2,
    consts: [[4, "ngIf"], ["innerCssClass", "k-bottom-nav-item-icon", "size", "xlarge", 3, "name", "customFontClass", "svgIcon", 4, "ngIf"], ["class", "k-bottom-nav-item-text", 4, "ngIf"], ["innerCssClass", "k-bottom-nav-item-icon", "size", "xlarge", 3, "name", "customFontClass", "svgIcon"], [1, "k-bottom-nav-item-text"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function BottomNavigationItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, BottomNavigationItemComponent_ng_container_0_Template, 3, 2, "ng-container", 0)(1, BottomNavigationItemComponent_1_Template, 1, 4, null, 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", !ctx.itemTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.itemTemplate);
      }
    },
    dependencies: [NgIf, IconWrapperComponent, NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BottomNavigationItemComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoBottomNavigationItem]",
      template: `
        <ng-container *ngIf="!itemTemplate">
            <kendo-icon-wrapper *ngIf="itemIcon"
                innerCssClass="k-bottom-nav-item-icon"
                size="xlarge"
                [name]="item.icon"
                [customFontClass]="item.iconClass"
                [svgIcon]="item.svgIcon"></kendo-icon-wrapper>
            <span *ngIf="item.text" class="k-bottom-nav-item-text">{{item.text}}</span>
        </ng-container>
        <ng-template *ngIf="itemTemplate"
            [ngTemplateOutlet]="itemTemplate?.templateRef"
            [ngTemplateOutletContext]="{ $implicit: item }">
        </ng-template>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent, NgTemplateOutlet]
    }]
  }], null, {
    itemTemplate: [{
      type: Input
    }],
    item: [{
      type: Input
    }],
    index: [{
      type: Input
    }],
    disabledComponent: [{
      type: Input
    }],
    selectedIdx: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }, {
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    label: [{
      type: HostBinding,
      args: ["attr.aria-label"]
    }],
    tabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    selectedClass: [{
      type: HostBinding,
      args: ["attr.aria-current"]
    }, {
      type: HostBinding,
      args: ["class.k-selected"]
    }]
  });
})();
var BottomNavigationComponent = class _BottomNavigationComponent {
  localization;
  hostElement;
  ngZone;
  changeDetector;
  renderer;
  /**
   * The collection of items that will be rendered in the BottomNavigation ([see example]({% slug items_bottomnavigation %})).
   */
  items;
  /**
   * Sets a top border to the BottomNavigation ([see example]({% slug appearance_bottomnavigation %})).
   *
   * @default false
   */
  border = false;
  /**
   * Disables the whole BottomNavigation.
   *
   * @default false
   */
  disabled = false;
  /**
   * The fill style of the BottomNavigation ([see example]({% slug appearance_bottomnavigation %})).
   *
   * * The possible values are:
   * * (Default) `flat`
   * * `solid`
   */
  set fill(fill) {
    this.renderer.removeClass(this._nativeHostElement, `k-bottom-nav-${this.fill}`);
    this.renderer.removeClass(this._nativeHostElement, `k-bottom-nav-${this.fill}-${this.themeColor}`);
    this._fill = fill === "solid" ? "solid" : "flat";
    this.renderer.addClass(this._nativeHostElement, `k-bottom-nav-${this._fill}`);
    this.renderer.addClass(this._nativeHostElement, `k-bottom-nav-${this._fill}-${this.themeColor}`);
  }
  get fill() {
    return this._fill;
  }
  /**
   * Specifies how the icon and text label are positioned in the BottomNavigation items.
   *
   * The possible values are:
   * * (Default) `vertical` - Renders the text below the icon.
   * * `horizontal` - Renders the icon and the text on the same line.
   */
  set itemFlow(itemFlow) {
    this.renderer.removeClass(this._nativeHostElement, `k-bottom-nav-item-flow-${this.itemFlow}`);
    this._itemFlow = itemFlow === "horizontal" ? "horizontal" : "vertical";
    this.renderer.addClass(this._nativeHostElement, `k-bottom-nav-item-flow-${this._itemFlow}`);
  }
  get itemFlow() {
    return this._itemFlow;
  }
  /**
   * Specifies the position and behavior of the BottomNavigation when the page is scrollable ([see example]({% slug positioning_bottomnavigation %})).
   *
   * The possible values are:
   * * (Default) `fixed` - The BottomNavigation always stays at the bottom of the viewport, regardless of the page scroll position.
   * * `sticky` - Positions the BottomNavigation at the end of the scrollable container.
   */
  set positionMode(positionMode) {
    this.renderer.removeClass(this._nativeHostElement, `k-pos-${this.positionMode}`);
    this._positionMode = positionMode === "sticky" ? "sticky" : "fixed";
    this.renderer.addClass(this._nativeHostElement, `k-pos-${this._positionMode}`);
  }
  get positionMode() {
    return this._positionMode;
  }
  /**
   * Specifies the theme color of the BottomNavigation ([see example]({% slug appearance_bottomnavigation %})).
   *
   * * The possible values are:
   * * (Default) `primary` - Applies coloring based on the primary theme color.
   * * `secondary` - Applies coloring based on the secondary theme color.
   * * `tertiary` - Applies coloring based on the tertiary theme color.
   * * `info` - Applies coloring based on the info theme color.
   * * `success` - Applies coloring based on the success theme color.
   * * `warning` - Applies coloring based on the warning theme color.
   * * `error` - Applies coloring based on the error theme color.
   * * `dark` - Applies coloring based on the dark theme color.
   * * `light` - Applies coloring based on the light theme color.
   * * `inverse` - Applies coloring based on the inverted theme color.
   */
  set themeColor(themeColor) {
    const newColor = colors.find((color) => color === themeColor);
    if (newColor) {
      this.renderer.removeClass(this._nativeHostElement, `k-bottom-nav-${this.fill}-${this._themeColor}`);
      this._themeColor = themeColor;
      this.renderer.addClass(this._nativeHostElement, `k-bottom-nav-${this.fill}-${this._themeColor}`);
    }
  }
  get themeColor() {
    return this._themeColor;
  }
  /**
   * Fires each time an item is selected. This event is preventable.
   */
  select = new EventEmitter();
  /**
   * @hidden
   */
  hostClass = true;
  /**
   * @hidden
   */
  get borderClass() {
    return this.border;
  }
  /**
   * @hidden
   */
  get disabledClass() {
    return this.disabled;
  }
  /**
   * @hidden
   */
  role = "navigation";
  /**
   * @hidden
   */
  direction;
  /**
   * @hidden
   */
  itemTemplate;
  /**
   * @hidden
   */
  selectedIdx;
  _fill = "flat";
  _itemFlow = "vertical";
  _positionMode = "fixed";
  _themeColor = "primary";
  _nativeHostElement;
  dynamicRTLSubscription;
  subscriptions = new Subscription();
  rtl = false;
  constructor(localization, hostElement, ngZone, changeDetector, renderer) {
    this.localization = localization;
    this.hostElement = hostElement;
    this.ngZone = ngZone;
    this.changeDetector = changeDetector;
    this.renderer = renderer;
    validatePackage(packageMetadata2);
    this._nativeHostElement = this.hostElement.nativeElement;
    this.dynamicRTLSubscription = this.localization.changes.subscribe(({
      rtl
    }) => {
      this.rtl = rtl;
      this.direction = this.rtl ? "rtl" : "ltr";
    });
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.initDomEvents();
  }
  /**
   * @hidden
   */
  ngAfterViewInit() {
    this.applyClasses();
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    if (this.dynamicRTLSubscription) {
      this.dynamicRTLSubscription.unsubscribe();
    }
    this.subscriptions.unsubscribe();
  }
  /**
   * @hidden
   */
  selectItem(idx2, args) {
    const eventArgs = new BottomNavigationSelectEvent(__spreadValues({}, args));
    this.select.emit(eventArgs);
    if (!eventArgs.isDefaultPrevented()) {
      this.selectedIdx = idx2;
    }
  }
  applyClasses() {
    this.renderer.addClass(this._nativeHostElement, `k-bottom-nav-${this.fill}`);
    this.renderer.addClass(this._nativeHostElement, `k-bottom-nav-item-flow-${this.itemFlow}`);
    this.renderer.addClass(this._nativeHostElement, `k-pos-${this.positionMode}`);
    this.renderer.addClass(this._nativeHostElement, `k-bottom-nav-${this.fill}-${this.themeColor}`);
  }
  initDomEvents() {
    if (!this.hostElement) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      this.subscriptions.add(this.renderer.listen(this._nativeHostElement, "click", this.clickHandler.bind(this)));
      this.subscriptions.add(this.renderer.listen(this._nativeHostElement, "keydown", this.keyDownHandler.bind(this)));
    });
  }
  clickHandler(e) {
    const itemIdx = this.getBottomNavigationItemIndex(e.target);
    const item = this.items[itemIdx];
    if (!item) {
      return;
    }
    if (item.disabled) {
      e.preventDefault();
      return;
    }
    const args = {
      index: itemIdx,
      item,
      originalEvent: e,
      sender: this
    };
    this.ngZone.run(() => {
      this.selectItem(itemIdx, args);
      this.changeDetector.markForCheck();
    });
  }
  keyDownHandler(e) {
    const isEnterOrSpace = e.keyCode === Keys.Enter || e.keyCode === Keys.Space;
    if (!isEnterOrSpace) {
      return;
    }
    this.clickHandler(e);
  }
  getBottomNavigationItemIndex(target) {
    const item = closestItem(target, BOTTOMNAVIGATION_ITEM_INDEX, this._nativeHostElement);
    if (item) {
      return itemIndex(item, BOTTOMNAVIGATION_ITEM_INDEX);
    }
  }
  static ɵfac = function BottomNavigationComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BottomNavigationComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _BottomNavigationComponent,
    selectors: [["kendo-bottomnavigation"]],
    contentQueries: function BottomNavigationComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, BottomNavigationItemTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);
      }
    },
    hostVars: 8,
    hostBindings: function BottomNavigationComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.role)("dir", ctx.direction);
        ɵɵclassProp("k-bottom-nav", ctx.hostClass)("k-bottom-nav-border", ctx.borderClass)("k-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      items: "items",
      border: "border",
      disabled: "disabled",
      fill: "fill",
      itemFlow: "itemFlow",
      positionMode: "positionMode",
      themeColor: "themeColor"
    },
    outputs: {
      select: "select"
    },
    exportAs: ["kendoBottomNavigation"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.bottomnavigation"
    }])],
    decls: 1,
    vars: 1,
    consts: [[4, "ngIf"], ["kendoBottomNavigationItem", "", "role", "link", "class", "k-bottom-nav-item", 3, "disabledComponent", "item", "index", "selectedIdx", "itemTemplate", "ngClass", "ngStyle", "orientation", 4, "ngFor", "ngForOf"], ["kendoBottomNavigationItem", "", "role", "link", 1, "k-bottom-nav-item", 3, "disabledComponent", "item", "index", "selectedIdx", "itemTemplate", "ngClass", "ngStyle", "orientation"]],
    template: function BottomNavigationComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, BottomNavigationComponent_ng_container_0_Template, 2, 1, "ng-container", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.items);
      }
    },
    dependencies: [NgIf, NgForOf, BottomNavigationItemComponent, NgClass, NgStyle],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BottomNavigationComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoBottomNavigation",
      selector: "kendo-bottomnavigation",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.bottomnavigation"
      }],
      template: `
        <ng-container *ngIf="items">
            <span kendoBottomNavigationItem
                *ngFor="let item of items; let idx=index"
                role="link"
                class="k-bottom-nav-item"
                [disabledComponent]="disabled"
                [item]="item"
                [index]="idx"
                [selectedIdx]="selectedIdx"
                [itemTemplate]="itemTemplate"
                [attr.${BOTTOMNAVIGATION_ITEM_INDEX}]="idx"
                [ngClass]="item.cssClass"
                [ngStyle]="item.cssStyle"
                [orientation]="itemFlow">
            </span>
        </ng-container>
    `,
      standalone: true,
      imports: [NgIf, NgForOf, BottomNavigationItemComponent, NgClass, NgStyle]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }];
  }, {
    items: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    fill: [{
      type: Input
    }],
    itemFlow: [{
      type: Input
    }],
    positionMode: [{
      type: Input
    }],
    themeColor: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-bottom-nav"]
    }],
    borderClass: [{
      type: HostBinding,
      args: ["class.k-bottom-nav-border"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    itemTemplate: [{
      type: ContentChild,
      args: [BottomNavigationItemTemplateDirective, {
        static: false
      }]
    }]
  });
})();
var BreadCrumbItemTemplateDirective = class _BreadCrumbItemTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function BreadCrumbItemTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BreadCrumbItemTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _BreadCrumbItemTemplateDirective,
    selectors: [["", "kendoBreadCrumbItemTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BreadCrumbItemTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoBreadCrumbItemTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var BREADCRUMB_ITEM_INDEX = "data-kendo-breadcrumb-index";
var DEFAULT_SIZE = "medium";
var SIZES = {
  small: "sm",
  medium: "md",
  large: "lg"
};
var getStylingClasses = (stylingOption, previousValue, newValue) => {
  switch (stylingOption) {
    case "size":
      return {
        toRemove: `k-breadcrumb-${SIZES[previousValue]}`,
        toAdd: newValue !== "none" ? `k-breadcrumb-${SIZES[newValue]}` : ""
      };
    default:
      break;
  }
};
var BreadCrumbItemComponent = class _BreadCrumbItemComponent {
  el;
  item;
  collapseMode;
  index = -1;
  itemTemplate;
  hostClasses = true;
  get isRootItem() {
    return this.item.context.isFirst;
  }
  get isDisabled() {
    return this.disabled || null;
  }
  get isLastItem() {
    return this.item.context.isLast;
  }
  width;
  disabled = false;
  constructor(el) {
    this.el = el;
  }
  ngOnInit() {
    this.disabled = this.item.data && (this.item.data.disabled || this.item.context.isLast);
  }
  ngAfterViewInit() {
    if (isDocumentAvailable()) {
      this.width = outerWidth(this.el.nativeElement);
    }
  }
  onImageLoad() {
    if (isDocumentAvailable()) {
      this.width = outerWidth(this.el.nativeElement);
    }
  }
  static ɵfac = function BreadCrumbItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BreadCrumbItemComponent)(ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _BreadCrumbItemComponent,
    selectors: [["", "kendoBreadCrumbItem", ""]],
    hostVars: 7,
    hostBindings: function BreadCrumbItemComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-disabled", ctx.isDisabled);
        ɵɵclassProp("k-breadcrumb-item", ctx.hostClasses)("k-breadcrumb-root-item", ctx.isRootItem)("k-breadcrumb-last-item", ctx.isLastItem);
      }
    },
    inputs: {
      item: "item",
      collapseMode: "collapseMode",
      index: "index",
      itemTemplate: "itemTemplate"
    },
    attrs: _c6,
    ngContentSelectors: _c8,
    decls: 5,
    vars: 3,
    consts: [["separator", ""], [4, "ngIf"], [4, "ngTemplateOutlet"], ["role", "link", 3, "ngClass", "title", "tabindex", 4, "ngIf"], ["role", "link", 3, "ngClass", "title", "tabindex"], ["class", "k-image", "role", "presentation", 3, "src", "load", 4, "ngIf"], [3, "name", "customFontClass", "svgIcon", 4, "ngIf"], [1, "k-breadcrumb-item-text"], ["role", "presentation", 1, "k-image", 3, "load", "src"], [3, "name", "customFontClass", "svgIcon"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function BreadCrumbItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c7);
        ɵɵtemplate(0, BreadCrumbItemComponent_ng_template_0_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, BreadCrumbItemComponent_ng_container_2_Template, 2, 1, "ng-container", 1)(3, BreadCrumbItemComponent_ng_container_3_Template, 3, 2, "ng-container", 1)(4, BreadCrumbItemComponent_ng_container_4_Template, 2, 1, "ng-container", 1);
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.collapseMode === "wrap");
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.item.context.collapsed);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.collapseMode !== "wrap");
      }
    },
    dependencies: [NgIf, NgTemplateOutlet, NgClass, IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BreadCrumbItemComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoBreadCrumbItem]",
      template: `
        <ng-template #separator>
            <ng-content select="[kendoBreadCrumbSeparator]"></ng-content>
        </ng-template>

        <ng-container *ngIf="collapseMode === 'wrap'">
            <ng-container *ngTemplateOutlet="separator"></ng-container>
        </ng-container>

        <ng-container *ngIf="!item.context.collapsed">
            <span
                *ngIf="!itemTemplate"
                [ngClass]="{
                    'k-breadcrumb-root-link': item.context.isFirst,
                    'k-breadcrumb-link': index !== 0,
                    'k-breadcrumb-icontext-link': (!!item.data.icon || !!item.data.svgIcon) && !!item.data.text,
                    'k-breadcrumb-icon-link': (!!item.data.icon || !!item.data.svgIcon) && !item.data.text,
                    'k-disabled': disabled
                }"
                [title]="item.data.title || ''"
                [tabindex]="disabled ? -1 : 0"
                [attr.aria-disabled]="disabled"
                [attr.aria-current]="item.context.isLast ? 'page' : null"
                role="link"
            >
                <img *ngIf="item.data.imageUrl" (load)="onImageLoad()" [src]="item.data.imageUrl" class="k-image" role="presentation" />
                <kendo-icon-wrapper *ngIf="item.data.icon || item.data.iconClass || item.data.svgIcon"
                    [name]="item.data.icon"
                    [customFontClass]="item.data.iconClass"
                    [svgIcon]="item.data.svgIcon"
                >
                </kendo-icon-wrapper>
                <span class="k-breadcrumb-item-text">{{ item.data.text }}</span>
            </span>
            <ng-template
                *ngIf="itemTemplate"
                [ngTemplateOutlet]="itemTemplate"
                [ngTemplateOutletContext]="{
                    $implicit: item.data,
                    index: index
                }"
            ></ng-template>
        </ng-container>

        <ng-container *ngIf="collapseMode !== 'wrap'">
            <ng-container *ngTemplateOutlet="separator"></ng-container>
        </ng-container>
    `,
      standalone: true,
      imports: [NgIf, NgTemplateOutlet, NgClass, IconWrapperComponent]
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    item: [{
      type: Input
    }],
    collapseMode: [{
      type: Input
    }],
    index: [{
      type: Input
    }],
    itemTemplate: [{
      type: Input
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-breadcrumb-item"]
    }],
    isRootItem: [{
      type: HostBinding,
      args: ["class.k-breadcrumb-root-item"]
    }],
    isDisabled: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    isLastItem: [{
      type: HostBinding,
      args: ["class.k-breadcrumb-last-item"]
    }]
  });
})();
var DEFAULT_ICON = "chevron-right";
var DEFAULT_RTL_ICON = "chevron-left";
var DEFAULT_SVG_ICON = chevronRightIcon;
var DEFAULT_RTL_SVG_ICON = chevronLeftIcon;
var BreadCrumbSeparatorDirective = class _BreadCrumbSeparatorDirective {
  el;
  localization;
  set icon(icon) {
    if (isPresent3(icon)) {
      this._icon = icon;
      this.hasDefaultIcon = false;
    } else {
      this._icon = this.direction === "ltr" ? DEFAULT_ICON : DEFAULT_RTL_ICON;
      this.hasDefaultIcon = true;
    }
  }
  get icon() {
    return this._icon;
  }
  set svgIcon(svgIcon) {
    if (isPresent3(svgIcon)) {
      this._svgIcon = svgIcon;
      this.hasDefaultSvgIcon = false;
    } else {
      this._svgIcon = this.direction === "ltr" ? DEFAULT_SVG_ICON : DEFAULT_RTL_SVG_ICON;
      this.hasDefaultSvgIcon = true;
    }
  }
  get svgIcon() {
    return this._svgIcon;
  }
  ariaHidden = true;
  _icon;
  _svgIcon;
  hasDefaultIcon;
  hasDefaultSvgIcon;
  direction = "ltr";
  localizationChangesSubscription;
  constructor(el, localization) {
    this.el = el;
    this.localization = localization;
    this.direction = this.localization.rtl ? "rtl" : "ltr";
  }
  ngOnInit() {
    this.localizationChangesSubscription = this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
      if (this.hasDefaultIcon) {
        this.icon = void 0;
      }
      if (this.hasDefaultSvgIcon) {
        this.svgIcon = void 0;
      }
    });
  }
  ngOnDestroy() {
    this.localizationChangesSubscription.unsubscribe();
  }
  static ɵfac = function BreadCrumbSeparatorDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BreadCrumbSeparatorDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _BreadCrumbSeparatorDirective,
    selectors: [["", "kendoBreadCrumbSeparator", ""]],
    hostVars: 1,
    hostBindings: function BreadCrumbSeparatorDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-hidden", ctx.ariaHidden);
      }
    },
    inputs: {
      icon: "icon",
      svgIcon: "svgIcon"
    },
    attrs: _c11,
    decls: 1,
    vars: 2,
    consts: [["size", "xsmall", "innerCssClass", "k-breadcrumb-delimiter-icon", 3, "name", "svgIcon"]],
    template: function BreadCrumbSeparatorDirective_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelement(0, "kendo-icon-wrapper", 0);
      }
      if (rf & 2) {
        ɵɵproperty("name", ctx.icon)("svgIcon", ctx.svgIcon);
      }
    },
    dependencies: [IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BreadCrumbSeparatorDirective, [{
    type: Component,
    args: [{
      selector: "[kendoBreadCrumbSeparator]",
      template: `
        <kendo-icon-wrapper
            size='xsmall'
            [name]="icon"
            [svgIcon]="svgIcon"
            innerCssClass="k-breadcrumb-delimiter-icon"
        >
        </kendo-icon-wrapper>
    `,
      standalone: true,
      imports: [IconWrapperComponent]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: LocalizationService
    }];
  }, {
    icon: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }],
    ariaHidden: [{
      type: HostBinding,
      args: ["attr.aria-hidden"]
    }]
  });
})();
var BreadCrumbListComponent = class _BreadCrumbListComponent {
  el;
  zone;
  items = [];
  itemTemplate;
  collapseMode = "auto";
  separatorIcon;
  separatorSVGIcon;
  itemClick = new EventEmitter();
  renderedItems;
  isRootItemContainer;
  domEventsSubscription;
  constructor(el, zone) {
    this.el = el;
    this.zone = zone;
    const element = this.el.nativeElement;
    this.isRootItemContainer = element.classList.contains("k-breadcrumb-root-item-container");
    this.zone.runOutsideAngular(() => {
      const click$ = fromEvent(element, "click");
      const enterKey$ = fromEvent(element, "keydown").pipe(filter((ev) => ev.keyCode === Keys.Enter));
      this.domEventsSubscription = merge(click$, enterKey$).pipe(
        map((ev) => ev.target),
        filter((e) => !e.classList.contains("k-breadcrumb-delimiter-icon")),
        // do not trigger handler when a separator is clicked
        map((e) => this.getItemIndex(e)),
        filter(isPresent3),
        map((i) => parseInt(i, 10)),
        map((i) => this.items[i]),
        filter((item) => !item.data.disabled && !item.context.isLast),
        map((item) => item.data)
      ).subscribe((el2) => {
        this.zone.run(() => this.itemClick.emit(el2));
      });
    });
  }
  ngOnDestroy() {
    this.domEventsSubscription.unsubscribe();
  }
  getItemIndex(target) {
    const item = closestItem(target, BREADCRUMB_ITEM_INDEX, this.el.nativeElement);
    if (item) {
      return itemIndex(item, BREADCRUMB_ITEM_INDEX);
    }
  }
  static ɵfac = function BreadCrumbListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BreadCrumbListComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _BreadCrumbListComponent,
    selectors: [["", "kendoBreadCrumbList", ""]],
    viewQuery: function BreadCrumbListComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(BreadCrumbItemComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.renderedItems = _t);
      }
    },
    inputs: {
      items: "items",
      itemTemplate: "itemTemplate",
      collapseMode: "collapseMode",
      separatorIcon: "separatorIcon",
      separatorSVGIcon: "separatorSVGIcon"
    },
    outputs: {
      itemClick: "itemClick"
    },
    attrs: _c12,
    decls: 1,
    vars: 1,
    consts: [["renderedItem", ""], [4, "ngFor", "ngForOf"], ["kendoBreadCrumbItem", "", 3, "item", "index", "collapseMode", "itemTemplate", 4, "ngIf"], ["kendoBreadCrumbItem", "", 3, "item", "index", "collapseMode", "itemTemplate"], ["kendoBreadCrumbSeparator", "", 3, "icon", "svgIcon", 4, "ngIf"], ["kendoBreadCrumbSeparator", "", 3, "icon", "svgIcon"]],
    template: function BreadCrumbListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, BreadCrumbListComponent_ng_container_0_Template, 2, 1, "ng-container", 1);
      }
      if (rf & 2) {
        ɵɵproperty("ngForOf", ctx.items);
      }
    },
    dependencies: [NgForOf, NgIf, BreadCrumbItemComponent, BreadCrumbSeparatorDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BreadCrumbListComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoBreadCrumbList]",
      template: `
        <ng-container *ngFor="let item of items; let i = index; let isFirst = first; let isLast = last">
            <li
                #renderedItem
                kendoBreadCrumbItem
                *ngIf="!(collapseMode === 'wrap' && isFirst) || isRootItemContainer"
                [attr.${BREADCRUMB_ITEM_INDEX}]="i"
                [item]="item"
                [index]="i"
                [collapseMode]="collapseMode"
                [itemTemplate]="itemTemplate"
            >
                <span kendoBreadCrumbSeparator [icon]="separatorIcon" [svgIcon]="separatorSVGIcon" *ngIf="collapseMode === 'wrap' && !isFirst"></span>
                <span
                    kendoBreadCrumbSeparator
                    [icon]="separatorIcon"
                    [svgIcon]="separatorSVGIcon"
                    *ngIf="collapseMode !== 'wrap' && !isLast && !(item?.context.collapsed && items[i + 1]?.context.collapsed)"
                ></span>
            </li>
        </ng-container>
    `,
      standalone: true,
      imports: [NgForOf, NgIf, BreadCrumbItemComponent, BreadCrumbSeparatorDirective]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, {
    items: [{
      type: Input
    }],
    itemTemplate: [{
      type: Input
    }],
    collapseMode: [{
      type: Input
    }],
    separatorIcon: [{
      type: Input
    }],
    separatorSVGIcon: [{
      type: Input
    }],
    itemClick: [{
      type: Output
    }],
    renderedItems: [{
      type: ViewChildren,
      args: [BreadCrumbItemComponent]
    }]
  });
})();
var getCollapsed = (itemComponent) => itemComponent.item.context.collapsed;
var collapsed = (itemComponent) => getCollapsed(itemComponent) === true;
var expanded = (itemComponent) => getCollapsed(itemComponent) === false;
var toggleFirst = (collapsed2) => (itemComponents) => itemComponents.find((ic) => getCollapsed(ic) === collapsed2).item.context.collapsed = !collapsed2;
var collapseFirst = toggleFirst(false);
var expandFirst = toggleFirst(true);
var BreadCrumbComponent = class _BreadCrumbComponent {
  localization;
  el;
  cdr;
  zone;
  renderer;
  /**
   * The collection of items that will be rendered in the Breadcrumb.
   */
  set items(items) {
    this._items = items || [];
    this.updateItems.next(this._items);
  }
  get items() {
    return this._items;
  }
  /**
   * Defines a name of a [built-in icon]({% slug icons %}) in a Kendo UI theme.
   */
  separatorIcon;
  /**
   * Defines an [`SVGIcon`](slug:api_icons_svgicon) to be rendered as a separator.
   */
  separatorSVGIcon;
  /**
   * Specifies the collapse mode of the Breadcrumb ([see example]({% slug collapse_modes_breadcrumb %})).
   *
   * The possible values are:
   * - `auto` (default)&mdash;items are automatically collapsed based on the width of the Breadcrumb.
   * - `wrap`&mdash;items are wrapped on multiple rows.
   * - `none`&mdash;all items are expanded on the same row.
   *
   * For more information and example refer to the [Collapse Modes]({% slug collapse_modes_breadcrumb %}) article.
   */
  set collapseMode(mode) {
    if (isDevMode() && ["auto", "wrap", "none"].indexOf(mode) < 0) {
      throw new Error('Invalid collapse mode. Allowed values are "auto", "wrap" or "none". \nFor more details see https://www.telerik.com/kendo-angular-ui/components/navigation/api/BreadCrumbCollapseMode/');
    }
    this._collapseMode = mode || "auto";
    this.updateItems.next(this.items);
  }
  get collapseMode() {
    return this._collapseMode;
  }
  /**
   * Specifies the padding of all Breadcrumb elements.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Fires when a Breadcrumb item is clicked. The event will not be fired by disabled items and the last item.
   */
  itemClick = new EventEmitter();
  /**
   * @hidden
   */
  resizeSensor;
  /**
   * @hidden
   */
  itemsContainers;
  /**
   * @hidden
   */
  listComponent;
  /**
   * @hidden
   */
  itemTemplate;
  hostClasses = true;
  get wrapMode() {
    return this.collapseMode === "wrap";
  }
  hostAriaLabel = "Breadcrumb";
  get getDir() {
    return this.direction;
  }
  itemsData$;
  firstItem$;
  _items = [];
  _collapseMode = "auto";
  _size = DEFAULT_SIZE;
  updateItems = new ReplaySubject();
  afterViewInit = new Subject();
  subscriptions = new Subscription();
  direction = "ltr";
  constructor(localization, el, cdr, zone, renderer) {
    this.localization = localization;
    this.el = el;
    this.cdr = cdr;
    this.zone = zone;
    this.renderer = renderer;
    validatePackage(packageMetadata2);
    const updateItems$ = this.updateItems.asObservable().pipe(startWith([]));
    this.direction = localization.rtl ? "rtl" : "ltr";
    this.itemsData$ = updateItems$.pipe(map((items) => items.filter(Boolean)), map((items) => items.map((item, index, collection) => ({
      context: {
        collapsed: false,
        isLast: index === collection.length - 1,
        isFirst: index === 0
      },
      data: item
    }))), share());
    this.firstItem$ = updateItems$.pipe(map((items) => {
      if (items.length > 0) {
        return [{
          context: {
            collapsed: false,
            isLast: items.length === 1,
            isFirst: true
          },
          data: items[0]
        }];
      }
      return [];
    }), share());
  }
  ngOnInit() {
    this.subscriptions.add(this.localization.changes.subscribe(({
      rtl
    }) => this.direction = rtl ? "rtl" : "ltr"));
    this.handleClasses(this.size, "size");
  }
  ngAfterViewInit() {
    this.attachResizeHandler();
    this.afterViewInit.next();
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  handleResize() {
    const autoCollapseCandidates = [...this.listComponent.renderedItems.toArray().filter((ri) => !ri.item.context.isFirst && !ri.item.context.isLast)];
    const componentWidth = Math.floor(outerWidth(this.el.nativeElement));
    const itemsContainerWidth = Math.round(this.itemsContainers.toArray().map((el) => outerWidth(el.nativeElement)).reduce((acc, curr) => acc + curr, 0));
    const nextExpandWidth = Math.ceil(([...autoCollapseCandidates].reverse().find(collapsed) || {
      width: 0
    }).width);
    if (componentWidth <= itemsContainerWidth && autoCollapseCandidates.find(expanded)) {
      collapseFirst(autoCollapseCandidates);
      this.cdr.detectChanges();
      return this.handleResize();
    }
    if (componentWidth > itemsContainerWidth + nextExpandWidth && autoCollapseCandidates.find(collapsed)) {
      expandFirst([...autoCollapseCandidates].reverse());
      this.cdr.detectChanges();
      return this.handleResize();
    }
  }
  shouldResize() {
    return isDocumentAvailable() && this.collapseMode === "auto";
  }
  attachResizeHandler() {
    this.subscriptions.add(merge(this.resizeSensor.resize, this.itemsData$, this.afterViewInit.asObservable()).pipe(filter(() => this.shouldResize())).subscribe(() => {
      this.resizeHandler();
    }));
  }
  handleClasses(value, input) {
    const elem = this.el.nativeElement;
    const classes = getStylingClasses(input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  resizeHandler = () => {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.zone.run(() => {
        if (this.listComponent) {
          this.handleResize();
          this.resizeSensor.acceptSize();
        }
      });
    }));
  };
  static ɵfac = function BreadCrumbComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BreadCrumbComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _BreadCrumbComponent,
    selectors: [["kendo-breadcrumb"]],
    contentQueries: function BreadCrumbComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, BreadCrumbItemTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);
      }
    },
    viewQuery: function BreadCrumbComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c13, 7);
        ɵɵviewQuery(BreadCrumbListComponent, 7);
        ɵɵviewQuery(_c14, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.resizeSensor = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.itemsContainers = _t);
      }
    },
    hostVars: 6,
    hostBindings: function BreadCrumbComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-label", ctx.hostAriaLabel)("dir", ctx.getDir);
        ɵɵclassProp("k-breadcrumb", ctx.hostClasses)("k-breadcrumb-wrap", ctx.wrapMode);
      }
    },
    inputs: {
      items: "items",
      separatorIcon: "separatorIcon",
      separatorSVGIcon: "separatorSVGIcon",
      collapseMode: "collapseMode",
      size: "size"
    },
    outputs: {
      itemClick: "itemClick"
    },
    exportAs: ["kendoBreadCrumb"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.breadcrumb"
    }])],
    decls: 6,
    vars: 13,
    consts: [["itemsContainer", ""], ["resizeSensor", ""], ["kendoBreadCrumbList", "", "class", "k-breadcrumb-root-item-container", 3, "items", "itemTemplate", "collapseMode", "separatorIcon", "separatorSVGIcon", "itemClick", 4, "ngIf"], ["kendoBreadCrumbList", "", 1, "k-breadcrumb-container", 3, "itemClick", "items", "itemTemplate", "collapseMode", "separatorIcon", "separatorSVGIcon", "ngClass"], [3, "rateLimit"], ["kendoBreadCrumbList", "", 1, "k-breadcrumb-root-item-container", 3, "itemClick", "items", "itemTemplate", "collapseMode", "separatorIcon", "separatorSVGIcon"]],
    template: function BreadCrumbComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵtemplate(0, BreadCrumbComponent_ol_0_Template, 3, 7, "ol", 2);
        ɵɵelementStart(1, "ol", 3, 0);
        ɵɵpipe(3, "async");
        ɵɵlistener("itemClick", function BreadCrumbComponent_Template_ol_itemClick_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.itemClick.emit($event));
        });
        ɵɵelementEnd();
        ɵɵelement(4, "kendo-resize-sensor", 4, 1);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.collapseMode === "wrap");
        ɵɵadvance();
        ɵɵproperty("items", ɵɵpipeBind1(3, 8, ctx.itemsData$))("itemTemplate", ctx.itemTemplate == null ? null : ctx.itemTemplate.templateRef)("collapseMode", ctx.collapseMode)("separatorIcon", ctx.separatorIcon)("separatorSVGIcon", ctx.separatorSVGIcon)("ngClass", ɵɵpureFunction2(10, _c15, ctx.collapseMode === "wrap", ctx.collapseMode === "none"));
        ɵɵadvance(3);
        ɵɵproperty("rateLimit", 1e3);
      }
    },
    dependencies: [NgIf, BreadCrumbListComponent, NgClass, ResizeSensorComponent, AsyncPipe],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BreadCrumbComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoBreadCrumb",
      selector: "kendo-breadcrumb",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.breadcrumb"
      }],
      template: `
        <ol
            #itemsContainer
            kendoBreadCrumbList
            class="k-breadcrumb-root-item-container"
            *ngIf="collapseMode === 'wrap'"
            [items]="firstItem$ | async"
            [itemTemplate]="itemTemplate?.templateRef"
            [collapseMode]="collapseMode"
            [separatorIcon]="separatorIcon"
            [separatorSVGIcon]="separatorSVGIcon"
            (itemClick)="itemClick.emit($event)"
        ></ol>
        <ol
            #itemsContainer
            kendoBreadCrumbList
            class="k-breadcrumb-container"
            [items]="itemsData$ | async"
            [itemTemplate]="itemTemplate?.templateRef"
            [collapseMode]="collapseMode"
            [separatorIcon]="separatorIcon"
            [separatorSVGIcon]="separatorSVGIcon"
            (itemClick)="itemClick.emit($event)"
            [ngClass]="{ '!k-flex-wrap': collapseMode === 'wrap', 'k-flex-none': collapseMode === 'none' }"
        ></ol>
        <kendo-resize-sensor [rateLimit]="1000" #resizeSensor></kendo-resize-sensor>
    `,
      standalone: true,
      imports: [NgIf, BreadCrumbListComponent, NgClass, ResizeSensorComponent, AsyncPipe]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }];
  }, {
    items: [{
      type: Input
    }],
    separatorIcon: [{
      type: Input
    }],
    separatorSVGIcon: [{
      type: Input
    }],
    collapseMode: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    itemClick: [{
      type: Output
    }],
    resizeSensor: [{
      type: ViewChild,
      args: ["resizeSensor", {
        static: true
      }]
    }],
    itemsContainers: [{
      type: ViewChildren,
      args: ["itemsContainer", {
        read: ElementRef
      }]
    }],
    listComponent: [{
      type: ViewChild,
      args: [BreadCrumbListComponent, {
        static: true
      }]
    }],
    itemTemplate: [{
      type: ContentChild,
      args: [BreadCrumbItemTemplateDirective]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-breadcrumb"]
    }],
    wrapMode: [{
      type: HostBinding,
      args: ["class.k-breadcrumb-wrap"]
    }],
    hostAriaLabel: [{
      type: HostBinding,
      args: ["attr.aria-label"]
    }],
    getDir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }]
  });
})();
var KENDO_ACTIONSHEET = [ActionSheetComponent, ActionSheetHeaderTemplateDirective, ActionSheetItemTemplateDirective, ActionSheetContentTemplateDirective, ActionSheetFooterTemplateDirective, ActionSheetTemplateDirective];
var KENDO_APPBAR = [AppBarComponent, AppBarSectionComponent, AppBarSpacerComponent];
var KENDO_BOTTOMNAVIGATION = [BottomNavigationComponent, BottomNavigationItemTemplateDirective];
var KENDO_BREADCRUMB = [BreadCrumbComponent, BreadCrumbItemTemplateDirective];
var KENDO_NAVIGATION = [...KENDO_ACTIONSHEET, ...KENDO_APPBAR, ...KENDO_BOTTOMNAVIGATION, ...KENDO_BREADCRUMB];
var AppBarModule = class _AppBarModule {
  static ɵfac = function AppBarModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AppBarModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _AppBarModule,
    imports: [AppBarComponent, AppBarSectionComponent, AppBarSpacerComponent],
    exports: [AppBarComponent, AppBarSectionComponent, AppBarSpacerComponent]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AppBarModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_APPBAR],
      imports: [...KENDO_APPBAR]
    }]
  }], null, null);
})();
var NavigationModule = class _NavigationModule {
  static ɵfac = function NavigationModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NavigationModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _NavigationModule,
    imports: [ActionSheetComponent, ActionSheetHeaderTemplateDirective, ActionSheetItemTemplateDirective, ActionSheetContentTemplateDirective, ActionSheetFooterTemplateDirective, ActionSheetTemplateDirective, AppBarComponent, AppBarSectionComponent, AppBarSpacerComponent, BottomNavigationComponent, BottomNavigationItemTemplateDirective, BreadCrumbComponent, BreadCrumbItemTemplateDirective],
    exports: [ActionSheetComponent, ActionSheetHeaderTemplateDirective, ActionSheetItemTemplateDirective, ActionSheetContentTemplateDirective, ActionSheetFooterTemplateDirective, ActionSheetTemplateDirective, AppBarComponent, AppBarSectionComponent, AppBarSpacerComponent, BottomNavigationComponent, BottomNavigationItemTemplateDirective, BreadCrumbComponent, BreadCrumbItemTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, ResizeBatchService],
    imports: [ActionSheetComponent, BottomNavigationComponent, BreadCrumbComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_NAVIGATION],
      exports: [...KENDO_NAVIGATION],
      providers: [IconsService, ResizeBatchService]
    }]
  }], null, null);
})();
var BreadCrumbModule = class _BreadCrumbModule {
  static ɵfac = function BreadCrumbModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BreadCrumbModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _BreadCrumbModule,
    imports: [BreadCrumbComponent, BreadCrumbItemTemplateDirective],
    exports: [BreadCrumbComponent, BreadCrumbItemTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, ResizeBatchService],
    imports: [BreadCrumbComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BreadCrumbModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_BREADCRUMB],
      imports: [...KENDO_BREADCRUMB],
      providers: [IconsService, ResizeBatchService]
    }]
  }], null, null);
})();
var BottomNavigationModule = class _BottomNavigationModule {
  static ɵfac = function BottomNavigationModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BottomNavigationModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _BottomNavigationModule,
    imports: [BottomNavigationComponent, BottomNavigationItemTemplateDirective],
    exports: [BottomNavigationComponent, BottomNavigationItemTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService],
    imports: [BottomNavigationComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BottomNavigationModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_BOTTOMNAVIGATION],
      imports: [...KENDO_BOTTOMNAVIGATION],
      providers: [IconsService]
    }]
  }], null, null);
})();
var ActionSheetModule = class _ActionSheetModule {
  static ɵfac = function ActionSheetModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ActionSheetModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ActionSheetModule,
    imports: [ActionSheetComponent, ActionSheetHeaderTemplateDirective, ActionSheetItemTemplateDirective, ActionSheetContentTemplateDirective, ActionSheetFooterTemplateDirective, ActionSheetTemplateDirective],
    exports: [ActionSheetComponent, ActionSheetHeaderTemplateDirective, ActionSheetItemTemplateDirective, ActionSheetContentTemplateDirective, ActionSheetFooterTemplateDirective, ActionSheetTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService],
    imports: [ActionSheetComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActionSheetModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_ACTIONSHEET],
      imports: [...KENDO_ACTIONSHEET],
      providers: [IconsService]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-intl/dist/es/cldr/default-data.js
var defaultData = {
  en: {
    name: "en",
    identity: {
      version: {
        _unicodeVersion: "14.0.0",
        _cldrVersion: "41"
      },
      language: "en"
    },
    territory: "US",
    numbers: {
      symbols: {
        decimal: ".",
        group: ",",
        list: ";",
        percentSign: "%",
        plusSign: "+",
        minusSign: "-",
        exponential: "E",
        superscriptingExponent: "×",
        perMille: "‰",
        infinity: "∞",
        nan: "NaN",
        timeSeparator: ":",
        approximatelySign: "~"
      },
      decimal: {
        patterns: ["n"],
        groupSize: [3]
      },
      scientific: {
        patterns: ["nEn"],
        groupSize: []
      },
      percent: {
        patterns: ["n%"],
        groupSize: [3]
      },
      currency: {
        patterns: ["$n"],
        groupSize: [3],
        "unitPattern-count-one": "n $",
        "unitPattern-count-other": "n $"
      },
      currencies: {
        BGN: {
          displayName: "Bulgarian Lev",
          "displayName-count-one": "Bulgarian lev",
          "displayName-count-other": "Bulgarian leva",
          symbol: "BGN"
        },
        EUR: {
          displayName: "Euro",
          "displayName-count-one": "euro",
          "displayName-count-other": "euros",
          symbol: "€",
          "symbol-alt-narrow": "€"
        },
        USD: {
          displayName: "US Dollar",
          "displayName-count-one": "US dollar",
          "displayName-count-other": "US dollars",
          symbol: "$",
          "symbol-alt-narrow": "$"
        }
      },
      localeCurrency: "USD",
      accounting: {
        patterns: ["$n", "($n)"],
        groupSize: [3]
      }
    },
    calendar: {
      gmtFormat: "GMT{0}",
      gmtZeroFormat: "GMT",
      patterns: {
        d: "M/d/y",
        D: "EEEE, MMMM d, y",
        m: "MMM d",
        M: "MMMM d",
        y: "MMM y",
        Y: "MMMM y",
        F: "EEEE, MMMM d, y h:mm:ss a",
        g: "M/d/y h:mm a",
        G: "M/d/y h:mm:ss a",
        t: "h:mm a",
        T: "h:mm:ss a",
        s: "yyyy'-'MM'-'dd'T'HH':'mm':'ss",
        u: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'"
      },
      dateTimeFormats: {
        full: "{1} 'at' {0}",
        long: "{1} 'at' {0}",
        medium: "{1}, {0}",
        short: "{1}, {0}",
        availableFormats: {
          Bh: "h B",
          Bhm: "h:mm B",
          Bhms: "h:mm:ss B",
          d: "d",
          E: "ccc",
          EBhm: "E h:mm B",
          EBhms: "E h:mm:ss B",
          Ed: "d E",
          Ehm: "E h:mm a",
          EHm: "E HH:mm",
          Ehms: "E h:mm:ss a",
          EHms: "E HH:mm:ss",
          Gy: "y G",
          GyMd: "M/d/y GGGGG",
          GyMMM: "MMM y G",
          GyMMMd: "MMM d, y G",
          GyMMMEd: "E, MMM d, y G",
          h: "h a",
          H: "HH",
          hm: "h:mm a",
          Hm: "HH:mm",
          hms: "h:mm:ss a",
          Hms: "HH:mm:ss",
          hmsv: "h:mm:ss a v",
          Hmsv: "HH:mm:ss v",
          hmv: "h:mm a v",
          Hmv: "HH:mm v",
          M: "L",
          Md: "M/d",
          MEd: "E, M/d",
          MMM: "LLL",
          MMMd: "MMM d",
          MMMEd: "E, MMM d",
          MMMMd: "MMMM d",
          "MMMMW-count-one": "'week' W 'of' MMMM",
          "MMMMW-count-other": "'week' W 'of' MMMM",
          ms: "mm:ss",
          y: "y",
          yM: "M/y",
          yMd: "M/d/y",
          yMEd: "E, M/d/y",
          yMMM: "MMM y",
          yMMMd: "MMM d, y",
          yMMMEd: "E, MMM d, y",
          yMMMM: "MMMM y",
          yQQQ: "QQQ y",
          yQQQQ: "QQQQ y",
          "yw-count-one": "'week' w 'of' Y",
          "yw-count-other": "'week' w 'of' Y"
        }
      },
      timeFormats: {
        full: "h:mm:ss a zzzz",
        long: "h:mm:ss a z",
        medium: "h:mm:ss a",
        short: "h:mm a"
      },
      dateFormats: {
        full: "EEEE, MMMM d, y",
        long: "MMMM d, y",
        medium: "MMM d, y",
        short: "M/d/yy"
      },
      days: {
        format: {
          abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          narrow: ["S", "M", "T", "W", "T", "F", "S"],
          short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
          wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
        },
        "stand-alone": {
          abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          narrow: ["S", "M", "T", "W", "T", "F", "S"],
          short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
          wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
        }
      },
      months: {
        format: {
          abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
          narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
          wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
        },
        "stand-alone": {
          abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
          narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
          wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
        }
      },
      quarters: {
        format: {
          abbreviated: ["Q1", "Q2", "Q3", "Q4"],
          narrow: ["1", "2", "3", "4"],
          wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
        },
        "stand-alone": {
          abbreviated: ["Q1", "Q2", "Q3", "Q4"],
          narrow: ["1", "2", "3", "4"],
          wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
        }
      },
      dayPeriods: {
        format: {
          abbreviated: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "in the morning",
            afternoon1: "in the afternoon",
            evening1: "in the evening",
            night1: "at night"
          },
          narrow: {
            midnight: "mi",
            am: "a",
            "am-alt-variant": "am",
            noon: "n",
            pm: "p",
            "pm-alt-variant": "pm",
            morning1: "in the morning",
            afternoon1: "in the afternoon",
            evening1: "in the evening",
            night1: "at night"
          },
          wide: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "in the morning",
            afternoon1: "in the afternoon",
            evening1: "in the evening",
            night1: "at night"
          }
        },
        "stand-alone": {
          abbreviated: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "morning",
            afternoon1: "afternoon",
            evening1: "evening",
            night1: "night"
          },
          narrow: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "morning",
            afternoon1: "afternoon",
            evening1: "evening",
            night1: "night"
          },
          wide: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "morning",
            afternoon1: "afternoon",
            evening1: "evening",
            night1: "night"
          }
        }
      },
      eras: {
        format: {
          wide: {
            "0": "Before Christ",
            "1": "Anno Domini",
            "0-alt-variant": "Before Common Era",
            "1-alt-variant": "Common Era"
          },
          abbreviated: {
            "0": "BC",
            "1": "AD",
            "0-alt-variant": "BCE",
            "1-alt-variant": "CE"
          },
          narrow: {
            "0": "B",
            "1": "A",
            "0-alt-variant": "BCE",
            "1-alt-variant": "CE"
          }
        }
      },
      dateFields: {
        era: {
          wide: "era",
          short: "era",
          narrow: "era"
        },
        year: {
          wide: "year",
          short: "yr.",
          narrow: "yr."
        },
        quarter: {
          wide: "quarter",
          short: "qtr.",
          narrow: "qtr."
        },
        month: {
          wide: "month",
          short: "mo.",
          narrow: "mo."
        },
        week: {
          wide: "week",
          short: "wk.",
          narrow: "wk."
        },
        weekOfMonth: {
          wide: "week of month",
          short: "wk. of mo.",
          narrow: "wk. of mo."
        },
        day: {
          wide: "day",
          short: "day",
          narrow: "day"
        },
        dayOfYear: {
          wide: "day of year",
          short: "day of yr.",
          narrow: "day of yr."
        },
        weekday: {
          wide: "day of the week",
          short: "day of wk.",
          narrow: "day of wk."
        },
        weekdayOfMonth: {
          wide: "weekday of the month",
          short: "wkday. of mo.",
          narrow: "wkday. of mo."
        },
        dayperiod: {
          short: "AM/PM",
          wide: "AM/PM",
          narrow: "AM/PM"
        },
        hour: {
          wide: "hour",
          short: "hr.",
          narrow: "hr."
        },
        minute: {
          wide: "minute",
          short: "min.",
          narrow: "min."
        },
        second: {
          wide: "second",
          short: "sec.",
          narrow: "sec."
        },
        zone: {
          wide: "time zone",
          short: "zone",
          narrow: "zone"
        },
        millisecond: {
          narrow: "ms",
          short: "ms",
          wide: "millisecond"
        }
      }
    }
  },
  supplemental: {
    likelySubtags: {
      en: "en-Latn-US"
    },
    currencyData: {
      region: {
        US: [{
          USD: {
            _from: "1792-01-01"
          }
        }]
      }
    },
    weekData: {
      firstDay: {
        US: "sun"
      },
      weekendStart: {
        "001": "sat"
      },
      weekendEnd: {
        "001": "sun"
      }
    }
  }
};
var default_data_default = defaultData;

// node_modules/@progress/kendo-intl/dist/es/common/is-string.js
function isString(value) {
  return typeof value === "string";
}

// node_modules/@progress/kendo-intl/dist/es/error-details.js
var error_details_default = {
  "NoLocale": "Missing locale info for '{0}'",
  "NoCurrency": "Cannot determine currency information. Please load the locale currencies data.",
  "NoSupplementalCurrency": "Cannot determine currency. Please load the supplemental currencyData.",
  "NoCurrencyRegion": "No currency data for region '{0}'",
  "NoCurrencyDisplay": "Cannot determine currency display information. Please load the locale currencies data. The default culture does not include the all currencies data.",
  "NoGMTInfo": "Cannot determine locale GMT format. Please load the locale timeZoneNames data.",
  "NoWeekData": "Cannot determine locale first day of week. Please load the supplemental weekData.",
  "NoFirstDay": "Cannot determine locale first day of week. Please load the supplemental weekData. The default culture includes only the 'en-US' first day info.",
  "NoValidCurrency": "Cannot determine a default currency for the {0} locale. Please specify explicitly the currency with the format options.",
  "NoDateFieldNames": "Cannot determine the locale date field names. Please load the locale dateFields data."
};

// node_modules/@progress/kendo-intl/dist/es/errors.js
var formatRegExp = /\{(\d+)}?\}/g;
var IntlError = function IntlError2(ref) {
  var name2 = ref.name;
  var message = ref.message;
  if (!name2 || !message) {
    throw new Error("{ name: string, message: string } object is required!");
  }
  this.name = name2;
  this.message = message;
};
IntlError.prototype.formatMessage = function formatMessage() {
  var values = [], len = arguments.length;
  while (len--) values[len] = arguments[len];
  var flattenValues = flatten(values);
  var formattedMessage = this.message.replace(formatRegExp, function(match2, index) {
    return flattenValues[parseInt(index, 10)];
  });
  return this.name + ": " + formattedMessage;
};
IntlError.prototype.error = function error() {
  var values = [], len = arguments.length;
  while (len--) values[len] = arguments[len];
  return new Error(this.formatMessage(values));
};
var flatten = function(arr) {
  return arr.reduce(function(a, b) {
    return a.concat(b);
  }, []);
};
var toIntlErrors = function(errors2) {
  var predicate = function(prev, name2) {
    prev[name2] = new IntlError({
      name: name2,
      message: errors2[name2]
    });
    return prev;
  };
  return Object.keys(errors2).reduce(predicate, {});
};
var errors = toIntlErrors(error_details_default);

// node_modules/@progress/kendo-intl/dist/es/cldr/info.js
function availableLocaleInfo(fullName, suffixes) {
  var parts = fullName.split("-");
  var language = parts[0];
  var script = parts[1];
  var territory = parts[2];
  return cldr[fullName] || suffixes.indexOf(territory) !== -1 && cldr[language + "-" + territory] || suffixes.indexOf(script) !== -1 && cldr[language + "-" + script] || cldr[language];
}
function localeFullName(language, suffixes) {
  var likelySubtags = cldr.supplemental.likelySubtags;
  for (var idx2 = 0; idx2 < suffixes.length; idx2++) {
    var name2 = likelySubtags[language + "-" + suffixes[idx2]];
    if (name2) {
      return name2;
    }
  }
  if (likelySubtags[language]) {
    return likelySubtags[language];
  }
}
var cldr = default_data_default;
function getLocaleInfo(locale) {
  var info;
  if (isString(locale)) {
    info = localeInfo(locale);
  } else {
    info = locale;
  }
  return info;
}
function localeInfo(locale) {
  if (cldr[locale]) {
    return cldr[locale];
  }
  var likelySubtags = cldr.supplemental.likelySubtags;
  if (likelySubtags) {
    var parts = locale.split("-");
    var language = parts[0];
    var suffixes = parts.slice(1);
    var fullName = localeFullName(language, suffixes);
    var info = fullName ? availableLocaleInfo(fullName, suffixes) : null;
    if (info) {
      return info;
    }
  }
  throw errors.NoLocale.error(locale);
}

// node_modules/@progress/kendo-intl/dist/es/common/constants.js
var DECIMAL = "decimal";
var CURRENCY = "currency";
var ACCOUNTING = "accounting";
var PERCENT = "percent";
var SCIENTIFIC = "scientific";
var CURRENCY_PLACEHOLDER = "$";
var PERCENT_PLACEHOLDER = "%";
var NUMBER_PLACEHOLDER = "n";
var LIST_SEPARATOR = ";";
var GROUP_SEPARATOR = ",";
var POINT = ".";
var EMPTY2 = "";
var DEFAULT_LOCALE = "en";

// node_modules/@progress/kendo-intl/dist/es/cldr/load-numbers.js
var LATIN_NUMBER_FORMATS = "Formats-numberSystem-latn";
var LATIN_NUMBER_SYMBOLS = "symbols-numberSystem-latn";
var patternRegExp = /([#,0.]+)/g;
var cldrCurrencyRegExp = /¤/g;
function getPatterns(pattern) {
  patternRegExp.lastIndex = 0;
  return pattern.replace(cldrCurrencyRegExp, CURRENCY_PLACEHOLDER).replace(patternRegExp, NUMBER_PLACEHOLDER).split(LIST_SEPARATOR);
}
function getGroupSize(pattern) {
  patternRegExp.lastIndex = 0;
  var numberPatterns = patternRegExp.exec(pattern.split(LIST_SEPARATOR)[0])[0].split(POINT);
  var integer = numberPatterns[0];
  var groupSize = integer.split(GROUP_SEPARATOR).slice(1).map(function(group) {
    return group.length;
  }).reverse();
  return groupSize;
}
function loadCurrencyUnitPatterns(currencyInfo, currencyFormats) {
  for (var field in currencyFormats) {
    if (field.startsWith("unitPattern")) {
      currencyInfo[field] = currencyFormats[field].replace("{0}", NUMBER_PLACEHOLDER).replace("{1}", CURRENCY_PLACEHOLDER);
    }
  }
}
function loadNumbersInfo(locale, info) {
  var localeInfo2 = cldr[locale];
  var numbers = localeInfo2.numbers = localeInfo2.numbers || {};
  numbers.symbols = numbers.symbols || {};
  for (var field in info) {
    if (field === LATIN_NUMBER_SYMBOLS) {
      Object.assign(numbers.symbols, info[field]);
    } else if (field.includes(LATIN_NUMBER_FORMATS)) {
      var style2 = field.substr(0, field.indexOf(LATIN_NUMBER_FORMATS));
      var pattern = info[field].standard;
      numbers[style2] = {
        patterns: getPatterns(pattern)
      };
      if (style2 === CURRENCY) {
        numbers[style2].groupSize = getGroupSize((info[DECIMAL + LATIN_NUMBER_FORMATS] || info[field]).standard);
        loadCurrencyUnitPatterns(numbers[style2], info[field]);
        numbers[ACCOUNTING] = {
          patterns: getPatterns(info[field][ACCOUNTING]),
          groupSize: numbers[style2].groupSize
        };
      } else {
        numbers[style2].groupSize = getGroupSize(pattern);
      }
    } else if (field === "currencies") {
      numbers.currencies = info[field];
    }
  }
}

// node_modules/@progress/kendo-intl/dist/es/cldr/load-dates.js
var predefinedDatePatterns = {
  s: "yyyy'-'MM'-'dd'T'HH':'mm':'ss",
  u: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'"
};
var YEAR_REGEX = /y+/g;
var SHORT_DATE = [["dateFormats", "short"]];
var datePatterns = {
  D: [["dateFormats", "full"]],
  m: [["dateTimeFormats", "availableFormats", "MMMd"]],
  M: [["dateTimeFormats", "availableFormats", "MMMMd"]],
  y: [["dateTimeFormats", "availableFormats", "yMMM"]],
  Y: [["dateTimeFormats", "availableFormats", "yMMMM"]],
  F: [["dateFormats", "full"], ["timeFormats", "medium"]],
  g: [["dateTimeFormats", "availableFormats", "yMd"], ["timeFormats", "short"]],
  G: [["dateTimeFormats", "availableFormats", "yMd"], ["timeFormats", "medium"]],
  t: [["timeFormats", "short"]],
  T: [["timeFormats", "medium"]]
};
function toArray(obj) {
  var result = [];
  var names = Object.getOwnPropertyNames(obj);
  for (var idx2 = 0; idx2 < names.length; idx2++) {
    var value = obj[names[idx2]];
    result.push(value);
  }
  return result;
}
function getCalendarNames(info, isObj) {
  var result = {};
  for (var formatType in info) {
    var names = result[formatType] = {};
    for (var format3 in info[formatType]) {
      var formats = info[formatType][format3];
      names[format3] = isObj ? formats : toArray(formats);
    }
  }
  return result;
}
function getEraNames(eras) {
  var result = {};
  var format3 = result.format = {};
  var eraNameMap = {
    eraAbbr: "abbreviated",
    eraNames: "wide",
    eraNarrow: "narrow"
  };
  for (var eraFormatName in eras) {
    var formatName = eraNameMap[eraFormatName];
    format3[formatName] = eras[eraFormatName];
  }
  return result;
}
function loadCalendarNames(locale, calendar) {
  var localeCalendar = cldr[locale].calendar;
  localeCalendar.days = getCalendarNames(calendar.days);
  localeCalendar.months = getCalendarNames(calendar.months);
  localeCalendar.quarters = getCalendarNames(calendar.quarters);
  localeCalendar.dayPeriods = getCalendarNames(calendar.dayPeriods, true);
  localeCalendar.eras = getEraNames(calendar.eras);
}
function loadCalendarDateFields(locale, fields) {
  var localeCalendar = cldr[locale].calendar;
  var dateFields = {};
  for (var field in fields) {
    var ref = field.split("-");
    var fieldName = ref[0];
    var formatType = ref[1];
    if (formatType === void 0) formatType = "wide";
    var fieldInfo = dateFields[fieldName] || {};
    var displayName = fields[field].displayName;
    if (!displayName) {
      continue;
    }
    fieldInfo[formatType] = displayName;
    dateFields[fieldName] = fieldInfo;
  }
  localeCalendar.dateFields = dateFields;
}
function getPredefinedFormat(paths, calendar) {
  var result = [];
  for (var pathIdx = 0; pathIdx < paths.length; pathIdx++) {
    var fields = paths[pathIdx];
    var pattern = calendar;
    for (var idx2 = 0; idx2 < fields.length; idx2++) {
      pattern = pattern[fields[idx2]];
    }
    result.push(pattern);
  }
  return result.join(" ");
}
function loadCalendarPatterns(locale, calendar) {
  var cldrCalendar = cldr[locale].calendar;
  var patterns = cldrCalendar.patterns = {};
  patterns.d = getPredefinedFormat(SHORT_DATE, calendar).replace(YEAR_REGEX, "y");
  for (var pattern in datePatterns) {
    patterns[pattern] = getPredefinedFormat(datePatterns[pattern], calendar);
  }
  for (var pattern$1 in predefinedDatePatterns) {
    patterns[pattern$1] = predefinedDatePatterns[pattern$1];
  }
  var dateTimeFormats = calendar.dateTimeFormats;
  cldrCalendar.dateTimeFormats = {
    full: dateTimeFormats.full,
    long: dateTimeFormats.long,
    medium: dateTimeFormats.medium,
    short: dateTimeFormats.short,
    availableFormats: dateTimeFormats.availableFormats
  };
  cldrCalendar.timeFormats = calendar.timeFormats;
  cldrCalendar.dateFormats = calendar.dateFormats;
}
function loadCalendarInfo(locale, info) {
  var calendar = cldr[locale].calendar = cldr[locale].calendar || {};
  for (var field in info) {
    if (field === "timeZoneNames") {
      calendar.gmtFormat = info[field].gmtFormat;
      calendar.gmtZeroFormat = info[field].gmtZeroFormat;
    } else if (field === "calendars" && info[field].gregorian) {
      loadCalendarPatterns(locale, info[field].gregorian);
      loadCalendarNames(locale, info[field].gregorian);
    } else if (field === "fields") {
      loadCalendarDateFields(locale, info.fields);
    }
  }
}

// node_modules/@progress/kendo-intl/dist/es/cldr/territory.js
function territoryFromName(name2, identity2) {
  var likelySubtags = cldr.supplemental.likelySubtags;
  var parts = name2.split("-");
  if (likelySubtags) {
    var likelyName = likelySubtags[name2] || likelySubtags[parts[0]];
    if (likelyName) {
      parts = likelyName.split("-");
    }
  }
  if (identity2) {
    for (var idx2 = parts.length - 1; idx2 >= 1; idx2--) {
      var part = parts[idx2];
      if (part === identity2.variant || part === identity2.script) {
        parts.splice(idx2, 1);
      }
    }
  }
  var length = parts.length;
  if (length > 1) {
    var territory = parts[length - 1];
    return territory.toUpperCase();
  }
}
function localeTerritory(info) {
  if (info.territory) {
    return info.territory;
  }
  var name2 = info.name;
  var identity2 = info.identity;
  var territory;
  if (identity2 && identity2.territory) {
    territory = identity2.territory;
  } else {
    territory = territoryFromName(name2, identity2);
  }
  info.territory = territory;
  return territory;
}

// node_modules/@progress/kendo-intl/dist/es/cldr/load-units.js
var MILLISECOND = "duration-millisecond";
var UNIT_PATTERN_ONE = "unitPattern-count-one";
var UNIT_PATTERN_OTHER = "unitPattern-count-other";
var placeholderPattern = /\{0\}\s?/;
function extractUnit(unit) {
  var value = unit[UNIT_PATTERN_ONE] || unit[UNIT_PATTERN_OTHER];
  return value.replace(placeholderPattern, "");
}
function loadUnits(localeInfo2, units) {
  localeInfo2.calendar.dateFields.millisecond = {
    narrow: extractUnit(units.narrow[MILLISECOND]),
    short: extractUnit(units.short[MILLISECOND]),
    wide: extractUnit(units.long[MILLISECOND])
  };
}

// node_modules/@progress/kendo-intl/dist/es/cldr/load.js
function loadLocale(locale, info) {
  for (var field in info) {
    if (field === "numbers") {
      loadNumbersInfo(locale, info[field]);
    } else if (field === "dates") {
      loadCalendarInfo(locale, info[field]);
    }
  }
}
function load() {
  var arguments$1 = arguments;
  var length = arguments.length;
  for (var idx2 = 0; idx2 < length; idx2++) {
    var entry = arguments$1[idx2];
    if (entry.main) {
      var locale = Object.keys(entry.main)[0];
      var info = entry.main[locale];
      var localeInfo2 = cldr[locale] = cldr[locale] || {};
      if (info.units) {
        loadUnits(localeInfo2, info.units);
      } else {
        localeInfo2.name = localeInfo2.name || locale;
        localeInfo2.identity = localeInfo2.identity || info.identity;
        localeTerritory(localeInfo2);
        loadLocale(locale, info);
      }
    } else if (entry.supplemental) {
      if (entry.supplemental.weekData) {
        cldr.supplemental.weekData = {
          firstDay: entry.supplemental.weekData.firstDay,
          weekendStart: entry.supplemental.weekData.weekendStart,
          weekendEnd: entry.supplemental.weekData.weekendEnd
        };
      } else if (entry.supplemental.likelySubtags) {
        cldr.supplemental.likelySubtags = Object.assign(cldr.supplemental.likelySubtags, entry.supplemental.likelySubtags);
      } else if (entry.supplemental.currencyData) {
        var currencyData = cldr.supplemental.currencyData;
        currencyData.region = Object.assign(currencyData.region || {}, entry.supplemental.currencyData.region);
        currencyData.fractions = Object.assign(currencyData.fractions || {}, entry.supplemental.currencyData.fractions);
      }
    }
  }
}

// node_modules/@progress/kendo-intl/dist/es/cldr/date-field-name.js
function dateFieldName(options2, locale) {
  if (locale === void 0) locale = DEFAULT_LOCALE;
  var info = localeInfo(locale);
  var dateFields = info.calendar.dateFields;
  if (!dateFields) {
    throw errors.NoDateFieldNames.error();
  }
  var fieldNameInfo = dateFields[options2.type] || {};
  return fieldNameInfo[options2.nameType] || fieldNameInfo["wide"];
}

// node_modules/@progress/kendo-intl/dist/es/cldr/date-format-names.js
function lowerArray(arr) {
  var result = [];
  for (var idx2 = 0; idx2 < arr.length; idx2++) {
    result.push(arr[idx2].toLowerCase());
  }
  return result;
}
function lowerObject(obj) {
  var result = {};
  for (var field in obj) {
    result[field] = obj[field].toLowerCase();
  }
  return result;
}
function cloneLower(obj) {
  var result = Array.isArray(obj) ? lowerArray(obj) : lowerObject(obj);
  return result;
}
function dateFormatNames(locale, options2) {
  var type = options2.type;
  var nameType = options2.nameType;
  var standAlone = options2.standAlone;
  var lower = options2.lower;
  var info = getLocaleInfo(locale);
  var formatType = standAlone ? "stand-alone" : "format";
  var lowerNameType = (lower ? "lower-" : EMPTY2) + nameType;
  var formatNames2 = info.calendar[type][formatType];
  var result = formatNames2[lowerNameType];
  if (!result && lower) {
    result = formatNames2[lowerNameType] = cloneLower(formatNames2[nameType]);
  }
  return result;
}

// node_modules/@progress/kendo-intl/dist/es/cldr/parse-range-date.js
function parseRangeDate(value) {
  var parts = value.split("-");
  var year = parseInt(parts[0], 10);
  var month = parseInt(parts[1], 10) - 1;
  var day = parseInt(parts[2], 10);
  return new Date(year, month, day);
}

// node_modules/@progress/kendo-intl/dist/es/cldr/currency.js
var NoCurrency = errors.NoCurrency;
var NoCurrencyDisplay = errors.NoCurrencyDisplay;
var NoSupplementalCurrency = errors.NoSupplementalCurrency;
var NoCurrencyRegion = errors.NoCurrencyRegion;
var NoValidCurrency = errors.NoValidCurrency;
var DEFAULT_CURRENCY_FRACTIONS = 2;
var SYMBOL = "symbol";
var INVALID_CURRENCY_CODE = "XXX";
var GLOBAL_CURRENCIES = {
  "001": "USD",
  // 001 refers to world. not sure if it is correct to assume USD but seems better than throw an error
  "150": "EUR"
  // 150 territory for Europe
};
function getCurrencyInfo(locale, currency, throwIfNoValid) {
  var info = getLocaleInfo(locale);
  var currencies = info.numbers.currencies;
  if (!currencies) {
    if (throwIfNoValid) {
      throw NoCurrency.error();
    }
    return;
  }
  var currencyDisplayInfo = currencies[currency];
  if (!currencyDisplayInfo) {
    if (throwIfNoValid) {
      throw NoCurrencyDisplay.error();
    }
    return;
  }
  return currencyDisplayInfo;
}
function lengthComparer(a, b) {
  return b.length - a.length;
}
function regionCurrency(regionCurrencies) {
  var latestValidUntil, latestValidUntilRange;
  var latestStillValid, latestStillValidDate;
  for (var idx2 = 0; idx2 < regionCurrencies.length; idx2++) {
    var currency = regionCurrencies[idx2];
    var code = Object.keys(currency)[0];
    var info = currency[code];
    if (code !== INVALID_CURRENCY_CODE && info._tender !== "false" && info._from) {
      if (!info._to) {
        var stillValidDate = parseRangeDate(info._from);
        if (!latestStillValidDate || latestStillValidDate < stillValidDate) {
          latestStillValid = code;
          latestStillValidDate = stillValidDate;
        }
      } else if (!latestStillValid) {
        var validFrom = parseRangeDate(info._from);
        var validTo = parseRangeDate(info._to);
        if (!latestValidUntilRange || latestValidUntilRange.to < validTo || latestValidUntilRange.from < validFrom) {
          latestValidUntil = code;
          latestValidUntilRange = {
            from: validFrom,
            to: validTo
          };
        }
      }
    }
  }
  return latestStillValid || latestValidUntil;
}
function currencyDisplays(locale, currency, throwIfNoValid) {
  if (throwIfNoValid === void 0) throwIfNoValid = true;
  var currencyInfo = getCurrencyInfo(locale, currency, throwIfNoValid);
  if (!currencyInfo) {
    return;
  }
  if (!currencyInfo.displays) {
    var displays = [currency];
    for (var field in currencyInfo) {
      displays.push(currencyInfo[field]);
    }
    displays.sort(lengthComparer);
    currencyInfo.displays = displays;
  }
  return currencyInfo.displays;
}
function currencyDisplay(locale, options2) {
  var value = options2.value;
  var currency = options2.currency;
  var currencyDisplay2 = options2.currencyDisplay;
  if (currencyDisplay2 === void 0) currencyDisplay2 = SYMBOL;
  if (currencyDisplay2 === "code") {
    return currency;
  }
  var currencyInfo = getCurrencyInfo(locale, currency, true);
  var result;
  if (currencyDisplay2 === SYMBOL) {
    result = currencyInfo["symbol-alt-narrow"] || currencyInfo[SYMBOL] || currency;
  } else {
    if (typeof value === "undefined" || value !== 1) {
      result = currencyInfo["displayName-count-other"];
    } else {
      result = currencyInfo["displayName-count-one"];
    }
  }
  return result;
}
function currencyFractionOptions(code) {
  var minimumFractionDigits = DEFAULT_CURRENCY_FRACTIONS;
  var maximumFractionDigits = DEFAULT_CURRENCY_FRACTIONS;
  var fractions = ((cldr.supplemental.currencyData || {}).fractions || {})[code];
  if (fractions && fractions._digits) {
    maximumFractionDigits = minimumFractionDigits = parseInt(fractions._digits, 10);
  }
  return {
    minimumFractionDigits,
    maximumFractionDigits
  };
}
function territoryCurrencyCode(territory, throwIfNoValid) {
  if (throwIfNoValid === void 0) throwIfNoValid = true;
  if (GLOBAL_CURRENCIES[territory]) {
    return GLOBAL_CURRENCIES[territory];
  }
  var currencyData = cldr.supplemental.currencyData;
  if (!currencyData) {
    if (throwIfNoValid) {
      throw NoSupplementalCurrency.error();
    }
    return;
  }
  var regionCurrencies = currencyData.region[territory];
  if (!regionCurrencies) {
    if (throwIfNoValid) {
      throw NoCurrencyRegion.error(territory);
    }
    return;
  }
  var currencyCode = regionCurrency(regionCurrencies);
  return currencyCode;
}
function localeCurrency(locale, throwIfNoValid) {
  var info = getLocaleInfo(locale);
  var numbers = info.numbers;
  if (!numbers.localeCurrency) {
    var currency = territoryCurrencyCode(localeTerritory(info), throwIfNoValid);
    if (!currency && throwIfNoValid) {
      throw NoValidCurrency.error(info.name);
    }
    numbers.localeCurrency = currency;
  }
  return numbers.localeCurrency;
}

// node_modules/@progress/kendo-intl/dist/es/cldr/constants.js
var DAYS_OF_WEEK = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
var DEFAULT_TERRITORY = "001";

// node_modules/@progress/kendo-intl/dist/es/cldr/first-day.js
var NoWeekData = errors.NoWeekData;
var NoFirstDay = errors.NoFirstDay;
function firstDay(locale) {
  var info = getLocaleInfo(locale);
  if (!isNaN(info.firstDay)) {
    return info.firstDay;
  }
  var weekData = cldr.supplemental.weekData;
  if (!weekData) {
    throw NoWeekData.error();
  }
  var firstDay3 = weekData.firstDay[localeTerritory(info)] || weekData.firstDay[DEFAULT_TERRITORY];
  if (!firstDay3) {
    throw NoFirstDay.error();
  }
  info.firstDay = DAYS_OF_WEEK.indexOf(firstDay3);
  return info.firstDay;
}

// node_modules/@progress/kendo-intl/dist/es/cldr/weekend-range.js
var NoWeekData2 = errors.NoWeekData;
function weekendRange(locale) {
  var info = getLocaleInfo(locale);
  if (info.weekendRange) {
    return info.weekendRange;
  }
  var weekData = cldr.supplemental.weekData;
  if (!weekData) {
    throw NoWeekData2.error();
  }
  var territory = localeTerritory(info);
  var start = weekData.weekendStart[territory] || weekData.weekendStart[DEFAULT_TERRITORY];
  var end = weekData.weekendEnd[territory] || weekData.weekendEnd[DEFAULT_TERRITORY];
  info.weekendRange = {
    start: DAYS_OF_WEEK.indexOf(start),
    end: DAYS_OF_WEEK.indexOf(end)
  };
  return info.weekendRange;
}

// node_modules/@progress/kendo-intl/dist/es/cldr/number-symbols.js
function numberSymbols(locale) {
  var info = getLocaleInfo(locale);
  return info.numbers.symbols;
}

// node_modules/@progress/kendo-intl/dist/es/common/is-negative-zero.js
function isNegativeZero(value) {
  return 1 / value === -Infinity;
}

// node_modules/@progress/kendo-intl/dist/es/numbers/format-currency-symbol.js
function formatCurrencySymbol(info, options2) {
  if (options2 === void 0) options2 = {};
  if (!options2.currency) {
    options2.currency = localeCurrency(info, true);
  }
  var display = currencyDisplay(info, options2);
  return display;
}

// node_modules/@progress/kendo-intl/dist/es/numbers/group-integer.js
function groupInteger(number, start, end, options2, info) {
  var symbols = info.numbers.symbols;
  var decimalIndex = number.indexOf(symbols.decimal);
  var groupSizes = options2.groupSize.slice();
  var groupSize = groupSizes.shift();
  var integerEnd = decimalIndex !== -1 ? decimalIndex : end + 1;
  var integer = number.substring(start, integerEnd);
  var result = number;
  var integerLength = integer.length;
  if (integerLength >= groupSize) {
    var idx2 = integerLength;
    var parts = [];
    while (idx2 > -1) {
      var value = integer.substring(idx2 - groupSize, idx2);
      if (value) {
        parts.push(value);
      }
      idx2 -= groupSize;
      var newGroupSize = groupSizes.shift();
      groupSize = newGroupSize !== void 0 ? newGroupSize : groupSize;
      if (groupSize === 0) {
        value = integer.substring(0, idx2);
        if (value) {
          parts.push(value);
        }
        break;
      }
    }
    integer = parts.reverse().join(symbols.group);
    result = number.substring(0, start) + integer + number.substring(integerEnd);
  }
  return result;
}

// node_modules/@progress/kendo-intl/dist/es/numbers/is-currency-style.js
function isCurrencyStyle(style2) {
  return style2 === CURRENCY || style2 === ACCOUNTING;
}

// node_modules/@progress/kendo-intl/dist/es/common/pad.js
function pad(number, digits, right) {
  if (digits === void 0) digits = 2;
  if (right === void 0) right = false;
  var count = digits - String(number).length;
  var result = number;
  if (count > 0) {
    var padString = new Array(count + 1).join("0");
    result = right ? number + padString : padString + number;
  }
  return result;
}

// node_modules/@progress/kendo-intl/dist/es/common/round.js
var MAX_PRECISION = 20;
function round(value, precision) {
  var result = value;
  var decimals = precision || 0;
  result = result.toString().split("e");
  result = Math.round(Number(result[0] + "e" + (result[1] ? Number(result[1]) + decimals : decimals)));
  result = result.toString().split("e");
  result = Number(result[0] + "e" + (result[1] ? Number(result[1]) - decimals : -decimals));
  return result.toFixed(Math.min(decimals, MAX_PRECISION));
}

// node_modules/@progress/kendo-intl/dist/es/numbers/standard-number-format.js
var DEFAULT_DECIMAL_ROUNDING = 3;
var DEFAULT_PERCENT_ROUNDING = 0;
var trailingZeroRegex = /0+$/;
function fractionOptions(options2) {
  var minimumFractionDigits = options2.minimumFractionDigits;
  var maximumFractionDigits = options2.maximumFractionDigits;
  var style2 = options2.style;
  var isCurrency = isCurrencyStyle(style2);
  var currencyFractions;
  if (isCurrency) {
    currencyFractions = currencyFractionOptions(options2.currency);
  }
  if (minimumFractionDigits === void 0) {
    minimumFractionDigits = isCurrency ? currencyFractions.minimumFractionDigits : 0;
  }
  if (maximumFractionDigits === void 0) {
    if (style2 === PERCENT) {
      maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_PERCENT_ROUNDING);
    } else if (isCurrency) {
      maximumFractionDigits = Math.max(minimumFractionDigits, currencyFractions.maximumFractionDigits);
    } else {
      maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_DECIMAL_ROUNDING);
    }
  }
  return {
    minimumFractionDigits,
    maximumFractionDigits
  };
}
function applyPattern(value, pattern, symbol) {
  var result = EMPTY2;
  for (var idx2 = 0, length = pattern.length; idx2 < length; idx2++) {
    var ch = pattern.charAt(idx2);
    if (ch === NUMBER_PLACEHOLDER) {
      result += value;
    } else if (ch === CURRENCY_PLACEHOLDER || ch === PERCENT_PLACEHOLDER) {
      result += symbol;
    } else {
      result += ch;
    }
  }
  return result;
}
function currencyUnitPattern(info, value) {
  var currencyInfo = info.numbers.currency;
  var pattern = value !== 1 ? currencyInfo["unitPattern-count-other"] : currencyInfo["unitPattern-count-one"];
  if (value < 0) {
    pattern = pattern.replace(NUMBER_PLACEHOLDER, "-" + NUMBER_PLACEHOLDER);
  }
  return pattern;
}
function standardNumberFormat(number, options2, info) {
  var symbols = info.numbers.symbols;
  var style2 = options2.style;
  var isCurrency = isCurrencyStyle(style2);
  if (style2 === SCIENTIFIC) {
    var exponential = options2.minimumFractionDigits !== void 0 ? number.toExponential(options2.minimumFractionDigits) : number.toExponential();
    return exponential.replace(POINT, symbols.decimal);
  }
  var value = number;
  var symbol;
  if (isCurrency) {
    options2.value = value;
    symbol = formatCurrencySymbol(info, options2);
  }
  if (style2 === PERCENT) {
    value *= 100;
    symbol = symbols.percentSign;
  }
  var ref = fractionOptions(options2);
  var minimumFractionDigits = ref.minimumFractionDigits;
  var maximumFractionDigits = ref.maximumFractionDigits;
  value = round(value, maximumFractionDigits);
  var negative = value < 0;
  var negativeZero = isNegativeZero(number);
  var parts = value.split(POINT);
  var integer = parts[0];
  var fraction = pad(parts[1] ? parts[1].replace(trailingZeroRegex, EMPTY2) : EMPTY2, minimumFractionDigits, true);
  if (negative) {
    integer = integer.substring(1);
  }
  if (options2.minimumIntegerDigits) {
    integer = pad(integer, options2.minimumIntegerDigits);
  }
  var formattedValue = options2.useGrouping !== false ? groupInteger(integer, 0, integer.length, options2, info) : integer;
  if (fraction) {
    formattedValue += symbols.decimal + fraction;
  }
  var pattern;
  if (isCurrency && options2.currencyDisplay === "name") {
    pattern = currencyUnitPattern(info, number);
  } else {
    var patterns = options2.patterns;
    pattern = negative || negativeZero ? patterns[1] || "-" + patterns[0] : patterns[0];
  }
  if (pattern === NUMBER_PLACEHOLDER && !negative) {
    return formattedValue;
  }
  var result = applyPattern(formattedValue, pattern, symbol);
  return result;
}

// node_modules/@progress/kendo-intl/dist/es/numbers/utils.js
var literalRegExp = /(\\.)|(['][^']*[']?)|(["][^"]*["]?)/g;
var PLACEHOLDER = "__??__";
function setStyleOptions(formatOptions2, info) {
  var format3 = formatOptions2.format;
  if (format3.indexOf(PERCENT_PLACEHOLDER) !== -1) {
    formatOptions2.style = PERCENT;
    formatOptions2.symbol = info.numbers.symbols.percentSign;
    formatOptions2.number *= 100;
  }
  if (format3.indexOf(CURRENCY_PLACEHOLDER) !== -1) {
    formatOptions2.style = CURRENCY;
    formatOptions2.symbol = formatCurrencySymbol(info);
  }
}
function setFormatLiterals(formatOptions2) {
  var format3 = formatOptions2.format;
  if (format3.indexOf("'") > -1 || format3.indexOf('"') > -1 || format3.indexOf("\\") > -1) {
    var literals2 = formatOptions2.literals = [];
    formatOptions2.format = format3.replace(literalRegExp, function(match2) {
      var quoteChar = match2.charAt(0).replace("\\", EMPTY2);
      var literal3 = match2.slice(1).replace(quoteChar, EMPTY2);
      literals2.push(literal3);
      return PLACEHOLDER;
    });
  }
}
function replaceLiterals(number, literals2) {
  var result = number;
  if (literals2) {
    var length = literals2.length;
    for (var idx2 = 0; idx2 < length; idx2++) {
      result = result.replace(PLACEHOLDER, literals2[idx2]);
    }
  }
  return result;
}

// node_modules/@progress/kendo-intl/dist/es/numbers/custom-number-format.js
var SHARP = "#";
var ZERO = "0";
var trailingZerosRegExp = /(\.(?:[0-9]*[1-9])?)0+$/g;
var trailingPointRegExp = /\.$/;
var commaRegExp = /,/g;
function trimTrailingZeros(value, lastZero) {
  var trimRegex;
  if (lastZero === 0) {
    trimRegex = trailingZerosRegExp;
  } else {
    trimRegex = new RegExp("(\\.[0-9]{" + lastZero + "}[1-9]*)0+$", "g");
  }
  return value.replace(trimRegex, "$1").replace(trailingPointRegExp, EMPTY2);
}
function roundNumber(formatOptions2) {
  var number = formatOptions2.number;
  var format3 = formatOptions2.format;
  var decimalIndex = format3.indexOf(POINT);
  if (decimalIndex !== -1) {
    var zeroIndex = format3.lastIndexOf(ZERO) - decimalIndex;
    var sharpIndex = format3.lastIndexOf(SHARP) - decimalIndex;
    var hasZero = zeroIndex > -1;
    var hasSharp = sharpIndex > -1;
    var fraction = number.toString().split("e");
    if (fraction[1]) {
      fraction = round(number, Math.abs(fraction[1]));
    } else {
      fraction = fraction[0];
    }
    fraction = fraction.split(POINT)[1] || EMPTY2;
    var precision = fraction.length;
    var trailingZeros = -1;
    if (!hasZero && !hasSharp) {
      formatOptions2.format = format3.substring(0, decimalIndex) + format3.substring(decimalIndex + 1);
      decimalIndex = -1;
      precision = 0;
    } else if (hasZero && zeroIndex > sharpIndex) {
      precision = zeroIndex;
    } else if (sharpIndex > zeroIndex) {
      if (hasSharp && precision > sharpIndex) {
        precision = sharpIndex;
      } else if (hasZero && precision < zeroIndex) {
        precision = zeroIndex;
      }
      trailingZeros = hasZero ? zeroIndex : 0;
    }
    if (precision > -1) {
      number = round(number, precision);
      if (trailingZeros > -1) {
        number = trimTrailingZeros(number, trailingZeros);
      }
    }
  } else {
    number = round(number);
  }
  if (formatOptions2.negative && number * -1 >= 0 && !formatOptions2.negativeZero) {
    formatOptions2.negative = false;
  }
  formatOptions2.number = number;
  formatOptions2.decimalIndex = decimalIndex;
}
function isConstantFormat(format3) {
  return format3.indexOf(SHARP) === -1 && format3.indexOf(ZERO) === -1;
}
function setValueSpecificFormat(formatOptions2) {
  var number = formatOptions2.number;
  var format3 = formatOptions2.format;
  format3 = format3.split(LIST_SEPARATOR);
  if ((formatOptions2.negative || formatOptions2.negativeZero) && format3[1]) {
    format3 = format3[1];
    formatOptions2.hasNegativeFormat = true;
  } else if (number === 0) {
    var zeroFormat = format3[2];
    format3 = zeroFormat || format3[0];
    if (zeroFormat && isConstantFormat(zeroFormat)) {
      formatOptions2.constant = zeroFormat;
    }
  } else {
    format3 = format3[0];
  }
  formatOptions2.format = format3;
}
function setGroupOptions(formatOptions2) {
  formatOptions2.hasGroup = formatOptions2.format.indexOf(GROUP_SEPARATOR) > -1;
  if (formatOptions2.hasGroup) {
    formatOptions2.format = formatOptions2.format.replace(commaRegExp, EMPTY2);
  }
}
function placeholderIndex(index1, index2, start) {
  var index;
  if (index1 === -1 && index2 !== -1) {
    index = index2;
  } else if (index1 !== -1 && index2 === -1) {
    index = index1;
  } else {
    index = start ? Math.min(index1, index2) : Math.max(index1, index2);
  }
  return index;
}
function setPlaceholderIndices(formatOptions2) {
  var format3 = formatOptions2.format;
  var sharpIndex = format3.indexOf(SHARP);
  var zeroIndex = format3.indexOf(ZERO);
  var start = placeholderIndex(sharpIndex, zeroIndex, true);
  sharpIndex = format3.lastIndexOf(SHARP);
  zeroIndex = format3.lastIndexOf(ZERO);
  var end = placeholderIndex(sharpIndex, zeroIndex);
  if (start === format3.length) {
    end = start;
  }
  formatOptions2.start = start;
  formatOptions2.end = end;
  formatOptions2.lastZeroIndex = zeroIndex;
}
function replaceStyleSymbols(number, style2, symbol) {
  var result = number;
  if (style2 === CURRENCY || style2 === PERCENT) {
    result = EMPTY2;
    for (var idx2 = 0, length = number.length; idx2 < length; idx2++) {
      var ch = number.charAt(idx2);
      result += ch === CURRENCY_PLACEHOLDER || ch === PERCENT_PLACEHOLDER ? symbol : ch;
    }
  }
  return result;
}
function replacePlaceHolders(formatOptions2, info) {
  var start = formatOptions2.start;
  var end = formatOptions2.end;
  var negative = formatOptions2.negative;
  var negativeZero = formatOptions2.negativeZero;
  var format3 = formatOptions2.format;
  var decimalIndex = formatOptions2.decimalIndex;
  var lastZeroIndex = formatOptions2.lastZeroIndex;
  var hasNegativeFormat = formatOptions2.hasNegativeFormat;
  var hasGroup = formatOptions2.hasGroup;
  var number = formatOptions2.number;
  var value = number.toString().split(POINT);
  var length = format3.length;
  var integer = value[0];
  var fraction = value[1] || EMPTY2;
  var integerLength = integer.length;
  var replacement = EMPTY2;
  number = format3.substring(0, start);
  if ((negative || negativeZero) && !hasNegativeFormat) {
    number += "-";
  }
  for (var idx2 = start; idx2 < length; idx2++) {
    var ch = format3.charAt(idx2);
    if (decimalIndex === -1) {
      if (end - idx2 < integerLength) {
        number += integer;
        break;
      }
    } else {
      if (lastZeroIndex !== -1 && lastZeroIndex < idx2) {
        replacement = EMPTY2;
      }
      if (decimalIndex - idx2 <= integerLength && decimalIndex - idx2 > -1) {
        number += integer;
        idx2 = decimalIndex;
      }
      if (decimalIndex === idx2) {
        number += (fraction ? info.numbers.symbols.decimal : EMPTY2) + fraction;
        idx2 += end - decimalIndex + 1;
        continue;
      }
    }
    if (ch === ZERO) {
      number += ch;
      replacement = ch;
    } else if (ch === SHARP) {
      number += replacement;
    }
  }
  if (hasGroup) {
    number = groupInteger(number, start + (negative && !hasNegativeFormat ? 1 : 0), Math.max(end, integerLength + start), info.numbers.decimal, info);
  }
  if (end >= start) {
    number += format3.substring(end + 1);
  }
  return number;
}
function applyCustomFormat(formatOptions2, info) {
  var number = formatOptions2.number;
  if (formatOptions2.start !== -1) {
    number = replacePlaceHolders(formatOptions2, info);
    number = replaceStyleSymbols(number, formatOptions2.style, formatOptions2.symbol);
    number = replaceLiterals(number, formatOptions2.literals);
  }
  return number;
}
function customNumberFormat(number, format3, info) {
  var formatOptions2 = {
    negative: number < 0,
    number: Math.abs(number),
    negativeZero: isNegativeZero(number),
    format: format3
  };
  setValueSpecificFormat(formatOptions2);
  if (formatOptions2.constant) {
    return formatOptions2.constant;
  }
  setFormatLiterals(formatOptions2);
  setStyleOptions(formatOptions2, info);
  setGroupOptions(formatOptions2);
  roundNumber(formatOptions2);
  setPlaceholderIndices(formatOptions2);
  return applyCustomFormat(formatOptions2, info);
}

// node_modules/@progress/kendo-intl/dist/es/numbers/format-options.js
var standardFormatRegExp = /^(n|c|p|e|a)(\d*)$/i;
function standardFormatOptions(format3) {
  var formatAndPrecision = standardFormatRegExp.exec(format3);
  if (formatAndPrecision) {
    var options2 = {
      style: DECIMAL
    };
    var style2 = formatAndPrecision[1].toLowerCase();
    if (style2 === "c") {
      options2.style = CURRENCY;
    } else if (style2 === "a") {
      options2.style = ACCOUNTING;
    } else if (style2 === "p") {
      options2.style = PERCENT;
    } else if (style2 === "e") {
      options2.style = SCIENTIFIC;
    }
    if (formatAndPrecision[2]) {
      options2.minimumFractionDigits = options2.maximumFractionDigits = parseInt(formatAndPrecision[2], 10);
    }
    return options2;
  }
}
function formatOptions(format3) {
  var options2;
  if (isString(format3)) {
    options2 = standardFormatOptions(format3);
  } else {
    options2 = format3;
  }
  return options2;
}

// node_modules/@progress/kendo-intl/dist/es/numbers/format-number.js
function formatNumber(number, format3, locale) {
  if (format3 === void 0) format3 = NUMBER_PLACEHOLDER;
  if (locale === void 0) locale = DEFAULT_LOCALE;
  if (number === void 0 || number === null) {
    return EMPTY2;
  }
  if (!isFinite(number)) {
    return String(number);
  }
  var info = localeInfo(locale);
  var options2 = formatOptions(format3);
  var result;
  if (options2) {
    var style2 = options2.style || DECIMAL;
    result = standardNumberFormat(number, Object.assign({}, info.numbers[style2], options2), info);
  } else {
    result = customNumberFormat(number, format3, info);
  }
  return result;
}

// node_modules/@progress/kendo-intl/dist/es/common/is-number.js
function isNumber(value) {
  return typeof value === "number";
}

// node_modules/@progress/kendo-intl/dist/es/numbers/parse-number.js
var exponentRegExp = /[eE][-+]?[0-9]+/;
var nonBreakingSpaceRegExp = /\u00A0/g;
function cleanNegativePattern(number, patterns) {
  if (patterns.length > 1) {
    var parts = (patterns[1] || EMPTY2).replace(CURRENCY_PLACEHOLDER, EMPTY2).split(NUMBER_PLACEHOLDER);
    if (number.indexOf(parts[0]) > -1 && number.indexOf(parts[1]) > -1) {
      return number.replace(parts[0], EMPTY2).replace(parts[1], EMPTY2);
    }
  }
}
function cleanCurrencyNumber(value, info, format3) {
  var options2 = formatOptions(format3) || {};
  var isCurrency = isCurrencyStyle(options2.style);
  var number = value;
  var negative;
  var currency = options2.currency || localeCurrency(info, isCurrency);
  if (currency) {
    var displays = currencyDisplays(info, currency, isCurrency);
    if (displays) {
      for (var idx2 = 0; idx2 < displays.length; idx2++) {
        var display = displays[idx2];
        if (number.includes(display)) {
          number = number.replace(display, EMPTY2);
          isCurrency = true;
          break;
        }
      }
    }
    if (isCurrency) {
      var cleanNumber = cleanNegativePattern(number, info.numbers.currency.patterns) || cleanNegativePattern(number, info.numbers.accounting.patterns);
      if (cleanNumber) {
        negative = true;
        number = cleanNumber;
      }
    }
  }
  return {
    number,
    negative
  };
}
function cleanLiterals(number, formatOptions2) {
  var literals2 = formatOptions2.literals;
  var result = number;
  if (literals2) {
    for (var idx2 = 0; idx2 < literals2.length; idx2++) {
      result = result.replace(literals2[idx2], EMPTY2);
    }
  }
  return result;
}
function divideBy100(number) {
  var strNumber = String(number);
  var pointIndex = strNumber.indexOf(POINT);
  var zeroesCount = 2;
  var result = number / Math.pow(10, zeroesCount);
  if (pointIndex === -1 || String(result).length <= strNumber.length + zeroesCount) {
    return result;
  }
  var fractionDigits = strNumber.length - pointIndex + 1 + zeroesCount;
  return parseFloat(result.toFixed(fractionDigits));
}
function parseNumber(value, locale, format3) {
  if (locale === void 0) locale = DEFAULT_LOCALE;
  if (format3 === void 0) format3 = {};
  if (!value && value !== 0) {
    return null;
  }
  if (isNumber(value)) {
    return value;
  }
  var info = localeInfo(locale);
  var symbols = info.numbers.symbols;
  var number = value.toString();
  var formatOptions2 = format3 || {};
  var isPercent;
  if (isString(format3)) {
    formatOptions2 = {
      format: format3
    };
    setFormatLiterals(formatOptions2);
    number = cleanLiterals(number, formatOptions2);
    setStyleOptions(formatOptions2, info);
  }
  if (formatOptions2.style === PERCENT || number.indexOf(symbols.percentSign) > -1) {
    number = number.replace(symbols.percentSign, EMPTY2);
    isPercent = true;
  }
  if (exponentRegExp.test(number)) {
    number = parseFloat(number.replace(symbols.decimal, POINT));
    return isNaN(number) ? null : number;
  }
  var ref = cleanCurrencyNumber(number, info, formatOptions2);
  var negativeCurrency = ref.negative;
  var currencyNumber = ref.number;
  number = String(currencyNumber).trim();
  var negativeSignIndex = number.indexOf("-");
  if (negativeSignIndex > 0) {
    return null;
  }
  var isNegative = negativeSignIndex > -1;
  isNegative = negativeCurrency !== void 0 ? negativeCurrency : isNegative;
  number = number.replace("-", EMPTY2).replace(nonBreakingSpaceRegExp, " ").split(symbols.group.replace(nonBreakingSpaceRegExp, " ")).join(EMPTY2).replace(symbols.decimal, POINT);
  number = parseFloat(number);
  if (isNaN(number)) {
    number = null;
  } else if (isNegative) {
    number *= -1;
  }
  if (number && isPercent) {
    number = divideBy100(number);
  }
  return number;
}

// node_modules/@progress/kendo-intl/dist/es/common/format-string.js
var formatRegExp2 = /\{(\d+)}/g;
function formatString(format3) {
  var values = arguments;
  return format3.replace(formatRegExp2, function(match2, index) {
    var value = values[parseInt(index, 10) + 1];
    return value;
  });
}

// node_modules/@progress/kendo-intl/dist/es/dates/date-pattern.js
var REMOVAL_PENALTY = 120;
var ADDITION_PENALTY = 20;
var LENGHT_DELTA = [2, 1, 5, 3, 4];
var LONG_LESS_PENALTY_DELTA = -2;
var SHORT_LESS_PENALTY_DELTA = -1;
var SHORT_MORE_PENALTY_DELTA = 1;
var LONG_MORE_PENALTY_DELTA = 2;
var PENALTIES = {};
PENALTIES[LONG_LESS_PENALTY_DELTA.toString()] = 8;
PENALTIES[SHORT_LESS_PENALTY_DELTA.toString()] = 6;
PENALTIES[LONG_MORE_PENALTY_DELTA.toString()] = 6;
PENALTIES[SHORT_MORE_PENALTY_DELTA.toString()] = 3;
var VALUE_FORMAT_LENGTH = {
  numeric: 1,
  "2-digit": 2,
  short: 3,
  long: 4,
  narrow: 5
};
var TIME_SPECIFIERS_REGEX = /[hHmsSzZoOvVxX]/;
function getHourSpecifier(options2) {
  return options2.hour12 ? "h" : "H";
}
var DATE_OPTIONS_MAP = [{
  key: "era",
  specifier: "G"
}, {
  key: "year",
  specifier: "y"
}, {
  key: "month",
  specifier: "M"
}, {
  key: "day",
  specifier: "d"
}, {
  key: "weekday",
  specifier: "E"
}, {
  key: "hour",
  getSpecifier: getHourSpecifier
}, {
  key: "minute",
  specifier: "m"
}, {
  key: "second",
  specifier: "s"
}, {
  key: "timeZoneName",
  specifier: "z"
}];
var STAND_ALONE_SPECIFIERS = {
  e: "c",
  E: "c",
  M: "L",
  Q: "q"
};
var specifiersRegex = {};
var resolvedFormats = {};
function getSpecifierRegex(specifier) {
  if (!specifiersRegex[specifier]) {
    specifiersRegex[specifier] = new RegExp(specifier + "+");
  }
  return specifiersRegex[specifier];
}
function skeletonSpecifiers(skeleton) {
  var result = [];
  var current = skeleton.charAt(0);
  var specifier = current;
  for (var idx2 = 1; idx2 < skeleton.length; idx2++) {
    var character = skeleton.charAt(idx2);
    if (character === specifier) {
      current += character;
    } else {
      result.push(current);
      current = specifier = character;
    }
  }
  result.push(current);
  return result;
}
function findBestMatch(specifiers, availableFormats) {
  var specifiersLength = specifiers.length;
  var maxScore = -Number.MAX_VALUE;
  var bestMatches, result;
  for (var format3 in availableFormats) {
    var matches3 = [];
    var currentFormat = format3.replace("v", "z");
    var score = 0;
    for (var idx2 = 0; idx2 < specifiersLength; idx2++) {
      var specifier = specifiers[idx2];
      var specifierRegex = getSpecifierRegex(specifier[0]);
      var match2 = (specifierRegex.exec(currentFormat) || [])[0];
      if (!match2) {
        score -= REMOVAL_PENALTY;
      } else {
        currentFormat = currentFormat.replace(match2, EMPTY2);
        if (match2.length !== specifier.length) {
          var delta = Math.max(Math.min(LENGHT_DELTA[match2.length] - LENGHT_DELTA[specifier.length], 2), -2);
          score -= PENALTIES[delta];
        }
      }
      matches3.push(match2);
      if (score < maxScore) {
        break;
      }
    }
    if (currentFormat.length) {
      score -= skeletonSpecifiers(currentFormat).length * ADDITION_PENALTY;
    }
    if (score > maxScore) {
      maxScore = score;
      bestMatches = matches3;
      result = availableFormats[format3];
    }
  }
  result = result.replace("v", "z");
  for (var idx$1 = 0; idx$1 < specifiersLength; idx$1++) {
    var bestMatch = bestMatches[idx$1];
    if (bestMatch && bestMatch !== specifiers[idx$1]) {
      var matchSpecifier = bestMatches[idx$1][0];
      result = result.replace(getSpecifierRegex(matchSpecifier), specifiers[idx$1]);
      if (STAND_ALONE_SPECIFIERS[matchSpecifier]) {
        result = result.replace(getSpecifierRegex(STAND_ALONE_SPECIFIERS[matchSpecifier]), specifiers[idx$1]);
      }
    }
  }
  return result;
}
function cacheFormat(skeleton, format3, locale) {
  if (!resolvedFormats[locale]) {
    resolvedFormats[locale] = {};
  }
  resolvedFormats[locale][skeleton] = format3;
}
function skeletonFormat(skeleton, info) {
  var availableFormats = info.calendar.dateTimeFormats.availableFormats;
  if (availableFormats[skeleton]) {
    return availableFormats[skeleton];
  }
  if (resolvedFormats[info.name] && resolvedFormats[info.name][skeleton]) {
    return resolvedFormats[info.name][skeleton];
  }
  var timeStartIndex = skeleton.search(TIME_SPECIFIERS_REGEX);
  var result;
  if (timeStartIndex > 0) {
    var dateSkeleton = skeleton.substr(0, timeStartIndex);
    var timeSkeleton = skeleton.substr(timeStartIndex);
    result = formatString(
      info.calendar.dateTimeFormats.short,
      //should be deterimed based on specifiers
      availableFormats[timeSkeleton] || findBestMatch(skeletonSpecifiers(timeSkeleton), availableFormats),
      availableFormats[dateSkeleton] || findBestMatch(skeletonSpecifiers(dateSkeleton), availableFormats)
    );
  } else {
    result = findBestMatch(skeletonSpecifiers(skeleton), availableFormats);
  }
  cacheFormat(skeleton, result, info.name);
  return result;
}
function skeletonFromOptions(options2) {
  var result = [];
  for (var idx2 = 0; idx2 < DATE_OPTIONS_MAP.length; idx2++) {
    var option = DATE_OPTIONS_MAP[idx2];
    var field = option.key;
    var value = options2[field];
    if (value) {
      var spcifier = option.specifier || option.getSpecifier(options2);
      result.push(spcifier.repeat(VALUE_FORMAT_LENGTH[value]));
    }
  }
  return result.join(EMPTY2);
}
function datePattern(format3, info) {
  var calendar = info.calendar;
  var result;
  if (isString(format3)) {
    if (calendar.patterns[format3]) {
      result = calendar.patterns[format3];
    } else {
      result = format3;
    }
  } else if (format3) {
    if (format3.pattern) {
      return format3.pattern;
    }
    var skeleton = format3.skeleton;
    if (!skeleton) {
      if (format3.datetime) {
        result = formatString(calendar.dateTimeFormats[format3.datetime], calendar.timeFormats[format3.datetime], calendar.dateFormats[format3.datetime]);
      } else if (format3.date) {
        result = calendar.dateFormats[format3.date];
      } else if (format3.time) {
        result = calendar.timeFormats[format3.time];
      } else {
        skeleton = skeletonFromOptions(format3);
      }
    }
    if (skeleton) {
      result = skeletonFormat(skeleton, info);
    }
  }
  if (!result) {
    result = calendar.patterns.d;
  }
  return result;
}

// node_modules/@progress/kendo-intl/dist/es/dates/date-name-type.js
function dateNameType(formatLength) {
  var nameType;
  if (formatLength <= 3) {
    nameType = "abbreviated";
  } else if (formatLength === 4) {
    nameType = "wide";
  } else if (formatLength === 5) {
    nameType = "narrow";
  } else if (formatLength === 6) {
    nameType = "short";
  }
  return nameType;
}

// node_modules/@progress/kendo-intl/dist/es/dates/format-names.js
function formatNames(locale, type, formatLength, standAlone, lower) {
  return dateFormatNames(locale, {
    type,
    nameType: dateNameType(formatLength),
    standAlone,
    lower
  });
}

// node_modules/@progress/kendo-intl/dist/es/common/is-date.js
function isFunction(fun) {
  return typeof fun === "function";
}
function isDate(value) {
  return Boolean(value) && isFunction(value.getTime) && isFunction(value.getMonth);
}

// node_modules/@progress/kendo-intl/dist/es/dates/constants.js
var MONTH = "month";
var HOUR = "hour";
var ZONE = "zone";
var WEEKDAY = "weekday";
var QUARTER = "quarter";
var DATE_FIELD_MAP = {
  "G": "era",
  "y": "year",
  "q": QUARTER,
  "Q": QUARTER,
  "M": MONTH,
  "L": MONTH,
  "d": "day",
  "E": WEEKDAY,
  "c": WEEKDAY,
  "e": WEEKDAY,
  "h": HOUR,
  "H": HOUR,
  "k": HOUR,
  "K": HOUR,
  "m": "minute",
  "s": "second",
  "S": "millisecond",
  "a": "dayperiod",
  "x": ZONE,
  "X": ZONE,
  "z": ZONE,
  "Z": ZONE
};
var dateFormatRegExp = /d{1,2}|E{1,6}|e{1,6}|c{3,6}|c{1}|M{1,5}|L{1,5}|y{1,4}|H{1,2}|h{1,2}|k{1,2}|K{1,2}|m{1,2}|a{1,5}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|x{1,5}|X{1,5}|G{1,5}|q{1,5}|Q{1,5}|"[^"]*"|'[^']*'/g;

// node_modules/@progress/kendo-intl/dist/es/dates/format-date.js
function formatDayOfWeekIndex(day, formatLength, localeInfo2) {
  var firstDayIndex = firstDay(localeInfo2);
  var dayIndex;
  if (day < firstDayIndex) {
    dayIndex = 7 - firstDayIndex + day;
  } else {
    dayIndex = day - firstDayIndex;
  }
  return dayIndex + 1;
}
function formatMonth(month, formatLength, info, standAlone) {
  if (formatLength <= 2) {
    return pad(month + 1, formatLength);
  }
  return formatNames(info, "months", formatLength, standAlone)[month];
}
function formatQuarter(date, formatLength, info, standAlone) {
  var quarter = Math.floor(date.getMonth() / 3);
  if (formatLength < 3) {
    return quarter + 1;
  }
  return formatNames(info, "quarters", formatLength, standAlone)[quarter];
}
function formatTimeZone(date, info, options2) {
  var shortHours = options2.shortHours;
  var optionalMinutes = options2.optionalMinutes;
  var separator = options2.separator;
  var localizedName = options2.localizedName;
  var zZeroOffset = options2.zZeroOffset;
  var offset = date.getTimezoneOffset() / 60;
  if (offset === 0 && zZeroOffset) {
    return "Z";
  }
  var sign = offset <= 0 ? "+" : "-";
  var hoursMinutes = Math.abs(offset).toString().split(".");
  var minutes = hoursMinutes[1] || 0;
  var result = sign + (shortHours ? hoursMinutes[0] : pad(hoursMinutes[0], 2));
  if (minutes || !optionalMinutes) {
    result += (separator ? ":" : EMPTY2) + pad(minutes, 2);
  }
  if (localizedName) {
    var localizedFormat = offset === 0 ? info.calendar.gmtZeroFormat : info.calendar.gmtFormat;
    result = formatString(localizedFormat, result);
  }
  return result;
}
function formatDayOfWeek(date, formatLength, info, standAlone) {
  var result;
  if (formatLength < 3) {
    result = formatDayOfWeekIndex(date.getDay(), formatLength, info);
  } else {
    result = formatNames(info, "days", formatLength, standAlone)[date.getDay()];
  }
  return result;
}
var formatters = {};
formatters.d = function(date, formatLength) {
  return pad(date.getDate(), formatLength);
};
formatters.E = function(date, formatLength, info) {
  return formatNames(info, "days", formatLength)[date.getDay()];
};
formatters.M = function(date, formatLength, info) {
  return formatMonth(date.getMonth(), formatLength, info, false);
};
formatters.L = function(date, formatLength, info) {
  return formatMonth(date.getMonth(), formatLength, info, true);
};
formatters.y = function(date, formatLength) {
  var year = date.getFullYear();
  if (formatLength === 2) {
    year = year % 100;
  }
  return pad(year, formatLength);
};
formatters.h = function(date, formatLength) {
  var hours = date.getHours() % 12 || 12;
  return pad(hours, formatLength);
};
formatters.H = function(date, formatLength) {
  return pad(date.getHours(), formatLength);
};
formatters.k = function(date, formatLength) {
  return pad(date.getHours() || 24, formatLength);
};
formatters.K = function(date, formatLength) {
  return pad(date.getHours() % 12, formatLength);
};
formatters.m = function(date, formatLength) {
  return pad(date.getMinutes(), formatLength);
};
formatters.s = function(date, formatLength) {
  return pad(date.getSeconds(), formatLength);
};
formatters.S = function(date, formatLength) {
  var milliseconds = date.getMilliseconds();
  var result;
  if (milliseconds !== 0) {
    result = pad(String(milliseconds / 1e3).split(".")[1].substr(0, formatLength), formatLength, true);
  } else {
    result = pad(EMPTY2, formatLength);
  }
  return result;
};
formatters.a = function(date, formatLength, info) {
  return formatNames(info, "dayPeriods", formatLength)[date.getHours() < 12 ? "am" : "pm"];
};
formatters.z = function(date, formatLength, info) {
  return formatTimeZone(date, info, {
    shortHours: formatLength < 4,
    optionalMinutes: formatLength < 4,
    separator: true,
    localizedName: true
  });
};
formatters.Z = function(date, formatLength, info) {
  return formatTimeZone(date, info, {
    separator: formatLength > 3,
    localizedName: formatLength === 4,
    zZeroOffset: formatLength === 5
  });
};
formatters.x = function(date, formatLength, info) {
  return formatTimeZone(date, info, {
    optionalMinutes: formatLength === 1,
    separator: formatLength === 3 || formatLength === 5
  });
};
formatters.X = function(date, formatLength, info) {
  return formatTimeZone(date, info, {
    optionalMinutes: formatLength === 1,
    separator: formatLength === 3 || formatLength === 5,
    zZeroOffset: true
  });
};
formatters.G = function(date, formatLength, info) {
  var era = date.getFullYear() >= 0 ? 1 : 0;
  return formatNames(info, "eras", formatLength)[era];
};
formatters.e = formatDayOfWeek;
formatters.c = function(date, formatLength, info) {
  return formatDayOfWeek(date, formatLength, info, true);
};
formatters.q = function(date, formatLength, info) {
  return formatQuarter(date, formatLength, info, true);
};
formatters.Q = formatQuarter;
function formatDate(date, format3, locale) {
  if (locale === void 0) locale = DEFAULT_LOCALE;
  if (!isDate(date)) {
    if (date === void 0 || date === null) {
      return EMPTY2;
    }
    return date;
  }
  var info = localeInfo(locale);
  var pattern = datePattern(format3, info);
  return pattern.replace(dateFormatRegExp, function(match2) {
    var formatLength = match2.length;
    var result;
    if (match2.includes("'") || match2.includes('"')) {
      result = match2.slice(1, formatLength - 1);
    } else {
      result = formatters[match2[0]](date, formatLength, info);
    }
    return result;
  });
}

// node_modules/@progress/kendo-intl/dist/es/dates/time-utils.js
function convertTimeZone(date, fromOffset, toOffset) {
  var fromLocalOffset = date.getTimezoneOffset();
  var offsetDate = new Date(date.getTime() + (fromOffset - toOffset) * 6e4);
  var toLocalOffset = offsetDate.getTimezoneOffset();
  return new Date(offsetDate.getTime() + (toLocalOffset - fromLocalOffset) * 6e4);
}
function adjustDST(date, hours) {
  if (!hours && date.getHours() === 23) {
    date.setHours(date.getHours() + 2);
  }
}

// node_modules/@progress/kendo-intl/dist/es/dates/parse-date.js
var timeZoneOffsetRegExp = /([+|-]\d{1,2})(:?)(\d{2})?/;
var dateRegExp = /^\/Date\((.*?)\)\/$/;
var offsetRegExp = /[+-]\d*/;
var numberRegExp = {
  2: /^\d{1,2}/,
  3: /^\d{1,3}/,
  4: /^\d{4}/
};
var numberRegex = /\d+/;
var PLACEHOLDER2 = "{0}";
var leadingSpacesRegex = /^ */;
var trailingSpacesRegex = / *$/;
var standardDateFormats = ["yyyy/MM/dd HH:mm:ss", "yyyy/MM/dd HH:mm", "yyyy/MM/dd", "E MMM dd yyyy HH:mm:ss", "yyyy-MM-ddTHH:mm:ss.SSSSSSSXXX", "yyyy-MM-ddTHH:mm:ss.SSSXXX", "yyyy-MM-ddTHH:mm:ss.SSXXX", "yyyy-MM-ddTHH:mm:ssXXX", "yyyy-MM-ddTHH:mm:ss.SSSSSSS", "yyyy-MM-ddTHH:mm:ss.SSS", "yyyy-MM-ddTHH:mmXXX", "yyyy-MM-ddTHH:mmX", "yyyy-MM-ddTHH:mm:ss", "yyyy-MM-ddTHH:mm", "yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd HH:mm", "yyyy-MM-dd", "HH:mm:ss", "HH:mm"];
var FORMATS_SEQUENCE = ["G", "g", "F", "Y", "y", "M", "m", "D", "d", "y", "T", "t"];
var TWO_DIGIT_YEAR_MAX = 2029;
function outOfRange(value, start, end) {
  return !(value >= start && value <= end);
}
function lookAhead(match2, state2) {
  var format3 = state2.format;
  var idx2 = state2.idx;
  var i = 0;
  while (format3[idx2] === match2) {
    i++;
    idx2++;
  }
  if (i > 0) {
    idx2 -= 1;
  }
  state2.idx = idx2;
  return i;
}
function getNumber(size, state2) {
  var regex = size ? numberRegExp[size] || new RegExp("^\\d{1," + size + "}") : numberRegex, match2 = state2.value.substr(state2.valueIdx, size).match(regex);
  if (match2) {
    match2 = match2[0];
    state2.valueIdx += match2.length;
    return parseInt(match2, 10);
  }
  return null;
}
function getIndexByName(names, state2, lower) {
  var i = 0, length = names.length, name2, nameLength, matchLength = 0, matchIdx = 0, subValue;
  for (; i < length; i++) {
    name2 = names[i];
    nameLength = name2.length;
    subValue = state2.value.substr(state2.valueIdx, nameLength);
    if (lower) {
      subValue = subValue.toLowerCase();
    }
    if (subValue === name2 && nameLength > matchLength) {
      matchLength = nameLength;
      matchIdx = i;
    }
  }
  if (matchLength) {
    state2.valueIdx += matchLength;
    return matchIdx + 1;
  }
  return null;
}
function checkLiteral(state2) {
  var result = false;
  if (state2.value.charAt(state2.valueIdx) === state2.format[state2.idx]) {
    state2.valueIdx++;
    result = true;
  }
  return result;
}
function calendarGmtFormats(calendar) {
  var gmtFormat = calendar.gmtFormat;
  var gmtZeroFormat = calendar.gmtZeroFormat;
  if (!gmtFormat) {
    throw errors.NoGMTInfo.error();
  }
  return [gmtFormat.replace(PLACEHOLDER2, EMPTY2).toLowerCase(), gmtZeroFormat.replace(PLACEHOLDER2, EMPTY2).toLowerCase()];
}
function parseTimeZoneOffset(state2, info, options2) {
  var shortHours = options2.shortHours;
  var noSeparator = options2.noSeparator;
  var optionalMinutes = options2.optionalMinutes;
  var localizedName = options2.localizedName;
  var zLiteral = options2.zLiteral;
  state2.UTC = true;
  if (zLiteral && state2.value.charAt(state2.valueIdx) === "Z") {
    state2.valueIdx++;
    return false;
  }
  if (localizedName && !getIndexByName(calendarGmtFormats(info.calendar), state2, true)) {
    return true;
  }
  var matches3 = timeZoneOffsetRegExp.exec(state2.value.substr(state2.valueIdx, 6));
  if (!matches3) {
    return !localizedName;
  }
  var hoursMatch = matches3[1];
  var minutesMatch = matches3[3];
  var hoursOffset = parseInt(hoursMatch, 10);
  var separator = matches3[2];
  var minutesOffset = parseInt(minutesMatch, 10);
  if (isNaN(hoursOffset) || !shortHours && hoursMatch.length !== 3 || !optionalMinutes && isNaN(minutesOffset) || noSeparator && separator) {
    return true;
  }
  if (isNaN(minutesOffset)) {
    minutesOffset = null;
  }
  if (outOfRange(hoursOffset, -12, 13) || minutesOffset && outOfRange(minutesOffset, 0, 59)) {
    return true;
  }
  state2.valueIdx += matches3[0].length;
  state2.hoursOffset = hoursOffset;
  state2.minutesOffset = minutesOffset;
}
function parseMonth(ch, state2, info) {
  var count = lookAhead(ch, state2);
  var names = formatNames(info, "months", count, ch === "L", true);
  var month = count < 3 ? getNumber(2, state2) : getIndexByName(names, state2, true);
  if (month === null || outOfRange(month, 1, 12)) {
    return true;
  }
  state2.month = month - 1;
}
function parseDayOfWeek(ch, state2, info) {
  var count = lookAhead(ch, state2);
  var names = formatNames(info, "days", count, ch === "c", true);
  var dayOfWeek = count < 3 ? getNumber(1, state2) : getIndexByName(names, state2, true);
  if (!dayOfWeek && dayOfWeek !== 0 || outOfRange(dayOfWeek, 1, 7)) {
    return true;
  }
}
var parsers = {};
parsers.d = function(state2) {
  lookAhead("d", state2);
  var day = getNumber(2, state2);
  if (day === null || outOfRange(day, 1, 31)) {
    return true;
  }
  if (state2.day === null) {
    state2.day = day;
  }
};
parsers.E = function(state2, info) {
  var count = lookAhead("E", state2);
  var dayOfWeek = getIndexByName(formatNames(info, "days", count, false, true), state2, true);
  if (dayOfWeek === null) {
    return true;
  }
};
parsers.M = function(state2, info) {
  return parseMonth("M", state2, info);
};
parsers.L = function(state2, info) {
  return parseMonth("L", state2, info);
};
parsers.y = function(state2) {
  var count = lookAhead("y", state2);
  var year = getNumber(count === 1 ? void 0 : count, state2);
  if (year === null) {
    return true;
  }
  if (count === 2) {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    year = currentYear - currentYear % 100 + year;
    if (year > TWO_DIGIT_YEAR_MAX) {
      year -= 100;
    }
  }
  state2.year = year;
};
parsers.h = function(state2) {
  lookAhead("h", state2);
  var hours = getNumber(2, state2);
  if (hours === 12) {
    hours = 0;
  }
  if (hours === null || outOfRange(hours, 0, 11)) {
    return true;
  }
  state2.hours = hours;
};
parsers.K = function(state2) {
  lookAhead("K", state2);
  var hours = getNumber(2, state2);
  if (hours === null || outOfRange(hours, 0, 11)) {
    return true;
  }
  state2.hours = hours;
};
parsers.a = function(state2, info) {
  var count = lookAhead("a", state2);
  var periodFormats = formatNames(info, "dayPeriods", count, false, true);
  var pmHour = getIndexByName([periodFormats.pm], state2, true);
  if (!pmHour && !getIndexByName([periodFormats.am], state2, true)) {
    return true;
  }
  state2.pmHour = pmHour;
};
parsers.H = function(state2) {
  lookAhead("H", state2);
  var hours = getNumber(2, state2);
  if (hours === null || outOfRange(hours, 0, 23)) {
    return true;
  }
  state2.hours = hours;
};
parsers.k = function(state2) {
  lookAhead("k", state2);
  var hours = getNumber(2, state2);
  if (hours === null || outOfRange(hours, 1, 24)) {
    return true;
  }
  state2.hours = hours === 24 ? 0 : hours;
};
parsers.m = function(state2) {
  lookAhead("m", state2);
  var minutes = getNumber(2, state2);
  if (minutes === null || outOfRange(minutes, 0, 59)) {
    return true;
  }
  state2.minutes = minutes;
};
parsers.s = function(state2) {
  lookAhead("s", state2);
  var seconds = getNumber(2, state2);
  if (seconds === null || outOfRange(seconds, 0, 59)) {
    return true;
  }
  state2.seconds = seconds;
};
parsers.S = function(state2) {
  var count = lookAhead("S", state2);
  var match2 = state2.value.substr(state2.valueIdx, count);
  var milliseconds = null;
  if (!isNaN(parseInt(match2, 10))) {
    milliseconds = parseFloat("0." + match2, 10);
    milliseconds = round(milliseconds, 3);
    milliseconds *= 1e3;
    state2.valueIdx += count;
  }
  if (milliseconds === null || outOfRange(milliseconds, 0, 999)) {
    return true;
  }
  state2.milliseconds = milliseconds;
};
parsers.z = function(state2, info) {
  var count = lookAhead("z", state2);
  var shortFormat = count < 4;
  var invalid = parseTimeZoneOffset(state2, info, {
    shortHours: shortFormat,
    optionalMinutes: shortFormat,
    localizedName: true
  });
  if (invalid) {
    return invalid;
  }
};
parsers.Z = function(state2, info) {
  var count = lookAhead("Z", state2);
  var invalid = parseTimeZoneOffset(state2, info, {
    noSeparator: count < 4,
    zLiteral: count === 5,
    localizedName: count === 4
  });
  if (invalid) {
    return invalid;
  }
};
parsers.x = function(state2, info) {
  var count = lookAhead("x", state2);
  var invalid = parseTimeZoneOffset(state2, info, {
    noSeparator: count !== 3 && count !== 5,
    optionalMinutes: count === 1
  });
  if (invalid) {
    return invalid;
  }
};
parsers.X = function(state2, info) {
  var count = lookAhead("X", state2);
  var invalid = parseTimeZoneOffset(state2, info, {
    noSeparator: count !== 3 && count !== 5,
    optionalMinutes: count === 1,
    zLiteral: true
  });
  if (invalid) {
    return invalid;
  }
};
parsers.G = function(state2, info) {
  var count = lookAhead("G", state2);
  var eras = formatNames(info, "eras", count, false, true);
  var era = getIndexByName([eras[0], eras[1]], state2, true);
  if (era === null) {
    return true;
  }
};
parsers.e = function(state2, info) {
  return parseDayOfWeek("e", state2, info);
};
parsers.c = function(state2, info) {
  return parseDayOfWeek("c", state2, info);
};
function createDate(state2) {
  var year = state2.year;
  var month = state2.month;
  var day = state2.day;
  var hours = state2.hours;
  var minutes = state2.minutes;
  var seconds = state2.seconds;
  var milliseconds = state2.milliseconds;
  var pmHour = state2.pmHour;
  var UTC = state2.UTC;
  var hoursOffset = state2.hoursOffset;
  var minutesOffset = state2.minutesOffset;
  var hasTime = hours !== null || minutes !== null || seconds || null;
  var date = /* @__PURE__ */ new Date();
  var result;
  if (year === null && month === null && day === null && hasTime) {
    year = date.getFullYear();
    month = date.getMonth();
    day = date.getDate();
  } else {
    if (year === null) {
      year = date.getFullYear();
    }
    if (day === null) {
      day = 1;
    }
  }
  if (pmHour && hours < 12) {
    hours += 12;
  }
  if (UTC) {
    if (hoursOffset) {
      hours += -hoursOffset;
    }
    if (minutesOffset) {
      minutes += -minutesOffset * (hoursOffset < 0 ? -1 : 1);
    }
    result = new Date(Date.UTC(year, month, day, hours, minutes, seconds, milliseconds));
  } else {
    result = new Date(year, month, day, hours, minutes, seconds, milliseconds);
    adjustDST(result, hours);
  }
  if (year < 100) {
    result.setFullYear(year);
  }
  if (result.getDate() !== day && UTC === void 0) {
    return null;
  }
  return result;
}
function addFormatSpaces(value, format3) {
  var leadingSpaces = leadingSpacesRegex.exec(format3)[0];
  var trailingSpaces = trailingSpacesRegex.exec(format3)[0];
  return "" + leadingSpaces + value + trailingSpaces;
}
function parseExact(value, format3, info) {
  var pattern = datePattern(format3, info).split(EMPTY2);
  var state2 = {
    format: pattern,
    idx: 0,
    value: addFormatSpaces(value, format3),
    valueIdx: 0,
    year: null,
    month: null,
    day: null,
    hours: null,
    minutes: null,
    seconds: null,
    milliseconds: null
  };
  var length = pattern.length;
  var literal3 = false;
  for (; state2.idx < length; state2.idx++) {
    var ch = pattern[state2.idx];
    if (literal3) {
      if (ch === "'") {
        literal3 = false;
      }
      checkLiteral(state2);
    } else {
      if (parsers[ch]) {
        var invalid = parsers[ch](state2, info);
        if (invalid) {
          return null;
        }
      } else if (ch === "'") {
        literal3 = true;
        checkLiteral(state2);
      } else if (!checkLiteral(state2)) {
        return null;
      }
    }
  }
  if (state2.valueIdx < value.length) {
    return null;
  }
  return createDate(state2) || null;
}
function parseMicrosoftDateOffset(offset) {
  var sign = offset.substr(0, 1) === "-" ? -1 : 1;
  var result = offset.substring(1);
  result = parseInt(result.substr(0, 2), 10) * 60 + parseInt(result.substring(2), 10);
  return sign * result;
}
function parseMicrosoftDateFormat(value) {
  if (value && value.indexOf("/D") === 0) {
    var date = dateRegExp.exec(value);
    if (date) {
      date = date[1];
      var tzoffset = offsetRegExp.exec(date.substring(1));
      date = new Date(parseInt(date, 10));
      if (tzoffset) {
        tzoffset = parseMicrosoftDateOffset(tzoffset[0]);
        date = convertTimeZone(date, date.getTimezoneOffset(), 0);
        date = convertTimeZone(date, 0, -1 * tzoffset);
      }
      return date;
    }
  }
}
function defaultFormats(calendar) {
  var formats = [];
  var patterns = calendar.patterns;
  var length = FORMATS_SEQUENCE.length;
  for (var idx2 = 0; idx2 < length; idx2++) {
    formats.push(patterns[FORMATS_SEQUENCE[idx2]]);
  }
  return formats.concat(standardDateFormats);
}
function parseDate(value, formats, locale) {
  if (locale === void 0) locale = DEFAULT_LOCALE;
  if (!value) {
    return null;
  }
  if (isDate(value)) {
    return value;
  }
  var parseValue = String(value).trim();
  var date = parseMicrosoftDateFormat(parseValue);
  if (date) {
    return date;
  }
  var info = localeInfo(locale);
  var parseFormats = formats || defaultFormats(info.calendar);
  parseFormats = Array.isArray(parseFormats) ? parseFormats : [parseFormats];
  var length = parseFormats.length;
  for (var idx2 = 0; idx2 < length; idx2++) {
    date = parseExact(parseValue, parseFormats[idx2], info);
    if (date) {
      return date;
    }
  }
  return date;
}

// node_modules/@progress/kendo-intl/dist/es/dates/split-date-format.js
var NAME_TYPES = {
  month: {
    type: "months",
    minLength: 3,
    standAlone: "L"
  },
  quarter: {
    type: "quarters",
    minLength: 3,
    standAlone: "q"
  },
  weekday: {
    type: "days",
    minLength: {
      E: 0,
      c: 3,
      e: 3
    },
    standAlone: "c"
  },
  dayperiod: {
    type: "dayPeriods",
    minLength: 0
  },
  era: {
    type: "eras",
    minLength: 0
  }
};
var LITERAL = "literal";
function addLiteral(parts, value) {
  var lastPart = parts[parts.length - 1];
  if (lastPart && lastPart.type === LITERAL) {
    lastPart.pattern += value;
  } else {
    parts.push({
      type: LITERAL,
      pattern: value
    });
  }
}
function isHour12(pattern) {
  return pattern === "h" || pattern === "K";
}
function splitDateFormat(format3, locale) {
  if (locale === void 0) locale = DEFAULT_LOCALE;
  var info = localeInfo(locale);
  var pattern = datePattern(format3, info);
  var parts = [];
  var lastIndex = dateFormatRegExp.lastIndex = 0;
  var match2 = dateFormatRegExp.exec(pattern);
  while (match2) {
    var value = match2[0];
    if (lastIndex < match2.index) {
      addLiteral(parts, pattern.substring(lastIndex, match2.index));
    }
    if (value.startsWith('"') || value.startsWith("'")) {
      addLiteral(parts, value);
    } else {
      var specifier = value[0];
      var type = DATE_FIELD_MAP[specifier];
      var part = {
        type,
        pattern: value
      };
      if (type === "hour") {
        part.hour12 = isHour12(value);
      }
      var names = NAME_TYPES[type];
      if (names) {
        var minLength = isNumber(names.minLength) ? names.minLength : names.minLength[specifier];
        var patternLength = value.length;
        if (patternLength >= minLength) {
          part.names = {
            type: names.type,
            nameType: dateNameType(patternLength),
            standAlone: names.standAlone === specifier
          };
        }
      }
      parts.push(part);
    }
    lastIndex = dateFormatRegExp.lastIndex;
    match2 = dateFormatRegExp.exec(pattern);
  }
  if (lastIndex < pattern.length) {
    addLiteral(parts, pattern.substring(lastIndex));
  }
  return parts;
}

// node_modules/@progress/kendo-intl/dist/es/format.js
var formatRegExp3 = /\{(\d+)(:[^}]+)?\}/g;
function toString(value, format3, locale) {
  if (format3) {
    if (isDate(value)) {
      return formatDate(value, format3, locale);
    } else if (isNumber(value)) {
      return formatNumber(value, format3, locale);
    }
  }
  return value !== void 0 && value !== null ? value : EMPTY2;
}
function format(format3, values, locale) {
  return format3.replace(formatRegExp3, function(match2, index, placeholderFormat) {
    var value = values[parseInt(index, 10)];
    return toString(value, placeholderFormat ? placeholderFormat.substring(1) : EMPTY2, locale);
  });
}

// node_modules/@progress/kendo-angular-intl/fesm2022/progress-kendo-angular-intl.mjs
var packageMetadata3 = {
  name: "@progress/kendo-angular-intl",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 1745303805,
  version: "18.5.2",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var DOCS_URL = "https://www.telerik.com/kendo-angular-ui/components/internationalization/troubleshooting/";
var errorSolutions = {
  "NoCurrency": `Solution: ${DOCS_URL}#toc-no-currency`,
  "NoCurrencyDisplay": `Solution: ${DOCS_URL}#toc-no-currency-display`,
  "NoCurrencyRegion": `Solution: ${DOCS_URL}#toc-no-currency-region`,
  "NoDateFieldNames": `Solution: ${DOCS_URL}#toc-no-date-filed-names`,
  "NoFirstDay": `Solution: ${DOCS_URL}#toc-no-first-day`,
  "NoGMTInfo": `Solution: ${DOCS_URL}#toc-no-gmt-info`,
  "NoLocale": `Solution: ${DOCS_URL}#toc-no-locale`,
  "NoValidCurrency": `Solution: ${DOCS_URL}#toc-no-valid-currency`,
  "NoWeekData": `Solution: ${DOCS_URL}#toc-no-week-data`
};
function formatMessage2(error2) {
  const message = error2.message;
  const errorSolution = errorSolutions[Object.keys(errorSolutions).filter((key) => message.indexOf(key) === 0)[0]];
  return errorSolution ? `${message} ${errorSolution}` : message;
}
function intlMethod(fn) {
  return function(...values) {
    try {
      return fn(...values);
    } catch (error2) {
      error2.message = formatMessage2(error2);
      throw error2;
    }
  };
}
var dateFormatNames2 = intlMethod(dateFormatNames);
var dateFieldName2 = intlMethod(dateFieldName);
var firstDay2 = intlMethod(firstDay);
var format2 = intlMethod(format);
var formatDate2 = intlMethod(formatDate);
var formatNumber2 = intlMethod(formatNumber);
var load2 = intlMethod(load);
var numberSymbols2 = intlMethod(numberSymbols);
var parseDate2 = intlMethod(parseDate);
var parseNumber2 = intlMethod(parseNumber);
var splitDateFormat2 = intlMethod(splitDateFormat);
var toString2 = intlMethod(toString);
var weekendRange2 = intlMethod(weekendRange);
var localeData = (locale) => {
  try {
    return localeInfo(locale);
  } catch (error2) {
    error2.message = formatMessage2(error2);
    throw error2;
  }
};
var LOCALE_REGEX = /_/g;
function cldrServiceFactory(localeId) {
  return new CldrIntlService(localeId);
}
var IntlService = class _IntlService {
  /**
   * @hidden
   */
  changes = new EventEmitter();
  /**
   * @hidden
   */
  constructor() {
    validatePackage(packageMetadata3);
  }
  /**
   * Notifies that the service was changed.
   */
  notify() {
    this.changes.emit();
  }
  static ɵfac = function IntlService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _IntlService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _IntlService,
    factory: function IntlService_Factory(__ngFactoryType__) {
      let __ngConditionalFactory__ = null;
      if (__ngFactoryType__) {
        __ngConditionalFactory__ = new __ngFactoryType__();
      } else {
        __ngConditionalFactory__ = cldrServiceFactory(ɵɵinject(LOCALE_ID));
      }
      return __ngConditionalFactory__;
    },
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IntlService, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: cldrServiceFactory,
      deps: [LOCALE_ID]
    }]
  }], function() {
    return [];
  }, null);
})();
var CldrIntlService = class _CldrIntlService extends IntlService {
  locale;
  /**
   * Gets or sets the current locale ID.
   */
  get localeId() {
    return this.locale;
  }
  set localeId(value) {
    const locale = value.replace(LOCALE_REGEX, "-");
    if (locale !== this.locale) {
      this.locale = locale;
      this.notify();
    }
  }
  /**
   * Creates a new instance of the service with the ID of the specified locale.
   *
   * Note that the parts of the locale ID can be separated by either `_` (underscore)
   * or `-` (dash).
   *
   * @param localeId - The default locale ID.
   */
  constructor(localeId) {
    super();
    this.localeId = localeId;
  }
  /**
   * Formats a string with placeholders such as
   * `Total amount {0:c}`.
   *
   * @param format - The format string.
   * @param values - One or more values to output in the format string placeholders.
   * @return - The formatted string.
   */
  format(format$1, ...values) {
    return format2(format$1, values, this.localeId);
  }
  /**
   * Converts an object into a string based on the specified format.
   *
   * @param value - The value to format.
   * @param format - The format to use.
   * @param localeId - The locale ID to use in place of the default one. Optional.
   * @return The formatted object.
   */
  toString(value, format3, localeId) {
    return toString2(value, format3, localeId || this.localeId);
  }
  /**
   * Converts a `Date` object into a string based on the specified format.
   * If no format is provided, the default short date format is used.
   *
   * @param value - The date to format.
   * @param format - The format string or options.
   * @param localeId - The locale ID to use in place of the default one. Optional.
   * @return The formatted date.
   */
  formatDate(value, format3, localeId) {
    return formatDate2(value, format3, localeId || this.localeId);
  }
  /**
   * Converts a string into a `Date` object based on the specified format.
   *
   * @param value - The string to convert.
   * @param format - The format strings or options.
   * @param localeId - The locale ID to use in place of the default one. Optional.
   * @return The parsed date.
   */
  parseDate(value, format3, localeId) {
    return parseDate2(value, format3, localeId || this.localeId);
  }
  /**
   * Converts a string into a `Number`.
   *
   * @param value - The string to convert.
   * @param format - The format string or options.
   * @param localeId - The locale ID to use in place of the default one. Optional.
   * @return The parsed number.
   */
  parseNumber(value, format3, localeId) {
    return parseNumber2(value, localeId || this.localeId, format3);
  }
  /**
   * Converts a `Number` into a string based on the specified format.
   *
   * @param value - The number to format.
   * @param format - The format string or options.
   * @param localeId - The locale ID to use in place of the default one. Optional.
   * @return The formatted number.
   */
  formatNumber(value, format3, localeId) {
    return formatNumber2(value, format3, localeId || this.localeId);
  }
  /**
   * Returns the date names from the current locale based on the option.
   *
   * The available `type` values are:
   * - `era`
   * - `year`
   * - `quarter`
   * - `month`
   * - `week`
   * - `day`
   * - `dayperiod`
   * - `hour`
   * - `minute`
   * - `second`
   * - `zone`
   *
   * The available `nameType` values are:
   * - `wide`
   * - `narrow`
   * - `short`
   *
   * @param options - Detailed configuration for the desired date field name.
   * @param localeId - The locale ID to use in place of the default one. Optional.
   * @return - The day names from the current locale based on the option.
   * @returns The localized date field name from the current locale based on the option.
   *
   * @example
   * ```ts
   * dateFieldName({ type: 'day' });                      //returns 'day';
   * dateFieldName({ type: 'day', nameType: 'wide' });    //returns 'day';
   * dateFieldName({ type: 'month', nameType: 'short' }); //returns 'mo.';
   * dateFieldName({ type: 'month', nameType: 'wide' });  //returns 'month';
   * ```
   */
  dateFieldName(options2, localeId) {
    return dateFieldName2(options2, localeId || this.localeId);
  }
  /**
   * Returns a localized date field name based on specific dateFieldName options.
   *
   * The available type values are:
   * - `day`
   * - `dayperiod`
   * - `months`
   * - `quarters`
   * - `eras`
   *
   * @param options - Detailed configuration for the desired date format.
   * @param localeId - The locale ID to use in place of the default one. Optional.
   * @return - The day names from the current locale based on the option.
   */
  dateFormatNames(options2, localeId) {
    return dateFormatNames2(localeId || this.localeId, options2);
  }
  /**
   * Splits the date format into objects containing information about each part of the pattern.
   *
   * @param format The format string or options.
   * @param localeId The optional locale id. If not specified, the `"en"` locale id is used.
   * @returns The date format parts.
   */
  splitDateFormat(format3, localeId) {
    return splitDateFormat2(format3, localeId || this.localeId);
  }
  /**
   * Returns the number symbols from the current locale based on the option.
   *
   * @param localeId - The locale ID to use in place of the default one. Optional.
   * @return - The number symbols from the current locale.
   */
  numberSymbols(localeId) {
    return numberSymbols2(localeId || this.localeId);
  }
  /**
   * Returns the first day index starting from Sunday.
   *
   * @param localeId - The locale ID. Defaults to the current locale ID.
   * @return - The index of the first day of the week (0 == Sunday).
   */
  firstDay(localeId) {
    return firstDay2(localeId || this.localeId);
  }
  /**
   * Returns the start and end index of the locale weekend starting from Sunday.
   *
   * @param localeId - The locale ID. Defaults to the current locale ID.
   * @return - The start and end index of the locale weekend (0 == Sunday).
   */
  weekendRange(localeId) {
    return weekendRange2(localeId || this.localeId);
  }
  static ɵfac = function CldrIntlService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CldrIntlService)(ɵɵinject(LOCALE_ID));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _CldrIntlService,
    factory: _CldrIntlService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CldrIntlService, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [LOCALE_ID]
      }]
    }];
  }, null);
})();
var isNumeric = (value) => !isNaN(value - parseFloat(value));
var DatePipe = class _DatePipe {
  intlService;
  /**
   * @hidden
   */
  constructor(intlService) {
    this.intlService = intlService;
  }
  /**
   * Converts a `Date` object into a string based on the specified format.
   * If no format is provided, the default short date format is used.
   *
   * @param value - The date to format.
   * @param format - The format string or options.
   * @param localeId - (Optional) The ID of the locale which will be used instead of the default one.
   * @return - The formatted date.
   */
  transform(value, format3 = "", localeId) {
    value = this.normalize(value);
    if (value) {
      return this.intlService.formatDate(value, format3, localeId);
    }
    return value;
  }
  normalize(value) {
    if (value && typeof value === "string") {
      value = this.intlService.parseDate(value);
    } else if (value && isNumeric(value)) {
      value = new Date(parseFloat(value));
    }
    return value;
  }
  static ɵfac = function DatePipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DatePipe)(ɵɵdirectiveInject(IntlService, 16));
  };
  static ɵpipe = ɵɵdefinePipe({
    name: "kendoDate",
    type: _DatePipe,
    pure: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePipe, [{
    type: Pipe,
    args: [{
      name: "kendoDate",
      standalone: true
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, null);
})();
var NumberPipe = class _NumberPipe {
  intlService;
  /**
   * @hidden
   */
  constructor(intlService) {
    this.intlService = intlService;
  }
  /**
   * Converts a `Number` object into a string based on the specified format.
   * If no format is provided, the value is formatted as decimal number using the
   * [`"n"`](https://github.com/telerik/kendo-intl/blob/master/docs/num-formatting/index.md#standard) format.
   *
   * @param value - The numer that will be formatted.
   * @param format - The format string or options.
   * @param localeId - (Optional) The locale ID that will be used in place of the default one.
   * @return - The formatted number.
   */
  transform(value, format3, localeId) {
    if (typeof value === "string") {
      value = this.intlService.parseNumber(value);
    }
    if (value !== null && value !== void 0) {
      return this.intlService.formatNumber(value, format3, localeId);
    }
    return value;
  }
  static ɵfac = function NumberPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NumberPipe)(ɵɵdirectiveInject(IntlService, 16));
  };
  static ɵpipe = ɵɵdefinePipe({
    name: "kendoNumber",
    type: _NumberPipe,
    pure: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberPipe, [{
    type: Pipe,
    args: [{
      name: "kendoNumber",
      standalone: true
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, null);
})();
var KENDO_NUMBER = [NumberPipe];
var KENDO_DATE = [DatePipe];
var KENDO_INTL = [...KENDO_NUMBER, ...KENDO_DATE];
var IntlModule = class _IntlModule {
  static ɵfac = function IntlModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _IntlModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _IntlModule,
    imports: [NumberPipe, DatePipe],
    exports: [NumberPipe, DatePipe]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IntlModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_INTL],
      exports: [...KENDO_INTL]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-drawing/dist/es/drawing.js
var drawing_exports = {};
__export(drawing_exports, {
  Animation: () => animation_default,
  AnimationFactory: () => animation_factory_default,
  Arc: () => arc_default2,
  BaseNode: () => base_node_default,
  Circle: () => circle_default2,
  Element: () => element_default,
  Gradient: () => gradient_default,
  GradientStop: () => gradient_stop_default,
  Group: () => group_default,
  HasObservers: () => has_observers_default,
  Image: () => image_default,
  Layout: () => layout_default,
  LinearGradient: () => linear_gradient_default,
  MultiPath: () => MultiPath,
  OptionsStore: () => options_store_default,
  Path: () => Path,
  PathParser: () => path_parser_default,
  Pattern: () => Pattern,
  QuadNode: () => quad_node_default,
  RadialGradient: () => radial_gradient_default,
  Rect: () => rect_default2,
  ShapesQuadTree: () => shapes_quad_tree_default,
  Surface: () => surface_default4,
  SurfaceFactory: () => surface_factory_default,
  Text: () => text_default,
  align: () => align,
  canvas: () => canvas_exports,
  crosshatchPattern: () => crosshatchPattern,
  diagonalStripesPattern: () => diagonalStripesPattern,
  dotsPattern: () => dotsPattern,
  exportImage: () => exportImage,
  exportSVG: () => exportSVG,
  fit: () => fit,
  gridPattern: () => gridPattern,
  parsePath: () => parse_path_default,
  stack: () => stack,
  svg: () => svg_exports,
  util: () => util_exports,
  vAlign: () => vAlign,
  vStack: () => vStack,
  vWrap: () => vWrap,
  verticalStripesPattern: () => verticalStripesPattern,
  wrap: () => wrap
});

// node_modules/@progress/kendo-drawing/dist/es/common/class.js
var Class = function Class2() {
};
var class_default = Class;

// node_modules/@progress/kendo-drawing/dist/es/common/observable.js
var Observable = function(Class3) {
  function Observable2() {
    Class3.call(this);
    this._events = {};
  }
  if (Class3) Observable2.__proto__ = Class3;
  Observable2.prototype = Object.create(Class3 && Class3.prototype);
  Observable2.prototype.constructor = Observable2;
  Observable2.prototype.bind = function bind(eventName, handlers, one) {
    var arguments$1 = arguments;
    var this$1 = this;
    var eventNames = getArray(eventName);
    var handlersIsFunction = isFunction2(handlers);
    var length = eventNames.length;
    if (handlers === void 0) {
      for (var field in eventName) {
        this$1.bind(field, eventName[field]);
      }
      return this;
    }
    var loop = function(idx3) {
      var eventName$1 = eventNames[idx3];
      var handler = handlersIsFunction ? handlers : handlers[eventName$1];
      if (handler) {
        if (one) {
          var original = handler;
          handler = function() {
            this$1.unbind(eventName$1, handler);
            original.apply(this$1, arguments$1);
          };
          handler.original = original;
        }
        var events2 = this$1._events[eventName$1] = this$1._events[eventName$1] || [];
        events2.push(handler);
      }
    };
    for (var idx2 = 0; idx2 < length; idx2++) loop(idx2);
    return this;
  };
  Observable2.prototype.one = function one(eventNames, handlers) {
    return this.bind(eventNames, handlers, true);
  };
  Observable2.prototype.first = function first(eventName, handlers) {
    var this$1 = this;
    var eventNames = getArray(eventName);
    var handlersIsFunction = isFunction2(handlers);
    for (var idx2 = 0, length = eventNames.length; idx2 < length; idx2++) {
      var eventName$1 = eventNames[idx2];
      var handler = handlersIsFunction ? handlers : handlers[eventName$1];
      if (handler) {
        var events2 = this$1._events[eventName$1] = this$1._events[eventName$1] || [];
        events2.unshift(handler);
      }
    }
    return this;
  };
  Observable2.prototype.trigger = function trigger2(eventName, e) {
    var this$1 = this;
    if (e === void 0) e = {};
    var events2 = this._events[eventName];
    if (events2) {
      var length = events2.length;
      e.sender = this;
      e._defaultPrevented = false;
      e.preventDefault = preventDefault;
      e.isDefaultPrevented = isDefaultPrevented;
      events2 = events2.slice();
      for (var idx2 = 0; idx2 < length; idx2++) {
        events2[idx2].call(this$1, e);
      }
      return e._defaultPrevented === true;
    }
    return false;
  };
  Observable2.prototype.unbind = function unbind(eventName, handler) {
    var events2 = this._events[eventName];
    if (eventName === void 0) {
      this._events = {};
    } else if (events2) {
      if (handler) {
        for (var idx2 = events2.length - 1; idx2 >= 0; idx2--) {
          if (events2[idx2] === handler || events2[idx2].original === handler) {
            events2.splice(idx2, 1);
          }
        }
      } else {
        this._events[eventName] = [];
      }
    }
    return this;
  };
  return Observable2;
}(class_default);
function isFunction2(value) {
  return typeof value === "function";
}
function getArray(value) {
  return typeof value === "string" ? [value] : value;
}
function preventDefault() {
  this._defaultPrevented = true;
}
function isDefaultPrevented() {
  return this._defaultPrevented === true;
}
var observable_default = Observable;

// node_modules/@progress/kendo-drawing/dist/es/common/animation-frame.js
var animationFrameProxy = function(callback) {
  var wnd = typeof window !== "undefined" ? window : {};
  var animationFrame = wnd.requestAnimationFrame || wnd.webkitRequestAnimationFrame || wnd.mozRequestAnimationFrame || wnd.oRequestAnimationFrame || wnd.msRequestAnimationFrame || function(callback2) {
    setTimeout(callback2, 1e3 / 60);
  };
  animationFrameProxy = function(callback2) {
    return animationFrame.call(wnd, callback2);
  };
  animationFrameProxy(callback);
};
var animation_frame_default = animationFrameProxy;

// node_modules/@progress/kendo-drawing/dist/es/common/html-encode.js
var ampRegExp = /&/g;
var ltRegExp = /</g;
var quoteRegExp = /"/g;
var aposRegExp = /'/g;
var gtRegExp = />/g;
function htmlEncode(value) {
  return String(value).replace(ampRegExp, "&amp;").replace(ltRegExp, "&lt;").replace(gtRegExp, "&gt;").replace(quoteRegExp, "&quot;").replace(aposRegExp, "&#39;");
}

// node_modules/@progress/kendo-drawing/dist/es/common/log-to-console.js
function logToConsole(message) {
  var console2 = window.console;
  if (typeof console2 != "undefined" && console2.log) {
    console2.log(message);
  }
}

// node_modules/@progress/kendo-drawing/dist/es/common/support.js
function matchUserAgent(userAgent) {
  var browserRxs = {
    edge: /(edge)[ \/]([\w.]+)/i,
    webkit: /(chrome)[ \/]([\w.]+)/i,
    safari: /(webkit)[ \/]([\w.]+)/i,
    opera: /(opera)(?:.*version|)[ \/]([\w.]+)/i,
    msie: /(msie\s|trident.*? rv:)([\w.]+)/i,
    mozilla: /(mozilla)(?:.*? rv:([\w.]+))/i
  };
  var browser6 = {};
  for (var agent in browserRxs) {
    if (browserRxs.hasOwnProperty(agent)) {
      var match2 = userAgent.match(browserRxs[agent]);
      if (match2) {
        browser6[agent] = true;
        browser6[match2[1].toLowerCase().split(" ")[0].split("/")[0]] = true;
        browser6.version = parseInt(document.documentMode || match2[2], 10);
        break;
      }
    }
  }
  return browser6;
}
var browser2 = null;
var support = {
  get browser() {
    if (typeof window === "undefined" || browser2) {
      return browser2;
    }
    browser2 = matchUserAgent(window.navigator.userAgent);
    return browser2;
  }
};
var support_default = support;

// node_modules/@progress/kendo-drawing/dist/es/common/template.js
function template() {
  throw new Error("Template implementation missing.");
}

// node_modules/@progress/kendo-drawing/dist/es/util/now.js
var now = Date.now || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
var now_default = now;

// node_modules/@progress/kendo-drawing/dist/es/common/throttle.js
function throttle(fn, delay2) {
  var lastExecTime = 0;
  var timeout;
  if (!delay2 || delay2 <= 0) {
    return fn;
  }
  var throttled = function() {
    var elapsed = now_default() - lastExecTime;
    var args = arguments;
    var exec = function() {
      fn.apply(null, args);
      lastExecTime = now_default();
    };
    if (!lastExecTime) {
      return exec();
    }
    if (timeout) {
      clearTimeout(timeout);
    }
    if (elapsed > delay2) {
      exec();
    } else {
      timeout = setTimeout(exec, delay2 - elapsed);
    }
  };
  throttled.cancel = function() {
    clearTimeout(timeout);
  };
  return throttled;
}

// node_modules/@progress/kendo-drawing/dist/es/common/color/named-colors.js
var namedColors = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "00ffff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000000",
  blanchedalmond: "ffebcd",
  blue: "0000ff",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "00ffff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgrey: "a9a9a9",
  darkgreen: "006400",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "ff00ff",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  grey: "808080",
  green: "008000",
  greenyellow: "adff2f",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgrey: "d3d3d3",
  lightgreen: "90ee90",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "778899",
  lightslategrey: "778899",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "00ff00",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "ff00ff",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370d8",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "d87093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  red: "ff0000",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "ffffff",
  whitesmoke: "f5f5f5",
  yellow: "ffff00",
  yellowgreen: "9acd32"
};
var named_colors_default = namedColors;

// node_modules/@progress/kendo-drawing/dist/es/common/color/parse-color.js
var browser3 = support_default.browser;
var matchNamedColor = function(color) {
  var colorNames = Object.keys(named_colors_default);
  colorNames.push("transparent");
  var regexp = new RegExp("^(" + colorNames.join("|") + ")(\\W|$)", "i");
  matchNamedColor = function(color2) {
    return regexp.exec(color2);
  };
  return regexp.exec(color);
};
var BaseColor = function(Class3) {
  function BaseColor2() {
    Class3.call(this);
  }
  if (Class3) BaseColor2.__proto__ = Class3;
  BaseColor2.prototype = Object.create(Class3 && Class3.prototype);
  BaseColor2.prototype.constructor = BaseColor2;
  BaseColor2.prototype.toHSV = function toHSV() {
    return this;
  };
  BaseColor2.prototype.toRGB = function toRGB() {
    return this;
  };
  BaseColor2.prototype.toHex = function toHex(options2) {
    return this.toBytes().toHex(options2);
  };
  BaseColor2.prototype.toBytes = function toBytes() {
    return this;
  };
  BaseColor2.prototype.toCss = function toCss(options2) {
    return "#" + this.toHex(options2);
  };
  BaseColor2.prototype.toCssRgba = function toCssRgba() {
    var rgb = this.toBytes();
    return "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ", " + parseFloat(Number(this.a).toFixed(3)) + ")";
  };
  BaseColor2.prototype.toDisplay = function toDisplay() {
    if (browser3.msie && browser3.version < 9) {
      return this.toCss();
    }
    return this.toCssRgba();
  };
  BaseColor2.prototype.equals = function equals(c) {
    return c === this || c !== null && c !== void 0 && this.toCssRgba() === parseColor(c).toCssRgba();
  };
  BaseColor2.prototype.diff = function diff(other) {
    if (other === null) {
      return NaN;
    }
    var c1 = this.toBytes();
    var c2 = other.toBytes();
    return Math.sqrt(Math.pow((c1.r - c2.r) * 0.3, 2) + Math.pow((c1.g - c2.g) * 0.59, 2) + Math.pow((c1.b - c2.b) * 0.11, 2));
  };
  BaseColor2.prototype.clone = function clone() {
    var c = this.toBytes();
    if (c === this) {
      c = new Bytes(c.r, c.g, c.b, c.a);
    }
    return c;
  };
  return BaseColor2;
}(class_default);
var RGB = function(BaseColor2) {
  function RGB2(r, g, b, a) {
    BaseColor2.call(this);
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  if (BaseColor2) RGB2.__proto__ = BaseColor2;
  RGB2.prototype = Object.create(BaseColor2 && BaseColor2.prototype);
  RGB2.prototype.constructor = RGB2;
  RGB2.prototype.toHSV = function toHSV() {
    var ref = this;
    var r = ref.r;
    var g = ref.g;
    var b = ref.b;
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var v = max;
    var h, s;
    if (delta === 0) {
      return new HSV(0, 0, v, this.a);
    }
    if (max !== 0) {
      s = delta / max;
      if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h *= 60;
      if (h < 0) {
        h += 360;
      }
    } else {
      s = 0;
      h = -1;
    }
    return new HSV(h, s, v, this.a);
  };
  RGB2.prototype.toHSL = function toHSL() {
    var ref = this;
    var r = ref.r;
    var g = ref.g;
    var b = ref.b;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
        default:
          break;
      }
    }
    return new HSL(h * 60, s * 100, l * 100, this.a);
  };
  RGB2.prototype.toBytes = function toBytes() {
    return new Bytes(this.r * 255, this.g * 255, this.b * 255, this.a);
  };
  return RGB2;
}(BaseColor);
var Bytes = function(RGB2) {
  function Bytes2(r, g, b, a) {
    RGB2.call(this, Math.round(r), Math.round(g), Math.round(b), a);
  }
  if (RGB2) Bytes2.__proto__ = RGB2;
  Bytes2.prototype = Object.create(RGB2 && RGB2.prototype);
  Bytes2.prototype.constructor = Bytes2;
  Bytes2.prototype.toRGB = function toRGB() {
    return new RGB2(this.r / 255, this.g / 255, this.b / 255, this.a);
  };
  Bytes2.prototype.toHSV = function toHSV() {
    return this.toRGB().toHSV();
  };
  Bytes2.prototype.toHSL = function toHSL() {
    return this.toRGB().toHSL();
  };
  Bytes2.prototype.toHex = function toHex(options2) {
    var value = hex(this.r, 2) + hex(this.g, 2) + hex(this.b, 2);
    if (options2 && options2.alpha) {
      value += hex(Math.round(this.a * 255), 2);
    }
    return value;
  };
  Bytes2.prototype.toBytes = function toBytes() {
    return this;
  };
  return Bytes2;
}(RGB);
function hex(n, width, pad4) {
  if (pad4 === void 0) pad4 = "0";
  var result = n.toString(16);
  while (width > result.length) {
    result = pad4 + result;
  }
  return result;
}
var HSV = function(BaseColor2) {
  function HSV2(h, s, v, a) {
    BaseColor2.call(this);
    this.h = h;
    this.s = s;
    this.v = v;
    this.a = a;
  }
  if (BaseColor2) HSV2.__proto__ = BaseColor2;
  HSV2.prototype = Object.create(BaseColor2 && BaseColor2.prototype);
  HSV2.prototype.constructor = HSV2;
  HSV2.prototype.toRGB = function toRGB() {
    var ref = this;
    var h = ref.h;
    var s = ref.s;
    var v = ref.v;
    var r, g, b;
    if (s === 0) {
      r = g = b = v;
    } else {
      h /= 60;
      var i = Math.floor(h);
      var f = h - i;
      var p = v * (1 - s);
      var q = v * (1 - s * f);
      var t = v * (1 - s * (1 - f));
      switch (i) {
        case 0:
          r = v;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = v;
          b = p;
          break;
        case 2:
          r = p;
          g = v;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = v;
          break;
        case 4:
          r = t;
          g = p;
          b = v;
          break;
        default:
          r = v;
          g = p;
          b = q;
          break;
      }
    }
    return new RGB(r, g, b, this.a);
  };
  HSV2.prototype.toHSL = function toHSL() {
    return this.toRGB().toHSL();
  };
  HSV2.prototype.toBytes = function toBytes() {
    return this.toRGB().toBytes();
  };
  return HSV2;
}(BaseColor);
var HSL = function(BaseColor2) {
  function HSL2(h, s, l, a) {
    BaseColor2.call(this);
    this.h = h;
    this.s = s;
    this.l = l;
    this.a = a;
  }
  if (BaseColor2) HSL2.__proto__ = BaseColor2;
  HSL2.prototype = Object.create(BaseColor2 && BaseColor2.prototype);
  HSL2.prototype.constructor = HSL2;
  HSL2.prototype.toRGB = function toRGB() {
    var h = this.h / 360;
    var s = this.s / 100;
    var l = this.l / 100;
    var r, g, b;
    if (s === 0) {
      r = g = b = l;
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
    return new RGB(r, g, b, this.a);
  };
  HSL2.prototype.toHSV = function toHSV() {
    return this.toRGB().toHSV();
  };
  HSL2.prototype.toBytes = function toBytes() {
    return this.toRGB().toBytes();
  };
  return HSL2;
}(BaseColor);
function hue2rgb(p, q, s) {
  var t = s;
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p + (q - p) * 6 * t;
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }
  return p;
}
function alphaFromHex(a) {
  return parseFloat(parseFloat(parseInt(a, 16) / 255).toFixed(3));
}
function parseColor(value, safe2) {
  var m, ret;
  if (!value || value === "none") {
    return null;
  }
  if (value instanceof BaseColor) {
    return value;
  }
  var color = value.toLowerCase();
  if (m = matchNamedColor(color)) {
    if (m[1] === "transparent") {
      color = new RGB(1, 1, 1, 0);
    } else {
      color = parseColor(named_colors_default[m[1]], safe2);
    }
    color.match = [m[1]];
    return color;
  }
  if (m = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})\b/i.exec(color)) {
    ret = new Bytes(parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16), 1);
  } else if (m = /^#?([0-9a-f])([0-9a-f])([0-9a-f])\b/i.exec(color)) {
    ret = new Bytes(parseInt(m[1] + m[1], 16), parseInt(m[2] + m[2], 16), parseInt(m[3] + m[3], 16), 1);
  } else if (m = /^#?([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])\b/i.exec(color)) {
    ret = new Bytes(parseInt(m[1] + m[1], 16), parseInt(m[2] + m[2], 16), parseInt(m[3] + m[3], 16), alphaFromHex(m[4] + m[4]));
  } else if (m = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})\b/i.exec(color)) {
    ret = new Bytes(parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16), alphaFromHex(m[4]));
  } else if (m = /^rgb\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/.exec(color)) {
    ret = new Bytes(parseInt(m[1], 10), parseInt(m[2], 10), parseInt(m[3], 10), 1);
  } else if (m = /^rgba\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9.]+)\s*\)/.exec(color)) {
    ret = new Bytes(parseInt(m[1], 10), parseInt(m[2], 10), parseInt(m[3], 10), parseFloat(m[4]));
  } else if (m = /^rgb\(\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*\)/.exec(color)) {
    ret = new RGB(parseFloat(m[1]) / 100, parseFloat(m[2]) / 100, parseFloat(m[3]) / 100, 1);
  } else if (m = /^rgba\(\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9.]+)\s*\)/.exec(color)) {
    ret = new RGB(parseFloat(m[1]) / 100, parseFloat(m[2]) / 100, parseFloat(m[3]) / 100, parseFloat(m[4]));
  } else if (m = /^color\(\s*srgb\s*([0-9]*\.?[0-9]+)\s+([0-9]*\.?[0-9]+)\s+([0-9]*\.?[0-9]+)\s*(\/\s+([0-9]*\.?[0-9]+))?\)/.exec(color)) {
    ret = new RGB(parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3]), parseFloat(m[5] || "1"));
  }
  if (ret) {
    ret.match = m;
  } else if (!safe2) {
    throw new Error("Cannot parse color: " + color);
  }
  return ret;
}

// node_modules/@progress/kendo-drawing/dist/es/common/color/color.js
var DARK_TRESHOLD = 180;
var Color = function(Class3) {
  function Color2(value) {
    var this$1 = this;
    Class3.call(this);
    if (arguments.length === 1) {
      var formats = Color2.formats;
      var resolvedColor = this.resolveColor(value);
      for (var idx2 = 0; idx2 < formats.length; idx2++) {
        var formatRegex = formats[idx2].re;
        var processor = formats[idx2].process;
        var parts = formatRegex.exec(resolvedColor);
        if (parts) {
          var channels = processor(parts);
          this$1.r = channels[0];
          this$1.g = channels[1];
          this$1.b = channels[2];
        }
      }
    } else {
      this.r = arguments[0];
      this.g = arguments[1];
      this.b = arguments[2];
    }
    this.r = this.normalizeByte(this.r);
    this.g = this.normalizeByte(this.g);
    this.b = this.normalizeByte(this.b);
  }
  if (Class3) Color2.__proto__ = Class3;
  Color2.prototype = Object.create(Class3 && Class3.prototype);
  Color2.prototype.constructor = Color2;
  Color2.prototype.toHex = function toHex() {
    var pad4 = this.padDigit;
    var r = this.r.toString(16);
    var g = this.g.toString(16);
    var b = this.b.toString(16);
    return "#" + pad4(r) + pad4(g) + pad4(b);
  };
  Color2.prototype.resolveColor = function resolveColor(value) {
    var color = value || "black";
    if (color.charAt(0) === "#") {
      color = color.substr(1, 6);
    }
    color = color.replace(/ /g, "");
    color = color.toLowerCase();
    color = Color2.namedColors[color] || color;
    return color;
  };
  Color2.prototype.normalizeByte = function normalizeByte(value) {
    if (value < 0 || isNaN(value)) {
      return 0;
    }
    return value > 255 ? 255 : value;
  };
  Color2.prototype.padDigit = function padDigit(value) {
    return value.length === 1 ? "0" + value : value;
  };
  Color2.prototype.brightness = function brightness(value) {
    var round3 = Math.round;
    this.r = round3(this.normalizeByte(this.r * value));
    this.g = round3(this.normalizeByte(this.g * value));
    this.b = round3(this.normalizeByte(this.b * value));
    return this;
  };
  Color2.prototype.percBrightness = function percBrightness() {
    return Math.sqrt(0.241 * this.r * this.r + 0.691 * this.g * this.g + 0.068 * this.b * this.b);
  };
  Color2.prototype.isDark = function isDark() {
    return this.percBrightness() < DARK_TRESHOLD;
  };
  Color2.fromBytes = function fromBytes(r, g, b, a) {
    return new Bytes(r, g, b, a != null ? a : 1);
  };
  Color2.fromRGB = function fromRGB(r, g, b, a) {
    return new RGB(r, g, b, a != null ? a : 1);
  };
  Color2.fromHSV = function fromHSV(h, s, v, a) {
    return new HSV(h, s, v, a != null ? a : 1);
  };
  Color2.fromHSL = function fromHSL(h, s, l, a) {
    return new HSL(h, s, l, a != null ? a : 1);
  };
  return Color2;
}(class_default);
Color.formats = [{
  re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
  process: function(parts) {
    return [parseInt(parts[1], 10), parseInt(parts[2], 10), parseInt(parts[3], 10)];
  }
}, {
  re: /^(\w{2})(\w{2})(\w{2})$/,
  process: function(parts) {
    return [parseInt(parts[1], 16), parseInt(parts[2], 16), parseInt(parts[3], 16)];
  }
}, {
  re: /^(\w{1})(\w{1})(\w{1})$/,
  process: function(parts) {
    return [parseInt(parts[1] + parts[1], 16), parseInt(parts[2] + parts[2], 16), parseInt(parts[3] + parts[3], 16)];
  }
}];
Color.namedColors = named_colors_default;
var color_default = Color;

// node_modules/@progress/kendo-drawing/dist/es/core/has-observers.js
var HasObservers = function(Class3) {
  function HasObservers2() {
    Class3.apply(this, arguments);
  }
  if (Class3) HasObservers2.__proto__ = Class3;
  HasObservers2.prototype = Object.create(Class3 && Class3.prototype);
  HasObservers2.prototype.constructor = HasObservers2;
  HasObservers2.prototype.observers = function observers() {
    this._observers = this._observers || [];
    return this._observers;
  };
  HasObservers2.prototype.addObserver = function addObserver(element) {
    if (!this._observers) {
      this._observers = [element];
    } else {
      this._observers.push(element);
    }
    return this;
  };
  HasObservers2.prototype.removeObserver = function removeObserver(element) {
    var observers = this.observers();
    var index = observers.indexOf(element);
    if (index !== -1) {
      observers.splice(index, 1);
    }
    return this;
  };
  HasObservers2.prototype.trigger = function trigger2(methodName, event) {
    var observers = this._observers;
    if (observers && !this._suspended) {
      for (var idx2 = 0; idx2 < observers.length; idx2++) {
        var observer = observers[idx2];
        if (observer[methodName]) {
          observer[methodName](event);
        }
      }
    }
    return this;
  };
  HasObservers2.prototype.optionsChange = function optionsChange(e) {
    if (e === void 0) e = {};
    e.element = this;
    this.trigger("optionsChange", e);
  };
  HasObservers2.prototype.geometryChange = function geometryChange() {
    this.trigger("geometryChange", {
      element: this
    });
  };
  HasObservers2.prototype.suspend = function suspend() {
    this._suspended = (this._suspended || 0) + 1;
    return this;
  };
  HasObservers2.prototype.resume = function resume() {
    this._suspended = Math.max((this._suspended || 0) - 1, 0);
    return this;
  };
  HasObservers2.prototype._observerField = function _observerField(field, value) {
    if (this[field]) {
      this[field].removeObserver(this);
    }
    this[field] = value;
    value.addObserver(this);
  };
  return HasObservers2;
}(class_default);
var has_observers_default = HasObservers;

// node_modules/@progress/kendo-drawing/dist/es/util.js
var util_exports = {};
__export(util_exports, {
  DEG_TO_RAD: () => DEG_TO_RAD,
  LRUCache: () => lru_cache_default,
  MAX_NUM: () => MAX_NUM,
  MIN_NUM: () => MIN_NUM,
  TextMetrics: () => text_metrics_default,
  append: () => append,
  arabicToRoman: () => arabicToRoman,
  bindEvents: () => bindEvents,
  createPromise: () => createPromise,
  defined: () => defined,
  definitionId: () => definitionId,
  deg: () => deg,
  elementOffset: () => elementOffset,
  elementPadding: () => elementPadding,
  elementScale: () => elementScale,
  elementSize: () => elementSize,
  elementStyles: () => elementStyles,
  encodeBase64: () => encodeBase64,
  eventCoordinates: () => eventCoordinates,
  eventElement: () => eventElement,
  hashKey: () => hashKey,
  isTransparent: () => isTransparent,
  last: () => last,
  limitValue: () => limitValue,
  measureText: () => measureText,
  mergeSort: () => mergeSort,
  normalizeText: () => normalizeText,
  now: () => now_default,
  objectKey: () => objectKey,
  promiseAll: () => promiseAll,
  rad: () => rad,
  round: () => round2,
  unbindEvents: () => unbindEvents,
  valueOrDefault: () => valueOrDefault
});

// node_modules/@progress/kendo-drawing/dist/es/util/append.js
function append(first, second) {
  first.push.apply(first, second);
  return first;
}

// node_modules/@progress/kendo-drawing/dist/es/util/arabic-to-roman.js
var literals = {
  1: "i",
  10: "x",
  100: "c",
  2: "ii",
  20: "xx",
  200: "cc",
  3: "iii",
  30: "xxx",
  300: "ccc",
  4: "iv",
  40: "xl",
  400: "cd",
  5: "v",
  50: "l",
  500: "d",
  6: "vi",
  60: "lx",
  600: "dc",
  7: "vii",
  70: "lxx",
  700: "dcc",
  8: "viii",
  80: "lxxx",
  800: "dccc",
  9: "ix",
  90: "xc",
  900: "cm",
  1e3: "m"
};
function arabicToRoman(n) {
  var values = [1e3, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];
  var roman = "";
  while (n > 0) {
    if (n < values[0]) {
      values.shift();
    } else {
      roman += literals[values[0]];
      n -= values[0];
    }
  }
  return roman;
}

// node_modules/@progress/kendo-drawing/dist/es/util/create-promise.js
function createPromise() {
  var resolveFn, rejectFn;
  var promise = new Promise(function(resolve, reject) {
    resolveFn = function(data) {
      promise._state = "resolved";
      resolve(data);
      return promise;
    };
    rejectFn = function(data) {
      promise._state = "rejected";
      reject(data);
      return promise;
    };
  });
  promise._state = "pending";
  promise.resolve = resolveFn;
  promise.reject = rejectFn;
  promise.state = function() {
    return promise._state;
  };
  return promise;
}

// node_modules/@progress/kendo-drawing/dist/es/util/defined.js
var UNDEFINED = "undefined";
function defined(value) {
  return typeof value !== UNDEFINED;
}

// node_modules/@progress/kendo-drawing/dist/es/util/definition-id.js
var defId = 1;
function definitionId() {
  return "kdef" + defId++;
}

// node_modules/@progress/kendo-drawing/dist/es/util/constants.js
var DEG_TO_RAD = Math.PI / 180;
var MAX_NUM = Number.MAX_VALUE;
var MIN_NUM = -Number.MAX_VALUE;

// node_modules/@progress/kendo-drawing/dist/es/util/deg.js
function deg(radians) {
  return radians / DEG_TO_RAD;
}

// node_modules/@progress/kendo-drawing/dist/es/util/encode-utf.js
var fromCharCode = String.fromCharCode;
var BOM = "þÿ";
function encodeUTF8(input) {
  var output = "";
  for (var i = 0; i < input.length; i++) {
    var code = input.charCodeAt(i);
    if (55296 <= code && code <= 56319) {
      var hi = code;
      var low = input.charCodeAt(++i);
      if (!isNaN(low)) {
        code = (hi - 55296) * 1024 + (low - 56320) + 65536;
      }
    }
    if (code < 128) {
      output += fromCharCode(code);
    } else if (code < 2048) {
      output += fromCharCode(192 | code >>> 6);
      output += fromCharCode(128 | code & 63);
    } else if (code < 65536) {
      output += fromCharCode(224 | code >>> 12);
      output += fromCharCode(128 | code >>> 6 & 63);
      output += fromCharCode(128 | code & 63);
    } else if (code < 1114111) {
      output += fromCharCode(240 | code >>> 18);
      output += fromCharCode(128 | code >>> 12 & 63);
      output += fromCharCode(128 | code >>> 6 & 63);
      output += fromCharCode(128 | code & 63);
    }
  }
  return output;
}
function encodeUnit(codeUnit) {
  return fromCharCode(codeUnit >> 8) + fromCharCode(codeUnit & 255);
}
function encodeUTF16BE(input) {
  var output = "";
  for (var i = 0; i < input.length; i++) {
    var c = input.charCodeAt(i);
    if (c < 65535) {
      output += encodeUnit(c);
    } else {
      var lead = (c - 65536 >> 10) + 55296;
      var trail = (c - 65536 & 1023) + 56320;
      output += encodeUnit(lead);
      output += encodeUnit(trail);
    }
  }
  return output;
}

// node_modules/@progress/kendo-drawing/dist/es/util/encode-base64.js
var KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function encodeBase64(input) {
  var output = "";
  var i = 0;
  var utfInput = encodeUTF8(input);
  while (i < utfInput.length) {
    var chr1 = utfInput.charCodeAt(i++);
    var chr2 = utfInput.charCodeAt(i++);
    var chr3 = utfInput.charCodeAt(i++);
    var enc1 = chr1 >> 2;
    var enc2 = (chr1 & 3) << 4 | chr2 >> 4;
    var enc3 = (chr2 & 15) << 2 | chr3 >> 6;
    var enc4 = chr3 & 63;
    if (isNaN(chr2)) {
      enc3 = enc4 = 64;
    } else if (isNaN(chr3)) {
      enc4 = 64;
    }
    output = output + KEY_STR.charAt(enc1) + KEY_STR.charAt(enc2) + KEY_STR.charAt(enc3) + KEY_STR.charAt(enc4);
  }
  return output;
}

// node_modules/@progress/kendo-drawing/dist/es/util/event-coordinates.js
function eventCoordinates(e) {
  if (defined((e.x || {}).location)) {
    return {
      x: e.x.location,
      y: e.y.location
    };
  }
  return {
    x: e.pageX || e.clientX || 0,
    y: e.pageY || e.clientY || 0
  };
}

// node_modules/@progress/kendo-drawing/dist/es/util/event-element.js
function eventElement(e) {
  if (e === void 0) e = {};
  return e.touch ? e.touch.initialTouch : e.target;
}

// node_modules/@progress/kendo-drawing/dist/es/util/is-transparent.js
function isTransparent(color) {
  return color === "" || color === null || color === "none" || color === "transparent" || !defined(color);
}

// node_modules/@progress/kendo-drawing/dist/es/util/last.js
function last(array) {
  if (array) {
    return array[array.length - 1];
  }
}

// node_modules/@progress/kendo-drawing/dist/es/util/limit-value.js
function limitValue(value, min, max) {
  return Math.max(Math.min(value, max), min);
}

// node_modules/@progress/kendo-drawing/dist/es/util/merge-sort.js
function mergeSort(a, cmp) {
  if (a.length < 2) {
    return a.slice();
  }
  function merge2(a2, b) {
    var r = [], ai = 0, bi = 0, i = 0;
    while (ai < a2.length && bi < b.length) {
      if (cmp(a2[ai], b[bi]) <= 0) {
        r[i++] = a2[ai++];
      } else {
        r[i++] = b[bi++];
      }
    }
    if (ai < a2.length) {
      r.push.apply(r, a2.slice(ai));
    }
    if (bi < b.length) {
      r.push.apply(r, b.slice(bi));
    }
    return r;
  }
  return function sort(a2) {
    if (a2.length <= 1) {
      return a2;
    }
    var m = Math.floor(a2.length / 2);
    var left = a2.slice(0, m);
    var right = a2.slice(m);
    left = sort(left);
    right = sort(right);
    return merge2(left, right);
  }(a);
}

// node_modules/@progress/kendo-drawing/dist/es/util/promise-all.js
function promiseAll(promises) {
  return Promise.all(promises);
}

// node_modules/@progress/kendo-drawing/dist/es/util/rad.js
function rad(degrees) {
  return degrees * DEG_TO_RAD;
}

// node_modules/@progress/kendo-drawing/dist/es/util/round.js
function pow(p) {
  if (p) {
    return Math.pow(10, p);
  }
  return 1;
}
function round2(value, precision) {
  var power = pow(precision);
  return Math.round(value * power) / power;
}

// node_modules/@progress/kendo-drawing/dist/es/util/value-or-default.js
function valueOrDefault(value, defaultValue) {
  return defined(value) ? value : defaultValue;
}

// node_modules/@progress/kendo-drawing/dist/es/util/bind-events.js
function bindEvents(element, events2) {
  for (var eventName in events2) {
    var eventNames = eventName.trim().split(" ");
    for (var idx2 = 0; idx2 < eventNames.length; idx2++) {
      element.addEventListener(eventNames[idx2], events2[eventName], false);
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/util/element-offset.js
function elementOffset(element) {
  var box = element.getBoundingClientRect();
  var documentElement = document.documentElement;
  return {
    top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0),
    left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0)
  };
}

// node_modules/@progress/kendo-drawing/dist/es/util/element-styles.js
function elementStyles(element, styles) {
  var result = {};
  var style2 = window.getComputedStyle(element) || {};
  var stylesArray = Array.isArray(styles) ? styles : [styles];
  for (var idx2 = 0; idx2 < stylesArray.length; idx2++) {
    var field = stylesArray[idx2];
    result[field] = style2[field];
  }
  return result;
}

// node_modules/@progress/kendo-drawing/dist/es/util/element-size.js
function getPixels(value) {
  if (isNaN(value)) {
    return value;
  }
  return value + "px";
}
function elementSize(element, size) {
  if (size) {
    var width = size.width;
    var height = size.height;
    if (defined(width)) {
      element.style.width = getPixels(width);
    }
    if (defined(height)) {
      element.style.height = getPixels(height);
    }
  } else {
    var size$1 = elementStyles(element, ["width", "height"]);
    return {
      width: parseInt(size$1.width, 10),
      height: parseInt(size$1.height, 10)
    };
  }
}

// node_modules/@progress/kendo-drawing/dist/es/util/unbind-events.js
function unbindEvents(element, events2) {
  if (events2 === void 0) events2 = {};
  for (var name2 in events2) {
    var eventNames = name2.trim().split(" ");
    for (var idx2 = 0; idx2 < eventNames.length; idx2++) {
      element.removeEventListener(eventNames[idx2], events2[name2], false);
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/util/element-padding.js
function elementPadding(element) {
  var ref = elementStyles(element, ["paddingLeft", "paddingTop"]);
  var paddingLeft = ref.paddingLeft;
  var paddingTop = ref.paddingTop;
  return {
    top: parseFloat(paddingTop),
    left: parseFloat(paddingLeft)
  };
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/matrix.js
var Matrix = function(Class3) {
  function Matrix2(a, b, c, d, e, f) {
    if (a === void 0) a = 0;
    if (b === void 0) b = 0;
    if (c === void 0) c = 0;
    if (d === void 0) d = 0;
    if (e === void 0) e = 0;
    if (f === void 0) f = 0;
    Class3.call(this);
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
  }
  if (Class3) Matrix2.__proto__ = Class3;
  Matrix2.prototype = Object.create(Class3 && Class3.prototype);
  Matrix2.prototype.constructor = Matrix2;
  Matrix2.prototype.multiplyCopy = function multiplyCopy(matrix) {
    return new Matrix2(this.a * matrix.a + this.c * matrix.b, this.b * matrix.a + this.d * matrix.b, this.a * matrix.c + this.c * matrix.d, this.b * matrix.c + this.d * matrix.d, this.a * matrix.e + this.c * matrix.f + this.e, this.b * matrix.e + this.d * matrix.f + this.f);
  };
  Matrix2.prototype.invert = function invert() {
    var ref = this;
    var a = ref.a;
    var b = ref.b;
    var d = ref.c;
    var e = ref.d;
    var g = ref.e;
    var h = ref.f;
    var det = a * e - b * d;
    if (det === 0) {
      return null;
    }
    return new Matrix2(e / det, -b / det, -d / det, a / det, (d * h - e * g) / det, (b * g - a * h) / det);
  };
  Matrix2.prototype.clone = function clone() {
    return new Matrix2(this.a, this.b, this.c, this.d, this.e, this.f);
  };
  Matrix2.prototype.equals = function equals(other) {
    if (!other) {
      return false;
    }
    return this.a === other.a && this.b === other.b && this.c === other.c && this.d === other.d && this.e === other.e && this.f === other.f;
  };
  Matrix2.prototype.round = function round$1(precision) {
    this.a = round2(this.a, precision);
    this.b = round2(this.b, precision);
    this.c = round2(this.c, precision);
    this.d = round2(this.d, precision);
    this.e = round2(this.e, precision);
    this.f = round2(this.f, precision);
    return this;
  };
  Matrix2.prototype.toArray = function toArray4(precision) {
    var result = [this.a, this.b, this.c, this.d, this.e, this.f];
    if (defined(precision)) {
      for (var i = 0; i < result.length; i++) {
        result[i] = round2(result[i], precision);
      }
    }
    return result;
  };
  Matrix2.prototype.toString = function toString5(precision, separator) {
    if (separator === void 0) separator = ",";
    return this.toArray(precision).join(separator);
  };
  Matrix2.translate = function translate(x, y) {
    return new Matrix2(1, 0, 0, 1, x, y);
  };
  Matrix2.unit = function unit() {
    return new Matrix2(1, 0, 0, 1, 0, 0);
  };
  Matrix2.rotate = function rotate(angle, x, y) {
    var matrix = new Matrix2();
    matrix.a = Math.cos(rad(angle));
    matrix.b = Math.sin(rad(angle));
    matrix.c = -matrix.b;
    matrix.d = matrix.a;
    matrix.e = x - x * matrix.a + y * matrix.b || 0;
    matrix.f = y - y * matrix.a - x * matrix.b || 0;
    return matrix;
  };
  Matrix2.scale = function scale(scaleX, scaleY) {
    return new Matrix2(scaleX, 0, 0, scaleY, 0, 0);
  };
  return Matrix2;
}(class_default);
Matrix.IDENTITY = Matrix.unit();
var matrix_default = Matrix;

// node_modules/@progress/kendo-drawing/dist/es/util/element-scale.js
var matrixRegexp = /matrix\((.*)\)/;
function parseMatrix(matrixString) {
  var match2 = matrixString.match(matrixRegexp);
  if (match2 === null || match2.length !== 2) {
    return matrix_default.unit();
  }
  var members = match2[1].split(",").map(function(x) {
    return parseFloat(x);
  });
  return new (Function.prototype.bind.apply(matrix_default, [null].concat(members)))();
}
function transformMatrix(element) {
  var transform3 = getComputedStyle(element).transform;
  if (transform3 === "none") {
    return matrix_default.unit();
  }
  return parseMatrix(transform3);
}
function elementScale(element) {
  if (!element) {
    return matrix_default.unit();
  }
  var matrix = transformMatrix(element);
  var parent = element.parentElement;
  while (parent) {
    var parentMatrix = transformMatrix(parent);
    matrix = matrix.multiplyCopy(parentMatrix);
    parent = parent.parentElement;
  }
  matrix.b = matrix.c = matrix.e = matrix.f = 0;
  return matrix;
}

// node_modules/@progress/kendo-drawing/dist/es/text-metrics/lru-cache.js
var LRUCache = function(Class3) {
  function LRUCache2(size) {
    Class3.call(this);
    this._size = size;
    this._length = 0;
    this._map = {};
  }
  if (Class3) LRUCache2.__proto__ = Class3;
  LRUCache2.prototype = Object.create(Class3 && Class3.prototype);
  LRUCache2.prototype.constructor = LRUCache2;
  LRUCache2.prototype.put = function put(key, value) {
    var map2 = this._map;
    var entry = {
      key,
      value
    };
    map2[key] = entry;
    if (!this._head) {
      this._head = this._tail = entry;
    } else {
      this._tail.newer = entry;
      entry.older = this._tail;
      this._tail = entry;
    }
    if (this._length >= this._size) {
      map2[this._head.key] = null;
      this._head = this._head.newer;
      this._head.older = null;
    } else {
      this._length++;
    }
  };
  LRUCache2.prototype.get = function get(key) {
    var entry = this._map[key];
    if (entry) {
      if (entry === this._head && entry !== this._tail) {
        this._head = entry.newer;
        this._head.older = null;
      }
      if (entry !== this._tail) {
        if (entry.older) {
          entry.older.newer = entry.newer;
          entry.newer.older = entry.older;
        }
        entry.older = this._tail;
        entry.newer = null;
        this._tail.newer = entry;
        this._tail = entry;
      }
      return entry.value;
    }
  };
  return LRUCache2;
}(class_default);
var lru_cache_default = LRUCache;

// node_modules/@progress/kendo-drawing/dist/es/text-metrics/util.js
var REPLACE_REGEX = /\r?\n|\r|\t/g;
var SPACE = " ";
function normalizeText(text) {
  return String(text).replace(REPLACE_REGEX, SPACE);
}
function objectKey(object) {
  var parts = [];
  for (var key in object) {
    parts.push(key + object[key]);
  }
  return parts.sort().join("");
}
function hashKey(str) {
  var hash = 2166136261;
  for (var i = 0; i < str.length; ++i) {
    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
    hash ^= str.charCodeAt(i);
  }
  return hash >>> 0;
}

// node_modules/@progress/kendo-drawing/dist/es/text-metrics/text-metrics.js
function zeroSize() {
  return {
    width: 0,
    height: 0,
    baseline: 0
  };
}
var DEFAULT_OPTIONS = {
  baselineMarkerSize: 1
};
var defaultMeasureBox;
if (typeof document !== "undefined") {
  defaultMeasureBox = document.createElement("div");
  defaultMeasureBox.style.setProperty("position", "absolute", "important");
  defaultMeasureBox.style.setProperty("top", "-4000px", "important");
  defaultMeasureBox.style.setProperty("width", "auto", "important");
  defaultMeasureBox.style.setProperty("height", "auto", "important");
  defaultMeasureBox.style.setProperty("padding", "0", "important");
  defaultMeasureBox.style.setProperty("margin", "0", "important");
  defaultMeasureBox.style.setProperty("border", "0", "important");
  defaultMeasureBox.style.setProperty("line-height", "normal", "important");
  defaultMeasureBox.style.setProperty("visibility", "hidden", "important");
  defaultMeasureBox.style.setProperty("white-space", "pre", "important");
}
var TextMetrics = function(Class3) {
  function TextMetrics2(options2) {
    Class3.call(this);
    this._cache = new lru_cache_default(1e3);
    this.options = Object.assign({}, DEFAULT_OPTIONS, options2);
  }
  if (Class3) TextMetrics2.__proto__ = Class3;
  TextMetrics2.prototype = Object.create(Class3 && Class3.prototype);
  TextMetrics2.prototype.constructor = TextMetrics2;
  TextMetrics2.prototype.measure = function measure(text, style2, options2) {
    if (options2 === void 0) options2 = {};
    if (typeof text === "undefined" || text === null) {
      return zeroSize();
    }
    var styleKey = objectKey(style2);
    var cacheKey = hashKey(text + styleKey);
    var cachedResult = this._cache.get(cacheKey);
    if (cachedResult) {
      return cachedResult;
    }
    var size = zeroSize();
    var measureBox = options2.box || defaultMeasureBox;
    var baselineMarker = this._baselineMarker().cloneNode(false);
    for (var key in style2) {
      var value = style2[key];
      if (typeof value !== "undefined") {
        measureBox.style[key] = value;
      }
    }
    var textStr = options2.normalizeText !== false ? normalizeText(text) : String(text);
    measureBox.textContent = textStr;
    measureBox.appendChild(baselineMarker);
    document.body.appendChild(measureBox);
    if (textStr.length) {
      size.width = measureBox.offsetWidth - this.options.baselineMarkerSize;
      size.height = measureBox.offsetHeight;
      size.baseline = baselineMarker.offsetTop + this.options.baselineMarkerSize;
    }
    if (size.width > 0 && size.height > 0) {
      this._cache.put(cacheKey, size);
    }
    measureBox.parentNode.removeChild(measureBox);
    return size;
  };
  TextMetrics2.prototype._baselineMarker = function _baselineMarker() {
    var marker = document.createElement("div");
    marker.style.display = "inline-block";
    marker.style.verticalAlign = "baseline";
    marker.style.width = this.options.baselineMarkerSize + "px";
    marker.style.height = this.options.baselineMarkerSize + "px";
    marker.style.overflow = "hidden";
    return marker;
  };
  return TextMetrics2;
}(class_default);
TextMetrics.current = new TextMetrics();
var text_metrics_default = TextMetrics;

// node_modules/@progress/kendo-drawing/dist/es/text-metrics/measure-text.js
function measureText(text, style2, measureBox) {
  return text_metrics_default.current.measure(text, style2, measureBox);
}

// node_modules/@progress/kendo-drawing/dist/es/core/options-store.js
var toString3 = {}.toString;
var OptionsStore = function(HasObservers2) {
  function OptionsStore2(options2, prefix) {
    var this$1 = this;
    if (prefix === void 0) prefix = "";
    HasObservers2.call(this);
    this.prefix = prefix;
    for (var field in options2) {
      var member = options2[field];
      member = this$1._wrap(member, field);
      this$1[field] = member;
    }
  }
  if (HasObservers2) OptionsStore2.__proto__ = HasObservers2;
  OptionsStore2.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  OptionsStore2.prototype.constructor = OptionsStore2;
  OptionsStore2.prototype.get = function get(field) {
    var parts = field.split(".");
    var result = this;
    while (parts.length && result) {
      var part = parts.shift();
      result = result[part];
    }
    return result;
  };
  OptionsStore2.prototype.set = function set(field, value) {
    var current = this.get(field);
    if (current !== value) {
      this._set(field, this._wrap(value, field));
      this.optionsChange({
        field: this.prefix + field,
        value
      });
    }
  };
  OptionsStore2.prototype._set = function _set(field, value) {
    var this$1 = this;
    var composite = field.indexOf(".") >= 0;
    var parentObj = this;
    var fieldName = field;
    if (composite) {
      var parts = fieldName.split(".");
      var prefix = this.prefix;
      while (parts.length > 1) {
        fieldName = parts.shift();
        prefix += fieldName + ".";
        var obj = parentObj[fieldName];
        if (!obj) {
          obj = new OptionsStore2({}, prefix);
          obj.addObserver(this$1);
          parentObj[fieldName] = obj;
        }
        parentObj = obj;
      }
      fieldName = parts[0];
    }
    parentObj._clear(fieldName);
    parentObj[fieldName] = value;
  };
  OptionsStore2.prototype._clear = function _clear(field) {
    var current = this[field];
    if (current && current.removeObserver) {
      current.removeObserver(this);
    }
  };
  OptionsStore2.prototype._wrap = function _wrap(object, field) {
    var type = toString3.call(object);
    var wrapped = object;
    if (wrapped !== null && defined(wrapped) && type === "[object Object]") {
      if (!(object instanceof OptionsStore2) && !(object instanceof class_default)) {
        wrapped = new OptionsStore2(wrapped, this.prefix + field + ".");
      }
      wrapped.addObserver(this);
    }
    return wrapped;
  };
  return OptionsStore2;
}(has_observers_default);
var options_store_default = OptionsStore;

// node_modules/@progress/kendo-drawing/dist/es/mixins/with-accessors.js
function setAccessor(field) {
  return function(value) {
    if (this[field] !== value) {
      this[field] = value;
      this.geometryChange();
    }
    return this;
  };
}
function getAccessor(field) {
  return function() {
    return this[field];
  };
}
function defineAccessors(fn, fields) {
  for (var i = 0; i < fields.length; i++) {
    var name2 = fields[i];
    var capitalized = name2.charAt(0).toUpperCase() + name2.substring(1, name2.length);
    fn["set" + capitalized] = setAccessor(name2);
    fn["get" + capitalized] = getAccessor(name2);
  }
}
var withAccessors = function(TBase, names) {
  var result = function(TBase2) {
    function result2() {
      TBase2.apply(this, arguments);
    }
    if (TBase2) result2.__proto__ = TBase2;
    result2.prototype = Object.create(TBase2 && TBase2.prototype);
    result2.prototype.constructor = result2;
    return result2;
  }(TBase);
  defineAccessors(result.prototype, names);
  return result;
};
var with_accessors_default = withAccessors;

// node_modules/@progress/kendo-drawing/dist/es/geometry/to-matrix.js
function toMatrix(transformation) {
  if (transformation && typeof transformation.matrix === "function") {
    return transformation.matrix();
  }
  return transformation;
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/point.js
var Point = function(superclass) {
  function Point3(x, y) {
    superclass.call(this);
    this.x = x || 0;
    this.y = y || 0;
  }
  if (superclass) Point3.__proto__ = superclass;
  Point3.prototype = Object.create(superclass && superclass.prototype);
  Point3.prototype.constructor = Point3;
  var staticAccessors = {
    ZERO: {
      configurable: true
    }
  };
  Point3.prototype.equals = function equals(other) {
    return other && other.x === this.x && other.y === this.y;
  };
  Point3.prototype.clone = function clone() {
    return new Point3(this.x, this.y);
  };
  Point3.prototype.rotate = function rotate(angle, origin) {
    var originPoint = Point3.create(origin) || Point3.ZERO;
    return this.transform(matrix_default.rotate(angle, originPoint.x, originPoint.y));
  };
  Point3.prototype.translate = function translate(x, y) {
    this.x += x;
    this.y += y;
    this.geometryChange();
    return this;
  };
  Point3.prototype.translateWith = function translateWith(point2) {
    return this.translate(point2.x, point2.y);
  };
  Point3.prototype.move = function move(x, y) {
    this.x = this.y = 0;
    return this.translate(x, y);
  };
  Point3.prototype.scale = function scale(scaleX, scaleY) {
    if (scaleY === void 0) scaleY = scaleX;
    this.x *= scaleX;
    this.y *= scaleY;
    this.geometryChange();
    return this;
  };
  Point3.prototype.scaleCopy = function scaleCopy(scaleX, scaleY) {
    return this.clone().scale(scaleX, scaleY);
  };
  Point3.prototype.transform = function transform3(transformation) {
    var matrix = toMatrix(transformation);
    var ref = this;
    var x = ref.x;
    var y = ref.y;
    this.x = matrix.a * x + matrix.c * y + matrix.e;
    this.y = matrix.b * x + matrix.d * y + matrix.f;
    this.geometryChange();
    return this;
  };
  Point3.prototype.transformCopy = function transformCopy(transformation) {
    var point2 = this.clone();
    if (transformation) {
      point2.transform(transformation);
    }
    return point2;
  };
  Point3.prototype.distanceTo = function distanceTo(point2) {
    var dx = this.x - point2.x;
    var dy = this.y - point2.y;
    return Math.sqrt(dx * dx + dy * dy);
  };
  Point3.prototype.round = function round$1(digits) {
    this.x = round2(this.x, digits);
    this.y = round2(this.y, digits);
    this.geometryChange();
    return this;
  };
  Point3.prototype.toArray = function toArray4(digits) {
    var doRound = defined(digits);
    var x = doRound ? round2(this.x, digits) : this.x;
    var y = doRound ? round2(this.y, digits) : this.y;
    return [x, y];
  };
  Point3.prototype.toString = function toString5(digits, separator) {
    if (separator === void 0) separator = " ";
    var ref = this;
    var x = ref.x;
    var y = ref.y;
    if (defined(digits)) {
      x = round2(x, digits);
      y = round2(y, digits);
    }
    return x + separator + y;
  };
  Point3.create = function create(arg0, arg1) {
    if (defined(arg0)) {
      if (arg0 instanceof Point3) {
        return arg0;
      } else if (arguments.length === 1 && arg0.length === 2) {
        return new Point3(arg0[0], arg0[1]);
      }
      return new Point3(arg0, arg1);
    }
  };
  Point3.min = function min() {
    var arguments$1 = arguments;
    var minX = MAX_NUM;
    var minY = MAX_NUM;
    for (var i = 0; i < arguments.length; i++) {
      var point2 = arguments$1[i];
      minX = Math.min(point2.x, minX);
      minY = Math.min(point2.y, minY);
    }
    return new Point3(minX, minY);
  };
  Point3.max = function max() {
    var arguments$1 = arguments;
    var maxX = MIN_NUM;
    var maxY = MIN_NUM;
    for (var i = 0; i < arguments.length; i++) {
      var point2 = arguments$1[i];
      maxX = Math.max(point2.x, maxX);
      maxY = Math.max(point2.y, maxY);
    }
    return new Point3(maxX, maxY);
  };
  Point3.minPoint = function minPoint() {
    return new Point3(MIN_NUM, MIN_NUM);
  };
  Point3.maxPoint = function maxPoint() {
    return new Point3(MAX_NUM, MAX_NUM);
  };
  staticAccessors.ZERO.get = function() {
    return new Point3(0, 0);
  };
  Object.defineProperties(Point3, staticAccessors);
  return Point3;
}(with_accessors_default(has_observers_default, ["x", "y"]));
var point_default = Point;

// node_modules/@progress/kendo-drawing/dist/es/geometry/size.js
var Size = function(superclass) {
  function Size2(width, height) {
    superclass.call(this);
    this.width = width || 0;
    this.height = height || 0;
  }
  if (superclass) Size2.__proto__ = superclass;
  Size2.prototype = Object.create(superclass && superclass.prototype);
  Size2.prototype.constructor = Size2;
  var staticAccessors = {
    ZERO: {
      configurable: true
    }
  };
  Size2.prototype.equals = function equals(other) {
    return other && other.width === this.width && other.height === this.height;
  };
  Size2.prototype.clone = function clone() {
    return new Size2(this.width, this.height);
  };
  Size2.prototype.toArray = function toArray4(digits) {
    var doRound = defined(digits);
    var width = doRound ? round2(this.width, digits) : this.width;
    var height = doRound ? round2(this.height, digits) : this.height;
    return [width, height];
  };
  Size2.create = function create(arg0, arg1) {
    if (defined(arg0)) {
      if (arg0 instanceof Size2) {
        return arg0;
      } else if (arguments.length === 1 && arg0.length === 2) {
        return new Size2(arg0[0], arg0[1]);
      }
      return new Size2(arg0, arg1);
    }
  };
  staticAccessors.ZERO.get = function() {
    return new Size2(0, 0);
  };
  Object.defineProperties(Size2, staticAccessors);
  return Size2;
}(with_accessors_default(has_observers_default, ["width", "height"]));
var size_default = Size;

// node_modules/@progress/kendo-drawing/dist/es/geometry/rect.js
var Rect = function(HasObservers2) {
  function Rect4(origin, size, cornerRadius) {
    if (origin === void 0) origin = new point_default();
    if (size === void 0) size = new size_default();
    if (cornerRadius === void 0) cornerRadius = 0;
    HasObservers2.call(this);
    this.setOrigin(origin);
    this.setSize(size);
    this.setCornerRadius(cornerRadius);
  }
  if (HasObservers2) Rect4.__proto__ = HasObservers2;
  Rect4.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  Rect4.prototype.constructor = Rect4;
  Rect4.prototype.clone = function clone() {
    return new Rect4(this.origin.clone(), this.size.clone());
  };
  Rect4.prototype.equals = function equals(other) {
    return other && other.origin.equals(this.origin) && other.size.equals(this.size);
  };
  Rect4.prototype.setOrigin = function setOrigin(value) {
    this._observerField("origin", point_default.create(value));
    this.geometryChange();
    return this;
  };
  Rect4.prototype.getOrigin = function getOrigin() {
    return this.origin;
  };
  Rect4.prototype.setCornerRadius = function setCornerRadius(radius) {
    this.cornerRadius = Array.isArray(radius) ? radius : [radius, radius];
    this.geometryChange();
    return this;
  };
  Rect4.prototype.getCornerRadius = function getCornerRadius() {
    return this.cornerRadius;
  };
  Rect4.prototype.setSize = function setSize(value) {
    this._observerField("size", size_default.create(value));
    this.geometryChange();
    return this;
  };
  Rect4.prototype.getSize = function getSize() {
    return this.size;
  };
  Rect4.prototype.width = function width() {
    return this.size.width;
  };
  Rect4.prototype.height = function height() {
    return this.size.height;
  };
  Rect4.prototype.topLeft = function topLeft() {
    return this.origin.clone();
  };
  Rect4.prototype.bottomRight = function bottomRight() {
    return this.origin.clone().translate(this.width(), this.height());
  };
  Rect4.prototype.topRight = function topRight() {
    return this.origin.clone().translate(this.width(), 0);
  };
  Rect4.prototype.bottomLeft = function bottomLeft() {
    return this.origin.clone().translate(0, this.height());
  };
  Rect4.prototype.center = function center() {
    return this.origin.clone().translate(this.width() / 2, this.height() / 2);
  };
  Rect4.prototype.bbox = function bbox(matrix) {
    var tl = this.topLeft().transformCopy(matrix);
    var tr = this.topRight().transformCopy(matrix);
    var br = this.bottomRight().transformCopy(matrix);
    var bl = this.bottomLeft().transformCopy(matrix);
    return Rect4.fromPoints(tl, tr, br, bl);
  };
  Rect4.prototype.transformCopy = function transformCopy(m) {
    return Rect4.fromPoints(this.topLeft().transform(m), this.bottomRight().transform(m));
  };
  Rect4.prototype.expand = function expand(x, y) {
    if (y === void 0) y = x;
    this.size.width += 2 * x;
    this.size.height += 2 * y;
    this.origin.translate(-x, -y);
    return this;
  };
  Rect4.prototype.expandCopy = function expandCopy(x, y) {
    return this.clone().expand(x, y);
  };
  Rect4.prototype.containsPoint = function containsPoint(point2) {
    var origin = this.origin;
    var bottomRight = this.bottomRight();
    return !(point2.x < origin.x || point2.y < origin.y || bottomRight.x < point2.x || bottomRight.y < point2.y);
  };
  Rect4.prototype._isOnPath = function _isOnPath(point2, width) {
    var rectOuter = this.expandCopy(width, width);
    var rectInner = this.expandCopy(-width, -width);
    return rectOuter.containsPoint(point2) && !rectInner.containsPoint(point2);
  };
  Rect4.fromPoints = function fromPoints() {
    var topLeft = point_default.min.apply(null, arguments);
    var bottomRight = point_default.max.apply(null, arguments);
    var size = new size_default(bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
    return new Rect4(topLeft, size);
  };
  Rect4.union = function union(a, b) {
    return Rect4.fromPoints(point_default.min(a.topLeft(), b.topLeft()), point_default.max(a.bottomRight(), b.bottomRight()));
  };
  Rect4.intersect = function intersect3(a, b) {
    var rect1 = {
      left: a.topLeft().x,
      top: a.topLeft().y,
      right: a.bottomRight().x,
      bottom: a.bottomRight().y
    };
    var rect2 = {
      left: b.topLeft().x,
      top: b.topLeft().y,
      right: b.bottomRight().x,
      bottom: b.bottomRight().y
    };
    if (rect1.left <= rect2.right && rect2.left <= rect1.right && rect1.top <= rect2.bottom && rect2.top <= rect1.bottom) {
      return Rect4.fromPoints(new point_default(Math.max(rect1.left, rect2.left), Math.max(rect1.top, rect2.top)), new point_default(Math.min(rect1.right, rect2.right), Math.min(rect1.bottom, rect2.bottom)));
    }
  };
  return Rect4;
}(has_observers_default);
var rect_default = Rect;

// node_modules/@progress/kendo-drawing/dist/es/geometry/transformation.js
var Transformation = function(HasObservers2) {
  function Transformation2(matrix) {
    if (matrix === void 0) matrix = matrix_default.unit();
    HasObservers2.call(this);
    this._matrix = matrix;
  }
  if (HasObservers2) Transformation2.__proto__ = HasObservers2;
  Transformation2.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  Transformation2.prototype.constructor = Transformation2;
  Transformation2.prototype.clone = function clone() {
    return new Transformation2(this._matrix.clone());
  };
  Transformation2.prototype.equals = function equals(other) {
    return other && other._matrix.equals(this._matrix);
  };
  Transformation2.prototype.translate = function translate(x, y) {
    this._matrix = this._matrix.multiplyCopy(matrix_default.translate(x, y));
    this._optionsChange();
    return this;
  };
  Transformation2.prototype.scale = function scale(scaleX, scaleY, origin) {
    if (scaleY === void 0) scaleY = scaleX;
    if (origin === void 0) origin = null;
    var originPoint = origin;
    if (originPoint) {
      originPoint = point_default.create(originPoint);
      this._matrix = this._matrix.multiplyCopy(matrix_default.translate(originPoint.x, originPoint.y));
    }
    this._matrix = this._matrix.multiplyCopy(matrix_default.scale(scaleX, scaleY));
    if (originPoint) {
      this._matrix = this._matrix.multiplyCopy(matrix_default.translate(-originPoint.x, -originPoint.y));
    }
    this._optionsChange();
    return this;
  };
  Transformation2.prototype.rotate = function rotate(angle, origin) {
    var originPoint = point_default.create(origin) || point_default.ZERO;
    this._matrix = this._matrix.multiplyCopy(matrix_default.rotate(angle, originPoint.x, originPoint.y));
    this._optionsChange();
    return this;
  };
  Transformation2.prototype.multiply = function multiply2(transformation) {
    var matrix = toMatrix(transformation);
    this._matrix = this._matrix.multiplyCopy(matrix);
    this._optionsChange();
    return this;
  };
  Transformation2.prototype.matrix = function matrix(value) {
    if (value) {
      this._matrix = value;
      this._optionsChange();
      return this;
    }
    return this._matrix;
  };
  Transformation2.prototype._optionsChange = function _optionsChange() {
    this.optionsChange({
      field: "transform",
      value: this
    });
  };
  return Transformation2;
}(has_observers_default);
var transformation_default = Transformation;

// node_modules/@progress/kendo-drawing/dist/es/geometry/transform.js
function transform(matrix) {
  if (matrix === null) {
    return null;
  }
  if (matrix instanceof transformation_default) {
    return matrix;
  }
  return new transformation_default(matrix);
}

// node_modules/@progress/kendo-drawing/dist/es/core/constants.js
var DASH_ARRAYS = {
  dot: [1.5, 3.5],
  dash: [4, 3.5],
  longdash: [8, 3.5],
  dashdot: [3.5, 3.5, 1.5, 3.5],
  longdashdot: [8, 3.5, 1.5, 3.5],
  longdashdotdot: [8, 3.5, 1.5, 3.5, 1.5, 3.5]
};
var SOLID = "solid";
var BUTT = "butt";
var PATTERN = "Pattern";

// node_modules/@progress/kendo-drawing/dist/es/shapes/element.js
var Element2 = function(HasObservers2) {
  function Element3(options2) {
    HasObservers2.call(this);
    this._initOptions(options2);
  }
  if (HasObservers2) Element3.__proto__ = HasObservers2;
  Element3.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  Element3.prototype.constructor = Element3;
  var prototypeAccessors = {
    nodeType: {
      configurable: true
    }
  };
  prototypeAccessors.nodeType.get = function() {
    return "Rect";
  };
  Element3.prototype._initOptions = function _initOptions(options2) {
    if (options2 === void 0) options2 = {};
    var clip = options2.clip;
    var transform3 = options2.transform;
    if (transform3) {
      options2.transform = transform(transform3);
    }
    if (clip && !clip.id) {
      clip.id = definitionId();
    }
    this.options = new options_store_default(options2);
    this.options.addObserver(this);
  };
  Element3.prototype.transform = function transform3(value) {
    if (defined(value)) {
      this.options.set("transform", transform(value));
    } else {
      return this.options.get("transform");
    }
  };
  Element3.prototype.parentTransform = function parentTransform() {
    var element = this;
    var parentMatrix;
    while (element.parent) {
      element = element.parent;
      var transformation = element.transform();
      if (transformation) {
        parentMatrix = transformation.matrix().multiplyCopy(parentMatrix || matrix_default.unit());
      }
    }
    if (parentMatrix) {
      return transform(parentMatrix);
    }
  };
  Element3.prototype.currentTransform = function currentTransform(parentTransform) {
    if (parentTransform === void 0) parentTransform = this.parentTransform();
    var elementTransform = this.transform();
    var elementMatrix = toMatrix(elementTransform);
    var parentMatrix = toMatrix(parentTransform);
    var combinedMatrix;
    if (elementMatrix && parentMatrix) {
      combinedMatrix = parentMatrix.multiplyCopy(elementMatrix);
    } else {
      combinedMatrix = elementMatrix || parentMatrix;
    }
    if (combinedMatrix) {
      return transform(combinedMatrix);
    }
  };
  Element3.prototype.visible = function visible(value) {
    if (defined(value)) {
      this.options.set("visible", value);
      return this;
    }
    return this.options.get("visible") !== false;
  };
  Element3.prototype.clip = function clip(value) {
    var options2 = this.options;
    if (defined(value)) {
      if (value && !value.id) {
        value.id = definitionId();
      }
      options2.set("clip", value);
      return this;
    }
    return options2.get("clip");
  };
  Element3.prototype.opacity = function opacity(value) {
    if (defined(value)) {
      this.options.set("opacity", value);
      return this;
    }
    return valueOrDefault(this.options.get("opacity"), 1);
  };
  Element3.prototype.className = function className(value) {
    if (defined(value)) {
      this.options.set("className", value);
      return this;
    }
    return this.options.get("className");
  };
  Element3.prototype.clippedBBox = function clippedBBox(transformation) {
    var bbox = this._clippedBBox(transformation);
    if (bbox) {
      var clip = this.clip();
      return clip ? rect_default.intersect(bbox, clip.bbox(transformation)) : bbox;
    }
  };
  Element3.prototype.containsPoint = function containsPoint(point2, parentTransform) {
    if (this.visible()) {
      var transform3 = this.currentTransform(parentTransform);
      var transformedPoint = point2;
      if (transform3) {
        transformedPoint = point2.transformCopy(transform3.matrix().invert());
      }
      return this._hasFill() && this._containsPoint(transformedPoint) || this._isOnPath && this._hasStroke() && this._isOnPath(transformedPoint);
    }
    return false;
  };
  Element3.prototype._hasFill = function _hasFill() {
    var fill = this.options.fill;
    return fill && (fill.nodeType === PATTERN || !isTransparent(fill.color));
  };
  Element3.prototype._hasStroke = function _hasStroke() {
    var stroke = this.options.stroke;
    return stroke && stroke.width > 0 && !isTransparent(stroke.color);
  };
  Element3.prototype._clippedBBox = function _clippedBBox(transformation) {
    return this.bbox(transformation);
  };
  Object.defineProperties(Element3.prototype, prototypeAccessors);
  return Element3;
}(has_observers_default);
var element_default = Element2;

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/ellipse-extreme-angles.js
function ellipseExtremeAngles(center, rx, ry, matrix) {
  var extremeX = 0;
  var extremeY = 0;
  if (matrix) {
    extremeX = Math.atan2(matrix.c * ry, matrix.a * rx);
    if (matrix.b !== 0) {
      extremeY = Math.atan2(matrix.d * ry, matrix.b * rx);
    }
  }
  return {
    x: extremeX,
    y: extremeY
  };
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/circle.js
var PI_DIV_2 = Math.PI / 2;
var Circle = function(superclass) {
  function Circle3(center, radius) {
    if (center === void 0) center = new point_default();
    if (radius === void 0) radius = 0;
    superclass.call(this);
    this.setCenter(center);
    this.setRadius(radius);
  }
  if (superclass) Circle3.__proto__ = superclass;
  Circle3.prototype = Object.create(superclass && superclass.prototype);
  Circle3.prototype.constructor = Circle3;
  Circle3.prototype.setCenter = function setCenter(value) {
    this._observerField("center", point_default.create(value));
    this.geometryChange();
    return this;
  };
  Circle3.prototype.getCenter = function getCenter() {
    return this.center;
  };
  Circle3.prototype.equals = function equals(other) {
    return other && other.center.equals(this.center) && other.radius === this.radius;
  };
  Circle3.prototype.clone = function clone() {
    return new Circle3(this.center.clone(), this.radius);
  };
  Circle3.prototype.pointAt = function pointAt(angle) {
    return this._pointAt(rad(angle));
  };
  Circle3.prototype.bbox = function bbox(matrix) {
    var this$1 = this;
    var extremeAngles = ellipseExtremeAngles(this.center, this.radius, this.radius, matrix);
    var minPoint = point_default.maxPoint();
    var maxPoint = point_default.minPoint();
    for (var i = 0; i < 4; i++) {
      var currentPointX = this$1._pointAt(extremeAngles.x + i * PI_DIV_2).transformCopy(matrix);
      var currentPointY = this$1._pointAt(extremeAngles.y + i * PI_DIV_2).transformCopy(matrix);
      var currentPoint = new point_default(currentPointX.x, currentPointY.y);
      minPoint = point_default.min(minPoint, currentPoint);
      maxPoint = point_default.max(maxPoint, currentPoint);
    }
    return rect_default.fromPoints(minPoint, maxPoint);
  };
  Circle3.prototype._pointAt = function _pointAt(angle) {
    var ref = this;
    var center = ref.center;
    var radius = ref.radius;
    return new point_default(center.x + radius * Math.cos(angle), center.y + radius * Math.sin(angle));
  };
  Circle3.prototype.containsPoint = function containsPoint(point2) {
    var ref = this;
    var center = ref.center;
    var radius = ref.radius;
    var inCircle = Math.pow(point2.x - center.x, 2) + Math.pow(point2.y - center.y, 2) <= Math.pow(radius, 2);
    return inCircle;
  };
  Circle3.prototype._isOnPath = function _isOnPath(point2, width) {
    var ref = this;
    var center = ref.center;
    var radius = ref.radius;
    var pointDistance = center.distanceTo(point2);
    return radius - width <= pointDistance && pointDistance <= radius + width;
  };
  return Circle3;
}(with_accessors_default(has_observers_default, ["radius"]));
var circle_default = Circle;

// node_modules/@progress/kendo-drawing/dist/es/mixins/paintable.js
var GRADIENT = "Gradient";
var paintable = function(TBase) {
  return function(TBase2) {
    function anonymous() {
      TBase2.apply(this, arguments);
    }
    if (TBase2) anonymous.__proto__ = TBase2;
    anonymous.prototype = Object.create(TBase2 && TBase2.prototype);
    anonymous.prototype.constructor = anonymous;
    anonymous.prototype.fill = function fill(color, opacity) {
      var options2 = this.options;
      if (defined(color)) {
        if (color && color.nodeType !== GRADIENT) {
          var newFill = {
            color
          };
          if (defined(opacity)) {
            newFill.opacity = opacity;
          }
          options2.set("fill", newFill);
        } else {
          options2.set("fill", color);
        }
        return this;
      }
      return options2.get("fill");
    };
    anonymous.prototype.stroke = function stroke(color, width, opacity) {
      if (defined(color)) {
        this.options.set("stroke.color", color);
        if (defined(width)) {
          this.options.set("stroke.width", width);
        }
        if (defined(opacity)) {
          this.options.set("stroke.opacity", opacity);
        }
        return this;
      }
      return this.options.get("stroke");
    };
    return anonymous;
  }(TBase);
};
var paintable_default = paintable;

// node_modules/@progress/kendo-drawing/dist/es/mixins/measurable.js
var IDENTITY_MATRIX_HASH = matrix_default.IDENTITY.toString();
var measurable = function(TBase) {
  return function(TBase2) {
    function anonymous() {
      TBase2.apply(this, arguments);
    }
    if (TBase2) anonymous.__proto__ = TBase2;
    anonymous.prototype = Object.create(TBase2 && TBase2.prototype);
    anonymous.prototype.constructor = anonymous;
    anonymous.prototype.bbox = function bbox(transformation) {
      var combinedMatrix = toMatrix(this.currentTransform(transformation));
      var matrixHash = combinedMatrix ? combinedMatrix.toString() : IDENTITY_MATRIX_HASH;
      var bbox2;
      if (this._bboxCache && this._matrixHash === matrixHash) {
        bbox2 = this._bboxCache.clone();
      } else {
        bbox2 = this._bbox(combinedMatrix);
        this._bboxCache = bbox2 ? bbox2.clone() : null;
        this._matrixHash = matrixHash;
      }
      var strokeWidth = this.options.get("stroke.width");
      if (strokeWidth && bbox2) {
        bbox2.expand(strokeWidth / 2);
      }
      return bbox2;
    };
    anonymous.prototype.geometryChange = function geometryChange() {
      delete this._bboxCache;
      this.trigger("geometryChange", {
        element: this
      });
    };
    return anonymous;
  }(TBase);
};
var measurable_default = measurable;

// node_modules/@progress/kendo-drawing/dist/es/mixins/with-geometry.js
function geometryAccessor(name2) {
  var fieldName = "_" + name2;
  return function(value) {
    if (defined(value)) {
      this._observerField(fieldName, value);
      this.geometryChange();
      return this;
    }
    return this[fieldName];
  };
}
function defineGeometryAccessors(fn, names) {
  for (var i = 0; i < names.length; i++) {
    fn[names[i]] = geometryAccessor(names[i]);
  }
}
var withGeometry = function(TBase, names) {
  if (names === void 0) names = ["geometry"];
  var result = function(TBase2) {
    function result2() {
      TBase2.apply(this, arguments);
    }
    if (TBase2) result2.__proto__ = TBase2;
    result2.prototype = Object.create(TBase2 && TBase2.prototype);
    result2.prototype.constructor = result2;
    return result2;
  }(TBase);
  defineGeometryAccessors(result.prototype, names);
  return result;
};
var with_geometry_default = withGeometry;

// node_modules/@progress/kendo-drawing/dist/es/shapes/circle.js
var DEFAULT_STROKE = "#000";
var Circle2 = function(superclass) {
  function Circle3(geometry, options2) {
    if (geometry === void 0) geometry = new circle_default();
    if (options2 === void 0) options2 = {};
    superclass.call(this, options2);
    this.geometry(geometry);
    if (!defined(this.options.stroke)) {
      this.stroke(DEFAULT_STROKE);
    }
  }
  if (superclass) Circle3.__proto__ = superclass;
  Circle3.prototype = Object.create(superclass && superclass.prototype);
  Circle3.prototype.constructor = Circle3;
  var prototypeAccessors = {
    nodeType: {
      configurable: true
    }
  };
  prototypeAccessors.nodeType.get = function() {
    return "Circle";
  };
  Circle3.prototype.rawBBox = function rawBBox() {
    return this._geometry.bbox();
  };
  Circle3.prototype._bbox = function _bbox(matrix) {
    return this._geometry.bbox(matrix);
  };
  Circle3.prototype._containsPoint = function _containsPoint(point2) {
    return this.geometry().containsPoint(point2);
  };
  Circle3.prototype._isOnPath = function _isOnPath(point2) {
    return this.geometry()._isOnPath(point2, this.options.stroke.width / 2);
  };
  Object.defineProperties(Circle3.prototype, prototypeAccessors);
  return Circle3;
}(paintable_default(measurable_default(with_geometry_default(element_default))));
var circle_default2 = Circle2;

// node_modules/@progress/kendo-drawing/dist/es/geometry/constants.js
var PRECISION = 10;

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/close.js
function close(a, b, tolerance) {
  if (tolerance === void 0) tolerance = PRECISION;
  return round2(Math.abs(a - b), tolerance) === 0;
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/close-or-less.js
function closeOrLess(a, b, tolerance) {
  return a < b || close(a, b, tolerance);
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/line-intersection.js
function lineIntersection(p0, p1, p2, p3) {
  var s1x = p1.x - p0.x;
  var s2x = p3.x - p2.x;
  var s1y = p1.y - p0.y;
  var s2y = p3.y - p2.y;
  var nx = p0.x - p2.x;
  var ny = p0.y - p2.y;
  var d = s1x * s2y - s2x * s1y;
  var s = (s1x * ny - s1y * nx) / d;
  var t = (s2x * ny - s2y * nx) / d;
  if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
    return new point_default(p0.x + t * s1x, p0.y + t * s1y);
  }
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/arc.js
var MAX_INTERVAL = 45;
var pow2 = Math.pow;
var accessors = ["radiusX", "radiusY", "startAngle", "endAngle", "anticlockwise"];
var Arc = function(superclass) {
  function Arc3(center, options2) {
    if (center === void 0) center = new point_default();
    if (options2 === void 0) options2 = {};
    superclass.call(this);
    this.setCenter(center);
    this.radiusX = options2.radiusX;
    this.radiusY = options2.radiusY || options2.radiusX;
    this.startAngle = options2.startAngle;
    this.endAngle = options2.endAngle;
    this.anticlockwise = options2.anticlockwise || false;
    this.xRotation = options2.xRotation;
  }
  if (superclass) Arc3.__proto__ = superclass;
  Arc3.prototype = Object.create(superclass && superclass.prototype);
  Arc3.prototype.constructor = Arc3;
  Arc3.prototype.clone = function clone() {
    return new Arc3(this.center, {
      radiusX: this.radiusX,
      radiusY: this.radiusY,
      startAngle: this.startAngle,
      endAngle: this.endAngle,
      anticlockwise: this.anticlockwise
    });
  };
  Arc3.prototype.setCenter = function setCenter(value) {
    this._observerField("center", point_default.create(value));
    this.geometryChange();
    return this;
  };
  Arc3.prototype.getCenter = function getCenter() {
    return this.center;
  };
  Arc3.prototype.pointAt = function pointAt(angle) {
    var center = this.center;
    var radian = rad(angle);
    return new point_default(center.x + this.radiusX * Math.cos(radian), center.y + this.radiusY * Math.sin(radian));
  };
  Arc3.prototype.curvePoints = function curvePoints() {
    var this$1 = this;
    var startAngle = this.startAngle;
    var dir = this.anticlockwise ? -1 : 1;
    var curvePoints2 = [this.pointAt(startAngle)];
    var interval2 = this._arcInterval();
    var intervalAngle = interval2.endAngle - interval2.startAngle;
    var subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);
    var subIntervalAngle = intervalAngle / subIntervalsCount;
    var currentAngle = startAngle;
    var transformation;
    if (this.xRotation) {
      transformation = transform().rotate(this.xRotation, this.center);
    }
    for (var i = 1; i <= subIntervalsCount; i++) {
      var nextAngle = currentAngle + dir * subIntervalAngle;
      var points3 = this$1._intervalCurvePoints(currentAngle, nextAngle, transformation);
      curvePoints2.push(points3.cp1, points3.cp2, points3.p2);
      currentAngle = nextAngle;
    }
    return curvePoints2;
  };
  Arc3.prototype.bbox = function bbox(matrix) {
    var this$1 = this;
    var interval2 = this._arcInterval();
    var startAngle = interval2.startAngle;
    var endAngle = interval2.endAngle;
    var extremeAngles = ellipseExtremeAngles(this.center, this.radiusX, this.radiusY, matrix);
    var extremeX = deg(extremeAngles.x);
    var extremeY = deg(extremeAngles.y);
    var endPoint = this.pointAt(endAngle).transformCopy(matrix);
    var currentAngleX = bboxStartAngle(extremeX, startAngle);
    var currentAngleY = bboxStartAngle(extremeY, startAngle);
    var currentPoint = this.pointAt(startAngle).transformCopy(matrix);
    var minPoint = point_default.min(currentPoint, endPoint);
    var maxPoint = point_default.max(currentPoint, endPoint);
    while (currentAngleX < endAngle || currentAngleY < endAngle) {
      var currentPointX = void 0;
      if (currentAngleX < endAngle) {
        currentPointX = this$1.pointAt(currentAngleX).transformCopy(matrix);
        currentAngleX += 90;
      }
      var currentPointY = void 0;
      if (currentAngleY < endAngle) {
        currentPointY = this$1.pointAt(currentAngleY).transformCopy(matrix);
        currentAngleY += 90;
      }
      currentPoint = new point_default(currentPointX.x, currentPointY.y);
      minPoint = point_default.min(minPoint, currentPoint);
      maxPoint = point_default.max(maxPoint, currentPoint);
    }
    return rect_default.fromPoints(minPoint, maxPoint);
  };
  Arc3.prototype._arcInterval = function _arcInterval() {
    var ref = this;
    var startAngle = ref.startAngle;
    var endAngle = ref.endAngle;
    var anticlockwise = ref.anticlockwise;
    if (anticlockwise) {
      var oldStart = startAngle;
      startAngle = endAngle;
      endAngle = oldStart;
    }
    if (startAngle > endAngle || anticlockwise && startAngle === endAngle) {
      endAngle += 360;
    }
    return {
      startAngle,
      endAngle
    };
  };
  Arc3.prototype._intervalCurvePoints = function _intervalCurvePoints(startAngle, endAngle, transformation) {
    var p1 = this.pointAt(startAngle);
    var p2 = this.pointAt(endAngle);
    var p1Derivative = this._derivativeAt(startAngle);
    var p2Derivative = this._derivativeAt(endAngle);
    var t = (rad(endAngle) - rad(startAngle)) / 3;
    var cp1 = new point_default(p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);
    var cp2 = new point_default(p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);
    if (transformation) {
      p1.transform(transformation);
      p2.transform(transformation);
      cp1.transform(transformation);
      cp2.transform(transformation);
    }
    return {
      p1,
      cp1,
      cp2,
      p2
    };
  };
  Arc3.prototype._derivativeAt = function _derivativeAt(angle) {
    var radian = rad(angle);
    return new point_default(-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));
  };
  Arc3.prototype.containsPoint = function containsPoint(point2) {
    var interval2 = this._arcInterval();
    var intervalAngle = interval2.endAngle - interval2.startAngle;
    var ref = this;
    var center = ref.center;
    var radiusX = ref.radiusX;
    var radiusY = ref.radiusY;
    var distance = center.distanceTo(point2);
    var angleRad = Math.atan2(point2.y - center.y, point2.x - center.x);
    var pointRadius = radiusX * radiusY / Math.sqrt(pow2(radiusX, 2) * pow2(Math.sin(angleRad), 2) + pow2(radiusY, 2) * pow2(Math.cos(angleRad), 2));
    var startPoint = this.pointAt(this.startAngle).round(PRECISION);
    var endPoint = this.pointAt(this.endAngle).round(PRECISION);
    var intersection = lineIntersection(center, point2.round(PRECISION), startPoint, endPoint);
    var containsPoint2;
    if (intervalAngle < 180) {
      containsPoint2 = intersection && closeOrLess(center.distanceTo(intersection), distance) && closeOrLess(distance, pointRadius);
    } else {
      var angle = calculateAngle(center.x, center.y, radiusX, radiusY, point2.x, point2.y);
      if (angle !== 360) {
        angle = (360 + angle) % 360;
      }
      var inAngleRange = interval2.startAngle <= angle && angle <= interval2.endAngle;
      containsPoint2 = inAngleRange && closeOrLess(distance, pointRadius) || !inAngleRange && (!intersection || intersection.equals(point2));
    }
    return containsPoint2;
  };
  Arc3.prototype._isOnPath = function _isOnPath(point2, width) {
    var interval2 = this._arcInterval();
    var center = this.center;
    var angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point2.x, point2.y);
    if (angle !== 360) {
      angle = (360 + angle) % 360;
    }
    var inAngleRange = interval2.startAngle <= angle && angle <= interval2.endAngle;
    return inAngleRange && this.pointAt(angle).distanceTo(point2) <= width;
  };
  Arc3.fromPoints = function fromPoints(start, end, rx, ry, largeArc, swipe, rotation) {
    var arcParameters = normalizeArcParameters({
      x1: start.x,
      y1: start.y,
      x2: end.x,
      y2: end.y,
      rx,
      ry,
      largeArc,
      swipe,
      rotation
    });
    return new Arc3(arcParameters.center, {
      startAngle: arcParameters.startAngle,
      endAngle: arcParameters.endAngle,
      radiusX: arcParameters.radiusX,
      radiusY: arcParameters.radiusY,
      xRotation: arcParameters.xRotation,
      anticlockwise: swipe === 0
    });
  };
  return Arc3;
}(with_accessors_default(has_observers_default, accessors));
function calculateAngle(cx, cy, rx, ry, x, y) {
  var cos = round2((x - cx) / rx, 3);
  var sin = round2((y - cy) / ry, 3);
  return round2(deg(Math.atan2(sin, cos)));
}
function normalizeArcParameters(parameters) {
  var x1 = parameters.x1;
  var y1 = parameters.y1;
  var x2 = parameters.x2;
  var y2 = parameters.y2;
  var rx = parameters.rx;
  var ry = parameters.ry;
  var largeArc = parameters.largeArc;
  var swipe = parameters.swipe;
  var rotation = parameters.rotation;
  if (rotation === void 0) rotation = 0;
  var radians = rad(rotation);
  var cosine = Math.cos(radians);
  var sine = Math.sin(radians);
  var xT = cosine * (x1 - x2) / 2 + sine * (y1 - y2) / 2;
  var yT = -sine * (x1 - x2) / 2 + cosine * (y1 - y2) / 2;
  var sign = largeArc !== swipe ? 1 : -1;
  var xt2 = Math.pow(xT, 2);
  var yt2 = Math.pow(yT, 2);
  var rx2 = Math.pow(rx, 2);
  var ry2 = Math.pow(ry, 2);
  var delta = xt2 / rx2 + yt2 / ry2;
  if (delta > 1) {
    delta = Math.sqrt(xt2 / rx2 + yt2 / ry2);
    rx = delta * rx;
    rx2 = Math.pow(rx, 2);
    ry = delta * ry;
    ry2 = Math.pow(ry, 2);
  }
  var constT = sign * Math.sqrt((rx2 * ry2 - rx2 * yt2 - ry2 * xt2) / (rx2 * yt2 + ry2 * xt2));
  if (isNaN(constT)) {
    constT = 0;
  }
  var cxT = constT * (rx * yT) / ry;
  var cyT = -constT * (ry * xT) / rx;
  var cx = cosine * cxT - sine * cyT + (x1 + x2) / 2;
  var cy = sine * cxT + cosine * cyT + (y1 + y2) / 2;
  var uX = (xT - cxT) / rx;
  var uY = (yT - cyT) / ry;
  var vX = -(xT + cxT) / rx;
  var vY = -(yT + cyT) / ry;
  var startAngle = (uY >= 0 ? 1 : -1) * deg(Math.acos(uX / Math.sqrt(uX * uX + uY * uY)));
  var angleCosine = round2((uX * vX + uY * vY) / (Math.sqrt(uX * uX + uY * uY) * Math.sqrt(vX * vX + vY * vY)), 10);
  var angle = (uX * vY - uY * vX >= 0 ? 1 : -1) * deg(Math.acos(angleCosine));
  if (!swipe && angle > 0) {
    angle -= 360;
  }
  if (swipe && angle < 0) {
    angle += 360;
  }
  var endAngle = startAngle + angle;
  var signEndAngle = endAngle >= 0 ? 1 : -1;
  endAngle = Math.abs(endAngle) % 360 * signEndAngle;
  return {
    center: new point_default(cx, cy),
    startAngle,
    endAngle,
    radiusX: rx,
    radiusY: ry,
    xRotation: rotation
  };
}
function bboxStartAngle(angle, start) {
  var startAngle = angle;
  while (startAngle < start) {
    startAngle += 90;
  }
  return startAngle;
}
var arc_default = Arc;

// node_modules/@progress/kendo-drawing/dist/es/shapes/elements-array.js
var push = [].push;
var pop = [].pop;
var splice = [].splice;
var shift = [].shift;
var slice = [].slice;
var unshift = [].unshift;
var ElementsArray = function(HasObservers2) {
  function ElementsArray2(array) {
    if (array === void 0) array = [];
    HasObservers2.call(this);
    this.length = 0;
    this._splice(0, array.length, array);
  }
  if (HasObservers2) ElementsArray2.__proto__ = HasObservers2;
  ElementsArray2.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  ElementsArray2.prototype.constructor = ElementsArray2;
  ElementsArray2.prototype.elements = function elements(value) {
    if (value) {
      this._splice(0, this.length, value);
      this._change();
      return this;
    }
    return this.slice(0);
  };
  ElementsArray2.prototype.push = function push$1() {
    var elements = arguments;
    var result = push.apply(this, elements);
    this._add(elements);
    return result;
  };
  ElementsArray2.prototype.slice = function slice$1() {
    return slice.call(this);
  };
  ElementsArray2.prototype.pop = function pop$1() {
    var length = this.length;
    var result = pop.apply(this);
    if (length) {
      this._remove([result]);
    }
    return result;
  };
  ElementsArray2.prototype.splice = function splice2(index, howMany) {
    var elements = slice.call(arguments, 2);
    var result = this._splice(index, howMany, elements);
    this._change();
    return result;
  };
  ElementsArray2.prototype.shift = function shift$1() {
    var length = this.length;
    var result = shift.apply(this);
    if (length) {
      this._remove([result]);
    }
    return result;
  };
  ElementsArray2.prototype.unshift = function unshift$1() {
    var elements = arguments;
    var result = unshift.apply(this, elements);
    this._add(elements);
    return result;
  };
  ElementsArray2.prototype.indexOf = function indexOf(element) {
    var this$1 = this;
    var length = this.length;
    for (var idx2 = 0; idx2 < length; idx2++) {
      if (this$1[idx2] === element) {
        return idx2;
      }
    }
    return -1;
  };
  ElementsArray2.prototype._splice = function _splice(index, howMany, elements) {
    var result = splice.apply(this, [index, howMany].concat(elements));
    this._clearObserver(result);
    this._setObserver(elements);
    return result;
  };
  ElementsArray2.prototype._add = function _add(elements) {
    this._setObserver(elements);
    this._change();
  };
  ElementsArray2.prototype._remove = function _remove(elements) {
    this._clearObserver(elements);
    this._change();
  };
  ElementsArray2.prototype._setObserver = function _setObserver(elements) {
    var this$1 = this;
    for (var idx2 = 0; idx2 < elements.length; idx2++) {
      elements[idx2].addObserver(this$1);
    }
  };
  ElementsArray2.prototype._clearObserver = function _clearObserver(elements) {
    var this$1 = this;
    for (var idx2 = 0; idx2 < elements.length; idx2++) {
      elements[idx2].removeObserver(this$1);
    }
  };
  ElementsArray2.prototype._change = function _change() {
  };
  return ElementsArray2;
}(has_observers_default);
var elements_array_default = ElementsArray;

// node_modules/@progress/kendo-drawing/dist/es/shapes/geometry-elements-array.js
var GeometryElementsArray = function(ElementsArray2) {
  function GeometryElementsArray2() {
    ElementsArray2.apply(this, arguments);
  }
  if (ElementsArray2) GeometryElementsArray2.__proto__ = ElementsArray2;
  GeometryElementsArray2.prototype = Object.create(ElementsArray2 && ElementsArray2.prototype);
  GeometryElementsArray2.prototype.constructor = GeometryElementsArray2;
  GeometryElementsArray2.prototype._change = function _change() {
    this.geometryChange();
  };
  return GeometryElementsArray2;
}(elements_array_default);
var geometry_elements_array_default = GeometryElementsArray;

// node_modules/@progress/kendo-drawing/dist/es/geometry.js
var geometry_exports = {};
__export(geometry_exports, {
  Arc: () => arc_default,
  Circle: () => circle_default,
  Matrix: () => matrix_default,
  Point: () => point_default,
  Rect: () => rect_default,
  Segment: () => segment_default,
  Size: () => size_default,
  Transformation: () => transformation_default,
  toMatrix: () => toMatrix,
  transform: () => transform
});

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/is-out-of-end-point.js
function isOutOfEndPoint(endPoint, controlPoint2, point2) {
  var angle = deg(Math.atan2(controlPoint2.y - endPoint.y, controlPoint2.x - endPoint.x));
  var rotatedPoint = point2.transformCopy(transform().rotate(-angle, endPoint));
  return rotatedPoint.x < endPoint.x;
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/calculate-curve-at.js
function calculateCurveAt(t, field, points3) {
  var t1 = 1 - t;
  return Math.pow(t1, 3) * points3[0][field] + 3 * Math.pow(t1, 2) * t * points3[1][field] + 3 * Math.pow(t, 2) * t1 * points3[2][field] + Math.pow(t, 3) * points3[3][field];
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/to-cubic-polynomial.js
function toCubicPolynomial(points3, field) {
  return [-points3[0][field] + 3 * points3[1][field] - 3 * points3[2][field] + points3[3][field], 3 * (points3[0][field] - 2 * points3[1][field] + points3[2][field]), 3 * (-points3[0][field] + points3[1][field]), points3[0][field]];
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/complex-number.js
var ComplexNumber = function(Class3) {
  function ComplexNumber2(real, img) {
    if (real === void 0) real = 0;
    if (img === void 0) img = 0;
    Class3.call(this);
    this.real = real;
    this.img = img;
  }
  if (Class3) ComplexNumber2.__proto__ = Class3;
  ComplexNumber2.prototype = Object.create(Class3 && Class3.prototype);
  ComplexNumber2.prototype.constructor = ComplexNumber2;
  ComplexNumber2.prototype.add = function add2(cNumber) {
    return new ComplexNumber2(round2(this.real + cNumber.real, PRECISION), round2(this.img + cNumber.img, PRECISION));
  };
  ComplexNumber2.prototype.addConstant = function addConstant(value) {
    return new ComplexNumber2(this.real + value, this.img);
  };
  ComplexNumber2.prototype.negate = function negate() {
    return new ComplexNumber2(-this.real, -this.img);
  };
  ComplexNumber2.prototype.multiply = function multiply2(cNumber) {
    return new ComplexNumber2(this.real * cNumber.real - this.img * cNumber.img, this.real * cNumber.img + this.img * cNumber.real);
  };
  ComplexNumber2.prototype.multiplyConstant = function multiplyConstant(value) {
    return new ComplexNumber2(this.real * value, this.img * value);
  };
  ComplexNumber2.prototype.nthRoot = function nthRoot(n) {
    var rad2 = Math.atan2(this.img, this.real);
    var r = Math.sqrt(Math.pow(this.img, 2) + Math.pow(this.real, 2));
    var nthR = Math.pow(r, 1 / n);
    return new ComplexNumber2(nthR * Math.cos(rad2 / n), nthR * Math.sin(rad2 / n));
  };
  ComplexNumber2.prototype.equals = function equals(cNumber) {
    return this.real === cNumber.real && this.img === cNumber.img;
  };
  ComplexNumber2.prototype.isReal = function isReal() {
    return this.img === 0;
  };
  return ComplexNumber2;
}(class_default);
var complex_number_default = ComplexNumber;

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/solve-cubic-equation.js
function numberSign(x) {
  return x < 0 ? -1 : 1;
}
function solveQuadraticEquation(a, b, c) {
  var squareRoot = Math.sqrt(Math.pow(b, 2) - 4 * a * c);
  return [(-b + squareRoot) / (2 * a), (-b - squareRoot) / (2 * a)];
}
function solveCubicEquation(a, b, c, d) {
  if (a === 0) {
    return solveQuadraticEquation(b, c, d);
  }
  var p = (3 * a * c - Math.pow(b, 2)) / (3 * Math.pow(a, 2));
  var q = (2 * Math.pow(b, 3) - 9 * a * b * c + 27 * Math.pow(a, 2) * d) / (27 * Math.pow(a, 3));
  var Q = Math.pow(p / 3, 3) + Math.pow(q / 2, 2);
  var i = new complex_number_default(0, 1);
  var b3a = -b / (3 * a);
  var x1, x2, y1, y2, y3, z1, z2;
  if (Q < 0) {
    x1 = new complex_number_default(-q / 2, Math.sqrt(-Q)).nthRoot(3);
    x2 = new complex_number_default(-q / 2, -Math.sqrt(-Q)).nthRoot(3);
  } else {
    x1 = -q / 2 + Math.sqrt(Q);
    x1 = new complex_number_default(numberSign(x1) * Math.pow(Math.abs(x1), 1 / 3));
    x2 = -q / 2 - Math.sqrt(Q);
    x2 = new complex_number_default(numberSign(x2) * Math.pow(Math.abs(x2), 1 / 3));
  }
  y1 = x1.add(x2);
  z1 = x1.add(x2).multiplyConstant(-1 / 2);
  z2 = x1.add(x2.negate()).multiplyConstant(Math.sqrt(3) / 2);
  y2 = z1.add(i.multiply(z2));
  y3 = z1.add(i.negate().multiply(z2));
  var result = [];
  if (y1.isReal()) {
    result.push(round2(y1.real + b3a, PRECISION));
  }
  if (y2.isReal()) {
    result.push(round2(y2.real + b3a, PRECISION));
  }
  if (y3.isReal()) {
    result.push(round2(y3.real + b3a, PRECISION));
  }
  return result;
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/has-roots-in-range.js
function hasRootsInRange(points3, point2, field, rootField, range) {
  var polynomial = toCubicPolynomial(points3, rootField);
  var roots = solveCubicEquation(polynomial[0], polynomial[1], polynomial[2], polynomial[3] - point2[rootField]);
  var intersection;
  for (var idx2 = 0; idx2 < roots.length; idx2++) {
    if (0 <= roots[idx2] && roots[idx2] <= 1) {
      intersection = calculateCurveAt(roots[idx2], field, points3);
      if (Math.abs(intersection - point2[field]) <= range) {
        return true;
      }
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/curve-intersections-count.js
function curveIntersectionsCount(points3, point2, bbox) {
  var polynomial = toCubicPolynomial(points3, "x");
  var roots = solveCubicEquation(polynomial[0], polynomial[1], polynomial[2], polynomial[3] - point2.x);
  var rayIntersection, intersectsRay;
  var count = 0;
  for (var i = 0; i < roots.length; i++) {
    rayIntersection = calculateCurveAt(roots[i], "y", points3);
    intersectsRay = close(rayIntersection, point2.y) || rayIntersection > point2.y;
    if (intersectsRay && ((roots[i] === 0 || roots[i] === 1) && bbox.bottomRight().x > point2.x || 0 < roots[i] && roots[i] < 1)) {
      count++;
    }
  }
  return count;
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/line-intersections-count.js
function lineIntersectionsCount(a, b, point2) {
  var intersects;
  if (a.x !== b.x) {
    var minX = Math.min(a.x, b.x);
    var maxX = Math.max(a.x, b.x);
    var minY = Math.min(a.y, b.y);
    var maxY = Math.max(a.y, b.y);
    var inRange = minX <= point2.x && point2.x < maxX;
    if (minY === maxY) {
      intersects = point2.y <= minY && inRange;
    } else {
      intersects = inRange && (maxY - minY) * ((a.x - b.x) * (a.y - b.y) > 0 ? point2.x - minX : maxX - point2.x) / (maxX - minX) + minY - point2.y >= 0;
    }
  }
  return intersects ? 1 : 0;
}

// node_modules/@progress/kendo-drawing/dist/es/mixins/with-points.js
function pointAccessor(name2) {
  var fieldName = "_" + name2;
  return function(value) {
    if (defined(value)) {
      this._observerField(fieldName, point_default.create(value));
      this.geometryChange();
      return this;
    }
    return this[fieldName];
  };
}
function definePointAccessors(fn, names) {
  for (var i = 0; i < names.length; i++) {
    fn[names[i]] = pointAccessor(names[i]);
  }
}
var withPoints = function(TBase, names) {
  var result = function(TBase2) {
    function result2() {
      TBase2.apply(this, arguments);
    }
    if (TBase2) result2.__proto__ = TBase2;
    result2.prototype = Object.create(TBase2 && TBase2.prototype);
    result2.prototype.constructor = result2;
    return result2;
  }(TBase);
  definePointAccessors(result.prototype, names);
  return result;
};
var with_points_default = withPoints;

// node_modules/@progress/kendo-drawing/dist/es/geometry/segment.js
var points = ["anchor", "controlIn", "controlOut"];
var Segment = function(superclass) {
  function Segment2(anchor, controlIn, controlOut) {
    superclass.call(this);
    this.anchor(anchor || new point_default());
    this.controlIn(controlIn);
    this.controlOut(controlOut);
  }
  if (superclass) Segment2.__proto__ = superclass;
  Segment2.prototype = Object.create(superclass && superclass.prototype);
  Segment2.prototype.constructor = Segment2;
  Segment2.prototype.bboxTo = function bboxTo(toSegment, matrix) {
    var segmentAnchor = this.anchor().transformCopy(matrix);
    var toSegmentAnchor = toSegment.anchor().transformCopy(matrix);
    var rect;
    if (this.controlOut() && toSegment.controlIn()) {
      rect = this._curveBoundingBox(segmentAnchor, this.controlOut().transformCopy(matrix), toSegment.controlIn().transformCopy(matrix), toSegmentAnchor);
    } else {
      rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);
    }
    return rect;
  };
  Segment2.prototype._lineBoundingBox = function _lineBoundingBox(p1, p2) {
    return rect_default.fromPoints(p1, p2);
  };
  Segment2.prototype._curveBoundingBox = function _curveBoundingBox(p1, cp1, cp2, p2) {
    var points3 = [p1, cp1, cp2, p2];
    var extremesX = this._curveExtremesFor(points3, "x");
    var extremesY = this._curveExtremesFor(points3, "y");
    var xLimits = arrayLimits([extremesX.min, extremesX.max, p1.x, p2.x]);
    var yLimits = arrayLimits([extremesY.min, extremesY.max, p1.y, p2.y]);
    return rect_default.fromPoints(new point_default(xLimits.min, yLimits.min), new point_default(xLimits.max, yLimits.max));
  };
  Segment2.prototype._curveExtremesFor = function _curveExtremesFor(points3, field) {
    var extremes = this._curveExtremes(points3[0][field], points3[1][field], points3[2][field], points3[3][field]);
    return {
      min: calculateCurveAt(extremes.min, field, points3),
      max: calculateCurveAt(extremes.max, field, points3)
    };
  };
  Segment2.prototype._curveExtremes = function _curveExtremes(x1, x2, x3, x4) {
    var a = x1 - 3 * x2 + 3 * x3 - x4;
    var b = -2 * (x1 - 2 * x2 + x3);
    var c = x1 - x2;
    var sqrt = Math.sqrt(b * b - 4 * a * c);
    var t1 = 0;
    var t2 = 1;
    if (a === 0) {
      if (b !== 0) {
        t1 = t2 = -c / b;
      }
    } else if (!isNaN(sqrt)) {
      t1 = (-b + sqrt) / (2 * a);
      t2 = (-b - sqrt) / (2 * a);
    }
    var min = Math.max(Math.min(t1, t2), 0);
    if (min < 0 || min > 1) {
      min = 0;
    }
    var max = Math.min(Math.max(t1, t2), 1);
    if (max > 1 || max < 0) {
      max = 1;
    }
    return {
      min,
      max
    };
  };
  Segment2.prototype._intersectionsTo = function _intersectionsTo(segment, point2) {
    var intersectionsCount;
    if (this.controlOut() && segment.controlIn()) {
      intersectionsCount = curveIntersectionsCount([this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor()], point2, this.bboxTo(segment));
    } else {
      intersectionsCount = lineIntersectionsCount(this.anchor(), segment.anchor(), point2);
    }
    return intersectionsCount;
  };
  Segment2.prototype._isOnCurveTo = function _isOnCurveTo(segment, point2, width, endSegment) {
    var bbox = this.bboxTo(segment).expand(width, width);
    if (bbox.containsPoint(point2)) {
      var p1 = this.anchor();
      var p2 = this.controlOut();
      var p3 = segment.controlIn();
      var p4 = segment.anchor();
      if (endSegment === "start" && p1.distanceTo(point2) <= width) {
        return !isOutOfEndPoint(p1, p2, point2);
      } else if (endSegment === "end" && p4.distanceTo(point2) <= width) {
        return !isOutOfEndPoint(p4, p3, point2);
      }
      var points3 = [p1, p2, p3, p4];
      if (hasRootsInRange(points3, point2, "x", "y", width) || hasRootsInRange(points3, point2, "y", "x", width)) {
        return true;
      }
      var rotation = transform().rotate(45, point2);
      var rotatedPoints = [p1.transformCopy(rotation), p2.transformCopy(rotation), p3.transformCopy(rotation), p4.transformCopy(rotation)];
      return hasRootsInRange(rotatedPoints, point2, "x", "y", width) || hasRootsInRange(rotatedPoints, point2, "y", "x", width);
    }
  };
  Segment2.prototype._isOnLineTo = function _isOnLineTo(segment, point2, width) {
    var p1 = this.anchor();
    var p2 = segment.anchor();
    var angle = deg(Math.atan2(p2.y - p1.y, p2.x - p1.x));
    var rect = new rect_default([p1.x, p1.y - width / 2], [p1.distanceTo(p2), width]);
    return rect.containsPoint(point2.transformCopy(transform().rotate(-angle, p1)));
  };
  Segment2.prototype._isOnPathTo = function _isOnPathTo(segment, point2, width, endSegment) {
    var isOnPath;
    if (this.controlOut() && segment.controlIn()) {
      isOnPath = this._isOnCurveTo(segment, point2, width / 2, endSegment);
    } else {
      isOnPath = this._isOnLineTo(segment, point2, width);
    }
    return isOnPath;
  };
  return Segment2;
}(with_points_default(has_observers_default, points));
function arrayLimits(arr) {
  var length = arr.length;
  var min = MAX_NUM;
  var max = MIN_NUM;
  for (var i = 0; i < length; i++) {
    max = Math.max(max, arr[i]);
    min = Math.min(min, arr[i]);
  }
  return {
    min,
    max
  };
}
var segment_default = Segment;

// node_modules/@progress/kendo-drawing/dist/es/shapes/utils/points-to-curve.js
var WEIGHT = 0.333;
var EXTREMUM_ALLOWED_DEVIATION = 0.01;
var X = "x";
var Y = "y";
function pointsToCurve(pointsIn, closed) {
  var points3 = pointsIn.slice(0);
  var segments = [];
  var length = points3.length;
  if (length > 2) {
    removeDuplicates(0, points3);
    length = points3.length;
  }
  if (length < 2 || length === 2 && points3[0].equals(points3[1])) {
    return segments;
  }
  var p0 = points3[0];
  var p1 = points3[1];
  var p2 = points3[2];
  segments.push(new segment_default(p0));
  while (p0.equals(points3[length - 1])) {
    closed = true;
    points3.pop();
    length--;
  }
  if (length === 2) {
    var tangent = getTangent(p0, p1, X, Y);
    last(segments).controlOut(firstControlPoint(tangent, p0, p1, X, Y));
    segments.push(new segment_default(p1, secondControlPoint(tangent, p0, p1, X, Y)));
    return segments;
  }
  var initialControlPoint, lastControlPoint;
  if (closed) {
    p0 = points3[length - 1];
    p1 = points3[0];
    p2 = points3[1];
    var controlPoints = getControlPoints(p0, p1, p2);
    initialControlPoint = controlPoints[1];
    lastControlPoint = controlPoints[0];
  } else {
    var tangent$1 = getTangent(p0, p1, X, Y);
    initialControlPoint = firstControlPoint(tangent$1, p0, p1, X, Y);
  }
  var cp0 = initialControlPoint;
  for (var idx2 = 0; idx2 <= length - 3; idx2++) {
    removeDuplicates(idx2, points3);
    length = points3.length;
    if (idx2 + 3 <= length) {
      p0 = points3[idx2];
      p1 = points3[idx2 + 1];
      p2 = points3[idx2 + 2];
      var controlPoints$1 = getControlPoints(p0, p1, p2);
      last(segments).controlOut(cp0);
      cp0 = controlPoints$1[1];
      var cp1 = controlPoints$1[0];
      segments.push(new segment_default(p1, cp1));
    }
  }
  if (closed) {
    p0 = points3[length - 2];
    p1 = points3[length - 1];
    p2 = points3[0];
    var controlPoints$2 = getControlPoints(p0, p1, p2);
    last(segments).controlOut(cp0);
    segments.push(new segment_default(p1, controlPoints$2[0]));
    last(segments).controlOut(controlPoints$2[1]);
    segments.push(new segment_default(p2, lastControlPoint));
  } else {
    var tangent$2 = getTangent(p1, p2, X, Y);
    last(segments).controlOut(cp0);
    segments.push(new segment_default(p2, secondControlPoint(tangent$2, p1, p2, X, Y)));
  }
  return segments;
}
function removeDuplicates(idx2, points3) {
  while (points3[idx2 + 1] && (points3[idx2].equals(points3[idx2 + 1]) || points3[idx2 + 1].equals(points3[idx2 + 2]))) {
    points3.splice(idx2 + 1, 1);
  }
}
function invertAxis(p0, p1, p2) {
  var invertAxis2 = false;
  if (p0.x === p1.x) {
    invertAxis2 = true;
  } else if (p1.x === p2.x) {
    if (p1.y < p2.y && p0.y <= p1.y || p2.y < p1.y && p1.y <= p0.y) {
      invertAxis2 = true;
    }
  } else {
    var fn = lineFunction(p0, p1);
    var y2 = calculateFunction(fn, p2.x);
    if (!(p0.y <= p1.y && p2.y <= y2) && !(p1.y <= p0.y && p2.y >= y2)) {
      invertAxis2 = true;
    }
  }
  return invertAxis2;
}
function isLine(p0, p1, p2) {
  var fn = lineFunction(p0, p1);
  var y2 = calculateFunction(fn, p2.x);
  return p0.x === p1.x && p1.x === p2.x || round2(y2, 1) === round2(p2.y, 1);
}
function lineFunction(p1, p2) {
  var a = (p2.y - p1.y) / (p2.x - p1.x);
  var b = p1.y - a * p1.x;
  return [b, a];
}
function getControlPoints(p0, p1, p2) {
  var xField = X;
  var yField = Y;
  var restrict = false;
  var switchOrientation = false;
  var tangent;
  if (isLine(p0, p1, p2)) {
    tangent = getTangent(p0, p1, X, Y);
  } else {
    var monotonic = {
      x: isMonotonicByField(p0, p1, p2, X),
      y: isMonotonicByField(p0, p1, p2, Y)
    };
    if (monotonic.x && monotonic.y) {
      tangent = getTangent(p0, p2, X, Y);
      restrict = true;
    } else {
      if (invertAxis(p0, p1, p2)) {
        xField = Y;
        yField = X;
      }
      if (monotonic[xField]) {
        tangent = 0;
      } else {
        var sign;
        if (p2[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p2[yField] && p1[yField] <= p0[yField]) {
          sign = numberSign2((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));
        } else {
          sign = -numberSign2((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));
        }
        tangent = EXTREMUM_ALLOWED_DEVIATION * sign;
        switchOrientation = true;
      }
    }
  }
  var secondCP = secondControlPoint(tangent, p0, p1, xField, yField);
  if (switchOrientation) {
    var oldXField = xField;
    xField = yField;
    yField = oldXField;
  }
  var firstCP = firstControlPoint(tangent, p1, p2, xField, yField);
  if (restrict) {
    restrictControlPoint(p0, p1, secondCP, tangent);
    restrictControlPoint(p1, p2, firstCP, tangent);
  }
  return [secondCP, firstCP];
}
function restrictControlPoint(p1, p2, cp, tangent) {
  if (p1.y < p2.y) {
    if (p2.y < cp.y) {
      cp.x = p1.x + (p2.y - p1.y) / tangent;
      cp.y = p2.y;
    } else if (cp.y < p1.y) {
      cp.x = p2.x - (p2.y - p1.y) / tangent;
      cp.y = p1.y;
    }
  } else {
    if (cp.y < p2.y) {
      cp.x = p1.x - (p1.y - p2.y) / tangent;
      cp.y = p2.y;
    } else if (p1.y < cp.y) {
      cp.x = p2.x + (p1.y - p2.y) / tangent;
      cp.y = p1.y;
    }
  }
}
function getTangent(p0, p1, xField, yField) {
  var x = p1[xField] - p0[xField];
  var y = p1[yField] - p0[yField];
  var tangent;
  if (x === 0) {
    tangent = 0;
  } else {
    tangent = y / x;
  }
  return tangent;
}
function isMonotonicByField(p0, p1, p2, field) {
  return p2[field] > p1[field] && p1[field] > p0[field] || p2[field] < p1[field] && p1[field] < p0[field];
}
function firstControlPoint(tangent, p0, p3, xField, yField) {
  var t1 = p0[xField];
  var t2 = p3[xField];
  var distance = (t2 - t1) * WEIGHT;
  return point(t1 + distance, p0[yField] + distance * tangent, xField, yField);
}
function secondControlPoint(tangent, p0, p3, xField, yField) {
  var t1 = p0[xField];
  var t2 = p3[xField];
  var distance = (t2 - t1) * WEIGHT;
  return point(t2 - distance, p3[yField] - distance * tangent, xField, yField);
}
function point(xValue, yValue, xField, yField) {
  var controlPoint2 = new point_default();
  controlPoint2[xField] = xValue;
  controlPoint2[yField] = yValue;
  return controlPoint2;
}
function calculateFunction(fn, x) {
  var length = fn.length;
  var result = 0;
  for (var i = 0; i < length; i++) {
    result += Math.pow(x, i) * fn[i];
  }
  return result;
}
function numberSign2(value) {
  return value <= 0 ? -1 : 1;
}

// node_modules/@progress/kendo-drawing/dist/es/parsing/shape-map.js
var ShapeMap = {
  l: function(path, options2) {
    var parameters = options2.parameters;
    var position = options2.position;
    for (var i = 0; i < parameters.length; i += 2) {
      var point2 = new point_default(parameters[i], parameters[i + 1]);
      if (options2.isRelative) {
        point2.translateWith(position);
      }
      path.lineTo(point2.x, point2.y);
      position.x = point2.x;
      position.y = point2.y;
    }
  },
  c: function(path, options2) {
    var parameters = options2.parameters;
    var position = options2.position;
    for (var i = 0; i < parameters.length; i += 6) {
      var controlOut = new point_default(parameters[i], parameters[i + 1]);
      var controlIn = new point_default(parameters[i + 2], parameters[i + 3]);
      var point2 = new point_default(parameters[i + 4], parameters[i + 5]);
      if (options2.isRelative) {
        controlIn.translateWith(position);
        controlOut.translateWith(position);
        point2.translateWith(position);
      }
      path.curveTo(controlOut, controlIn, point2);
      position.x = point2.x;
      position.y = point2.y;
    }
  },
  v: function(path, options2) {
    var value = options2.isRelative ? 0 : options2.position.x;
    toLineParamaters(options2.parameters, true, value);
    this.l(path, options2);
  },
  h: function(path, options2) {
    var value = options2.isRelative ? 0 : options2.position.y;
    toLineParamaters(options2.parameters, false, value);
    this.l(path, options2);
  },
  a: function(path, options2) {
    var parameters = options2.parameters;
    var position = options2.position;
    for (var i = 0; i < parameters.length; i += 7) {
      var radiusX = parameters[i];
      var radiusY = parameters[i + 1];
      var rotation = parameters[i + 2];
      var largeArc = parameters[i + 3];
      var swipe = parameters[i + 4];
      var endPoint = new point_default(parameters[i + 5], parameters[i + 6]);
      if (options2.isRelative) {
        endPoint.translateWith(position);
      }
      if (position.x !== endPoint.x || position.y !== endPoint.y) {
        path.arcTo(endPoint, radiusX, radiusY, largeArc, swipe, rotation);
        position.x = endPoint.x;
        position.y = endPoint.y;
      }
    }
  },
  s: function(path, options2) {
    var parameters = options2.parameters;
    var position = options2.position;
    var previousCommand = options2.previousCommand;
    var lastControlIn;
    if (previousCommand === "s" || previousCommand === "c") {
      lastControlIn = last(last(path.paths).segments).controlIn();
    }
    for (var i = 0; i < parameters.length; i += 4) {
      var controlIn = new point_default(parameters[i], parameters[i + 1]);
      var endPoint = new point_default(parameters[i + 2], parameters[i + 3]);
      var controlOut = void 0;
      if (options2.isRelative) {
        controlIn.translateWith(position);
        endPoint.translateWith(position);
      }
      if (lastControlIn) {
        controlOut = reflectionPoint(lastControlIn, position);
      } else {
        controlOut = position.clone();
      }
      lastControlIn = controlIn;
      path.curveTo(controlOut, controlIn, endPoint);
      position.x = endPoint.x;
      position.y = endPoint.y;
    }
  },
  q: function(path, options2) {
    var parameters = options2.parameters;
    var position = options2.position;
    for (var i = 0; i < parameters.length; i += 4) {
      var controlPoint2 = new point_default(parameters[i], parameters[i + 1]);
      var endPoint = new point_default(parameters[i + 2], parameters[i + 3]);
      if (options2.isRelative) {
        controlPoint2.translateWith(position);
        endPoint.translateWith(position);
      }
      var cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint2, endPoint);
      path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);
      position.x = endPoint.x;
      position.y = endPoint.y;
    }
  },
  t: function(path, options2) {
    var parameters = options2.parameters;
    var position = options2.position;
    var previousCommand = options2.previousCommand;
    var controlPoint2;
    if (previousCommand === "q" || previousCommand === "t") {
      var lastSegment = last(last(path.paths).segments);
      controlPoint2 = lastSegment.controlIn().clone().translateWith(position.scaleCopy(-1 / 3)).scale(3 / 2);
    }
    for (var i = 0; i < parameters.length; i += 2) {
      var endPoint = new point_default(parameters[i], parameters[i + 1]);
      if (options2.isRelative) {
        endPoint.translateWith(position);
      }
      if (controlPoint2) {
        controlPoint2 = reflectionPoint(controlPoint2, position);
      } else {
        controlPoint2 = position.clone();
      }
      var cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint2, endPoint);
      path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);
      position.x = endPoint.x;
      position.y = endPoint.y;
    }
  }
};
function toLineParamaters(parameters, isVertical, value) {
  var insertPosition = isVertical ? 0 : 1;
  for (var i = 0; i < parameters.length; i += 2) {
    parameters.splice(i + insertPosition, 0, value);
  }
}
function reflectionPoint(point2, center) {
  if (point2 && center) {
    return center.scaleCopy(2).translate(-point2.x, -point2.y);
  }
}
var third = 1 / 3;
function quadraticToCubicControlPoints(position, controlPoint2, endPoint) {
  var scaledPoint = controlPoint2.clone().scale(2 / 3);
  return {
    controlOut: scaledPoint.clone().translateWith(position.scaleCopy(third)),
    controlIn: scaledPoint.translateWith(endPoint.scaleCopy(third))
  };
}
var shape_map_default = ShapeMap;

// node_modules/@progress/kendo-drawing/dist/es/parsing/parse-path.js
var SEGMENT_REGEX = /([a-df-z]{1})([^a-df-z]*)(z)?/gi;
var SPLIT_REGEX = /[,\s]?([+\-]?(?:\d*\.\d+|\d+)(?:[eE][+\-]?\d+)?)/g;
var MOVE = "m";
var CLOSE = "z";
function parseParameters(str) {
  var parameters = [];
  str.replace(SPLIT_REGEX, function(match2, number) {
    parameters.push(parseFloat(number));
  });
  return parameters;
}
function parsePath(pathInstance, str) {
  var position = new point_default();
  var previousCommand;
  str.replace(SEGMENT_REGEX, function(match2, element, params, closePath) {
    var command = element.toLowerCase();
    var isRelative = command === element;
    var parameters = parseParameters(params.trim());
    if (command === MOVE) {
      if (isRelative) {
        position.x += parameters[0];
        position.y += parameters[1];
      } else {
        position.x = parameters[0];
        position.y = parameters[1];
      }
      pathInstance.moveTo(position.x, position.y);
      if (parameters.length > 2) {
        command = "l";
        parameters.splice(0, 2);
      }
    }
    if (shape_map_default[command]) {
      shape_map_default[command](pathInstance, {
        parameters,
        position,
        isRelative,
        previousCommand
      });
      if (closePath && closePath.toLowerCase() === CLOSE) {
        pathInstance.close();
      }
    } else if (command !== MOVE) {
      throw new Error("Error while parsing SVG path. Unsupported command: " + command);
    }
    previousCommand = command;
  });
  return pathInstance;
}
var parse_path_default = parsePath;

// node_modules/@progress/kendo-drawing/dist/es/shapes/utils/elements-bounding-box.js
function elementsBoundingBox(elements, applyTransform, transformation) {
  var boundingBox;
  for (var i = 0; i < elements.length; i++) {
    var element = elements[i];
    if (element.visible()) {
      var elementBoundingBox = applyTransform ? element.bbox(transformation) : element.rawBBox();
      if (elementBoundingBox) {
        if (boundingBox) {
          boundingBox = rect_default.union(boundingBox, elementBoundingBox);
        } else {
          boundingBox = elementBoundingBox;
        }
      }
    }
  }
  return boundingBox;
}

// node_modules/@progress/kendo-drawing/dist/es/shapes/utils/elements-clippend-bounding-box.js
function elementsClippedBoundingBox(elements, transformation) {
  var boundingBox;
  for (var i = 0; i < elements.length; i++) {
    var element = elements[i];
    if (element.visible()) {
      var elementBoundingBox = element.clippedBBox(transformation);
      if (elementBoundingBox) {
        if (boundingBox) {
          boundingBox = rect_default.union(boundingBox, elementBoundingBox);
        } else {
          boundingBox = elementBoundingBox;
        }
      }
    }
  }
  return boundingBox;
}

// node_modules/@progress/kendo-drawing/dist/es/shapes/path.js
var SPACE2 = " ";
var printPoints = function(precision) {
  return function() {
    var points3 = [], len = arguments.length;
    while (len--) points3[len] = arguments[len];
    return points3.map(function(p) {
      return p.toString(precision);
    }).join(SPACE2);
    ;
  };
};
var segmentType = function(segmentStart, segmentEnd) {
  return segmentStart.controlOut() && segmentEnd.controlIn() ? "C" : "L";
};
var Path = function(superclass) {
  function Path2(options2) {
    superclass.call(this, options2);
    this.segments = new geometry_elements_array_default();
    this.segments.addObserver(this);
    if (!defined(this.options.stroke)) {
      this.stroke("#000");
      if (!defined(this.options.stroke.lineJoin)) {
        this.options.set("stroke.lineJoin", "miter");
      }
    }
  }
  if (superclass) Path2.__proto__ = superclass;
  Path2.prototype = Object.create(superclass && superclass.prototype);
  Path2.prototype.constructor = Path2;
  var prototypeAccessors = {
    nodeType: {
      configurable: true
    }
  };
  prototypeAccessors.nodeType.get = function() {
    return "Path";
  };
  Path2.prototype.moveTo = function moveTo(x, y) {
    this.suspend();
    this.segments.elements([]);
    this.resume();
    this.lineTo(x, y);
    return this;
  };
  Path2.prototype.lineTo = function lineTo(x, y) {
    var point2 = defined(y) ? new point_default(x, y) : x;
    var segment = new segment_default(point2);
    this.segments.push(segment);
    return this;
  };
  Path2.prototype.curveTo = function curveTo(controlOut, controlIn, point2) {
    if (this.segments.length > 0) {
      var lastSegment = last(this.segments);
      var segment = new segment_default(point2, controlIn);
      this.suspend();
      lastSegment.controlOut(controlOut);
      this.resume();
      this.segments.push(segment);
    }
    return this;
  };
  Path2.prototype.arc = function arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {
    if (this.segments.length > 0) {
      var lastSegment = last(this.segments);
      var anchor = lastSegment.anchor();
      var start = rad(startAngle);
      var center = new point_default(anchor.x - radiusX * Math.cos(start), anchor.y - radiusY * Math.sin(start));
      var arc2 = new arc_default(center, {
        startAngle,
        endAngle,
        radiusX,
        radiusY,
        anticlockwise
      });
      this._addArcSegments(arc2);
    }
    return this;
  };
  Path2.prototype.arcTo = function arcTo(end, rx, ry, largeArc, swipe, rotation) {
    if (this.segments.length > 0) {
      var lastSegment = last(this.segments);
      var anchor = lastSegment.anchor();
      var arc = arc_default.fromPoints(anchor, point_default.create(end), rx, ry, largeArc, swipe, rotation);
      this._addArcSegments(arc);
    }
    return this;
  };
  Path2.prototype._addArcSegments = function _addArcSegments(arc) {
    var this$1 = this;
    this.suspend();
    var curvePoints = arc.curvePoints();
    for (var i = 1; i < curvePoints.length; i += 3) {
      this$1.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);
    }
    this.resume();
    this.geometryChange();
  };
  Path2.prototype.close = function close2() {
    this.options.closed = true;
    this.geometryChange();
    return this;
  };
  Path2.prototype.rawBBox = function rawBBox() {
    return this._bbox();
  };
  Path2.prototype.toString = function toString5(digits) {
    var output = "";
    var segments = this.segments;
    var length = segments.length;
    if (length > 0) {
      var parts = [];
      var print = printPoints(digits);
      var currentType;
      for (var i = 1; i < length; i++) {
        var type = segmentType(segments[i - 1], segments[i]);
        if (type !== currentType) {
          currentType = type;
          parts.push(type);
        }
        if (type === "L") {
          parts.push(print(segments[i].anchor()));
        } else {
          parts.push(print(segments[i - 1].controlOut(), segments[i].controlIn(), segments[i].anchor()));
        }
      }
      output = "M" + print(segments[0].anchor()) + SPACE2 + parts.join(SPACE2);
      if (this.options.closed) {
        output += "Z";
      }
    }
    return output;
  };
  Path2.prototype._containsPoint = function _containsPoint(point2) {
    var segments = this.segments;
    var length = segments.length;
    var intersectionsCount = 0;
    var previous, current;
    for (var idx2 = 1; idx2 < length; idx2++) {
      previous = segments[idx2 - 1];
      current = segments[idx2];
      intersectionsCount += previous._intersectionsTo(current, point2);
    }
    if (this.options.closed || !segments[0].anchor().equals(segments[length - 1].anchor())) {
      intersectionsCount += lineIntersectionsCount(segments[0].anchor(), segments[length - 1].anchor(), point2);
    }
    return intersectionsCount % 2 !== 0;
  };
  Path2.prototype._isOnPath = function _isOnPath(point2, width) {
    var segments = this.segments;
    var length = segments.length;
    var pathWidth = width || this.options.stroke.width;
    if (length > 1) {
      if (segments[0]._isOnPathTo(segments[1], point2, pathWidth, "start")) {
        return true;
      }
      for (var idx2 = 2; idx2 <= length - 2; idx2++) {
        if (segments[idx2 - 1]._isOnPathTo(segments[idx2], point2, pathWidth)) {
          return true;
        }
      }
      if (segments[length - 2]._isOnPathTo(segments[length - 1], point2, pathWidth, "end")) {
        return true;
      }
    }
    return false;
  };
  Path2.prototype._bbox = function _bbox(matrix) {
    var segments = this.segments;
    var length = segments.length;
    var boundingBox;
    if (length === 1) {
      var anchor = segments[0].anchor().transformCopy(matrix);
      boundingBox = new rect_default(anchor, size_default.ZERO);
    } else if (length > 0) {
      for (var i = 1; i < length; i++) {
        var segmentBox = segments[i - 1].bboxTo(segments[i], matrix);
        if (boundingBox) {
          boundingBox = rect_default.union(boundingBox, segmentBox);
        } else {
          boundingBox = segmentBox;
        }
      }
    }
    return boundingBox;
  };
  Path2.parse = function parse3(str, options2) {
    return MultiPath.parse(str, options2);
  };
  Path2.fromRect = function fromRect(rect, options2) {
    var path = new Path2(options2);
    var ref = rect.cornerRadius;
    var rx = ref[0];
    var ry = ref[1];
    if (rx === 0 && ry === 0) {
      path.moveTo(rect.topLeft()).lineTo(rect.topRight()).lineTo(rect.bottomRight()).lineTo(rect.bottomLeft()).close();
    } else {
      var origin = rect.origin;
      var x = origin.x;
      var y = origin.y;
      var width = rect.width();
      var height = rect.height();
      rx = limitValue(rx, 0, width / 2);
      ry = limitValue(ry, 0, height / 2);
      path.moveTo(x + rx, y).lineTo(x + width - rx, y).arcTo([x + width, y + ry], rx, ry, false).lineTo(x + width, y + height - ry).arcTo([x + width - rx, y + height], rx, ry, false).lineTo(x + rx, y + height).arcTo([x, y + height - ry], rx, ry, false).lineTo(x, y + ry).arcTo([x + rx, y], rx, ry, false);
    }
    return path;
  };
  Path2.fromPoints = function fromPoints(points3, options2) {
    if (points3) {
      var path = new Path2(options2);
      for (var i = 0; i < points3.length; i++) {
        var point2 = point_default.create(points3[i]);
        if (point2) {
          if (i === 0) {
            path.moveTo(point2);
          } else {
            path.lineTo(point2);
          }
        }
      }
      return path;
    }
  };
  Path2.curveFromPoints = function curveFromPoints(points3, options2) {
    if (points3) {
      var segments = pointsToCurve(points3);
      var path = new Path2(options2);
      path.segments.push.apply(path.segments, segments);
      return path;
    }
  };
  Path2.fromArc = function fromArc(arc, options2) {
    var path = new Path2(options2);
    var startAngle = arc.startAngle;
    var start = arc.pointAt(startAngle);
    path.moveTo(start.x, start.y);
    path.arc(startAngle, arc.endAngle, arc.radiusX, arc.radiusY, arc.anticlockwise);
    return path;
  };
  Object.defineProperties(Path2.prototype, prototypeAccessors);
  return Path2;
}(paintable_default(measurable_default(element_default)));
var MultiPath = function(superclass) {
  function MultiPath2(options2) {
    superclass.call(this, options2);
    this.paths = new geometry_elements_array_default();
    this.paths.addObserver(this);
    if (!defined(this.options.stroke)) {
      this.stroke("#000");
    }
  }
  if (superclass) MultiPath2.__proto__ = superclass;
  MultiPath2.prototype = Object.create(superclass && superclass.prototype);
  MultiPath2.prototype.constructor = MultiPath2;
  var prototypeAccessors$1 = {
    nodeType: {
      configurable: true
    }
  };
  MultiPath2.parse = function parse3(str, options2) {
    var instance4 = new MultiPath2(options2);
    return parse_path_default(instance4, str);
  };
  MultiPath2.prototype.toString = function toString5(digits) {
    var paths = this.paths;
    var output = "";
    if (paths.length > 0) {
      var result = [];
      for (var i = 0; i < paths.length; i++) {
        result.push(paths[i].toString(digits));
      }
      output = result.join(SPACE2);
    }
    return output;
  };
  prototypeAccessors$1.nodeType.get = function() {
    return "MultiPath";
  };
  MultiPath2.prototype.moveTo = function moveTo(x, y) {
    var path = new Path();
    path.moveTo(x, y);
    this.paths.push(path);
    return this;
  };
  MultiPath2.prototype.lineTo = function lineTo(x, y) {
    if (this.paths.length > 0) {
      last(this.paths).lineTo(x, y);
    }
    return this;
  };
  MultiPath2.prototype.curveTo = function curveTo(controlOut, controlIn, point2) {
    if (this.paths.length > 0) {
      last(this.paths).curveTo(controlOut, controlIn, point2);
    }
    return this;
  };
  MultiPath2.prototype.arc = function arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {
    if (this.paths.length > 0) {
      last(this.paths).arc(startAngle, endAngle, radiusX, radiusY, anticlockwise);
    }
    return this;
  };
  MultiPath2.prototype.arcTo = function arcTo(end, rx, ry, largeArc, swipe, rotation) {
    if (this.paths.length > 0) {
      last(this.paths).arcTo(end, rx, ry, largeArc, swipe, rotation);
    }
    return this;
  };
  MultiPath2.prototype.close = function close2() {
    if (this.paths.length > 0) {
      last(this.paths).close();
    }
    return this;
  };
  MultiPath2.prototype._bbox = function _bbox(matrix) {
    return elementsBoundingBox(this.paths, true, matrix);
  };
  MultiPath2.prototype.rawBBox = function rawBBox() {
    return elementsBoundingBox(this.paths, false);
  };
  MultiPath2.prototype._containsPoint = function _containsPoint(point2) {
    var paths = this.paths;
    for (var idx2 = 0; idx2 < paths.length; idx2++) {
      if (paths[idx2]._containsPoint(point2)) {
        return true;
      }
    }
    return false;
  };
  MultiPath2.prototype._isOnPath = function _isOnPath(point2) {
    var paths = this.paths;
    var width = this.options.stroke.width;
    for (var idx2 = 0; idx2 < paths.length; idx2++) {
      if (paths[idx2]._isOnPath(point2, width)) {
        return true;
      }
    }
    return false;
  };
  MultiPath2.prototype._clippedBBox = function _clippedBBox(transformation) {
    return elementsClippedBoundingBox(this.paths, this.currentTransform(transformation));
  };
  Object.defineProperties(MultiPath2.prototype, prototypeAccessors$1);
  return MultiPath2;
}(paintable_default(measurable_default(element_default)));

// node_modules/@progress/kendo-drawing/dist/es/shapes/arc.js
var DEFAULT_STROKE2 = "#000";
var Arc2 = function(superclass) {
  function Arc3(geometry, options2) {
    if (geometry === void 0) geometry = new arc_default();
    if (options2 === void 0) options2 = {};
    superclass.call(this, options2);
    this.geometry(geometry);
    if (!defined(this.options.stroke)) {
      this.stroke(DEFAULT_STROKE2);
    }
  }
  if (superclass) Arc3.__proto__ = superclass;
  Arc3.prototype = Object.create(superclass && superclass.prototype);
  Arc3.prototype.constructor = Arc3;
  var prototypeAccessors = {
    nodeType: {
      configurable: true
    }
  };
  prototypeAccessors.nodeType.get = function() {
    return "Arc";
  };
  Arc3.prototype._bbox = function _bbox(matrix) {
    return this._geometry.bbox(matrix);
  };
  Arc3.prototype.rawBBox = function rawBBox() {
    return this.geometry().bbox();
  };
  Arc3.prototype.toPath = function toPath() {
    var path = new Path();
    var curvePoints = this.geometry().curvePoints();
    if (curvePoints.length > 0) {
      path.moveTo(curvePoints[0].x, curvePoints[0].y);
      for (var i = 1; i < curvePoints.length; i += 3) {
        path.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);
      }
    }
    return path;
  };
  Arc3.prototype._containsPoint = function _containsPoint(point2) {
    return this.geometry().containsPoint(point2);
  };
  Arc3.prototype._isOnPath = function _isOnPath(point2) {
    return this.geometry()._isOnPath(point2, this.options.stroke.width / 2);
  };
  Object.defineProperties(Arc3.prototype, prototypeAccessors);
  return Arc3;
}(paintable_default(measurable_default(with_geometry_default(element_default))));
var arc_default2 = Arc2;

// node_modules/@progress/kendo-drawing/dist/es/shapes/text.js
var DEFAULT_FONT = "12px sans-serif";
var DEFAULT_FILL = "#000";
var Text = function(superclass) {
  function Text2(content, position, options2) {
    if (position === void 0) position = new point_default();
    if (options2 === void 0) options2 = {};
    superclass.call(this, options2);
    this.content(content);
    this.position(position);
    if (!this.options.font) {
      this.options.font = DEFAULT_FONT;
    }
    if (!defined(this.options.fill)) {
      this.fill(DEFAULT_FILL);
    }
  }
  if (superclass) Text2.__proto__ = superclass;
  Text2.prototype = Object.create(superclass && superclass.prototype);
  Text2.prototype.constructor = Text2;
  var prototypeAccessors = {
    nodeType: {
      configurable: true
    }
  };
  prototypeAccessors.nodeType.get = function() {
    return "Text";
  };
  Text2.prototype.content = function content(value) {
    if (defined(value)) {
      this.options.set("content", value);
      return this;
    }
    return this.options.get("content");
  };
  Text2.prototype.measure = function measure() {
    var metrics = measureText(this.content(), {
      font: this.options.get("font")
    });
    return metrics;
  };
  Text2.prototype.rect = function rect() {
    var size = this.measure();
    var pos = this.position().clone();
    return new rect_default(pos, [size.width, size.height]);
  };
  Text2.prototype.bbox = function bbox(transformation) {
    var combinedMatrix = toMatrix(this.currentTransform(transformation));
    return this.rect().bbox(combinedMatrix);
  };
  Text2.prototype.rawBBox = function rawBBox() {
    return this.rect().bbox();
  };
  Text2.prototype._containsPoint = function _containsPoint(point2) {
    return this.rect().containsPoint(point2);
  };
  Object.defineProperties(Text2.prototype, prototypeAccessors);
  return Text2;
}(paintable_default(with_points_default(element_default, ["position"])));
var text_default = Text;

// node_modules/@progress/kendo-drawing/dist/es/shapes/image.js
var Image2 = function(superclass) {
  function Image3(src, rect, options2) {
    if (rect === void 0) rect = new rect_default();
    if (options2 === void 0) options2 = {};
    superclass.call(this, options2);
    this.src(src);
    this.rect(rect);
  }
  if (superclass) Image3.__proto__ = superclass;
  Image3.prototype = Object.create(superclass && superclass.prototype);
  Image3.prototype.constructor = Image3;
  var prototypeAccessors = {
    nodeType: {
      configurable: true
    }
  };
  prototypeAccessors.nodeType.get = function() {
    return "Image";
  };
  Image3.prototype.src = function src(value) {
    if (defined(value)) {
      this.options.set("src", value);
      return this;
    }
    return this.options.get("src");
  };
  Image3.prototype.bbox = function bbox(transformation) {
    var combinedMatrix = toMatrix(this.currentTransform(transformation));
    return this._rect.bbox(combinedMatrix);
  };
  Image3.prototype.rawBBox = function rawBBox() {
    return this._rect.bbox();
  };
  Image3.prototype._containsPoint = function _containsPoint(point2) {
    return this._rect.containsPoint(point2);
  };
  Image3.prototype._hasFill = function _hasFill() {
    return this.src();
  };
  Object.defineProperties(Image3.prototype, prototypeAccessors);
  return Image3;
}(with_geometry_default(element_default, ["rect"]));
var image_default = Image2;

// node_modules/@progress/kendo-drawing/dist/es/mixins/traversable.js
var traversable = function(TBase, childrenField) {
  return function(TBase2) {
    function anonymous() {
      TBase2.apply(this, arguments);
    }
    if (TBase2) anonymous.__proto__ = TBase2;
    anonymous.prototype = Object.create(TBase2 && TBase2.prototype);
    anonymous.prototype.constructor = anonymous;
    anonymous.prototype.traverse = function traverse(callback) {
      var children = this[childrenField];
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (child.traverse) {
          child.traverse(callback);
        } else {
          callback(child);
        }
      }
      return this;
    };
    return anonymous;
  }(TBase);
};
var traversable_default = traversable;

// node_modules/@progress/kendo-drawing/dist/es/shapes/group.js
var Group = function(superclass) {
  function Group2(options2) {
    superclass.call(this, options2);
    this.children = [];
  }
  if (superclass) Group2.__proto__ = superclass;
  Group2.prototype = Object.create(superclass && superclass.prototype);
  Group2.prototype.constructor = Group2;
  var prototypeAccessors = {
    nodeType: {
      configurable: true
    }
  };
  prototypeAccessors.nodeType.get = function() {
    return "Group";
  };
  Group2.prototype.childrenChange = function childrenChange(action, items, index) {
    this.trigger("childrenChange", {
      action,
      items,
      index
    });
  };
  Group2.prototype.append = function append$1() {
    append(this.children, arguments);
    this._reparent(arguments, this);
    this.childrenChange("add", arguments);
    return this;
  };
  Group2.prototype.insert = function insert(index, element) {
    this.children.splice(index, 0, element);
    element.parent = this;
    this.childrenChange("add", [element], index);
    return this;
  };
  Group2.prototype.insertAt = function insertAt(element, index) {
    return this.insert(index, element);
  };
  Group2.prototype.remove = function remove(element) {
    var index = this.children.indexOf(element);
    if (index >= 0) {
      this.children.splice(index, 1);
      element.parent = null;
      this.childrenChange("remove", [element], index);
    }
    return this;
  };
  Group2.prototype.removeAt = function removeAt(index) {
    if (0 <= index && index < this.children.length) {
      var element = this.children[index];
      this.children.splice(index, 1);
      element.parent = null;
      this.childrenChange("remove", [element], index);
    }
    return this;
  };
  Group2.prototype.clear = function clear2() {
    var items = this.children;
    this.children = [];
    this._reparent(items, null);
    this.childrenChange("remove", items, 0);
    return this;
  };
  Group2.prototype.bbox = function bbox(transformation) {
    return elementsBoundingBox(this.children, true, this.currentTransform(transformation));
  };
  Group2.prototype.rawBBox = function rawBBox() {
    return elementsBoundingBox(this.children, false);
  };
  Group2.prototype._clippedBBox = function _clippedBBox(transformation) {
    return elementsClippedBoundingBox(this.children, this.currentTransform(transformation));
  };
  Group2.prototype.currentTransform = function currentTransform(transformation) {
    return element_default.prototype.currentTransform.call(this, transformation) || null;
  };
  Group2.prototype.containsPoint = function containsPoint(point2, parentTransform) {
    if (this.visible()) {
      var children = this.children;
      var transform3 = this.currentTransform(parentTransform);
      for (var idx2 = 0; idx2 < children.length; idx2++) {
        if (children[idx2].containsPoint(point2, transform3)) {
          return true;
        }
      }
    }
    return false;
  };
  Group2.prototype._reparent = function _reparent(elements, newParent) {
    var this$1 = this;
    for (var i = 0; i < elements.length; i++) {
      var child = elements[i];
      var parent = child.parent;
      if (parent && parent !== this$1 && parent.remove) {
        parent.remove(child);
      }
      child.parent = newParent;
    }
  };
  Object.defineProperties(Group2.prototype, prototypeAccessors);
  return Group2;
}(traversable_default(element_default, "children"));
var group_default = Group;

// node_modules/@progress/kendo-drawing/dist/es/alignment/translate-to-point.js
function translateToPoint(point2, bbox, element) {
  var transofrm = element.transform() || transform();
  var matrix = transofrm.matrix();
  matrix.e += point2.x - bbox.origin.x;
  matrix.f += point2.y - bbox.origin.y;
  transofrm.matrix(matrix);
  element.transform(transofrm);
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/align-start.js
function alignStart(size, rect, align2, axis, sizeField) {
  var start;
  if (align2 === "start") {
    start = rect.origin[axis];
  } else if (align2 === "end") {
    start = rect.origin[axis] + rect.size[sizeField] - size;
  } else {
    start = rect.origin[axis] + (rect.size[sizeField] - size) / 2;
  }
  return start;
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/align-start-reverse.js
function alignStartReverse(size, rect, align2, axis, sizeField) {
  var start;
  if (align2 === "start") {
    start = rect.origin[axis] + rect.size[sizeField] - size;
  } else if (align2 === "end") {
    start = rect.origin[axis];
  } else {
    start = rect.origin[axis] + (rect.size[sizeField] - size) / 2;
  }
  return start;
}

// node_modules/@progress/kendo-drawing/dist/es/shapes/layout.js
var DEFAULT_OPTIONS2 = {
  alignContent: "start",
  justifyContent: "start",
  alignItems: "start",
  spacing: 0,
  orientation: "horizontal",
  lineSpacing: 0,
  wrap: true,
  revers: false
};
var forEach = function(elements, callback) {
  elements.forEach(callback);
};
var forEachReverse = function(elements, callback) {
  var length = elements.length;
  for (var idx2 = length - 1; idx2 >= 0; idx2--) {
    callback(elements[idx2], idx2);
  }
};
var Layout = function(Group2) {
  function Layout2(rect, options2) {
    Group2.call(this, Object.assign({}, DEFAULT_OPTIONS2, options2));
    this._rect = rect;
    this._fieldMap = {};
  }
  if (Group2) Layout2.__proto__ = Group2;
  Layout2.prototype = Object.create(Group2 && Group2.prototype);
  Layout2.prototype.constructor = Layout2;
  Layout2.prototype.rect = function rect(value) {
    if (value) {
      this._rect = value;
      return this;
    }
    return this._rect;
  };
  Layout2.prototype._initMap = function _initMap() {
    var options2 = this.options;
    var fieldMap = this._fieldMap;
    if (options2.orientation === "horizontal") {
      fieldMap.sizeField = "width";
      fieldMap.groupsSizeField = "height";
      fieldMap.groupAxis = "x";
      fieldMap.groupsAxis = "y";
    } else {
      fieldMap.sizeField = "height";
      fieldMap.groupsSizeField = "width";
      fieldMap.groupAxis = "y";
      fieldMap.groupsAxis = "x";
    }
    if (options2.reverse) {
      this.forEach = forEachReverse;
      this.justifyAlign = alignStartReverse;
    } else {
      this.forEach = forEach;
      this.justifyAlign = alignStart;
    }
  };
  Layout2.prototype.reflow = function reflow() {
    var this$1 = this;
    if (!this._rect || this.children.length === 0) {
      return;
    }
    this._initMap();
    if (this.options.transform) {
      this.transform(null);
    }
    var options2 = this.options;
    var rect = this._rect;
    var ref = this._initGroups();
    var groups = ref.groups;
    var groupsSize = ref.groupsSize;
    var ref$1 = this._fieldMap;
    var sizeField = ref$1.sizeField;
    var groupsSizeField = ref$1.groupsSizeField;
    var groupAxis = ref$1.groupAxis;
    var groupsAxis = ref$1.groupsAxis;
    var groupOrigin = new point_default();
    var elementOrigin = new point_default();
    var size = new size_default();
    var groupStart = alignStart(groupsSize, rect, options2.alignContent, groupsAxis, groupsSizeField);
    var elementStart, group, groupBox;
    var arrangeElements = function(bbox, idx2) {
      var element = group.elements[idx2];
      elementOrigin[groupAxis] = elementStart;
      elementOrigin[groupsAxis] = alignStart(bbox.size[groupsSizeField], groupBox, options2.alignItems, groupsAxis, groupsSizeField);
      translateToPoint(elementOrigin, bbox, element);
      elementStart += bbox.size[sizeField] + options2.spacing;
    };
    for (var groupIdx = 0; groupIdx < groups.length; groupIdx++) {
      group = groups[groupIdx];
      groupOrigin[groupAxis] = elementStart = this$1.justifyAlign(group.size, rect, options2.justifyContent, groupAxis, sizeField);
      groupOrigin[groupsAxis] = groupStart;
      size[sizeField] = group.size;
      size[groupsSizeField] = group.lineSize;
      groupBox = new rect_default(groupOrigin, size);
      this$1.forEach(group.bboxes, arrangeElements);
      groupStart += group.lineSize + options2.lineSpacing;
    }
    if (!options2.wrap && group.size > rect.size[sizeField]) {
      var scale = rect.size[sizeField] / groupBox.size[sizeField];
      var scaledStart = groupBox.topLeft().scale(scale, scale);
      var scaledSize = groupBox.size[groupsSizeField] * scale;
      var newStart = alignStart(scaledSize, rect, options2.alignContent, groupsAxis, groupsSizeField);
      var transform3 = transform();
      if (groupAxis === "x") {
        transform3.translate(rect.origin.x - scaledStart.x, newStart - scaledStart.y);
      } else {
        transform3.translate(newStart - scaledStart.x, rect.origin.y - scaledStart.y);
      }
      transform3.scale(scale, scale);
      this.transform(transform3);
    }
  };
  Layout2.prototype._initGroups = function _initGroups() {
    var this$1 = this;
    var ref = this;
    var options2 = ref.options;
    var children = ref.children;
    var lineSpacing = options2.lineSpacing;
    var wrap2 = options2.wrap;
    var spacing = options2.spacing;
    var sizeField = this._fieldMap.sizeField;
    var group = this._newGroup();
    var groups = [];
    var addGroup = function() {
      groups.push(group);
      groupsSize += group.lineSize + lineSpacing;
    };
    var groupsSize = -lineSpacing;
    for (var idx2 = 0; idx2 < children.length; idx2++) {
      var element = children[idx2];
      var bbox = children[idx2].clippedBBox();
      if (element.visible() && bbox) {
        if (wrap2 && group.size + bbox.size[sizeField] + spacing > this$1._rect.size[sizeField]) {
          if (group.bboxes.length === 0) {
            this$1._addToGroup(group, bbox, element);
            addGroup();
            group = this$1._newGroup();
          } else {
            addGroup();
            group = this$1._newGroup();
            this$1._addToGroup(group, bbox, element);
          }
        } else {
          this$1._addToGroup(group, bbox, element);
        }
      }
    }
    if (group.bboxes.length) {
      addGroup();
    }
    return {
      groups,
      groupsSize
    };
  };
  Layout2.prototype._addToGroup = function _addToGroup(group, bbox, element) {
    group.size += bbox.size[this._fieldMap.sizeField] + this.options.spacing;
    group.lineSize = Math.max(bbox.size[this._fieldMap.groupsSizeField], group.lineSize);
    group.bboxes.push(bbox);
    group.elements.push(element);
  };
  Layout2.prototype._newGroup = function _newGroup() {
    return {
      lineSize: 0,
      size: -this.options.spacing,
      bboxes: [],
      elements: []
    };
  };
  return Layout2;
}(group_default);
var layout_default = Layout;

// node_modules/@progress/kendo-drawing/dist/es/shapes/rect.js
var Rect2 = function(superclass) {
  function Rect4(geometry, options2) {
    if (geometry === void 0) geometry = new rect_default();
    if (options2 === void 0) options2 = {};
    superclass.call(this, options2);
    this.geometry(geometry);
    if (!defined(this.options.stroke)) {
      this.stroke("#000");
    }
  }
  if (superclass) Rect4.__proto__ = superclass;
  Rect4.prototype = Object.create(superclass && superclass.prototype);
  Rect4.prototype.constructor = Rect4;
  var prototypeAccessors = {
    nodeType: {
      configurable: true
    }
  };
  prototypeAccessors.nodeType.get = function() {
    return "Rect";
  };
  Rect4.prototype._bbox = function _bbox(matrix) {
    return this._geometry.bbox(matrix);
  };
  Rect4.prototype.rawBBox = function rawBBox() {
    return this._geometry.bbox();
  };
  Rect4.prototype._containsPoint = function _containsPoint(point2) {
    return this._geometry.containsPoint(point2);
  };
  Rect4.prototype._isOnPath = function _isOnPath(point2) {
    return this.geometry()._isOnPath(point2, this.options.stroke.width / 2);
  };
  Object.defineProperties(Rect4.prototype, prototypeAccessors);
  return Rect4;
}(paintable_default(measurable_default(with_geometry_default(element_default))));
var rect_default2 = Rect2;

// node_modules/@progress/kendo-drawing/dist/es/alignment/align-elements.js
function alignElements(elements, rect, alignment, axis, sizeField) {
  for (var idx2 = 0; idx2 < elements.length; idx2++) {
    var bbox = elements[idx2].clippedBBox();
    if (bbox) {
      var point2 = bbox.origin.clone();
      point2[axis] = alignStart(bbox.size[sizeField], rect, alignment || "start", axis, sizeField);
      translateToPoint(point2, bbox, elements[idx2]);
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/align.js
function align(elements, rect, alignment) {
  alignElements(elements, rect, alignment, "x", "width");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/v-align.js
function vAlign(elements, rect, alignment) {
  alignElements(elements, rect, alignment, "y", "height");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/stack-elements.js
function stackElements(elements, stackAxis, otherAxis, sizeField) {
  if (elements.length > 1) {
    var origin = new point_default();
    var previousBBox = elements[0].bbox;
    for (var idx2 = 1; idx2 < elements.length; idx2++) {
      var element = elements[idx2].element;
      var bbox = elements[idx2].bbox;
      origin[stackAxis] = previousBBox.origin[stackAxis] + previousBBox.size[sizeField];
      origin[otherAxis] = bbox.origin[otherAxis];
      translateToPoint(origin, bbox, element);
      bbox.origin[stackAxis] = origin[stackAxis];
      previousBBox = bbox;
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/create-stack-elements.js
function createStackElements(elements) {
  var stackElements2 = [];
  for (var idx2 = 0; idx2 < elements.length; idx2++) {
    var element = elements[idx2];
    var bbox = element.clippedBBox();
    if (bbox) {
      stackElements2.push({
        element,
        bbox
      });
    }
  }
  return stackElements2;
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/stack.js
function stack(elements) {
  stackElements(createStackElements(elements), "x", "y", "width");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/v-stack.js
function vStack(elements) {
  stackElements(createStackElements(elements), "y", "x", "height");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/wrap-elements.js
function getStacks(elements, rect, sizeField) {
  var maxSize = rect.size[sizeField];
  var stacks = [];
  var stack2 = [];
  var stackSize = 0;
  var element, bbox;
  var addElementToStack = function() {
    stack2.push({
      element,
      bbox
    });
  };
  for (var idx2 = 0; idx2 < elements.length; idx2++) {
    element = elements[idx2];
    bbox = element.clippedBBox();
    if (bbox) {
      var size = bbox.size[sizeField];
      if (stackSize + size > maxSize) {
        if (stack2.length) {
          stacks.push(stack2);
          stack2 = [];
          addElementToStack();
          stackSize = size;
        } else {
          addElementToStack();
          stacks.push(stack2);
          stack2 = [];
          stackSize = 0;
        }
      } else {
        addElementToStack();
        stackSize += size;
      }
    }
  }
  if (stack2.length) {
    stacks.push(stack2);
  }
  return stacks;
}
function wrapElements(elements, rect, axis, otherAxis, sizeField) {
  var stacks = getStacks(elements, rect, sizeField);
  var origin = rect.origin.clone();
  var result = [];
  for (var idx2 = 0; idx2 < stacks.length; idx2++) {
    var stack2 = stacks[idx2];
    var startElement = stack2[0];
    origin[otherAxis] = startElement.bbox.origin[otherAxis];
    translateToPoint(origin, startElement.bbox, startElement.element);
    startElement.bbox.origin[axis] = origin[axis];
    stackElements(stack2, axis, otherAxis, sizeField);
    result.push([]);
    for (var elementIdx = 0; elementIdx < stack2.length; elementIdx++) {
      result[idx2].push(stack2[elementIdx].element);
    }
  }
  return result;
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/wrap.js
function wrap(elements, rect) {
  return wrapElements(elements, rect, "x", "y", "width");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/v-wrap.js
function vWrap(elements, rect) {
  return wrapElements(elements, rect, "y", "x", "height");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/fit.js
function fit(element, rect) {
  var bbox = element.clippedBBox();
  if (bbox) {
    var elementSize2 = bbox.size;
    var rectSize = rect.size;
    if (rectSize.width < elementSize2.width || rectSize.height < elementSize2.height) {
      var scale = Math.min(rectSize.width / elementSize2.width, rectSize.height / elementSize2.height);
      var transform3 = element.transform() || transform();
      transform3.scale(scale, scale);
      element.transform(transform3);
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/gradients/stops-array.js
var StopsArray = function(ElementsArray2) {
  function StopsArray2() {
    ElementsArray2.apply(this, arguments);
  }
  if (ElementsArray2) StopsArray2.__proto__ = ElementsArray2;
  StopsArray2.prototype = Object.create(ElementsArray2 && ElementsArray2.prototype);
  StopsArray2.prototype.constructor = StopsArray2;
  StopsArray2.prototype._change = function _change() {
    this.optionsChange({
      field: "stops"
    });
  };
  return StopsArray2;
}(elements_array_default);
var stops_array_default = StopsArray;

// node_modules/@progress/kendo-drawing/dist/es/mixins/with-options.js
function optionsAccessor(name2) {
  return function(value) {
    if (defined(value)) {
      this.options.set(name2, value);
      return this;
    }
    return this.options.get(name2);
  };
}
function defineOptionsAccessors(fn, names) {
  for (var i = 0; i < names.length; i++) {
    fn[names[i]] = optionsAccessor(names[i]);
  }
}
var withOptions = function(TBase, names) {
  var result = function(TBase2) {
    function result2() {
      TBase2.apply(this, arguments);
    }
    if (TBase2) result2.__proto__ = TBase2;
    result2.prototype = Object.create(TBase2 && TBase2.prototype);
    result2.prototype.constructor = result2;
    return result2;
  }(TBase);
  defineOptionsAccessors(result.prototype, names);
  return result;
};
var with_options_default = withOptions;

// node_modules/@progress/kendo-drawing/dist/es/gradients/gradient-stop.js
var options = ["offset", "color", "opacity"];
var GradientStop = function(superclass) {
  function GradientStop2(offset, color, opacity) {
    superclass.call(this);
    this.options = new options_store_default({
      offset,
      color,
      opacity: defined(opacity) ? opacity : 1
    });
    this.options.addObserver(this);
  }
  if (superclass) GradientStop2.__proto__ = superclass;
  GradientStop2.prototype = Object.create(superclass && superclass.prototype);
  GradientStop2.prototype.constructor = GradientStop2;
  GradientStop2.create = function create(arg) {
    if (defined(arg)) {
      var stop;
      if (arg instanceof GradientStop2) {
        stop = arg;
      } else if (arg.length > 1) {
        stop = new GradientStop2(arg[0], arg[1], arg[2]);
      } else {
        stop = new GradientStop2(arg.offset, arg.color, arg.opacity);
      }
      return stop;
    }
  };
  return GradientStop2;
}(with_options_default(has_observers_default, options));
var gradient_stop_default = GradientStop;

// node_modules/@progress/kendo-drawing/dist/es/gradients/gradient.js
var Gradient = function(HasObservers2) {
  function Gradient2(options2) {
    if (options2 === void 0) options2 = {};
    HasObservers2.call(this);
    this.stops = new stops_array_default(this._createStops(options2.stops));
    this.stops.addObserver(this);
    this._userSpace = options2.userSpace;
    this.id = definitionId();
  }
  if (HasObservers2) Gradient2.__proto__ = HasObservers2;
  Gradient2.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  Gradient2.prototype.constructor = Gradient2;
  var prototypeAccessors = {
    nodeType: {
      configurable: true
    }
  };
  prototypeAccessors.nodeType.get = function() {
    return "Gradient";
  };
  Gradient2.prototype.userSpace = function userSpace(value) {
    if (defined(value)) {
      this._userSpace = value;
      this.optionsChange();
      return this;
    }
    return this._userSpace;
  };
  Gradient2.prototype._createStops = function _createStops(stops) {
    if (stops === void 0) stops = [];
    var result = [];
    for (var idx2 = 0; idx2 < stops.length; idx2++) {
      result.push(gradient_stop_default.create(stops[idx2]));
    }
    return result;
  };
  Gradient2.prototype.addStop = function addStop(offset, color, opacity) {
    this.stops.push(new gradient_stop_default(offset, color, opacity));
  };
  Gradient2.prototype.removeStop = function removeStop(stop) {
    var index = this.stops.indexOf(stop);
    if (index >= 0) {
      this.stops.splice(index, 1);
    }
  };
  Gradient2.prototype.optionsChange = function optionsChange(e) {
    this.trigger("optionsChange", {
      field: "gradient" + (e ? "." + e.field : ""),
      value: this
    });
  };
  Gradient2.prototype.geometryChange = function geometryChange() {
    this.optionsChange();
  };
  Object.defineProperties(Gradient2.prototype, prototypeAccessors);
  return Gradient2;
}(has_observers_default);
var gradient_default = Gradient;

// node_modules/@progress/kendo-drawing/dist/es/gradients/linear-gradient.js
var points2 = ["start", "end"];
var LinearGradient = function(superclass) {
  function LinearGradient2(options2) {
    if (options2 === void 0) options2 = {};
    superclass.call(this, options2);
    this.start(options2.start || new point_default());
    this.end(options2.end || new point_default(1, 0));
  }
  if (superclass) LinearGradient2.__proto__ = superclass;
  LinearGradient2.prototype = Object.create(superclass && superclass.prototype);
  LinearGradient2.prototype.constructor = LinearGradient2;
  return LinearGradient2;
}(with_points_default(gradient_default, points2));
var linear_gradient_default = LinearGradient;

// node_modules/@progress/kendo-drawing/dist/es/gradients/radial-gradient.js
var RadialGradient = function(superclass) {
  function RadialGradient2(options2) {
    if (options2 === void 0) options2 = {};
    superclass.call(this, options2);
    this.center(options2.center || new point_default());
    this._radius = defined(options2.radius) ? options2.radius : 1;
    this._fallbackFill = options2.fallbackFill;
  }
  if (superclass) RadialGradient2.__proto__ = superclass;
  RadialGradient2.prototype = Object.create(superclass && superclass.prototype);
  RadialGradient2.prototype.constructor = RadialGradient2;
  RadialGradient2.prototype.radius = function radius(value) {
    if (defined(value)) {
      this._radius = value;
      this.geometryChange();
      return this;
    }
    return this._radius;
  };
  RadialGradient2.prototype.fallbackFill = function fallbackFill(value) {
    if (defined(value)) {
      this._fallbackFill = value;
      this.optionsChange();
      return this;
    }
    return this._fallbackFill;
  };
  return RadialGradient2;
}(with_points_default(gradient_default, ["center"]));
var radial_gradient_default = RadialGradient;

// node_modules/@progress/kendo-drawing/dist/es/patterns/pattern.js
var defaultColor = "#aba4a6";
var defaultLine = {
  width: 2,
  gap: 18
};
var defaultDot = {
  radius: 10,
  gap: 10
};
var defaultGrid = {
  size: 18,
  gap: 2
};
var Pattern = function(Group2) {
  function Pattern2(options2) {
    Group2.call(this);
    var width = options2.width;
    var height = options2.height;
    this._size = size_default.create([width, height]);
    this.id = definitionId();
  }
  if (Group2) Pattern2.__proto__ = Group2;
  Pattern2.prototype = Object.create(Group2 && Group2.prototype);
  Pattern2.prototype.constructor = Pattern2;
  var prototypeAccessors = {
    nodeType: {
      configurable: true
    }
  };
  prototypeAccessors.nodeType.get = function() {
    return PATTERN;
  };
  Pattern2.prototype.size = function size(value) {
    if (value) {
      this._size = size_default.create(value);
      return this;
    }
    return this._size;
  };
  Object.defineProperties(Pattern2.prototype, prototypeAccessors);
  return Pattern2;
}(group_default);
var drawBackground = function(pattern, color, size) {
  if (color) {
    pattern.append(new rect_default2(new rect_default([0, 0], size), {
      fill: {
        color
      },
      stroke: null
    }));
  }
};
function dotsPattern(options2) {
  if (options2 === void 0) options2 = {};
  var gap = options2.gap;
  if (gap === void 0) gap = defaultDot.gap;
  var radius = options2.radius;
  if (radius === void 0) radius = defaultDot.radius;
  var color = options2.color;
  if (color === void 0) color = defaultColor;
  var background = options2.background;
  var shapeOptions = {
    fill: {
      color
    },
    stroke: null
  };
  var size = 4 * radius + 2 * gap;
  var yC2 = 3 * radius + 1.5 * gap;
  var center1 = [size / 2, radius + 1 / 2 * gap];
  var center2 = [0, yC2];
  var center3 = [size, yC2];
  var pattern = new Pattern({
    width: size,
    height: size
  });
  drawBackground(pattern, background, [size, size]);
  pattern.append(new circle_default2(new circle_default(center1, radius), shapeOptions), new circle_default2(new circle_default(center2, radius), shapeOptions), new circle_default2(new circle_default(center3, radius), shapeOptions));
  return pattern;
}
function verticalStripesPattern(options2) {
  if (options2 === void 0) options2 = {};
  var gap = options2.gap;
  if (gap === void 0) gap = defaultLine.gap;
  var width = options2.width;
  if (width === void 0) width = defaultLine.width;
  var color = options2.color;
  if (color === void 0) color = defaultColor;
  var background = options2.background;
  var size = width + gap;
  var shapeOptions = {
    fill: null,
    stroke: {
      color,
      width: width / 2
    }
  };
  var pattern = new Pattern({
    width: size,
    height: size
  });
  drawBackground(pattern, background, [size, size]);
  var xStart = width / 4;
  var xEnd = size - width / 4;
  var startLine = new Path(shapeOptions);
  startLine.moveTo(xStart, 0).lineTo(xStart, size);
  var endLine = new Path(shapeOptions);
  endLine.moveTo(xEnd, 0).lineTo(xEnd, size);
  pattern.append(startLine, endLine);
  return pattern;
}
function crosshatchPattern(options2) {
  if (options2 === void 0) options2 = {};
  var gap = options2.gap;
  if (gap === void 0) gap = defaultLine.gap;
  var width = options2.width;
  if (width === void 0) width = defaultLine.width;
  var color = options2.color;
  if (color === void 0) color = defaultColor;
  var background = options2.background;
  var size = Math.sqrt(2) * (width + gap);
  var shapeOptions = {
    fill: null,
    stroke: {
      color,
      width
    }
  };
  var pattern = new Pattern({
    width: size,
    height: size
  });
  drawBackground(pattern, background, [size, size]);
  var line1 = new Path(shapeOptions);
  line1.moveTo(0, 0).lineTo(size, size);
  var line2 = new Path(shapeOptions);
  line2.moveTo(size, 0).lineTo(0, size);
  pattern.append(line1, line2);
  return pattern;
}
function diagonalStripesPattern(options2) {
  if (options2 === void 0) options2 = {};
  var gap = options2.gap;
  if (gap === void 0) gap = defaultLine.gap;
  var width = options2.width;
  if (width === void 0) width = defaultLine.width;
  var color = options2.color;
  if (color === void 0) color = defaultColor;
  var background = options2.background;
  var size = Math.sqrt(2) * (width + gap);
  var shapeOptions = {
    fill: null,
    stroke: {
      color,
      width,
      lineCap: "square"
    }
  };
  var pattern = new Pattern({
    width: size,
    height: size
  });
  drawBackground(pattern, background, [size, size]);
  var line1 = new Path(shapeOptions);
  line1.moveTo(0, size / 2).lineTo(size / 2, 0);
  var line2 = new Path(shapeOptions);
  line2.moveTo(size / 2, size).lineTo(size, size / 2);
  pattern.append(line1, line2);
  return pattern;
}
function gridPattern(options2) {
  if (options2 === void 0) options2 = {};
  var gap = options2.gap;
  if (gap === void 0) gap = defaultGrid.gap;
  var squareSize = options2.size;
  if (squareSize === void 0) squareSize = defaultGrid.size;
  var color = options2.color;
  if (color === void 0) color = defaultColor;
  var background = options2.background;
  var size = squareSize + gap;
  var halfGap = gap / 2;
  var shapeOptions = {
    fill: {
      color
    },
    stroke: null
  };
  var pattern = new Pattern({
    width: size,
    height: size
  });
  drawBackground(pattern, background, [size, size]);
  var rect = new rect_default2(new rect_default([halfGap, halfGap], [squareSize, squareSize]), shapeOptions);
  pattern.append(rect);
  return pattern;
}

// node_modules/@progress/kendo-drawing/dist/es/animations/easing-functions.js
var easing_functions_exports = {};
__export(easing_functions_exports, {
  easeOutElastic: () => easeOutElastic,
  linear: () => linear,
  swing: () => swing
});
function swing(position) {
  return 0.5 - Math.cos(position * Math.PI) / 2;
}
function linear(position) {
  return position;
}
function easeOutElastic(position, time, start, diff) {
  var s = 1.70158, p = 0, a = diff;
  if (position === 0) {
    return start;
  }
  if (position === 1) {
    return start + diff;
  }
  if (!p) {
    p = 0.5;
  }
  if (a < Math.abs(diff)) {
    a = diff;
    s = p / 4;
  } else {
    s = p / (2 * Math.PI) * Math.asin(diff / a);
  }
  return a * Math.pow(2, -10 * position) * Math.sin((Number(position) - s) * (1.1 * Math.PI) / p) + diff + start;
}

// node_modules/@progress/kendo-drawing/dist/es/animations/animation-factory.js
var instance;
var AnimationFactory = function(Class3) {
  function AnimationFactory2() {
    Class3.call(this);
    this._items = [];
  }
  if (Class3) AnimationFactory2.__proto__ = Class3;
  AnimationFactory2.prototype = Object.create(Class3 && Class3.prototype);
  AnimationFactory2.prototype.constructor = AnimationFactory2;
  var staticAccessors = {
    current: {
      configurable: true
    }
  };
  staticAccessors.current.get = function() {
    if (!instance) {
      instance = new AnimationFactory2();
    }
    return instance;
  };
  AnimationFactory2.prototype.register = function register(name2, type) {
    this._items.push({
      name: name2,
      type
    });
  };
  AnimationFactory2.prototype.create = function create(element, options2) {
    var items = this._items;
    var match2;
    if (options2 && options2.type) {
      var type = options2.type.toLowerCase();
      for (var i = 0; i < items.length; i++) {
        if (items[i].name.toLowerCase() === type) {
          match2 = items[i];
          break;
        }
      }
    }
    if (match2) {
      return new match2.type(element, options2);
    }
  };
  Object.defineProperties(AnimationFactory2, staticAccessors);
  return AnimationFactory2;
}(class_default);
var animation_factory_default = AnimationFactory;

// node_modules/@progress/kendo-drawing/dist/es/animations/animation.js
var Animation = function(Class3) {
  function Animation2(element, options2) {
    Class3.call(this);
    this.options = Object.assign({}, this.options, options2);
    this.element = element;
  }
  if (Class3) Animation2.__proto__ = Class3;
  Animation2.prototype = Object.create(Class3 && Class3.prototype);
  Animation2.prototype.constructor = Animation2;
  var prototypeAccessors = {
    options: {
      configurable: true
    }
  };
  Animation2.create = function create(type, element, options2) {
    return animation_factory_default.current.create(type, element, options2);
  };
  prototypeAccessors.options.get = function() {
    return this._options || {
      duration: 500,
      easing: "swing"
    };
  };
  prototypeAccessors.options.set = function(value) {
    this._options = value;
  };
  Animation2.prototype.setup = function setup() {
  };
  Animation2.prototype.step = function step() {
  };
  Animation2.prototype.play = function play() {
    var this$1 = this;
    var options2 = this.options;
    var duration = options2.duration;
    var delay2 = options2.delay;
    if (delay2 === void 0) delay2 = 0;
    var easing = easing_functions_exports[options2.easing];
    var start = now_default() + delay2;
    var finish = start + duration;
    if (duration === 0) {
      this.step(1);
      this.abort();
    } else {
      setTimeout(function() {
        var loop = function() {
          if (this$1._stopped) {
            return;
          }
          var wallTime = now_default();
          var time = limitValue(wallTime - start, 0, duration);
          var position = time / duration;
          var easingPosition = easing(position, time, 0, 1, duration);
          this$1.step(easingPosition);
          if (wallTime < finish) {
            animation_frame_default(loop);
          } else {
            this$1.abort();
          }
        };
        loop();
      }, delay2);
    }
  };
  Animation2.prototype.abort = function abort() {
    this._stopped = true;
  };
  Animation2.prototype.destroy = function destroy2() {
    this.abort();
  };
  Object.defineProperties(Animation2.prototype, prototypeAccessors);
  return Animation2;
}(class_default);
var animation_default = Animation;

// node_modules/@progress/kendo-drawing/dist/es/parsing/path-parser.js
var instance2;
var PathParser = function(Class3) {
  function PathParser2() {
    Class3.apply(this, arguments);
  }
  if (Class3) PathParser2.__proto__ = Class3;
  PathParser2.prototype = Object.create(Class3 && Class3.prototype);
  PathParser2.prototype.constructor = PathParser2;
  var staticAccessors = {
    current: {
      configurable: true
    }
  };
  staticAccessors.current.get = function() {
    if (!instance2) {
      instance2 = new PathParser2();
    }
    return instance2;
  };
  PathParser2.prototype.parse = function parse3(str, options2) {
    var multiPath = new MultiPath(options2);
    return parse_path_default(multiPath, str);
  };
  Object.defineProperties(PathParser2, staticAccessors);
  return PathParser2;
}(class_default);
var path_parser_default = PathParser;

// node_modules/@progress/kendo-drawing/dist/es/core/base-node.js
var BaseNode = function(Class3) {
  function BaseNode2(srcElement) {
    Class3.call(this);
    this.childNodes = [];
    this.parent = null;
    if (srcElement) {
      this.srcElement = srcElement;
      this.observe();
    }
  }
  if (Class3) BaseNode2.__proto__ = Class3;
  BaseNode2.prototype = Object.create(Class3 && Class3.prototype);
  BaseNode2.prototype.constructor = BaseNode2;
  BaseNode2.prototype.destroy = function destroy2() {
    var this$1 = this;
    if (this.srcElement) {
      this.srcElement.removeObserver(this);
    }
    var children = this.childNodes;
    for (var i = 0; i < children.length; i++) {
      this$1.childNodes[i].destroy();
    }
    this.parent = null;
  };
  BaseNode2.prototype.load = function load3() {
  };
  BaseNode2.prototype.observe = function observe() {
    if (this.srcElement) {
      this.srcElement.addObserver(this);
    }
  };
  BaseNode2.prototype.append = function append4(node) {
    this.childNodes.push(node);
    node.parent = this;
  };
  BaseNode2.prototype.insertAt = function insertAt(node, pos) {
    this.childNodes.splice(pos, 0, node);
    node.parent = this;
  };
  BaseNode2.prototype.remove = function remove(index, count) {
    var this$1 = this;
    var end = index + count;
    for (var i = index; i < end; i++) {
      this$1.childNodes[i].removeSelf();
    }
    this.childNodes.splice(index, count);
  };
  BaseNode2.prototype.removeSelf = function removeSelf() {
    this.clear();
    this.destroy();
  };
  BaseNode2.prototype.clear = function clear2() {
    this.remove(0, this.childNodes.length);
  };
  BaseNode2.prototype.invalidate = function invalidate() {
    if (this.parent) {
      this.parent.invalidate();
    }
  };
  BaseNode2.prototype.geometryChange = function geometryChange() {
    this.invalidate();
  };
  BaseNode2.prototype.optionsChange = function optionsChange() {
    this.invalidate();
  };
  BaseNode2.prototype.childrenChange = function childrenChange(e) {
    if (e.action === "add") {
      this.load(e.items, e.index);
    } else if (e.action === "remove") {
      this.remove(e.index, e.items.length);
    }
    this.invalidate();
  };
  return BaseNode2;
}(class_default);
var base_node_default = BaseNode;

// node_modules/@progress/kendo-drawing/dist/es/core/surface.js
var events = ["click", "mouseenter", "mouseleave", "mousemove", "resize"];
var Surface = function(Observable2) {
  function Surface5(element, options2) {
    Observable2.call(this);
    this.options = Object.assign({}, options2);
    this.element = element;
    this.element._kendoExportVisual = this.exportVisual.bind(this);
    this._click = this._handler("click");
    this._mouseenter = this._handler("mouseenter");
    this._mouseleave = this._handler("mouseleave");
    this._mousemove = this._handler("mousemove");
    this._visual = new group_default();
    elementSize(element, this.options);
    this.bind(events, this.options);
    this._enableTracking();
  }
  if (Observable2) Surface5.__proto__ = Observable2;
  Surface5.prototype = Object.create(Observable2 && Observable2.prototype);
  Surface5.prototype.constructor = Surface5;
  Surface5.prototype.draw = function draw(element) {
    this._visual.children.push(element);
  };
  Surface5.prototype.clear = function clear2() {
    this._visual.children = [];
  };
  Surface5.prototype.destroy = function destroy2() {
    this._visual = null;
    this.element._kendoExportVisual = null;
    this.unbind();
  };
  Surface5.prototype.eventTarget = function eventTarget(e) {
    var this$1 = this;
    var domNode = eventElement(e);
    var node;
    while (!node && domNode) {
      node = domNode._kendoNode;
      if (domNode === this$1.element) {
        break;
      }
      domNode = domNode.parentElement;
    }
    if (node) {
      return node.srcElement;
    }
  };
  Surface5.prototype.exportVisual = function exportVisual() {
    return this._visual;
  };
  Surface5.prototype.getSize = function getSize() {
    return elementSize(this.element);
  };
  Surface5.prototype.currentSize = function currentSize(size) {
    if (size) {
      this._size = size;
    } else {
      return this._size;
    }
  };
  Surface5.prototype.setSize = function setSize(size) {
    elementSize(this.element, size);
    this.currentSize(size);
    this._resize();
  };
  Surface5.prototype.resize = function resize(force) {
    var size = this.getSize();
    var currentSize = this.currentSize();
    if (force || (size.width > 0 || size.height > 0) && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {
      this.currentSize(size);
      this._resize(size, force);
      this.trigger("resize", size);
    }
  };
  Surface5.prototype.size = function size(value) {
    if (!value) {
      return this.getSize();
    }
    this.setSize(value);
  };
  Surface5.prototype.suspendTracking = function suspendTracking() {
    this._suspendedTracking = true;
  };
  Surface5.prototype.resumeTracking = function resumeTracking() {
    this._suspendedTracking = false;
  };
  Surface5.prototype._enableTracking = function _enableTracking() {
  };
  Surface5.prototype._resize = function _resize() {
  };
  Surface5.prototype._handler = function _handler(eventName) {
    var this$1 = this;
    return function(e) {
      var node = this$1.eventTarget(e);
      if (node && !this$1._suspendedTracking) {
        this$1.trigger(eventName, {
          element: node,
          originalEvent: e,
          type: eventName
        });
      }
    };
  };
  Surface5.prototype._elementOffset = function _elementOffset() {
    var element = this.element;
    var padding = elementPadding(element);
    var ref = elementOffset(element);
    var left = ref.left;
    var top = ref.top;
    return {
      left: left + padding.left,
      top: top + padding.top
    };
  };
  Surface5.prototype._surfacePoint = function _surfacePoint(e) {
    var offset = this._elementOffset();
    var coord = eventCoordinates(e);
    var x = coord.x - offset.left;
    var y = coord.y - offset.top;
    var inverseTransform = elementScale(this.element).invert();
    var point2 = new point_default(x, y).transform(inverseTransform);
    return point2;
  };
  return Surface5;
}(observable_default);
var surface_default = Surface;

// node_modules/@progress/kendo-drawing/dist/es/svg/utils/render-attribute.js
function renderAttr(name2, value) {
  return defined(value) && value !== null ? " " + name2 + '="' + value + '" ' : "";
}

// node_modules/@progress/kendo-drawing/dist/es/svg/utils/render-all-attributes.js
function renderAllAttr(attrs) {
  var output = "";
  for (var i = 0; i < attrs.length; i++) {
    output += renderAttr(attrs[i][0], attrs[i][1]);
  }
  return output;
}

// node_modules/@progress/kendo-drawing/dist/es/svg/utils/render-style.js
function renderStyle(attrs) {
  var output = "";
  for (var i = 0; i < attrs.length; i++) {
    var value = attrs[i][1];
    if (defined(value)) {
      output += attrs[i][0] + ":" + value + ";";
    }
  }
  if (output !== "") {
    return output;
  }
}

// node_modules/@progress/kendo-drawing/dist/es/svg/node-map.js
var NODE_MAP = {};
var node_map_default = NODE_MAP;

// node_modules/@progress/kendo-drawing/dist/es/util/element-set-styles-safe.js
var setStyle = function(element, styleString) {
  var styles = parseInlineStyles(styleString);
  Object.keys(styles).forEach(function(key) {
    element.style[key] = styles[key];
  });
};
var styleAttr = "data-style";
var replaceStyleAttr = function(html) {
  return (html || "").replace(/\sstyle=/g, " " + styleAttr + "=");
};
var restoreStyleAttr = function(container) {
  Array.from(container.querySelectorAll("[" + styleAttr + "]")).forEach(function(element) {
    var styleString = element.getAttribute(styleAttr);
    element.removeAttribute(styleAttr);
    setStyle(element, styleString);
  });
};
var setInnerHTML = function(container, html) {
  container.innerHTML = replaceStyleAttr(html);
  restoreStyleAttr(container);
};

// node_modules/@progress/kendo-drawing/dist/es/svg/constants.js
var SVG_NS = "http://www.w3.org/2000/svg";
var NONE = "none";
var POINT_DIGITS = 3;

// node_modules/@progress/kendo-drawing/dist/es/svg/utils/render-svg.js
var renderSVG = function(container, svg) {
  setInnerHTML(container, svg);
};
if (typeof document !== "undefined") {
  testFragment = "<svg xmlns='" + SVG_NS + "'></svg>";
  testContainer = document.createElement("div");
  hasParser = typeof DOMParser !== "undefined";
  testContainer.innerHTML = testFragment;
  if (hasParser && testContainer.firstChild.namespaceURI !== SVG_NS) {
    renderSVG = function(container, svg) {
      var parser = new DOMParser();
      var chartDoc = parser.parseFromString(replaceStyleAttr(svg), "text/xml");
      restoreStyleAttr(chartDoc);
      var importedDoc = document.adoptNode(chartDoc.documentElement);
      container.innerHTML = "";
      container.appendChild(importedDoc);
    };
  }
}
var testFragment;
var testContainer;
var hasParser;
var render_svg_default = renderSVG;

// node_modules/@progress/kendo-drawing/dist/es/svg/node.js
var TRANSFORM = "transform";
var DefinitionMap = {
  clip: "clip-path",
  fill: "fill"
};
function isDefinition(type, value) {
  return type === "clip" || type === "fill" && (!value || value.nodeType === "Gradient" || value.nodeType === PATTERN);
}
function baseUrl() {
  var base = document.getElementsByTagName("base")[0];
  var href = document.location.href;
  var url = "";
  if (base && !(support_default.browser || {}).msie) {
    var hashIndex = href.indexOf("#");
    if (hashIndex !== -1) {
      href = href.substring(0, hashIndex);
    }
    url = href;
  }
  return url;
}
var Node2 = function(BaseNode2) {
  function Node4(srcElement, options2) {
    BaseNode2.call(this, srcElement);
    this.definitions = {};
    this.options = options2;
  }
  if (BaseNode2) Node4.__proto__ = BaseNode2;
  Node4.prototype = Object.create(BaseNode2 && BaseNode2.prototype);
  Node4.prototype.constructor = Node4;
  Node4.prototype.destroy = function destroy2() {
    if (this.element) {
      this.element._kendoNode = null;
      this.element = null;
    }
    this.clearDefinitions();
    BaseNode2.prototype.destroy.call(this);
  };
  Node4.prototype.load = function load3(elements, pos) {
    var this$1 = this;
    for (var i = 0; i < elements.length; i++) {
      var srcElement = elements[i];
      var children = srcElement.children;
      var childNode = new node_map_default[srcElement.nodeType](srcElement, this$1.options);
      if (defined(pos)) {
        this$1.insertAt(childNode, pos);
      } else {
        this$1.append(childNode);
      }
      childNode.createDefinitions();
      if (children && children.length > 0) {
        childNode.load(children);
      }
      var element = this$1.element;
      if (element) {
        childNode.attachTo(element, pos);
      }
    }
  };
  Node4.prototype.root = function root() {
    var root2 = this;
    while (root2.parent) {
      root2 = root2.parent;
    }
    return root2;
  };
  Node4.prototype.attachTo = function attachTo(domElement, pos) {
    var container = document.createElement("div");
    render_svg_default(container, "<svg xmlns='" + SVG_NS + "' version='1.1'>" + this.render() + "</svg>");
    var element = container.firstChild.firstChild;
    if (element) {
      if (defined(pos)) {
        domElement.insertBefore(element, domElement.childNodes[pos] || null);
      } else {
        domElement.appendChild(element);
      }
      this.setElement(element);
    }
  };
  Node4.prototype.setElement = function setElement(element) {
    if (this.element) {
      this.element._kendoNode = null;
    }
    this.element = element;
    this.element._kendoNode = this;
    var nodes = this.childNodes;
    for (var i = 0; i < nodes.length; i++) {
      var childElement = element.childNodes[i];
      nodes[i].setElement(childElement);
    }
  };
  Node4.prototype.clear = function clear2() {
    this.clearDefinitions();
    if (this.element) {
      this.element.innerHTML = "";
    }
    var children = this.childNodes;
    for (var i = 0; i < children.length; i++) {
      children[i].destroy();
    }
    this.childNodes = [];
  };
  Node4.prototype.removeSelf = function removeSelf() {
    if (this.element) {
      var parentNode = this.element.parentNode;
      if (parentNode) {
        parentNode.removeChild(this.element);
      }
      this.element = null;
    }
    BaseNode2.prototype.removeSelf.call(this);
  };
  Node4.prototype.template = function template2() {
    return this.renderChildren();
  };
  Node4.prototype.render = function render4() {
    return this.template();
  };
  Node4.prototype.renderChildren = function renderChildren() {
    var nodes = this.childNodes;
    var output = "";
    for (var i = 0; i < nodes.length; i++) {
      output += nodes[i].render();
    }
    return output;
  };
  Node4.prototype.optionsChange = function optionsChange(e) {
    var field = e.field;
    var value = e.value;
    if (field === "visible") {
      this.css("display", value ? "" : NONE);
    } else if (DefinitionMap[field] && isDefinition(field, value)) {
      this.updateDefinition(field, value);
    } else if (field === "opacity") {
      this.attr("opacity", value);
    } else if (field === "cursor") {
      this.css("cursor", value);
    } else if (field === "id") {
      if (value) {
        this.attr("id", value);
      } else {
        this.removeAttr("id");
      }
    }
    BaseNode2.prototype.optionsChange.call(this, e);
  };
  Node4.prototype.accessibilityOptionsChange = function accessibilityOptionsChange(e) {
    var field = e.field;
    var value = e.value;
    if (field === "role") {
      if (value) {
        this.attr("role", value);
      } else {
        this.removeAttr("role");
      }
    } else if (field === "ariaLabel") {
      if (value) {
        this.attr("aria-label", htmlEncode(value));
      } else {
        this.removeAttr("aria-label");
      }
    } else if (field === "ariaRoleDescription") {
      if (value) {
        this.attr("aria-roledescription", htmlEncode(value));
      } else {
        this.removeAttr("aria-roledescription");
      }
    } else if (field === "ariaChecked") {
      if (defined(value)) {
        this.attr("aria-checked", value);
      } else {
        this.removeAttr("aria-checked");
      }
    } else if (field === "className") {
      this.className(value);
    }
  };
  Node4.prototype.attr = function attr(name2, value) {
    if (this.element) {
      this.element.setAttribute(name2, value);
    }
  };
  Node4.prototype.allAttr = function allAttr(attrs) {
    var this$1 = this;
    for (var i = 0; i < attrs.length; i++) {
      this$1.attr(attrs[i][0], attrs[i][1]);
    }
  };
  Node4.prototype.toggleAttr = function toggleAttr(name2, value) {
    if (value) {
      this.attr(name2, value);
    } else {
      this.removeAttr(name2);
    }
  };
  Node4.prototype.css = function css(name2, value) {
    if (this.element) {
      this.element.style[name2] = value;
    }
  };
  Node4.prototype.allCss = function allCss(styles) {
    var this$1 = this;
    for (var i = 0; i < styles.length; i++) {
      this$1.css(styles[i][0], styles[i][1]);
    }
  };
  Node4.prototype.className = function className(value) {
    var this$1 = this;
    if (this.element) {
      (ref = this.element.classList).remove.apply(ref, this.element.classList);
      value.split(" ").forEach(function(item) {
        this$1.element.classList.add(item);
      });
    }
    var ref;
  };
  Node4.prototype.removeAttr = function removeAttr(name2) {
    if (this.element) {
      this.element.removeAttribute(name2);
    }
  };
  Node4.prototype.mapTransform = function mapTransform(transform3) {
    var attrs = [];
    if (transform3) {
      attrs.push([TRANSFORM, "matrix(" + transform3.matrix().toString(6) + ")"]);
    }
    return attrs;
  };
  Node4.prototype.renderTransform = function renderTransform() {
    return renderAllAttr(this.mapTransform(this.srcElement.transform()));
  };
  Node4.prototype.transformChange = function transformChange(value) {
    if (value) {
      this.allAttr(this.mapTransform(value));
    } else {
      this.removeAttr(TRANSFORM);
    }
  };
  Node4.prototype.mapStyle = function mapStyle() {
    var options2 = this.srcElement.options;
    var style2 = [["cursor", options2.cursor]];
    if (options2.visible === false) {
      style2.push(["display", NONE]);
    }
    return style2;
  };
  Node4.prototype.renderStyle = function renderStyle$1() {
    return renderAttr("style", renderStyle(this.mapStyle(true)));
  };
  Node4.prototype.renderOpacity = function renderOpacity() {
    return renderAttr("opacity", this.srcElement.options.opacity);
  };
  Node4.prototype.renderId = function renderId() {
    return renderAttr("id", this.srcElement.options.id);
  };
  Node4.prototype.renderClassName = function renderClassName() {
    return renderAttr("class", this.srcElement.options.className);
  };
  Node4.prototype.renderRole = function renderRole() {
    return renderAttr("role", this.srcElement.options.role);
  };
  Node4.prototype.renderAriaLabel = function renderAriaLabel() {
    var value = this.srcElement.options.ariaLabel;
    if (value) {
      value = htmlEncode(value);
    }
    return renderAttr("aria-label", value);
  };
  Node4.prototype.renderAriaRoleDescription = function renderAriaRoleDescription() {
    var value = this.srcElement.options.ariaRoleDescription;
    if (value) {
      value = htmlEncode(value);
    }
    return renderAttr("aria-roledescription", value);
  };
  Node4.prototype.renderAriaChecked = function renderAriaChecked() {
    return renderAttr("aria-checked", this.srcElement.options.ariaChecked);
  };
  Node4.prototype.createDefinitions = function createDefinitions() {
    var srcElement = this.srcElement;
    var definitions = this.definitions;
    if (srcElement) {
      var options2 = srcElement.options;
      var hasDefinitions;
      for (var field in DefinitionMap) {
        var definition = options2.get(field);
        if (definition && isDefinition(field, definition)) {
          definitions[field] = definition;
          hasDefinitions = true;
        }
      }
      if (hasDefinitions) {
        this.definitionChange({
          action: "add",
          definitions
        });
      }
    }
  };
  Node4.prototype.definitionChange = function definitionChange(e) {
    if (this.parent) {
      this.parent.definitionChange(e);
    }
  };
  Node4.prototype.updateDefinition = function updateDefinition(type, value) {
    var definitions = this.definitions;
    var current = definitions[type];
    var attr = DefinitionMap[type];
    var definition = {};
    if (current) {
      definition[type] = current;
      this.definitionChange({
        action: "remove",
        definitions: definition
      });
      delete definitions[type];
    }
    if (!value) {
      if (current) {
        this.removeAttr(attr);
      }
    } else {
      definition[type] = value;
      this.definitionChange({
        action: "add",
        definitions: definition
      });
      definitions[type] = value;
      this.attr(attr, this.refUrl(value.id));
    }
  };
  Node4.prototype.clearDefinitions = function clearDefinitions() {
    var definitions = this.definitions;
    this.definitionChange({
      action: "remove",
      definitions
    });
    this.definitions = {};
  };
  Node4.prototype.renderDefinitions = function renderDefinitions() {
    return renderAllAttr(this.mapDefinitions());
  };
  Node4.prototype.mapDefinitions = function mapDefinitions() {
    var this$1 = this;
    var definitions = this.definitions;
    var attrs = [];
    for (var field in definitions) {
      attrs.push([DefinitionMap[field], this$1.refUrl(definitions[field].id)]);
    }
    return attrs;
  };
  Node4.prototype.refUrl = function refUrl(id2) {
    var skipBaseHref = (this.options || {}).skipBaseHref;
    var baseHref = this.baseUrl().replace(/'/g, "\\'");
    var base = skipBaseHref ? "" : baseHref;
    return "url(" + base + "#" + id2 + ")";
  };
  Node4.prototype.baseUrl = function baseUrl$1() {
    return baseUrl();
  };
  return Node4;
}(base_node_default);
var node_default = Node2;

// node_modules/@progress/kendo-drawing/dist/es/svg/gradient-stop-node.js
var GradientStopNode = function(Node4) {
  function GradientStopNode2() {
    Node4.apply(this, arguments);
  }
  if (Node4) GradientStopNode2.__proto__ = Node4;
  GradientStopNode2.prototype = Object.create(Node4 && Node4.prototype);
  GradientStopNode2.prototype.constructor = GradientStopNode2;
  GradientStopNode2.prototype.template = function template2() {
    return "<stop " + this.renderOffset() + " " + this.renderStyle() + " />";
  };
  GradientStopNode2.prototype.renderOffset = function renderOffset() {
    return renderAttr("offset", this.srcElement.offset());
  };
  GradientStopNode2.prototype.mapStyle = function mapStyle() {
    var srcElement = this.srcElement;
    return [["stop-color", srcElement.color()], ["stop-opacity", srcElement.opacity()]];
  };
  GradientStopNode2.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "offset") {
      this.attr(e.field, e.value);
    } else if (e.field === "color" || e.field === "opacity") {
      this.css("stop-" + e.field, e.value);
    }
  };
  return GradientStopNode2;
}(node_default);
var gradient_stop_node_default = GradientStopNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/gradient-node.js
var GradientNode = function(Node4) {
  function GradientNode2(srcElement) {
    Node4.call(this, srcElement);
    this.id = srcElement.id;
    this.loadStops();
  }
  if (Node4) GradientNode2.__proto__ = Node4;
  GradientNode2.prototype = Object.create(Node4 && Node4.prototype);
  GradientNode2.prototype.constructor = GradientNode2;
  GradientNode2.prototype.loadStops = function loadStops() {
    var this$1 = this;
    var stops = this.srcElement.stops;
    var element = this.element;
    for (var idx2 = 0; idx2 < stops.length; idx2++) {
      var stopNode = new gradient_stop_node_default(stops[idx2]);
      this$1.append(stopNode);
      if (element) {
        stopNode.attachTo(element);
      }
    }
  };
  GradientNode2.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "gradient.stops") {
      base_node_default.prototype.clear.call(this);
      this.loadStops();
    } else if (e.field === "gradient") {
      this.allAttr(this.mapCoordinates());
    }
  };
  GradientNode2.prototype.renderCoordinates = function renderCoordinates() {
    return renderAllAttr(this.mapCoordinates());
  };
  GradientNode2.prototype.mapSpace = function mapSpace() {
    return ["gradientUnits", this.srcElement.userSpace() ? "userSpaceOnUse" : "objectBoundingBox"];
  };
  return GradientNode2;
}(node_default);
var gradient_node_default = GradientNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/linear-gradient-node.js
var LinearGradientNode = function(GradientNode2) {
  function LinearGradientNode2() {
    GradientNode2.apply(this, arguments);
  }
  if (GradientNode2) LinearGradientNode2.__proto__ = GradientNode2;
  LinearGradientNode2.prototype = Object.create(GradientNode2 && GradientNode2.prototype);
  LinearGradientNode2.prototype.constructor = LinearGradientNode2;
  LinearGradientNode2.prototype.template = function template2() {
    return "<linearGradient id='" + this.id + "' " + this.renderCoordinates() + ">" + this.renderChildren() + "</linearGradient>";
  };
  LinearGradientNode2.prototype.mapCoordinates = function mapCoordinates() {
    var srcElement = this.srcElement;
    var start = srcElement.start();
    var end = srcElement.end();
    var attrs = [["x1", start.x], ["y1", start.y], ["x2", end.x], ["y2", end.y], this.mapSpace()];
    return attrs;
  };
  return LinearGradientNode2;
}(gradient_node_default);
var linear_gradient_node_default = LinearGradientNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/radial-gradient-node.js
var RadialGradientNode = function(GradientNode2) {
  function RadialGradientNode2() {
    GradientNode2.apply(this, arguments);
  }
  if (GradientNode2) RadialGradientNode2.__proto__ = GradientNode2;
  RadialGradientNode2.prototype = Object.create(GradientNode2 && GradientNode2.prototype);
  RadialGradientNode2.prototype.constructor = RadialGradientNode2;
  RadialGradientNode2.prototype.template = function template2() {
    return "<radialGradient id='" + this.id + "' " + this.renderCoordinates() + ">" + this.renderChildren() + "</radialGradient>";
  };
  RadialGradientNode2.prototype.mapCoordinates = function mapCoordinates() {
    var srcElement = this.srcElement;
    var center = srcElement.center();
    var radius = srcElement.radius();
    var attrs = [["cx", center.x], ["cy", center.y], ["r", radius], this.mapSpace()];
    return attrs;
  };
  return RadialGradientNode2;
}(gradient_node_default);
var radial_gradient_node_default = RadialGradientNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/pattern-node.js
var PatternNode = function(Node4) {
  function PatternNode2(pattern) {
    Node4.call(this, pattern);
    this.id = pattern.id;
    this.load(pattern.children);
  }
  if (Node4) PatternNode2.__proto__ = Node4;
  PatternNode2.prototype = Object.create(Node4 && Node4.prototype);
  PatternNode2.prototype.constructor = PatternNode2;
  PatternNode2.prototype.template = function template2() {
    var width = this.srcElement.size().getWidth();
    var height = this.srcElement.size().getHeight();
    return "<pattern id='" + this.srcElement.id + "' width='" + width + "' height='" + height + "' patternUnits='userSpaceOnUse'>" + this.renderChildren() + "</pattern>";
  };
  return PatternNode2;
}(node_default);

// node_modules/@progress/kendo-drawing/dist/es/svg/clip-node.js
var ClipNode = function(Node4) {
  function ClipNode2(srcElement) {
    Node4.call(this);
    this.srcElement = srcElement;
    this.id = srcElement.id;
    this.load([srcElement]);
  }
  if (Node4) ClipNode2.__proto__ = Node4;
  ClipNode2.prototype = Object.create(Node4 && Node4.prototype);
  ClipNode2.prototype.constructor = ClipNode2;
  ClipNode2.prototype.renderClipRule = function renderClipRule() {
    return renderAttr("clip-rule", "evenodd");
  };
  ClipNode2.prototype.template = function template2() {
    return "<clipPath " + this.renderClipRule() + " id='" + this.id + "'>" + this.renderChildren() + "</clipPath>";
  };
  return ClipNode2;
}(node_default);
var clip_node_default = ClipNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/definition-node.js
var DefinitionNode = function(Node4) {
  function DefinitionNode2() {
    Node4.call(this);
    this.definitionMap = {};
  }
  if (Node4) DefinitionNode2.__proto__ = Node4;
  DefinitionNode2.prototype = Object.create(Node4 && Node4.prototype);
  DefinitionNode2.prototype.constructor = DefinitionNode2;
  DefinitionNode2.prototype.attachTo = function attachTo(domElement) {
    this.element = domElement;
  };
  DefinitionNode2.prototype.template = function template2() {
    return "<defs>" + this.renderChildren() + "</defs>";
  };
  DefinitionNode2.prototype.definitionChange = function definitionChange(e) {
    var definitions = e.definitions;
    var action = e.action;
    if (action === "add") {
      this.addDefinitions(definitions);
    } else if (action === "remove") {
      this.removeDefinitions(definitions);
    }
  };
  DefinitionNode2.prototype.createDefinition = function createDefinition(type, item) {
    var nodeType;
    if (type === "clip") {
      nodeType = clip_node_default;
    } else if (type === "fill") {
      if (item instanceof linear_gradient_default) {
        nodeType = linear_gradient_node_default;
      } else if (item instanceof radial_gradient_default) {
        nodeType = radial_gradient_node_default;
      } else if (item.nodeType === PATTERN) {
        nodeType = PatternNode;
      }
    }
    return new nodeType(item);
  };
  DefinitionNode2.prototype.addDefinitions = function addDefinitions(definitions) {
    var this$1 = this;
    for (var field in definitions) {
      this$1.addDefinition(field, definitions[field]);
    }
  };
  DefinitionNode2.prototype.addDefinition = function addDefinition(type, srcElement) {
    var ref = this;
    var element = ref.element;
    var definitionMap = ref.definitionMap;
    var id2 = srcElement.id;
    var mapItem = definitionMap[id2];
    if (!mapItem) {
      var node = this.createDefinition(type, srcElement);
      definitionMap[id2] = {
        element: node,
        count: 1
      };
      this.append(node);
      if (element) {
        node.attachTo(this.element);
      }
    } else {
      mapItem.count++;
    }
  };
  DefinitionNode2.prototype.removeDefinitions = function removeDefinitions(definitions) {
    var this$1 = this;
    for (var field in definitions) {
      this$1.removeDefinition(definitions[field]);
    }
  };
  DefinitionNode2.prototype.removeDefinition = function removeDefinition(srcElement) {
    var definitionMap = this.definitionMap;
    var id2 = srcElement.id;
    var mapItem = definitionMap[id2];
    if (mapItem) {
      mapItem.count--;
      if (mapItem.count === 0) {
        this.remove(this.childNodes.indexOf(mapItem.element), 1);
        delete definitionMap[id2];
      }
    }
  };
  return DefinitionNode2;
}(node_default);
var definition_node_default = DefinitionNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/root-node.js
var RootNode = function(Node4) {
  function RootNode3(options2) {
    Node4.call(this);
    this.options = options2;
    this.defs = new definition_node_default();
  }
  if (Node4) RootNode3.__proto__ = Node4;
  RootNode3.prototype = Object.create(Node4 && Node4.prototype);
  RootNode3.prototype.constructor = RootNode3;
  RootNode3.prototype.attachTo = function attachTo(domElement) {
    this.element = domElement;
    this.defs.attachTo(domElement.firstElementChild);
  };
  RootNode3.prototype.clear = function clear2() {
    base_node_default.prototype.clear.call(this);
  };
  RootNode3.prototype.template = function template2() {
    return this.defs.render() + this.renderChildren();
  };
  RootNode3.prototype.definitionChange = function definitionChange(e) {
    this.defs.definitionChange(e);
  };
  return RootNode3;
}(node_default);
var root_node_default = RootNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/path-node.js
var ATTRIBUTE_MAP = {
  "fill.opacity": "fill-opacity",
  "stroke.color": "stroke",
  "stroke.width": "stroke-width",
  "stroke.opacity": "stroke-opacity"
};
var PathNode = function(Node4) {
  function PathNode3() {
    Node4.apply(this, arguments);
  }
  if (Node4) PathNode3.__proto__ = Node4;
  PathNode3.prototype = Object.create(Node4 && Node4.prototype);
  PathNode3.prototype.constructor = PathNode3;
  PathNode3.prototype.geometryChange = function geometryChange() {
    this.attr("d", this.renderData());
    this.invalidate();
  };
  PathNode3.prototype.optionsChange = function optionsChange(e) {
    switch (e.field) {
      case "fill":
        if (e.value) {
          this.allAttr(this.mapFill(e.value));
        } else {
          this.removeAttr("fill");
        }
        break;
      case "fill.color":
        this.allAttr(this.mapFill({
          color: e.value
        }));
        break;
      case "stroke":
        if (e.value) {
          this.allAttr(this.mapStroke(e.value));
        } else {
          this.removeAttr("stroke");
        }
        break;
      case "transform":
        this.transformChange(e.value);
        break;
      default:
        var name2 = ATTRIBUTE_MAP[e.field];
        if (name2) {
          this.attr(name2, e.value);
        }
        break;
    }
    this.accessibilityOptionsChange(e);
    Node4.prototype.optionsChange.call(this, e);
  };
  PathNode3.prototype.content = function content() {
    if (this.element) {
      this.element.textContent = this.srcElement.content();
    }
  };
  PathNode3.prototype.renderData = function renderData() {
    return this.srcElement.toString(POINT_DIGITS) || void 0;
  };
  PathNode3.prototype.mapStroke = function mapStroke(stroke) {
    var attrs = [];
    if (stroke && !isTransparent(stroke.color)) {
      attrs.push(["stroke", stroke.color]);
      attrs.push(["stroke-width", stroke.width]);
      attrs.push(["stroke-linecap", this.renderLinecap(stroke)]);
      attrs.push(["stroke-linejoin", stroke.lineJoin]);
      if (defined(stroke.opacity)) {
        attrs.push(["stroke-opacity", stroke.opacity]);
      }
      if (defined(stroke.dashType)) {
        attrs.push(["stroke-dasharray", this.renderDashType(stroke)]);
      }
    } else {
      attrs.push(["stroke", NONE]);
    }
    return attrs;
  };
  PathNode3.prototype.renderStroke = function renderStroke() {
    return renderAllAttr(this.mapStroke(this.srcElement.options.stroke));
  };
  PathNode3.prototype.renderDashType = function renderDashType(stroke) {
    var dashType = stroke.dashType;
    var width = stroke.width;
    if (width === void 0) width = 1;
    if (dashType && dashType !== SOLID) {
      var dashArray = DASH_ARRAYS[dashType.toLowerCase()];
      var result = [];
      for (var i = 0; i < dashArray.length; i++) {
        result.push(dashArray[i] * width);
      }
      return result.join(" ");
    }
  };
  PathNode3.prototype.renderLinecap = function renderLinecap(stroke) {
    var dashType = stroke.dashType;
    var lineCap = stroke.lineCap;
    return dashType && dashType !== SOLID ? BUTT : lineCap;
  };
  PathNode3.prototype.mapFill = function mapFill(fill) {
    var attrs = [];
    if (!(fill && (fill.nodeType === "Gradient" || fill.nodeType === PATTERN))) {
      if (fill && !isTransparent(fill.color)) {
        attrs.push(["fill", fill.color]);
        if (defined(fill.opacity)) {
          attrs.push(["fill-opacity", fill.opacity]);
        }
      } else {
        attrs.push(["fill", NONE]);
      }
    }
    return attrs;
  };
  PathNode3.prototype.renderFill = function renderFill() {
    return renderAllAttr(this.mapFill(this.srcElement.options.fill));
  };
  PathNode3.prototype.template = function template2() {
    return "<path " + this.renderId() + " " + this.renderStyle() + " " + this.renderOpacity() + " " + renderAttr("d", this.renderData()) + this.renderStroke() + this.renderFill() + this.renderDefinitions() + this.renderTransform() + this.renderClassName() + " " + this.renderRole() + this.renderAriaLabel() + " " + this.renderAriaRoleDescription() + this.renderAriaChecked() + " ></path>";
  };
  return PathNode3;
}(node_default);
var path_node_default = PathNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/arc-node.js
var ArcNode = function(PathNode3) {
  function ArcNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3) ArcNode3.__proto__ = PathNode3;
  ArcNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  ArcNode3.prototype.constructor = ArcNode3;
  ArcNode3.prototype.renderData = function renderData() {
    return this.srcElement.toPath().toString(POINT_DIGITS);
  };
  return ArcNode3;
}(path_node_default);
var arc_node_default = ArcNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/circle-node.js
var CircleNode = function(PathNode3) {
  function CircleNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3) CircleNode3.__proto__ = PathNode3;
  CircleNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  CircleNode3.prototype.constructor = CircleNode3;
  CircleNode3.prototype.geometryChange = function geometryChange() {
    var center = this.center();
    this.attr("cx", center.x);
    this.attr("cy", center.y);
    this.attr("r", this.radius());
    this.invalidate();
  };
  CircleNode3.prototype.center = function center() {
    return this.srcElement.geometry().center;
  };
  CircleNode3.prototype.radius = function radius() {
    return this.srcElement.geometry().radius;
  };
  CircleNode3.prototype.template = function template2() {
    return "<circle " + this.renderId() + " " + this.renderStyle() + " " + this.renderOpacity() + "cx='" + this.center().x + "' cy='" + this.center().y + "' r='" + this.radius() + "'" + this.renderStroke() + " " + this.renderFill() + " " + this.renderDefinitions() + this.renderClassName() + " " + this.renderRole() + this.renderAriaLabel() + " " + this.renderAriaRoleDescription() + this.renderAriaChecked() + " " + this.renderTransform() + " ></circle>";
  };
  return CircleNode3;
}(path_node_default);
var circle_node_default = CircleNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/group-node.js
var GroupNode = function(Node4) {
  function GroupNode3() {
    Node4.apply(this, arguments);
  }
  if (Node4) GroupNode3.__proto__ = Node4;
  GroupNode3.prototype = Object.create(Node4 && Node4.prototype);
  GroupNode3.prototype.constructor = GroupNode3;
  GroupNode3.prototype.template = function template2() {
    return "<g" + (this.renderId() + this.renderTransform() + this.renderClassName() + this.renderStyle() + this.renderOpacity() + this.renderRole() + this.renderAriaLabel() + this.renderAriaRoleDescription() + this.renderAriaChecked() + this.renderDefinitions()) + ">" + this.renderChildren() + "</g>";
  };
  GroupNode3.prototype.optionsChange = function optionsChange(e) {
    var field = e.field;
    var value = e.value;
    if (field === "transform") {
      this.transformChange(value);
    }
    this.accessibilityOptionsChange(e);
    Node4.prototype.optionsChange.call(this, e);
  };
  return GroupNode3;
}(node_default);
var group_node_default = GroupNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/image-node.js
var ImageNode = function(PathNode3) {
  function ImageNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3) ImageNode3.__proto__ = PathNode3;
  ImageNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  ImageNode3.prototype.constructor = ImageNode3;
  ImageNode3.prototype.geometryChange = function geometryChange() {
    this.allAttr(this.mapPosition());
    this.invalidate();
  };
  ImageNode3.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "src") {
      this.allAttr(this.mapSource());
    }
    PathNode3.prototype.optionsChange.call(this, e);
  };
  ImageNode3.prototype.mapPosition = function mapPosition() {
    var rect = this.srcElement.rect();
    var tl = rect.topLeft();
    return [["x", tl.x], ["y", tl.y], ["width", rect.width() + "px"], ["height", rect.height() + "px"]];
  };
  ImageNode3.prototype.renderPosition = function renderPosition() {
    return renderAllAttr(this.mapPosition());
  };
  ImageNode3.prototype.mapSource = function mapSource(encode) {
    var src = this.srcElement.src();
    if (encode) {
      src = htmlEncode(src);
    }
    return [["xlink:href", src]];
  };
  ImageNode3.prototype.renderSource = function renderSource() {
    return renderAllAttr(this.mapSource(true));
  };
  ImageNode3.prototype.template = function template2() {
    return "<image preserveAspectRatio='none' " + this.renderId() + " " + this.renderStyle() + " " + this.renderTransform() + " " + this.renderOpacity() + this.renderPosition() + " " + this.renderSource() + " " + this.renderDefinitions() + this.renderClassName() + " " + this.renderRole() + this.renderAriaLabel() + " " + this.renderAriaRoleDescription() + this.renderAriaChecked() + " ></image>";
  };
  return ImageNode3;
}(path_node_default);
var image_node_default = ImageNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/multi-path-node.js
var MultiPathNode = function(PathNode3) {
  function MultiPathNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3) MultiPathNode3.__proto__ = PathNode3;
  MultiPathNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  MultiPathNode3.prototype.constructor = MultiPathNode3;
  MultiPathNode3.prototype.renderData = function renderData() {
    return this.srcElement.toString(POINT_DIGITS) || "undefined";
  };
  return MultiPathNode3;
}(path_node_default);
var multi_path_node_default = MultiPathNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/rect-node.js
var RectNode = function(PathNode3) {
  function RectNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3) RectNode3.__proto__ = PathNode3;
  RectNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  RectNode3.prototype.constructor = RectNode3;
  RectNode3.prototype.geometryChange = function geometryChange() {
    var geometry = this.srcElement.geometry();
    this.attr("x", geometry.origin.x);
    this.attr("y", geometry.origin.y);
    this.attr("width", geometry.size.width);
    this.attr("height", geometry.size.height);
    this.attr("rx", geometry.cornerRadius[0]);
    this.attr("ry", geometry.cornerRadius[1]);
    this.invalidate();
  };
  RectNode3.prototype.size = function size() {
    return this.srcElement.geometry().size;
  };
  RectNode3.prototype.origin = function origin() {
    return this.srcElement.geometry().origin;
  };
  RectNode3.prototype.rx = function rx() {
    return this.srcElement.geometry().cornerRadius[0];
  };
  RectNode3.prototype.ry = function ry() {
    return this.srcElement.geometry().cornerRadius[1];
  };
  RectNode3.prototype.template = function template2() {
    return "<rect " + this.renderId() + " " + this.renderStyle() + " " + this.renderOpacity() + " x='" + this.origin().x + "' y='" + this.origin().y + "' rx='" + this.rx() + "' ry='" + this.ry() + "' width='" + this.size().width + "' height='" + this.size().height + "' " + this.renderStroke() + " " + this.renderFill() + " " + this.renderDefinitions() + " " + this.renderTransform() + this.renderClassName() + " " + this.renderRole() + this.renderAriaLabel() + " " + this.renderAriaRoleDescription() + this.renderAriaChecked() + " />";
  };
  return RectNode3;
}(path_node_default);
var rect_node_default = RectNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/text-node.js
var ENTITY_REGEX = /&(?:[a-zA-Z]+|#\d+);/g;
function decodeEntities(text) {
  if (!text || typeof text !== "string" || !ENTITY_REGEX.test(text)) {
    return text;
  }
  var element = decodeEntities._element;
  ENTITY_REGEX.lastIndex = 0;
  return text.replace(ENTITY_REGEX, function(match2) {
    element.innerHTML = match2;
    return element.textContent || element.innerText;
  });
}
if (typeof document !== "undefined") {
  decodeEntities._element = document.createElement("span");
}
var TextNode = function(PathNode3) {
  function TextNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3) TextNode3.__proto__ = PathNode3;
  TextNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  TextNode3.prototype.constructor = TextNode3;
  TextNode3.prototype.geometryChange = function geometryChange() {
    var pos = this.pos();
    this.attr("x", pos.x);
    this.attr("y", pos.y);
    this.invalidate();
  };
  TextNode3.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "font") {
      this.attr("style", renderStyle(this.mapStyle()));
      this.geometryChange();
    } else if (e.field === "content") {
      PathNode3.prototype.content.call(this, this.srcElement.content());
    }
    PathNode3.prototype.optionsChange.call(this, e);
  };
  TextNode3.prototype.mapStyle = function mapStyle(encode) {
    var style2 = PathNode3.prototype.mapStyle.call(this, encode);
    var font = this.srcElement.options.font;
    if (encode) {
      font = htmlEncode(font);
    }
    style2.push(["font", font], ["white-space", "pre"]);
    return style2;
  };
  TextNode3.prototype.pos = function pos() {
    var pos2 = this.srcElement.position();
    var size = this.srcElement.measure();
    return pos2.clone().setY(pos2.y + size.baseline);
  };
  TextNode3.prototype.renderContent = function renderContent() {
    var content = this.srcElement.content();
    content = decodeEntities(content);
    content = htmlEncode(content);
    return normalizeText(content);
  };
  TextNode3.prototype.renderTextAnchor = function renderTextAnchor() {
    var anchor;
    if ((this.options || {}).rtl && !(support_default.browser.msie || support_default.browser.edge)) {
      anchor = "end";
    }
    return renderAttr("text-anchor", anchor);
  };
  TextNode3.prototype.renderPaintOrder = function renderPaintOrder() {
    var paintOrder = this.srcElement.options.paintOrder;
    return paintOrder ? renderAttr("paint-order", paintOrder) : "";
  };
  TextNode3.prototype.template = function template2() {
    return "<text " + this.renderId() + " " + this.renderTextAnchor() + " " + this.renderStyle() + " " + this.renderOpacity() + "x='" + this.pos().x + "' y='" + this.pos().y + "' " + this.renderStroke() + " " + this.renderTransform() + " " + this.renderDefinitions() + this.renderPaintOrder() + this.renderFill() + this.renderClassName() + " " + this.renderRole() + this.renderAriaLabel() + " " + this.renderAriaRoleDescription() + this.renderAriaChecked() + ">" + this.renderContent() + "</text>";
  };
  return TextNode3;
}(path_node_default);
var text_node_default = TextNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/surface.js
node_map_default.Arc = arc_node_default;
node_map_default.Circle = circle_node_default;
node_map_default.Group = group_node_default;
node_map_default.Image = image_node_default;
node_map_default.MultiPath = multi_path_node_default;
node_map_default.Path = path_node_default;
node_map_default.Rect = rect_node_default;
node_map_default.Text = text_node_default;
var RTL2 = "rtl";
function alignToScreen(element) {
  var ctm;
  try {
    ctm = element.getScreenCTM ? element.getScreenCTM() : null;
  } catch (e) {
  }
  if (ctm) {
    var left = -ctm.e % 1;
    var top = -ctm.f % 1;
    var style2 = element.style;
    if (left !== 0 || top !== 0) {
      style2.left = left + "px";
      style2.top = top + "px";
    }
  }
}
var Surface2 = function(BaseSurface) {
  function Surface5(element, options2) {
    BaseSurface.call(this, element, options2);
    this._root = new root_node_default(Object.assign({
      rtl: elementStyles(element, "direction").direction === RTL2
    }, this.options));
    render_svg_default(this.element, this._template(""));
    this._rootElement = this.element.firstElementChild;
    this._rootElement.style.width = "100%";
    this._rootElement.style.height = "100%";
    this._rootElement.style.overflow = "hidden";
    alignToScreen(this._rootElement);
    this._root.attachTo(this._rootElement);
    bindEvents(this.element, {
      click: this._click,
      mouseover: this._mouseenter,
      mouseout: this._mouseleave,
      mousemove: this._mousemove
    });
    this.resize();
  }
  if (BaseSurface) Surface5.__proto__ = BaseSurface;
  Surface5.prototype = Object.create(BaseSurface && BaseSurface.prototype);
  Surface5.prototype.constructor = Surface5;
  var prototypeAccessors = {
    type: {
      configurable: true
    }
  };
  prototypeAccessors.type.get = function() {
    return "svg";
  };
  Surface5.prototype.destroy = function destroy2() {
    if (this._root) {
      this._root.destroy();
      this._root = null;
      this._rootElement = null;
      unbindEvents(this.element, {
        click: this._click,
        mouseover: this._mouseenter,
        mouseout: this._mouseleave,
        mousemove: this._mousemove
      });
    }
    BaseSurface.prototype.destroy.call(this);
  };
  Surface5.prototype.translate = function translate(offset) {
    var viewBox = Math.round(offset.x) + " " + Math.round(offset.y) + " " + this._size.width + " " + this._size.height;
    this._offset = offset;
    this._rootElement.setAttribute("viewBox", viewBox);
  };
  Surface5.prototype.draw = function draw(element) {
    BaseSurface.prototype.draw.call(this, element);
    this._root.load([element]);
  };
  Surface5.prototype.clear = function clear2() {
    BaseSurface.prototype.clear.call(this);
    this._root.clear();
  };
  Surface5.prototype.svg = function svg() {
    return "<?xml version='1.0' ?>" + this._template();
  };
  Surface5.prototype.exportVisual = function exportVisual() {
    var ref = this;
    var visual = ref._visual;
    var offset = ref._offset;
    if (offset) {
      var wrap2 = new group_default();
      wrap2.children.push(visual);
      wrap2.transform(transform().translate(-offset.x, -offset.y));
      visual = wrap2;
    }
    return visual;
  };
  Surface5.prototype._resize = function _resize() {
    if (this._offset) {
      this.translate(this._offset);
    }
  };
  Surface5.prototype._template = function _template(svgStyles) {
    var styles = typeof svgStyles === "string" ? svgStyles : "style='width: 100%; height: 100%; overflow: hidden;' ";
    return "<svg " + styles + "xmlns='" + SVG_NS + "' xmlns:xlink='http://www.w3.org/1999/xlink' version='1.1'>" + this._root.render() + "</svg>";
  };
  Object.defineProperties(Surface5.prototype, prototypeAccessors);
  return Surface5;
}(surface_default);
var surface_default2 = Surface2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/node-map.js
var NODE_MAP2 = {};
var node_map_default2 = NODE_MAP2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/node.js
var Node3 = function(BaseNode2) {
  function Node4(srcElement) {
    BaseNode2.call(this, srcElement);
    if (srcElement) {
      this.initClip();
    }
  }
  if (BaseNode2) Node4.__proto__ = BaseNode2;
  Node4.prototype = Object.create(BaseNode2 && BaseNode2.prototype);
  Node4.prototype.constructor = Node4;
  Node4.prototype.initClip = function initClip() {
    var clip = this.srcElement.clip();
    if (clip) {
      this.clip = clip;
      clip.addObserver(this);
    }
  };
  Node4.prototype.clear = function clear2() {
    if (this.srcElement) {
      this.srcElement.removeObserver(this);
    }
    this.clearClip();
    BaseNode2.prototype.clear.call(this);
  };
  Node4.prototype.clearClip = function clearClip() {
    if (this.clip) {
      this.clip.removeObserver(this);
      delete this.clip;
    }
  };
  Node4.prototype.setClip = function setClip(ctx) {
    if (this.clip) {
      ctx.beginPath();
      var clipNode = new node_map_default2[this.clip.nodeType](this.clip);
      clipNode.renderPoints(ctx, this.clip);
      ctx.clip("evenodd");
    }
  };
  Node4.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "clip") {
      this.clearClip();
      this.initClip();
    }
    BaseNode2.prototype.optionsChange.call(this, e);
  };
  Node4.prototype.setTransform = function setTransform2(ctx) {
    if (this.srcElement) {
      var transform3 = this.srcElement.transform();
      if (transform3) {
        ctx.transform.apply(ctx, transform3.matrix().toArray(6));
      }
    }
  };
  Node4.prototype.loadElements = function loadElements(elements, pos, cors) {
    var this$1 = this;
    for (var i = 0; i < elements.length; i++) {
      var srcElement = elements[i];
      var children = srcElement.children;
      var childNode = new node_map_default2[srcElement.nodeType](srcElement, cors);
      if (children && children.length > 0) {
        childNode.load(children, pos, cors);
      }
      if (defined(pos)) {
        this$1.insertAt(childNode, pos);
      } else {
        this$1.append(childNode);
      }
    }
  };
  Node4.prototype.load = function load3(elements, pos, cors) {
    this.loadElements(elements, pos, cors);
    this.invalidate();
  };
  Node4.prototype.setOpacity = function setOpacity(ctx) {
    if (this.srcElement) {
      var opacity = this.srcElement.opacity();
      if (defined(opacity)) {
        this.globalAlpha(ctx, opacity);
      }
    }
  };
  Node4.prototype.globalAlpha = function globalAlpha(ctx, value) {
    var opactity = value;
    if (opactity && ctx.globalAlpha) {
      opactity *= ctx.globalAlpha;
    }
    ctx.globalAlpha = opactity;
  };
  Node4.prototype.visible = function visible() {
    var src = this.srcElement;
    return !src || src && src.options.visible !== false;
  };
  return Node4;
}(base_node_default);
var node_default2 = Node3;

// node_modules/@progress/kendo-drawing/dist/es/canvas/group-node.js
var GroupNode2 = function(superclass) {
  function GroupNode3() {
    superclass.apply(this, arguments);
  }
  if (superclass) GroupNode3.__proto__ = superclass;
  GroupNode3.prototype = Object.create(superclass && superclass.prototype);
  GroupNode3.prototype.constructor = GroupNode3;
  GroupNode3.prototype.renderTo = function renderTo(ctx) {
    if (!this.visible()) {
      return;
    }
    ctx.save();
    this.setTransform(ctx);
    this.setClip(ctx);
    this.setOpacity(ctx);
    var childNodes = this.childNodes;
    for (var i = 0; i < childNodes.length; i++) {
      var child = childNodes[i];
      if (child.visible()) {
        child.renderTo(ctx);
      }
    }
    ctx.restore();
  };
  return GroupNode3;
}(traversable_default(node_default2, "childNodes"));
var group_node_default2 = GroupNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/root-node.js
var FRAME_DELAY = 1e3 / 60;
var RootNode2 = function(superclass) {
  function RootNode3(canvas, size) {
    superclass.call(this);
    this.canvas = canvas;
    this.size = size;
    this.ctx = canvas.getContext("2d");
    var invalidateHandler = this._invalidate.bind(this);
    this.invalidate = throttle(function() {
      animation_frame_default(invalidateHandler);
    }, FRAME_DELAY);
  }
  if (superclass) RootNode3.__proto__ = superclass;
  RootNode3.prototype = Object.create(superclass && superclass.prototype);
  RootNode3.prototype.constructor = RootNode3;
  RootNode3.prototype.destroy = function destroy2() {
    superclass.prototype.destroy.call(this);
    this.canvas = null;
    this.ctx = null;
  };
  RootNode3.prototype.load = function load3(elements, pos, cors) {
    this.loadElements(elements, pos, cors);
    this._invalidate();
  };
  RootNode3.prototype._rescale = function _rescale(scale) {
    var ref = this;
    var canvas = ref.canvas;
    var size = ref.size;
    canvas.width = size.width * scale;
    canvas.height = size.height * scale;
    this.ctx.scale(scale, scale);
  };
  RootNode3.prototype._devicePixelRatio = function _devicePixelRatio() {
    if (typeof window.devicePixelRatio === "number") {
      return window.devicePixelRatio;
    }
    return 1;
  };
  RootNode3.prototype._invalidate = function _invalidate(options2) {
    if (!this.ctx) {
      return;
    }
    var fixedScale = options2 && options2.fixedScale;
    var scale = fixedScale ? 1 : this._devicePixelRatio();
    this._rescale(scale);
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.renderTo(this.ctx);
  };
  return RootNode3;
}(traversable_default(group_node_default2, "childNodes"));
var root_node_default2 = RootNode2;

// node_modules/@progress/kendo-drawing/dist/es/search/quad-root.js
var QuadRoot = function(Class3) {
  function QuadRoot2() {
    Class3.call(this);
    this.shapes = [];
  }
  if (Class3) QuadRoot2.__proto__ = Class3;
  QuadRoot2.prototype = Object.create(Class3 && Class3.prototype);
  QuadRoot2.prototype.constructor = QuadRoot2;
  QuadRoot2.prototype._add = function _add(shape, bbox) {
    this.shapes.push({
      bbox,
      shape
    });
    shape._quadNode = this;
  };
  QuadRoot2.prototype.pointShapes = function pointShapes(point2) {
    var shapes = this.shapes;
    var length = shapes.length;
    var result = [];
    for (var idx2 = 0; idx2 < length; idx2++) {
      if (shapes[idx2].bbox.containsPoint(point2)) {
        result.push(shapes[idx2].shape);
      }
    }
    return result;
  };
  QuadRoot2.prototype.insert = function insert(shape, bbox) {
    this._add(shape, bbox);
  };
  QuadRoot2.prototype.remove = function remove(shape) {
    var shapes = this.shapes;
    var length = shapes.length;
    for (var idx2 = 0; idx2 < length; idx2++) {
      if (shapes[idx2].shape === shape) {
        shapes.splice(idx2, 1);
        break;
      }
    }
  };
  return QuadRoot2;
}(class_default);
var quad_root_default = QuadRoot;

// node_modules/@progress/kendo-drawing/dist/es/search/quad-node.js
var QuadNode = function(QuadRoot2) {
  function QuadNode2(rect) {
    QuadRoot2.call(this);
    this.children = [];
    this.rect = rect;
  }
  if (QuadRoot2) QuadNode2.__proto__ = QuadRoot2;
  QuadNode2.prototype = Object.create(QuadRoot2 && QuadRoot2.prototype);
  QuadNode2.prototype.constructor = QuadNode2;
  QuadNode2.prototype.inBounds = function inBounds(rect) {
    var nodeRect = this.rect;
    var nodeBottomRight = nodeRect.bottomRight();
    var bottomRight = rect.bottomRight();
    var inBounds2 = nodeRect.origin.x <= rect.origin.x && nodeRect.origin.y <= rect.origin.y && bottomRight.x <= nodeBottomRight.x && bottomRight.y <= nodeBottomRight.y;
    return inBounds2;
  };
  QuadNode2.prototype.pointShapes = function pointShapes(point2) {
    var children = this.children;
    var length = children.length;
    var result = QuadRoot2.prototype.pointShapes.call(this, point2);
    for (var idx2 = 0; idx2 < length; idx2++) {
      append(result, children[idx2].pointShapes(point2));
    }
    return result;
  };
  QuadNode2.prototype.insert = function insert(shape, bbox) {
    var children = this.children;
    var inserted = false;
    if (this.inBounds(bbox)) {
      if (this.shapes.length < 4) {
        this._add(shape, bbox);
      } else {
        if (!children.length) {
          this._initChildren();
        }
        for (var idx2 = 0; idx2 < children.length; idx2++) {
          if (children[idx2].insert(shape, bbox)) {
            inserted = true;
            break;
          }
        }
        if (!inserted) {
          this._add(shape, bbox);
        }
      }
      inserted = true;
    }
    return inserted;
  };
  QuadNode2.prototype._initChildren = function _initChildren() {
    var ref = this;
    var rect = ref.rect;
    var children = ref.children;
    var center = rect.center();
    var halfWidth = rect.width() / 2;
    var halfHeight = rect.height() / 2;
    children.push(new QuadNode2(new rect_default([rect.origin.x, rect.origin.y], [halfWidth, halfHeight])), new QuadNode2(new rect_default([center.x, rect.origin.y], [halfWidth, halfHeight])), new QuadNode2(new rect_default([rect.origin.x, center.y], [halfWidth, halfHeight])), new QuadNode2(new rect_default([center.x, center.y], [halfWidth, halfHeight])));
  };
  return QuadNode2;
}(quad_root_default);
var quad_node_default = QuadNode;

// node_modules/@progress/kendo-drawing/dist/es/search/shapes-quad-tree.js
var ROOT_SIZE = 3e3;
var LEVEL_STEP = 1e4;
var MAX_LEVEL = 75;
var ShapesQuadTree = function(Class3) {
  function ShapesQuadTree2() {
    Class3.call(this);
    this.initRoots();
  }
  if (Class3) ShapesQuadTree2.__proto__ = Class3;
  ShapesQuadTree2.prototype = Object.create(Class3 && Class3.prototype);
  ShapesQuadTree2.prototype.constructor = ShapesQuadTree2;
  ShapesQuadTree2.prototype.initRoots = function initRoots() {
    this.rootMap = {};
    this.root = new quad_root_default();
    this.rootElements = [];
  };
  ShapesQuadTree2.prototype.clear = function clear2() {
    var this$1 = this;
    var rootElements = this.rootElements;
    for (var idx2 = 0; idx2 < rootElements.length; idx2++) {
      this$1.remove(rootElements[idx2]);
    }
    this.initRoots();
  };
  ShapesQuadTree2.prototype.pointShape = function pointShape(point2) {
    var sectorRoot = (this.rootMap[Math.floor(point2.x / ROOT_SIZE)] || {})[Math.floor(point2.y / ROOT_SIZE)];
    var result = this.root.pointShapes(point2);
    if (sectorRoot) {
      result = result.concat(sectorRoot.pointShapes(point2));
    }
    this.assignZindex(result);
    result.sort(zIndexComparer);
    for (var idx2 = 0; idx2 < result.length; idx2++) {
      if (result[idx2].containsPoint(point2)) {
        return result[idx2];
      }
    }
  };
  ShapesQuadTree2.prototype.assignZindex = function assignZindex(elements) {
    var this$1 = this;
    for (var idx2 = 0; idx2 < elements.length; idx2++) {
      var element = elements[idx2];
      var zIndex = 0;
      var levelWeight = Math.pow(LEVEL_STEP, MAX_LEVEL);
      var parents = [];
      while (element) {
        parents.push(element);
        element = element.parent;
      }
      while (parents.length) {
        element = parents.pop();
        zIndex += ((element.parent ? element.parent.children : this$1.rootElements).indexOf(element) + 1) * levelWeight;
        levelWeight /= LEVEL_STEP;
      }
      elements[idx2]._zIndex = zIndex;
    }
  };
  ShapesQuadTree2.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "transform" || e.field === "stroke.width") {
      this.bboxChange(e.element);
    }
  };
  ShapesQuadTree2.prototype.geometryChange = function geometryChange(e) {
    this.bboxChange(e.element);
  };
  ShapesQuadTree2.prototype.bboxChange = function bboxChange(element) {
    var this$1 = this;
    if (element.nodeType === "Group") {
      for (var idx2 = 0; idx2 < element.children.length; idx2++) {
        this$1.bboxChange(element.children[idx2]);
      }
    } else {
      if (element._quadNode) {
        element._quadNode.remove(element);
      }
      this._insertShape(element);
    }
  };
  ShapesQuadTree2.prototype.add = function add2(elements) {
    var elementsArray = Array.isArray(elements) ? elements.slice(0) : [elements];
    append(this.rootElements, elementsArray);
    this._insert(elementsArray);
  };
  ShapesQuadTree2.prototype.childrenChange = function childrenChange(e) {
    var this$1 = this;
    if (e.action === "remove") {
      for (var idx2 = 0; idx2 < e.items.length; idx2++) {
        this$1.remove(e.items[idx2]);
      }
    } else {
      this._insert(Array.prototype.slice.call(e.items, 0));
    }
  };
  ShapesQuadTree2.prototype._insert = function _insert(elements) {
    var this$1 = this;
    var element;
    while (elements.length > 0) {
      element = elements.pop();
      element.addObserver(this$1);
      if (element.nodeType === "Group") {
        append(elements, element.children);
      } else {
        this$1._insertShape(element);
      }
    }
  };
  ShapesQuadTree2.prototype._insertShape = function _insertShape(shape) {
    var bbox = shape.bbox();
    if (bbox) {
      var sectors = this.getSectors(bbox);
      var x = sectors[0][0];
      var y = sectors[1][0];
      if (this.inRoot(sectors)) {
        this.root.insert(shape, bbox);
      } else {
        var rootMap = this.rootMap;
        if (!rootMap[x]) {
          rootMap[x] = {};
        }
        if (!rootMap[x][y]) {
          rootMap[x][y] = new quad_node_default(new rect_default([x * ROOT_SIZE, y * ROOT_SIZE], [ROOT_SIZE, ROOT_SIZE]));
        }
        rootMap[x][y].insert(shape, bbox);
      }
    }
  };
  ShapesQuadTree2.prototype.remove = function remove(element) {
    var this$1 = this;
    element.removeObserver(this);
    if (element.nodeType === "Group") {
      var children = element.children;
      for (var idx2 = 0; idx2 < children.length; idx2++) {
        this$1.remove(children[idx2]);
      }
    } else if (element._quadNode) {
      element._quadNode.remove(element);
      delete element._quadNode;
    }
  };
  ShapesQuadTree2.prototype.inRoot = function inRoot(sectors) {
    return sectors[0].length > 1 || sectors[1].length > 1;
  };
  ShapesQuadTree2.prototype.getSectors = function getSectors(rect) {
    var bottomRight = rect.bottomRight();
    var bottomX = Math.floor(bottomRight.x / ROOT_SIZE);
    var bottomY = Math.floor(bottomRight.y / ROOT_SIZE);
    var sectors = [[], []];
    for (var x = Math.floor(rect.origin.x / ROOT_SIZE); x <= bottomX; x++) {
      sectors[0].push(x);
    }
    for (var y = Math.floor(rect.origin.y / ROOT_SIZE); y <= bottomY; y++) {
      sectors[1].push(y);
    }
    return sectors;
  };
  return ShapesQuadTree2;
}(class_default);
function zIndexComparer(x1, x2) {
  if (x1._zIndex < x2._zIndex) {
    return 1;
  }
  if (x1._zIndex > x2._zIndex) {
    return -1;
  }
  return 0;
}
var shapes_quad_tree_default = ShapesQuadTree;

// node_modules/@progress/kendo-drawing/dist/es/canvas/surface-cursor.js
var SurfaceCursor = function SurfaceCursor2(surface) {
  surface.bind("mouseenter", this._mouseenter.bind(this));
  surface.bind("mouseleave", this._mouseleave.bind(this));
  this.element = surface.element;
};
SurfaceCursor.prototype.clear = function clear() {
  this._resetCursor();
};
SurfaceCursor.prototype.destroy = function destroy() {
  this._resetCursor();
  delete this.element;
};
SurfaceCursor.prototype._mouseenter = function _mouseenter(e) {
  var cursor = this._shapeCursor(e);
  if (!cursor) {
    this._resetCursor();
  } else {
    if (!this._current) {
      this._defaultCursor = this._getCursor();
    }
    this._setCursor(cursor);
  }
};
SurfaceCursor.prototype._mouseleave = function _mouseleave() {
  this._resetCursor();
};
SurfaceCursor.prototype._shapeCursor = function _shapeCursor(e) {
  var shape = e.element;
  while (shape && !defined(shape.options.cursor)) {
    shape = shape.parent;
  }
  if (shape) {
    return shape.options.cursor;
  }
};
SurfaceCursor.prototype._getCursor = function _getCursor() {
  if (this.element) {
    return this.element.style.cursor;
  }
};
SurfaceCursor.prototype._setCursor = function _setCursor(cursor) {
  if (this.element) {
    this.element.style.cursor = cursor;
    this._current = cursor;
  }
};
SurfaceCursor.prototype._resetCursor = function _resetCursor() {
  if (this._current) {
    this._setCursor(this._defaultCursor || "");
    delete this._current;
  }
};
var surface_cursor_default = SurfaceCursor;

// node_modules/@progress/kendo-drawing/dist/es/canvas/utils/render-path.js
function renderPath(ctx, path) {
  var segments = path.segments;
  if (segments.length === 0) {
    return;
  }
  var segment = segments[0];
  var anchor = segment.anchor();
  ctx.moveTo(anchor.x, anchor.y);
  for (var i = 1; i < segments.length; i++) {
    segment = segments[i];
    anchor = segment.anchor();
    var prevSeg = segments[i - 1];
    var prevOut = prevSeg.controlOut();
    var controlIn = segment.controlIn();
    if (prevOut && controlIn) {
      ctx.bezierCurveTo(prevOut.x, prevOut.y, controlIn.x, controlIn.y, anchor.x, anchor.y);
    } else {
      ctx.lineTo(anchor.x, anchor.y);
    }
  }
  if (path.options.closed) {
    ctx.closePath();
  }
}

// node_modules/@progress/kendo-drawing/dist/es/canvas/path-node.js
function addGradientStops(gradient, stops) {
  for (var idx2 = 0; idx2 < stops.length; idx2++) {
    var stop = stops[idx2];
    var color = parseColor(stop.color());
    color.a *= stop.opacity();
    gradient.addColorStop(stop.offset(), color.toCssRgba());
  }
}
var PathNode2 = function(Node4) {
  function PathNode3() {
    Node4.apply(this, arguments);
  }
  if (Node4) PathNode3.__proto__ = Node4;
  PathNode3.prototype = Object.create(Node4 && Node4.prototype);
  PathNode3.prototype.constructor = PathNode3;
  PathNode3.prototype.renderTo = function renderTo(ctx) {
    ctx.save();
    this.setTransform(ctx);
    this.setClip(ctx);
    this.setOpacity(ctx);
    ctx.beginPath();
    this.renderPoints(ctx, this.srcElement);
    this.setLineDash(ctx);
    this.setLineCap(ctx);
    this.setLineJoin(ctx);
    this.setFill(ctx);
    this.setStroke(ctx);
    ctx.restore();
  };
  PathNode3.prototype.setFill = function setFill(ctx) {
    var fill = this.srcElement.options.fill;
    var hasFill = false;
    if (fill) {
      if (fill.nodeType === "Gradient") {
        this.setGradientFill(ctx, fill);
        hasFill = true;
      } else if (fill.nodeType === PATTERN) {
        this.setPatternFill(ctx, fill);
        hasFill = true;
      } else if (!isTransparent(fill.color)) {
        ctx.fillStyle = fill.color;
        ctx.save();
        this.globalAlpha(ctx, fill.opacity);
        ctx.fill();
        ctx.restore();
        hasFill = true;
      }
    }
    return hasFill;
  };
  PathNode3.prototype.setGradientFill = function setGradientFill(ctx, fill) {
    var bbox = this.srcElement.rawBBox();
    var gradient;
    if (fill instanceof linear_gradient_default) {
      var start = fill.start();
      var end = fill.end();
      gradient = ctx.createLinearGradient(start.x, start.y, end.x, end.y);
    } else if (fill instanceof radial_gradient_default) {
      var center = fill.center();
      gradient = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, fill.radius());
    }
    addGradientStops(gradient, fill.stops);
    ctx.save();
    if (!fill.userSpace()) {
      ctx.transform(bbox.width(), 0, 0, bbox.height(), bbox.origin.x, bbox.origin.y);
    }
    ctx.fillStyle = gradient;
    ctx.fill();
    ctx.restore();
  };
  PathNode3.prototype.setPatternFill = function setPatternFill(ctx, pattern) {
    var size = pattern.size();
    var patternCanvas = document.createElement("canvas");
    var patternContext = patternCanvas.getContext("2d");
    patternCanvas.width = size.getWidth();
    patternCanvas.height = size.getHeight();
    this.childNodes.length = 0;
    this.loadElements(pattern.children);
    var childNodes = this.childNodes;
    for (var i = 0; i < childNodes.length; i++) {
      var child = childNodes[i];
      child.renderTo(patternContext);
    }
    ctx.save();
    ctx.fillStyle = ctx.createPattern(patternCanvas, "repeat");
    ctx.fill();
    ctx.restore();
  };
  PathNode3.prototype.setStroke = function setStroke(ctx) {
    var stroke = this.srcElement.options.stroke;
    if (stroke && !isTransparent(stroke.color) && stroke.width > 0) {
      ctx.strokeStyle = stroke.color;
      ctx.lineWidth = valueOrDefault(stroke.width, 1);
      ctx.lineJoin = valueOrDefault(stroke.lineJoin, ctx.lineJoin);
      ctx.save();
      this.globalAlpha(ctx, stroke.opacity);
      ctx.stroke();
      ctx.restore();
      return true;
    }
  };
  PathNode3.prototype.dashType = function dashType() {
    var stroke = this.srcElement.options.stroke;
    if (stroke && stroke.dashType) {
      return stroke.dashType.toLowerCase();
    }
  };
  PathNode3.prototype.setLineDash = function setLineDash(ctx) {
    var dashType = this.dashType();
    if (dashType && dashType !== SOLID) {
      var dashArray = DASH_ARRAYS[dashType];
      if (ctx.setLineDash) {
        ctx.setLineDash(dashArray);
      } else {
        ctx.mozDash = dashArray;
        ctx.webkitLineDash = dashArray;
      }
    }
  };
  PathNode3.prototype.setLineCap = function setLineCap(ctx) {
    var dashType = this.dashType();
    var stroke = this.srcElement.options.stroke;
    if (dashType && dashType !== SOLID) {
      ctx.lineCap = BUTT;
    } else if (stroke && stroke.lineCap) {
      ctx.lineCap = stroke.lineCap;
    }
  };
  PathNode3.prototype.setLineJoin = function setLineJoin(ctx) {
    var stroke = this.srcElement.options.stroke;
    if (stroke && stroke.lineJoin) {
      ctx.lineJoin = stroke.lineJoin;
    }
  };
  PathNode3.prototype.renderPoints = function renderPoints(ctx, path) {
    renderPath(ctx, path);
  };
  return PathNode3;
}(node_default2);
var path_node_default2 = PathNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/arc-node.js
var ArcNode2 = function(PathNode3) {
  function ArcNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3) ArcNode3.__proto__ = PathNode3;
  ArcNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  ArcNode3.prototype.constructor = ArcNode3;
  ArcNode3.prototype.renderPoints = function renderPoints(ctx) {
    var path = this.srcElement.toPath();
    renderPath(ctx, path);
  };
  return ArcNode3;
}(path_node_default2);
var arc_node_default2 = ArcNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/circle-node.js
var CircleNode2 = function(PathNode3) {
  function CircleNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3) CircleNode3.__proto__ = PathNode3;
  CircleNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  CircleNode3.prototype.constructor = CircleNode3;
  CircleNode3.prototype.renderPoints = function renderPoints(ctx) {
    var ref = this.srcElement.geometry();
    var center = ref.center;
    var radius = ref.radius;
    ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
  };
  return CircleNode3;
}(path_node_default2);
var circle_node_default2 = CircleNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/image-node.js
var ImageNode2 = function(PathNode3) {
  function ImageNode3(srcElement, cors) {
    PathNode3.call(this, srcElement);
    this.onLoad = this.onLoad.bind(this);
    this.onError = this.onError.bind(this);
    this.loading = createPromise();
    var img = this.img = new Image();
    var src = srcElement.src();
    if (cors && !/^data:/i.test(src)) {
      img.crossOrigin = cors;
    }
    if (src) {
      img.src = src;
    }
    if (img.complete) {
      this.onLoad();
    } else {
      img.onload = this.onLoad;
      img.onerror = this.onError;
    }
  }
  if (PathNode3) ImageNode3.__proto__ = PathNode3;
  ImageNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  ImageNode3.prototype.constructor = ImageNode3;
  ImageNode3.prototype.renderTo = function renderTo(ctx) {
    if (this.loading.state() === "resolved") {
      ctx.save();
      this.setTransform(ctx);
      this.setClip(ctx);
      this.drawImage(ctx);
      ctx.restore();
    }
  };
  ImageNode3.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "src") {
      this.loading = createPromise();
      this.img.src = this.srcElement.src();
    } else {
      PathNode3.prototype.optionsChange.call(this, e);
    }
  };
  ImageNode3.prototype.onLoad = function onLoad() {
    this.loading.resolve();
    this.invalidate();
  };
  ImageNode3.prototype.onError = function onError() {
    this.loading.reject(new Error("Unable to load image '" + this.img.src + "'. Check for connectivity and verify CORS headers."));
  };
  ImageNode3.prototype.drawImage = function drawImage2(ctx) {
    var rect = this.srcElement.rect();
    var topLeft = rect.topLeft();
    ctx.drawImage(this.img, topLeft.x, topLeft.y, rect.width(), rect.height());
  };
  return ImageNode3;
}(path_node_default2);
var image_node_default2 = ImageNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/multi-path-node.js
var MultiPathNode2 = function(PathNode3) {
  function MultiPathNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3) MultiPathNode3.__proto__ = PathNode3;
  MultiPathNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  MultiPathNode3.prototype.constructor = MultiPathNode3;
  MultiPathNode3.prototype.renderPoints = function renderPoints(ctx) {
    var paths = this.srcElement.paths;
    for (var i = 0; i < paths.length; i++) {
      renderPath(ctx, paths[i]);
    }
  };
  return MultiPathNode3;
}(path_node_default2);
var multi_path_node_default2 = MultiPathNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/rect-node.js
var RectNode2 = function(PathNode3) {
  function RectNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3) RectNode3.__proto__ = PathNode3;
  RectNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  RectNode3.prototype.constructor = RectNode3;
  RectNode3.prototype.renderPoints = function renderPoints(ctx) {
    var geometry = this.srcElement.geometry();
    var ref = geometry.cornerRadius;
    var rx = ref[0];
    var ry = ref[1];
    if (rx === 0 && ry === 0) {
      var origin = geometry.origin;
      var size = geometry.size;
      ctx.rect(origin.x, origin.y, size.width, size.height);
    } else {
      PathNode3.prototype.renderPoints.call(this, ctx, Path.fromRect(geometry));
    }
  };
  return RectNode3;
}(path_node_default2);
var rect_node_default2 = RectNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/text-node.js
var TextNode2 = function(PathNode3) {
  function TextNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3) TextNode3.__proto__ = PathNode3;
  TextNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  TextNode3.prototype.constructor = TextNode3;
  TextNode3.prototype.renderTo = function renderTo(ctx) {
    var text = this.srcElement;
    var pos = text.position();
    var size = text.measure();
    ctx.save();
    this.setTransform(ctx);
    this.setClip(ctx);
    this.setOpacity(ctx);
    ctx.beginPath();
    ctx.font = text.options.font;
    ctx.textAlign = "left";
    if (text.options.paintOrder === "stroke") {
      this.stroke(ctx, text, pos, size);
      this.fill(ctx, text, pos, size);
    } else {
      this.fill(ctx, text, pos, size);
      this.stroke(ctx, text, pos, size);
    }
    ctx.restore();
  };
  TextNode3.prototype.stroke = function stroke(ctx, text, pos, size) {
    if (this.setStroke(ctx)) {
      this.setLineDash(ctx);
      ctx.strokeText(text.content(), pos.x, pos.y + size.baseline);
    }
  };
  TextNode3.prototype.fill = function fill(ctx, text, pos, size) {
    if (this.setFill(ctx)) {
      ctx.fillText(text.content(), pos.x, pos.y + size.baseline);
    }
  };
  return TextNode3;
}(path_node_default2);
var text_node_default2 = TextNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/surface.js
node_map_default2.Arc = arc_node_default2;
node_map_default2.Circle = circle_node_default2;
node_map_default2.Group = group_node_default2;
node_map_default2.Image = image_node_default2;
node_map_default2.MultiPath = multi_path_node_default2;
node_map_default2.Path = path_node_default2;
node_map_default2.Rect = rect_node_default2;
node_map_default2.Text = text_node_default2;
var Surface3 = function(BaseSurface) {
  function Surface5(element, options2) {
    BaseSurface.call(this, element, options2);
    this.element.innerHTML = this._template(this);
    var canvas = this.element.firstElementChild;
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    var size = elementSize(element);
    canvas.width = size.width;
    canvas.height = size.height;
    this._rootElement = canvas;
    this._root = new root_node_default2(canvas, size);
    this._mouseTrackHandler = this._trackMouse.bind(this);
    bindEvents(this.element, {
      click: this._mouseTrackHandler,
      mousemove: this._mouseTrackHandler
    });
  }
  if (BaseSurface) Surface5.__proto__ = BaseSurface;
  Surface5.prototype = Object.create(BaseSurface && BaseSurface.prototype);
  Surface5.prototype.constructor = Surface5;
  var prototypeAccessors = {
    type: {
      configurable: true
    }
  };
  prototypeAccessors.type.get = function() {
    return "canvas";
  };
  Surface5.prototype.destroy = function destroy2() {
    BaseSurface.prototype.destroy.call(this);
    if (this._root) {
      this._root.destroy();
      this._root = null;
    }
    if (this._searchTree) {
      this._searchTree.clear();
      delete this._searchTree;
    }
    if (this._cursor) {
      this._cursor.destroy();
      delete this._cursor;
    }
    unbindEvents(this.element, {
      click: this._mouseTrackHandler,
      mousemove: this._mouseTrackHandler
    });
  };
  Surface5.prototype.draw = function draw(element) {
    BaseSurface.prototype.draw.call(this, element);
    this._root.load([element], void 0, this.options.cors);
    if (this._searchTree) {
      this._searchTree.add([element]);
    }
  };
  Surface5.prototype.clear = function clear2() {
    BaseSurface.prototype.clear.call(this);
    this._root.clear();
    if (this._searchTree) {
      this._searchTree.clear();
    }
    if (this._cursor) {
      this._cursor.clear();
    }
  };
  Surface5.prototype.eventTarget = function eventTarget(e) {
    if (this._searchTree) {
      var point2 = this._surfacePoint(e);
      var shape = this._searchTree.pointShape(point2);
      return shape;
    }
  };
  Surface5.prototype.image = function image() {
    var ref = this;
    var root = ref._root;
    var rootElement = ref._rootElement;
    var loadingStates = [];
    root.traverse(function(childNode) {
      if (childNode.loading) {
        loadingStates.push(childNode.loading);
      }
    });
    var promise = createPromise();
    var resolveDataURL = function() {
      root._invalidate({
        fixedScale: true
      });
      try {
        var data = rootElement.toDataURL();
        promise.resolve(data);
      } catch (e) {
        promise.reject(e);
      }
    };
    promiseAll(loadingStates).then(resolveDataURL, resolveDataURL);
    return promise;
  };
  Surface5.prototype.suspendTracking = function suspendTracking() {
    BaseSurface.prototype.suspendTracking.call(this);
    if (this._searchTree) {
      this._searchTree.clear();
      delete this._searchTree;
    }
  };
  Surface5.prototype.resumeTracking = function resumeTracking() {
    BaseSurface.prototype.resumeTracking.call(this);
    if (!this._searchTree) {
      this._searchTree = new shapes_quad_tree_default();
      var childNodes = this._root.childNodes;
      var rootElements = [];
      for (var idx2 = 0; idx2 < childNodes.length; idx2++) {
        rootElements.push(childNodes[idx2].srcElement);
      }
      this._searchTree.add(rootElements);
    }
  };
  Surface5.prototype._resize = function _resize() {
    this._rootElement.width = this._size.width;
    this._rootElement.height = this._size.height;
    this._root.size = this._size;
    this._root.invalidate();
  };
  Surface5.prototype._template = function _template() {
    return "<canvas></canvas>";
  };
  Surface5.prototype._enableTracking = function _enableTracking() {
    this._searchTree = new shapes_quad_tree_default();
    this._cursor = new surface_cursor_default(this);
    BaseSurface.prototype._enableTracking.call(this);
  };
  Surface5.prototype._trackMouse = function _trackMouse(e) {
    if (this._suspendedTracking) {
      return;
    }
    var shape = this.eventTarget(e);
    if (e.type !== "click") {
      var currentShape = this._currentShape;
      if (currentShape && currentShape !== shape) {
        this.trigger("mouseleave", {
          element: currentShape,
          originalEvent: e,
          type: "mouseleave"
        });
      }
      if (shape && currentShape !== shape) {
        this.trigger("mouseenter", {
          element: shape,
          originalEvent: e,
          type: "mouseenter"
        });
      }
      this.trigger("mousemove", {
        element: shape,
        originalEvent: e,
        type: "mousemove"
      });
      this._currentShape = shape;
    } else if (shape) {
      this.trigger("click", {
        element: shape,
        originalEvent: e,
        type: "click"
      });
    }
  };
  Object.defineProperties(Surface5.prototype, prototypeAccessors);
  return Surface5;
}(surface_default);
var surface_default3 = Surface3;

// node_modules/@progress/kendo-drawing/dist/es/surface-factory.js
var instance3;
var support2;
var hasDocument = function() {
  return typeof document !== "undefined";
};
var supportsCanvas = function() {
  return hasDocument() && document.createElement("canvas").getContext;
};
var supportsSVG = function() {
  return hasDocument() && document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
};
var SurfaceFactory = function(Class3) {
  function SurfaceFactory2() {
    Class3.call(this);
    this._items = [{
      name: "svg",
      type: surface_default2
    }, {
      name: "canvas",
      type: surface_default3
    }];
  }
  if (Class3) SurfaceFactory2.__proto__ = Class3;
  SurfaceFactory2.prototype = Object.create(Class3 && Class3.prototype);
  SurfaceFactory2.prototype.constructor = SurfaceFactory2;
  var staticAccessors = {
    support: {
      configurable: true
    },
    current: {
      configurable: true
    }
  };
  staticAccessors.support.get = function() {
    if (!support2) {
      support2 = {
        canvas: supportsCanvas(),
        svg: supportsSVG()
      };
    }
    return support2;
  };
  staticAccessors.current.get = function() {
    if (!instance3) {
      instance3 = new SurfaceFactory2();
    }
    return instance3;
  };
  SurfaceFactory2.prototype.create = function create(element, options2) {
    var items = this._items;
    var match2 = items[0];
    if (options2 && options2.type) {
      var preferred = options2.type.toLowerCase();
      for (var i = 0; i < items.length; i++) {
        if (items[i].name === preferred) {
          match2 = items[i];
          break;
        }
      }
    }
    if (match2) {
      return new match2.type(element, options2);
    }
    logToConsole("Warning: Unable to create Kendo UI Drawing Surface. Possible causes:\n- The browser does not support SVG and Canvas. User agent: " + navigator.userAgent);
  };
  Object.defineProperties(SurfaceFactory2, staticAccessors);
  return SurfaceFactory2;
}(class_default);
var surface_factory_default = SurfaceFactory;

// node_modules/@progress/kendo-drawing/dist/es/surface.js
var Surface4 = function(BaseSurface) {
  function Surface5() {
    BaseSurface.apply(this, arguments);
  }
  if (BaseSurface) Surface5.__proto__ = BaseSurface;
  Surface5.prototype = Object.create(BaseSurface && BaseSurface.prototype);
  Surface5.prototype.constructor = Surface5;
  var staticAccessors = {
    support: {
      configurable: true
    }
  };
  staticAccessors.support.get = function() {
    return surface_factory_default.support;
  };
  Surface5.create = function create(element, options2) {
    return surface_factory_default.current.create(element, options2);
  };
  Object.defineProperties(Surface5, staticAccessors);
  return Surface5;
}(surface_default);
var surface_default4 = Surface4;

// node_modules/@progress/kendo-drawing/dist/es/svg.js
var svg_exports = {};
__export(svg_exports, {
  ArcNode: () => arc_node_default,
  CircleNode: () => circle_node_default,
  ClipNode: () => clip_node_default,
  DefinitionNode: () => definition_node_default,
  GradientStopNode: () => gradient_stop_node_default,
  GroupNode: () => group_node_default,
  ImageNode: () => image_node_default,
  LinearGradientNode: () => linear_gradient_node_default,
  MultiPathNode: () => multi_path_node_default,
  Node: () => node_default,
  PathNode: () => path_node_default,
  RadialGradientNode: () => radial_gradient_node_default,
  RectNode: () => rect_node_default,
  RootNode: () => root_node_default,
  Surface: () => surface_default2,
  TextNode: () => text_node_default,
  exportGroup: () => exportGroup
});

// node_modules/@progress/kendo-drawing/dist/es/svg/export-group.js
function exportGroup(group) {
  var root = new root_node_default({
    skipBaseHref: true
  });
  var bbox = group.clippedBBox();
  var rootGroup = group;
  if (bbox) {
    var origin = bbox.getOrigin();
    var exportRoot = new group_default();
    exportRoot.transform(transform().translate(-origin.x, -origin.y));
    exportRoot.children.push(group);
    rootGroup = exportRoot;
  }
  root.load([rootGroup]);
  var svg = "<?xml version='1.0' ?><svg xmlns='" + SVG_NS + "' xmlns:xlink='http://www.w3.org/1999/xlink' version='1.1'>" + root.render() + "</svg>";
  root.destroy();
  return svg;
}

// node_modules/@progress/kendo-drawing/dist/es/canvas.js
var canvas_exports = {};
__export(canvas_exports, {
  ArcNode: () => arc_node_default2,
  CircleNode: () => circle_node_default2,
  GroupNode: () => group_node_default2,
  ImageNode: () => image_node_default2,
  MultiPathNode: () => multi_path_node_default2,
  Node: () => node_default2,
  PathNode: () => path_node_default2,
  RectNode: () => rect_node_default2,
  RootNode: () => root_node_default2,
  Surface: () => surface_default3,
  TextNode: () => text_node_default2
});

// node_modules/@progress/kendo-drawing/dist/es/canvas/export-image.js
function exportImage(group, options2) {
  var defaults = {
    width: "800px",
    height: "600px",
    cors: "Anonymous"
  };
  var exportRoot = group;
  var bbox = group.clippedBBox();
  if (bbox) {
    var origin = bbox.getOrigin();
    exportRoot = new group_default();
    exportRoot.transform(transform().translate(-origin.x, -origin.y));
    exportRoot.children.push(group);
    var size = bbox.getSize();
    defaults.width = size.width + "px";
    defaults.height = size.height + "px";
  }
  var surfaceOptions = Object.assign(defaults, options2);
  var container = document.createElement("div");
  var style2 = container.style;
  style2.display = "none";
  style2.width = surfaceOptions.width;
  style2.height = surfaceOptions.height;
  document.body.appendChild(container);
  var surface = new surface_default3(container, surfaceOptions);
  surface.suspendTracking();
  surface.draw(exportRoot);
  var promise = surface.image();
  var destroy2 = function() {
    surface.destroy();
    document.body.removeChild(container);
  };
  promise.then(destroy2, destroy2);
  return promise;
}

// node_modules/@progress/kendo-drawing/dist/es/svg/export-svg.js
function exportSVG(group, options2) {
  var svg = exportGroup(group);
  if (!options2 || !options2.raw) {
    svg = "data:image/svg+xml;base64," + encodeBase64(svg);
  }
  return createPromise().resolve(svg);
}

// node_modules/@progress/kendo-drawing/dist/es/pdf/utils.js
var HAS_TYPED_ARRAYS = typeof Uint8Array !== "undefined" && support_default.browser && (!support_default.browser.msie || support_default.browser.version > 9);
var BASE64 = /* @__PURE__ */ function() {
  var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  return {
    decode: function(str) {
      var input = str.replace(/[^A-Za-z0-9\+\/\=]/g, ""), i = 0, n = input.length, output = [];
      while (i < n) {
        var enc1 = keyStr.indexOf(input.charAt(i++));
        var enc2 = keyStr.indexOf(input.charAt(i++));
        var enc3 = keyStr.indexOf(input.charAt(i++));
        var enc4 = keyStr.indexOf(input.charAt(i++));
        var chr1 = enc1 << 2 | enc2 >>> 4;
        var chr2 = (enc2 & 15) << 4 | enc3 >>> 2;
        var chr3 = (enc3 & 3) << 6 | enc4;
        output.push(chr1);
        if (enc3 != 64) {
          output.push(chr2);
        }
        if (enc4 != 64) {
          output.push(chr3);
        }
      }
      return output;
    },
    encode: function(bytes) {
      var i = 0, n = bytes.length;
      var output = "";
      while (i < n) {
        var chr1 = bytes[i++];
        var chr2 = bytes[i++];
        var chr3 = bytes[i++];
        var enc1 = chr1 >>> 2;
        var enc2 = (chr1 & 3) << 4 | chr2 >>> 4;
        var enc3 = (chr2 & 15) << 2 | chr3 >>> 6;
        var enc4 = chr3 & 63;
        if (i - n == 2) {
          enc3 = enc4 = 64;
        } else if (i - n == 1) {
          enc4 = 64;
        }
        output += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
      }
      return output;
    }
  };
}();
function BinaryStream(data) {
  var offset = 0, length = 0;
  if (data == null) {
    data = HAS_TYPED_ARRAYS ? new Uint8Array(256) : [];
  } else {
    length = data.length;
  }
  var ensure = HAS_TYPED_ARRAYS ? function(len) {
    if (len >= data.length) {
      var tmp = new Uint8Array(Math.max(len + 256, data.length * 2));
      tmp.set(data, 0);
      data = tmp;
    }
  } : function() {
  };
  var get = HAS_TYPED_ARRAYS ? function() {
    return new Uint8Array(data.buffer, 0, length);
  } : function() {
    return data;
  };
  var write = HAS_TYPED_ARRAYS ? function(bytes) {
    if (typeof bytes == "string") {
      return writeString(bytes);
    }
    var len = bytes.length;
    ensure(offset + len);
    data.set(bytes, offset);
    offset += len;
    if (offset > length) {
      length = offset;
    }
  } : function(bytes) {
    if (typeof bytes == "string") {
      return writeString(bytes);
    }
    for (var i = 0; i < bytes.length; ++i) {
      writeByte(bytes[i]);
    }
  };
  var slice3 = HAS_TYPED_ARRAYS ? function(start, length2) {
    if (data.buffer.slice) {
      return new Uint8Array(data.buffer.slice(start, start + length2));
    } else {
      var x = new Uint8Array(length2);
      x.set(new Uint8Array(data.buffer, start, length2));
      return x;
    }
  } : function(start, length2) {
    return data.slice(start, start + length2);
  };
  function eof() {
    return offset >= length;
  }
  function readByte() {
    return offset < length ? data[offset++] : 0;
  }
  function writeByte(b) {
    ensure(offset);
    data[offset++] = b & 255;
    if (offset > length) {
      length = offset;
    }
  }
  function readShort() {
    return readByte() << 8 | readByte();
  }
  function writeShort(w) {
    writeByte(w >> 8);
    writeByte(w);
  }
  function readShort_() {
    var w = readShort();
    return w >= 32768 ? w - 65536 : w;
  }
  function writeShort_(w) {
    writeShort(w < 0 ? w + 65536 : w);
  }
  function readLong() {
    return readShort() * 65536 + readShort();
  }
  function writeLong(w) {
    writeShort(w >>> 16 & 65535);
    writeShort(w & 65535);
  }
  function readLong_() {
    var w = readLong();
    return w >= 2147483648 ? w - 4294967296 : w;
  }
  function writeLong_(w) {
    writeLong(w < 0 ? w + 4294967296 : w);
  }
  function readFixed() {
    return readLong() / 65536;
  }
  function writeFixed(f) {
    writeLong(Math.round(f * 65536));
  }
  function readFixed_() {
    return readLong_() / 65536;
  }
  function writeFixed_(f) {
    writeLong_(Math.round(f * 65536));
  }
  function read(len) {
    return times(len, readByte);
  }
  function readString(len) {
    return String.fromCharCode.apply(String, read(len));
  }
  function writeString(str) {
    for (var i = 0; i < str.length; ++i) {
      writeByte(str.charCodeAt(i));
    }
  }
  function times(n, reader) {
    for (var ret = new Array(n), i = 0; i < n; ++i) {
      ret[i] = reader();
    }
    return ret;
  }
  var stream2 = {
    eof,
    readByte,
    writeByte,
    readShort,
    writeShort,
    readLong,
    writeLong,
    readFixed,
    writeFixed,
    // signed numbers.
    readShort_,
    writeShort_,
    readLong_,
    writeLong_,
    readFixed_,
    writeFixed_,
    read,
    write,
    readString,
    writeString,
    times,
    get,
    slice: slice3,
    offset: function(pos) {
      if (pos != null) {
        offset = pos;
        return stream2;
      }
      return offset;
    },
    skip: function(nbytes) {
      offset += nbytes;
    },
    toString: function() {
      throw new Error("FIX CALLER.  BinaryStream is no longer convertible to string!");
    },
    length: function() {
      return length;
    },
    saveExcursion: function(f) {
      var pos = offset;
      try {
        return f();
      } finally {
        offset = pos;
      }
    },
    writeBase64: function(base64) {
      if (window.atob) {
        writeString(window.atob(base64));
      } else {
        write(BASE64.decode(base64));
      }
    },
    base64: function() {
      return BASE64.encode(get());
    }
  };
  return stream2;
}
function ucs2decode(string) {
  var output = [], counter = 0, length = string.length, value, extra;
  while (counter < length) {
    value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
function ucs2encode(array) {
  return array.map(function(value) {
    var output = "";
    if (value > 65535) {
      value -= 65536;
      output += String.fromCharCode(value >>> 10 & 1023 | 55296);
      value = 56320 | value & 1023;
    }
    output += String.fromCharCode(value);
    return output;
  }).join("");
}
function atobUint8Array(base64) {
  var data = window.atob(base64);
  var result = new Uint8Array(data.length);
  for (var idx2 = 0; idx2 < data.length; idx2++) {
    result[idx2] = data.charCodeAt(idx2);
  }
  return result;
}
function createUint8Array(data) {
  var result = new Uint8Array(data.length);
  for (var idx2 = 0; idx2 < data.length; idx2++) {
    result[idx2] = data[idx2];
  }
  return result;
}
function base64ToUint8Array(base64) {
  if (window.atob) {
    return atobUint8Array(base64);
  }
  return createUint8Array(BASE64.decode(base64));
}

// node_modules/@progress/kendo-drawing/dist/es/pdf/ttf.js
function hasOwnProperty(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function sortedKeys(obj) {
  return Object.keys(obj).sort(function(a, b) {
    return a - b;
  }).map(parseFloat);
}
var Directory = function Directory2(data) {
  this.raw = data;
  this.scalerType = data.readLong();
  this.tableCount = data.readShort();
  this.searchRange = data.readShort();
  this.entrySelector = data.readShort();
  this.rangeShift = data.readShort();
  var tables = this.tables = {};
  for (var i = 0; i < this.tableCount; ++i) {
    var entry = {
      tag: data.readString(4),
      checksum: data.readLong(),
      offset: data.readLong(),
      length: data.readLong()
    };
    tables[entry.tag] = entry;
  }
};
Directory.prototype.readTable = function readTable(name2, Ctor) {
  var def = this.tables[name2];
  if (!def) {
    throw new Error("Table " + name2 + " not found in directory");
  }
  return this[name2] = def.table = new Ctor(this, def);
};
Directory.prototype.render = function render(tables) {
  var this$1 = this;
  var tableCount = Object.keys(tables).length;
  var maxpow2 = Math.pow(2, Math.floor(Math.log(tableCount) / Math.LN2));
  var searchRange = maxpow2 * 16;
  var entrySelector = Math.floor(Math.log(maxpow2) / Math.LN2);
  var rangeShift = tableCount * 16 - searchRange;
  var out = BinaryStream();
  out.writeLong(this.scalerType);
  out.writeShort(tableCount);
  out.writeShort(searchRange);
  out.writeShort(entrySelector);
  out.writeShort(rangeShift);
  var directoryLength = tableCount * 16;
  var offset = out.offset() + directoryLength;
  var headOffset = null;
  var tableData = BinaryStream();
  for (var tag in tables) {
    if (hasOwnProperty(tables, tag)) {
      var table = tables[tag];
      out.writeString(tag);
      out.writeLong(this$1.checksum(table));
      out.writeLong(offset);
      out.writeLong(table.length);
      tableData.write(table);
      if (tag == "head") {
        headOffset = offset;
      }
      offset += table.length;
      while (offset % 4) {
        tableData.writeByte(0);
        offset++;
      }
    }
  }
  out.write(tableData.get());
  var sum = this.checksum(out.get());
  var adjustment = 2981146554 - sum;
  out.offset(headOffset + 8);
  out.writeLong(adjustment);
  return out.get();
};
Directory.prototype.checksum = function checksum(data) {
  data = BinaryStream(data);
  var sum = 0;
  while (!data.eof()) {
    sum += data.readLong();
  }
  return sum & 4294967295;
};
var Table = function Table2(file, def) {
  this.definition = def;
  this.length = def.length;
  this.offset = def.offset;
  this.file = file;
  this.rawData = file.raw;
  this.parse(file.raw);
};
Table.prototype.raw = function raw() {
  return this.rawData.slice(this.offset, this.length);
};
Table.prototype.parse = function parse() {
};
var HeadTable = function(Table3) {
  function HeadTable2() {
    Table3.apply(this, arguments);
  }
  if (Table3) HeadTable2.__proto__ = Table3;
  HeadTable2.prototype = Object.create(Table3 && Table3.prototype);
  HeadTable2.prototype.constructor = HeadTable2;
  HeadTable2.prototype.parse = function parse3(data) {
    data.offset(this.offset);
    this.version = data.readLong();
    this.revision = data.readLong();
    this.checkSumAdjustment = data.readLong();
    this.magicNumber = data.readLong();
    this.flags = data.readShort();
    this.unitsPerEm = data.readShort();
    this.created = data.read(8);
    this.modified = data.read(8);
    this.xMin = data.readShort_();
    this.yMin = data.readShort_();
    this.xMax = data.readShort_();
    this.yMax = data.readShort_();
    this.macStyle = data.readShort();
    this.lowestRecPPEM = data.readShort();
    this.fontDirectionHint = data.readShort_();
    this.indexToLocFormat = data.readShort_();
    this.glyphDataFormat = data.readShort_();
  };
  HeadTable2.prototype.render = function render4(indexToLocFormat) {
    var out = BinaryStream();
    out.writeLong(this.version);
    out.writeLong(this.revision);
    out.writeLong(0);
    out.writeLong(this.magicNumber);
    out.writeShort(this.flags);
    out.writeShort(this.unitsPerEm);
    out.write(this.created);
    out.write(this.modified);
    out.writeShort_(this.xMin);
    out.writeShort_(this.yMin);
    out.writeShort_(this.xMax);
    out.writeShort_(this.yMax);
    out.writeShort(this.macStyle);
    out.writeShort(this.lowestRecPPEM);
    out.writeShort_(this.fontDirectionHint);
    out.writeShort_(indexToLocFormat);
    out.writeShort_(this.glyphDataFormat);
    return out.get();
  };
  return HeadTable2;
}(Table);
var LocaTable = function(Table3) {
  function LocaTable2() {
    Table3.apply(this, arguments);
  }
  if (Table3) LocaTable2.__proto__ = Table3;
  LocaTable2.prototype = Object.create(Table3 && Table3.prototype);
  LocaTable2.prototype.constructor = LocaTable2;
  LocaTable2.prototype.parse = function parse3(data) {
    data.offset(this.offset);
    var format3 = this.file.head.indexToLocFormat;
    if (format3 === 0) {
      this.offsets = data.times(this.length / 2, function() {
        return 2 * data.readShort();
      });
    } else {
      this.offsets = data.times(this.length / 4, data.readLong);
    }
  };
  LocaTable2.prototype.offsetOf = function offsetOf(id2) {
    return this.offsets[id2];
  };
  LocaTable2.prototype.lengthOf = function lengthOf(id2) {
    return this.offsets[id2 + 1] - this.offsets[id2];
  };
  LocaTable2.prototype.render = function render4(offsets) {
    var out = BinaryStream();
    var needsLongFormat = offsets[offsets.length - 1] > 65535;
    for (var i = 0; i < offsets.length; ++i) {
      if (needsLongFormat) {
        out.writeLong(offsets[i]);
      } else {
        out.writeShort(offsets[i] / 2);
      }
    }
    return {
      format: needsLongFormat ? 1 : 0,
      table: out.get()
    };
  };
  return LocaTable2;
}(Table);
var HheaTable = function(Table3) {
  function HheaTable2() {
    Table3.apply(this, arguments);
  }
  if (Table3) HheaTable2.__proto__ = Table3;
  HheaTable2.prototype = Object.create(Table3 && Table3.prototype);
  HheaTable2.prototype.constructor = HheaTable2;
  HheaTable2.prototype.parse = function parse3(data) {
    data.offset(this.offset);
    this.version = data.readLong();
    this.ascent = data.readShort_();
    this.descent = data.readShort_();
    this.lineGap = data.readShort_();
    this.advanceWidthMax = data.readShort();
    this.minLeftSideBearing = data.readShort_();
    this.minRightSideBearing = data.readShort_();
    this.xMaxExtent = data.readShort_();
    this.caretSlopeRise = data.readShort_();
    this.caretSlopeRun = data.readShort_();
    this.caretOffset = data.readShort_();
    data.skip(4 * 2);
    this.metricDataFormat = data.readShort_();
    this.numOfLongHorMetrics = data.readShort();
  };
  HheaTable2.prototype.render = function render4(ids) {
    var out = BinaryStream();
    out.writeLong(this.version);
    out.writeShort_(this.ascent);
    out.writeShort_(this.descent);
    out.writeShort_(this.lineGap);
    out.writeShort(this.advanceWidthMax);
    out.writeShort_(this.minLeftSideBearing);
    out.writeShort_(this.minRightSideBearing);
    out.writeShort_(this.xMaxExtent);
    out.writeShort_(this.caretSlopeRise);
    out.writeShort_(this.caretSlopeRun);
    out.writeShort_(this.caretOffset);
    out.write([0, 0, 0, 0, 0, 0, 0, 0]);
    out.writeShort_(this.metricDataFormat);
    out.writeShort(ids.length);
    return out.get();
  };
  return HheaTable2;
}(Table);
var MaxpTable = function(Table3) {
  function MaxpTable2() {
    Table3.apply(this, arguments);
  }
  if (Table3) MaxpTable2.__proto__ = Table3;
  MaxpTable2.prototype = Object.create(Table3 && Table3.prototype);
  MaxpTable2.prototype.constructor = MaxpTable2;
  MaxpTable2.prototype.parse = function parse3(data) {
    data.offset(this.offset);
    this.version = data.readLong();
    this.numGlyphs = data.readShort();
    this.maxPoints = data.readShort();
    this.maxContours = data.readShort();
    this.maxComponentPoints = data.readShort();
    this.maxComponentContours = data.readShort();
    this.maxZones = data.readShort();
    this.maxTwilightPoints = data.readShort();
    this.maxStorage = data.readShort();
    this.maxFunctionDefs = data.readShort();
    this.maxInstructionDefs = data.readShort();
    this.maxStackElements = data.readShort();
    this.maxSizeOfInstructions = data.readShort();
    this.maxComponentElements = data.readShort();
    this.maxComponentDepth = data.readShort();
  };
  MaxpTable2.prototype.render = function render4(glyphIds2) {
    var out = BinaryStream();
    out.writeLong(this.version);
    out.writeShort(glyphIds2.length);
    out.writeShort(this.maxPoints);
    out.writeShort(this.maxContours);
    out.writeShort(this.maxComponentPoints);
    out.writeShort(this.maxComponentContours);
    out.writeShort(this.maxZones);
    out.writeShort(this.maxTwilightPoints);
    out.writeShort(this.maxStorage);
    out.writeShort(this.maxFunctionDefs);
    out.writeShort(this.maxInstructionDefs);
    out.writeShort(this.maxStackElements);
    out.writeShort(this.maxSizeOfInstructions);
    out.writeShort(this.maxComponentElements);
    out.writeShort(this.maxComponentDepth);
    return out.get();
  };
  return MaxpTable2;
}(Table);
var HmtxTable = function(Table3) {
  function HmtxTable2() {
    Table3.apply(this, arguments);
  }
  if (Table3) HmtxTable2.__proto__ = Table3;
  HmtxTable2.prototype = Object.create(Table3 && Table3.prototype);
  HmtxTable2.prototype.constructor = HmtxTable2;
  HmtxTable2.prototype.parse = function parse3(data) {
    data.offset(this.offset);
    var dir = this.file, hhea = dir.hhea;
    this.metrics = data.times(hhea.numOfLongHorMetrics, function() {
      return {
        advance: data.readShort(),
        lsb: data.readShort_()
      };
    });
    var lsbCount = dir.maxp.numGlyphs - dir.hhea.numOfLongHorMetrics;
    this.leftSideBearings = data.times(lsbCount, data.readShort_);
  };
  HmtxTable2.prototype.forGlyph = function forGlyph(id2) {
    var metrics = this.metrics;
    var n = metrics.length;
    if (id2 < n) {
      return metrics[id2];
    }
    return {
      advance: metrics[n - 1].advance,
      lsb: this.leftSideBearings[id2 - n]
    };
  };
  HmtxTable2.prototype.render = function render4(glyphIds2) {
    var this$1 = this;
    var out = BinaryStream();
    for (var i = 0; i < glyphIds2.length; ++i) {
      var m = this$1.forGlyph(glyphIds2[i]);
      out.writeShort(m.advance);
      out.writeShort_(m.lsb);
    }
    return out.get();
  };
  return HmtxTable2;
}(Table);
var GlyfTable = function() {
  var SimpleGlyph = function SimpleGlyph2(raw2) {
    this.raw = raw2;
  };
  var prototypeAccessors = {
    compound: {
      configurable: true
    }
  };
  prototypeAccessors.compound.get = function() {
    return false;
  };
  SimpleGlyph.prototype.render = function render4() {
    return this.raw.get();
  };
  Object.defineProperties(SimpleGlyph.prototype, prototypeAccessors);
  var ARG_1_AND_2_ARE_WORDS = 1;
  var WE_HAVE_A_SCALE = 8;
  var MORE_COMPONENTS = 32;
  var WE_HAVE_AN_X_AND_Y_SCALE = 64;
  var WE_HAVE_A_TWO_BY_TWO = 128;
  var CompoundGlyph = function CompoundGlyph2(data) {
    this.raw = data;
    var ids = this.glyphIds = [];
    var offsets = this.idOffsets = [];
    while (true) {
      var flags = data.readShort();
      offsets.push(data.offset());
      ids.push(data.readShort());
      if (!(flags & MORE_COMPONENTS)) {
        break;
      }
      data.skip(flags & ARG_1_AND_2_ARE_WORDS ? 4 : 2);
      if (flags & WE_HAVE_A_TWO_BY_TWO) {
        data.skip(8);
      } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
        data.skip(4);
      } else if (flags & WE_HAVE_A_SCALE) {
        data.skip(2);
      }
    }
  };
  var prototypeAccessors$1 = {
    compound: {
      configurable: true
    }
  };
  prototypeAccessors$1.compound.get = function() {
    return true;
  };
  CompoundGlyph.prototype.render = function render4(old2new) {
    var this$1 = this;
    var out = BinaryStream(this.raw.get());
    for (var i = 0; i < this.glyphIds.length; ++i) {
      var id2 = this$1.glyphIds[i];
      out.offset(this$1.idOffsets[i]);
      out.writeShort(old2new[id2]);
    }
    return out.get();
  };
  Object.defineProperties(CompoundGlyph.prototype, prototypeAccessors$1);
  return function(Table3) {
    function anonymous() {
      Table3.apply(this, arguments);
    }
    if (Table3) anonymous.__proto__ = Table3;
    anonymous.prototype = Object.create(Table3 && Table3.prototype);
    anonymous.prototype.constructor = anonymous;
    anonymous.prototype.parse = function parse3() {
      this.cache = {};
    };
    anonymous.prototype.glyphFor = function glyphFor(id2) {
      var cache = this.cache;
      if (hasOwnProperty(cache, id2)) {
        return cache[id2];
      }
      var loca = this.file.loca;
      var length = loca.lengthOf(id2);
      if (length === 0) {
        return cache[id2] = null;
      }
      var data = this.rawData;
      var offset = this.offset + loca.offsetOf(id2);
      var raw2 = BinaryStream(data.slice(offset, length));
      var numberOfContours = raw2.readShort_();
      var xMin = raw2.readShort_();
      var yMin = raw2.readShort_();
      var xMax = raw2.readShort_();
      var yMax = raw2.readShort_();
      var glyph = cache[id2] = numberOfContours < 0 ? new CompoundGlyph(raw2) : new SimpleGlyph(raw2);
      glyph.numberOfContours = numberOfContours;
      glyph.xMin = xMin;
      glyph.yMin = yMin;
      glyph.xMax = xMax;
      glyph.yMax = yMax;
      return glyph;
    };
    anonymous.prototype.render = function render4(glyphs, oldIds, old2new) {
      var out = BinaryStream(), offsets = [];
      for (var i = 0; i < oldIds.length; ++i) {
        var id2 = oldIds[i];
        var glyph = glyphs[id2];
        if (out.offset() % 2) {
          out.writeByte(0);
        }
        offsets.push(out.offset());
        if (glyph) {
          out.write(glyph.render(old2new));
        }
      }
      if (out.offset() % 2) {
        out.writeByte(0);
      }
      offsets.push(out.offset());
      return {
        table: out.get(),
        offsets
      };
    };
    return anonymous;
  }(Table);
}();
var NameTable = function() {
  var NameEntry = function NameEntry2(text, entry) {
    this.text = text;
    this.length = text.length;
    this.platformID = entry.platformID;
    this.platformSpecificID = entry.platformSpecificID;
    this.languageID = entry.languageID;
    this.nameID = entry.nameID;
  };
  return function(Table3) {
    function anonymous() {
      Table3.apply(this, arguments);
    }
    if (Table3) anonymous.__proto__ = Table3;
    anonymous.prototype = Object.create(Table3 && Table3.prototype);
    anonymous.prototype.constructor = anonymous;
    anonymous.prototype.parse = function parse3(data) {
      data.offset(this.offset);
      data.readShort();
      var count = data.readShort();
      var stringOffset = this.offset + data.readShort();
      var nameRecords = data.times(count, function() {
        return {
          platformID: data.readShort(),
          platformSpecificID: data.readShort(),
          languageID: data.readShort(),
          nameID: data.readShort(),
          length: data.readShort(),
          offset: data.readShort() + stringOffset
        };
      });
      var strings = this.strings = {};
      for (var i = 0; i < nameRecords.length; ++i) {
        var rec = nameRecords[i];
        data.offset(rec.offset);
        var text = data.readString(rec.length);
        if (!strings[rec.nameID]) {
          strings[rec.nameID] = [];
        }
        strings[rec.nameID].push(new NameEntry(text, rec));
      }
      this.postscriptEntry = strings[6][0];
      this.postscriptName = this.postscriptEntry.text.replace(/[^\x20-\x7F]/g, "");
    };
    anonymous.prototype.render = function render4(psName) {
      var this$1 = this;
      var strings = this.strings;
      var strCount = 0;
      for (var i in strings) {
        if (hasOwnProperty(strings, i)) {
          strCount += strings[i].length;
        }
      }
      var out = BinaryStream();
      var strTable = BinaryStream();
      out.writeShort(0);
      out.writeShort(strCount);
      out.writeShort(6 + 12 * strCount);
      for (i in strings) {
        if (hasOwnProperty(strings, i)) {
          var list = i == 6 ? [new NameEntry(psName, this$1.postscriptEntry)] : strings[i];
          for (var j = 0; j < list.length; ++j) {
            var str = list[j];
            out.writeShort(str.platformID);
            out.writeShort(str.platformSpecificID);
            out.writeShort(str.languageID);
            out.writeShort(str.nameID);
            out.writeShort(str.length);
            out.writeShort(strTable.offset());
            strTable.writeString(str.text);
          }
        }
      }
      out.write(strTable.get());
      return out.get();
    };
    return anonymous;
  }(Table);
}();
var PostTable = function() {
  var POSTSCRIPT_GLYPHS = ".notdef .null nonmarkingreturn space exclam quotedbl numbersign dollar percent ampersand quotesingle parenleft parenright asterisk plus comma hyphen period slash zero one two three four five six seven eight nine colon semicolon less equal greater question at A B C D E F G H I J K L M N O P Q R S T U V W X Y Z bracketleft backslash bracketright asciicircum underscore grave a b c d e f g h i j k l m n o p q r s t u v w x y z braceleft bar braceright asciitilde Adieresis Aring Ccedilla Eacute Ntilde Odieresis Udieresis aacute agrave acircumflex adieresis atilde aring ccedilla eacute egrave ecircumflex edieresis iacute igrave icircumflex idieresis ntilde oacute ograve ocircumflex odieresis otilde uacute ugrave ucircumflex udieresis dagger degree cent sterling section bullet paragraph germandbls registered copyright trademark acute dieresis notequal AE Oslash infinity plusminus lessequal greaterequal yen mu partialdiff summation product pi integral ordfeminine ordmasculine Omega ae oslash questiondown exclamdown logicalnot radical florin approxequal Delta guillemotleft guillemotright ellipsis nonbreakingspace Agrave Atilde Otilde OE oe endash emdash quotedblleft quotedblright quoteleft quoteright divide lozenge ydieresis Ydieresis fraction currency guilsinglleft guilsinglright fi fl daggerdbl periodcentered quotesinglbase quotedblbase perthousand Acircumflex Ecircumflex Aacute Edieresis Egrave Iacute Icircumflex Idieresis Igrave Oacute Ocircumflex apple Ograve Uacute Ucircumflex Ugrave dotlessi circumflex tilde macron breve dotaccent ring cedilla hungarumlaut ogonek caron Lslash lslash Scaron scaron Zcaron zcaron brokenbar Eth eth Yacute yacute Thorn thorn minus multiply onesuperior twosuperior threesuperior onehalf onequarter threequarters franc Gbreve gbreve Idotaccent Scedilla scedilla Cacute cacute Ccaron ccaron dcroat".split(/\s+/g);
  return function(Table3) {
    function anonymous() {
      Table3.apply(this, arguments);
    }
    if (Table3) anonymous.__proto__ = Table3;
    anonymous.prototype = Object.create(Table3 && Table3.prototype);
    anonymous.prototype.constructor = anonymous;
    anonymous.prototype.parse = function parse3(data) {
      var this$1 = this;
      data.offset(this.offset);
      this.format = data.readLong();
      this.italicAngle = data.readFixed_();
      this.underlinePosition = data.readShort_();
      this.underlineThickness = data.readShort_();
      this.isFixedPitch = data.readLong();
      this.minMemType42 = data.readLong();
      this.maxMemType42 = data.readLong();
      this.minMemType1 = data.readLong();
      this.maxMemType1 = data.readLong();
      var numberOfGlyphs;
      switch (this.format) {
        case 65536:
        case 196608:
          break;
        case 131072:
          numberOfGlyphs = data.readShort();
          this.glyphNameIndex = data.times(numberOfGlyphs, data.readShort);
          this.names = [];
          var limit = this.offset + this.length;
          while (data.offset() < limit) {
            this$1.names.push(data.readString(data.readByte()));
          }
          break;
        case 151552:
          numberOfGlyphs = data.readShort();
          this.offsets = data.read(numberOfGlyphs);
          break;
        case 262144:
          this.map = data.times(this.file.maxp.numGlyphs, data.readShort);
          break;
      }
    };
    anonymous.prototype.glyphFor = function glyphFor(code) {
      switch (this.format) {
        case 65536:
          return POSTSCRIPT_GLYPHS[code] || ".notdef";
        case 131072:
          var index = this.glyphNameIndex[code];
          if (index < POSTSCRIPT_GLYPHS.length) {
            return POSTSCRIPT_GLYPHS[index];
          }
          return this.names[index - POSTSCRIPT_GLYPHS.length] || ".notdef";
        case 151552:
        case 196608:
          return ".notdef";
        case 262144:
          return this.map[code] || 65535;
      }
    };
    anonymous.prototype.render = function render4(mapping) {
      var this$1 = this;
      if (this.format == 196608) {
        return this.raw();
      }
      var out = BinaryStream(this.rawData.slice(this.offset, 32));
      out.writeLong(131072);
      out.offset(32);
      var indexes = [];
      var strings = [];
      for (var i = 0; i < mapping.length; ++i) {
        var id2 = mapping[i];
        var post = this$1.glyphFor(id2);
        var index = POSTSCRIPT_GLYPHS.indexOf(post);
        if (index >= 0) {
          indexes.push(index);
        } else {
          indexes.push(POSTSCRIPT_GLYPHS.length + strings.length);
          strings.push(post);
        }
      }
      out.writeShort(mapping.length);
      for (i = 0; i < indexes.length; ++i) {
        out.writeShort(indexes[i]);
      }
      for (i = 0; i < strings.length; ++i) {
        out.writeByte(strings[i].length);
        out.writeString(strings[i]);
      }
      return out.get();
    };
    return anonymous;
  }(Table);
}();
var CmapTable = function() {
  var CmapEntry = function CmapEntry2(data, offset, codeMap) {
    var self = this;
    self.platformID = data.readShort();
    self.platformSpecificID = data.readShort();
    self.offset = offset + data.readLong();
    data.saveExcursion(function() {
      var code;
      data.offset(self.offset);
      self.format = data.readShort();
      switch (self.format) {
        case 0:
          self.length = data.readShort();
          self.language = data.readShort();
          for (var i = 0; i < 256; ++i) {
            codeMap[i] = data.readByte();
          }
          break;
        case 4:
          self.length = data.readShort();
          self.language = data.readShort();
          var segCount = data.readShort() / 2;
          data.skip(6);
          var endCode = data.times(segCount, data.readShort);
          data.skip(2);
          var startCode = data.times(segCount, data.readShort);
          var idDelta = data.times(segCount, data.readShort_);
          var idRangeOffset = data.times(segCount, data.readShort);
          var count = (self.length + self.offset - data.offset()) / 2;
          var glyphIds2 = data.times(count, data.readShort);
          for (i = 0; i < segCount; ++i) {
            var start = startCode[i], end = endCode[i];
            for (code = start; code <= end; ++code) {
              var glyphId;
              if (idRangeOffset[i] === 0) {
                glyphId = code + idDelta[i];
              } else {
                var index = idRangeOffset[i] / 2 - (segCount - i) + (code - start);
                glyphId = glyphIds2[index] || 0;
                if (glyphId !== 0) {
                  glyphId += idDelta[i];
                }
              }
              codeMap[code] = glyphId & 65535;
            }
          }
          break;
        case 6:
          self.length = data.readShort();
          self.language = data.readShort();
          code = data.readShort();
          var length = data.readShort();
          while (length-- > 0) {
            codeMap[code++] = data.readShort();
          }
          break;
        case 12:
          data.readShort();
          self.length = data.readLong();
          self.language = data.readLong();
          var ngroups = data.readLong();
          while (ngroups-- > 0) {
            code = data.readLong();
            var endCharCode = data.readLong();
            var glyphCode = data.readLong();
            while (code <= endCharCode) {
              codeMap[code++] = glyphCode++;
            }
          }
          break;
        default:
          if (window.console) {
            window.console.error("Unhandled CMAP format: " + self.format);
          }
      }
    });
  };
  function renderCharmap(ncid2ogid, ogid2ngid) {
    var codes = sortedKeys(ncid2ogid);
    var startCodes = [];
    var endCodes = [];
    var last2 = null;
    var diff = null;
    function new_gid(charcode) {
      return ogid2ngid[ncid2ogid[charcode]];
    }
    for (var i = 0; i < codes.length; ++i) {
      var code = codes[i];
      var gid = new_gid(code);
      var delta = gid - code;
      if (last2 == null || delta !== diff) {
        if (last2) {
          endCodes.push(last2);
        }
        startCodes.push(code);
        diff = delta;
      }
      last2 = code;
    }
    if (last2) {
      endCodes.push(last2);
    }
    endCodes.push(65535);
    startCodes.push(65535);
    var segCount = startCodes.length;
    var segCountX2 = segCount * 2;
    var searchRange = 2 * Math.pow(2, Math.floor(Math.log(segCount) / Math.LN2));
    var entrySelector = Math.log(searchRange / 2) / Math.LN2;
    var rangeShift = segCountX2 - searchRange;
    var deltas = [];
    var rangeOffsets = [];
    var glyphIds2 = [];
    for (i = 0; i < segCount; ++i) {
      var startCode = startCodes[i];
      var endCode = endCodes[i];
      if (startCode == 65535) {
        deltas.push(0);
        rangeOffsets.push(0);
        break;
      }
      var startGlyph = new_gid(startCode);
      if (startCode - startGlyph >= 32768) {
        deltas.push(0);
        rangeOffsets.push(2 * (glyphIds2.length + segCount - i));
        for (var j = startCode; j <= endCode; ++j) {
          glyphIds2.push(new_gid(j));
        }
      } else {
        deltas.push(startGlyph - startCode);
        rangeOffsets.push(0);
      }
    }
    var out = BinaryStream();
    out.writeShort(3);
    out.writeShort(1);
    out.writeLong(12);
    out.writeShort(4);
    out.writeShort(16 + segCount * 8 + glyphIds2.length * 2);
    out.writeShort(0);
    out.writeShort(segCountX2);
    out.writeShort(searchRange);
    out.writeShort(entrySelector);
    out.writeShort(rangeShift);
    endCodes.forEach(out.writeShort);
    out.writeShort(0);
    startCodes.forEach(out.writeShort);
    deltas.forEach(out.writeShort_);
    rangeOffsets.forEach(out.writeShort);
    glyphIds2.forEach(out.writeShort);
    return out.get();
  }
  return function(Table3) {
    function anonymous() {
      Table3.apply(this, arguments);
    }
    if (Table3) anonymous.__proto__ = Table3;
    anonymous.prototype = Object.create(Table3 && Table3.prototype);
    anonymous.prototype.constructor = anonymous;
    anonymous.prototype.parse = function parse3(data) {
      var self = this;
      var offset = self.offset;
      data.offset(offset);
      self.codeMap = {};
      self.version = data.readShort();
      var tableCount = data.readShort();
      self.tables = data.times(tableCount, function() {
        return new CmapEntry(data, offset, self.codeMap);
      });
    };
    anonymous.render = function render4(ncid2ogid, ogid2ngid) {
      var out = BinaryStream();
      out.writeShort(0);
      out.writeShort(1);
      out.write(renderCharmap(ncid2ogid, ogid2ngid));
      return out.get();
    };
    return anonymous;
  }(Table);
}();
var OS2Table = function(Table3) {
  function OS2Table2() {
    Table3.apply(this, arguments);
  }
  if (Table3) OS2Table2.__proto__ = Table3;
  OS2Table2.prototype = Object.create(Table3 && Table3.prototype);
  OS2Table2.prototype.constructor = OS2Table2;
  OS2Table2.prototype.parse = function parse3(data) {
    data.offset(this.offset);
    this.version = data.readShort();
    this.averageCharWidth = data.readShort_();
    this.weightClass = data.readShort();
    this.widthClass = data.readShort();
    this.type = data.readShort();
    this.ySubscriptXSize = data.readShort_();
    this.ySubscriptYSize = data.readShort_();
    this.ySubscriptXOffset = data.readShort_();
    this.ySubscriptYOffset = data.readShort_();
    this.ySuperscriptXSize = data.readShort_();
    this.ySuperscriptYSize = data.readShort_();
    this.ySuperscriptXOffset = data.readShort_();
    this.ySuperscriptYOffset = data.readShort_();
    this.yStrikeoutSize = data.readShort_();
    this.yStrikeoutPosition = data.readShort_();
    this.familyClass = data.readShort_();
    this.panose = data.times(10, data.readByte);
    this.charRange = data.times(4, data.readLong);
    this.vendorID = data.readString(4);
    this.selection = data.readShort();
    this.firstCharIndex = data.readShort();
    this.lastCharIndex = data.readShort();
    if (this.version > 0) {
      this.ascent = data.readShort_();
      this.descent = data.readShort_();
      this.lineGap = data.readShort_();
      this.winAscent = data.readShort();
      this.winDescent = data.readShort();
      this.codePageRange = data.times(2, data.readLong);
      if (this.version > 1) {
        this.xHeight = data.readShort();
        this.capHeight = data.readShort();
        this.defaultChar = data.readShort();
        this.breakChar = data.readShort();
        this.maxContext = data.readShort();
      }
    }
  };
  OS2Table2.prototype.render = function render4() {
    return this.raw();
  };
  return OS2Table2;
}(Table);
var subsetTag = 1e5;
function nextSubsetTag() {
  var ret = "", n = String(subsetTag);
  for (var i = 0; i < n.length; ++i) {
    ret += String.fromCharCode(n.charCodeAt(i) - 48 + 65);
  }
  ++subsetTag;
  return ret;
}
var Subfont = function Subfont2(font) {
  this.font = font;
  this.subset = {};
  this.unicodes = {};
  this.ogid2ngid = {
    0: 0
  };
  this.ngid2ogid = {
    0: 0
  };
  this.ncid2ogid = {};
  this.next = this.firstChar = 1;
  this.nextGid = 1;
  this.psName = nextSubsetTag() + "+" + this.font.psName;
};
Subfont.prototype.use = function use(ch) {
  var self = this;
  if (typeof ch == "string") {
    return ucs2decode(ch).reduce(function(ret, code2) {
      return ret + String.fromCharCode(self.use(code2));
    }, "");
  }
  var code = self.unicodes[ch];
  if (!code) {
    code = self.next++;
    self.subset[code] = ch;
    self.unicodes[ch] = code;
    var old_gid = self.font.cmap.codeMap[ch];
    if (old_gid) {
      self.ncid2ogid[code] = old_gid;
      if (self.ogid2ngid[old_gid] == null) {
        var new_gid = self.nextGid++;
        self.ogid2ngid[old_gid] = new_gid;
        self.ngid2ogid[new_gid] = old_gid;
      }
    }
  }
  return code;
};
Subfont.prototype.encodeText = function encodeText(text) {
  return this.use(text);
};
Subfont.prototype.glyphIds = function glyphIds() {
  return sortedKeys(this.ogid2ngid);
};
Subfont.prototype.glyphsFor = function glyphsFor(glyphIds2, result) {
  var this$1 = this;
  if (!result) {
    result = {};
  }
  for (var i = 0; i < glyphIds2.length; ++i) {
    var id2 = glyphIds2[i];
    if (!result[id2]) {
      var glyph = result[id2] = this$1.font.glyf.glyphFor(id2);
      if (glyph && glyph.compound) {
        this$1.glyphsFor(glyph.glyphIds, result);
      }
    }
  }
  return result;
};
Subfont.prototype.render = function render2() {
  var this$1 = this;
  var glyphs = this.glyphsFor(this.glyphIds());
  for (var old_gid in glyphs) {
    if (hasOwnProperty(glyphs, old_gid)) {
      old_gid = parseInt(old_gid, 10);
      if (this$1.ogid2ngid[old_gid] == null) {
        var new_gid = this$1.nextGid++;
        this$1.ogid2ngid[old_gid] = new_gid;
        this$1.ngid2ogid[new_gid] = old_gid;
      }
    }
  }
  var new_gid_ids = sortedKeys(this.ngid2ogid);
  var old_gid_ids = new_gid_ids.map(function(id2) {
    return this.ngid2ogid[id2];
  }, this);
  var font = this.font;
  var glyf = font.glyf.render(glyphs, old_gid_ids, this.ogid2ngid);
  var loca = font.loca.render(glyf.offsets);
  this.lastChar = this.next - 1;
  var tables = {
    "cmap": CmapTable.render(this.ncid2ogid, this.ogid2ngid),
    "glyf": glyf.table,
    "loca": loca.table,
    "hmtx": font.hmtx.render(old_gid_ids),
    "hhea": font.hhea.render(old_gid_ids),
    "maxp": font.maxp.render(old_gid_ids),
    "post": font.post.render(old_gid_ids),
    "name": font.name.render(this.psName),
    "head": font.head.render(loca.format),
    "OS/2": font.os2.render()
  };
  return this.font.directory.render(tables);
};
Subfont.prototype.cidToGidMap = function cidToGidMap() {
  var this$1 = this;
  var out = BinaryStream(), len = 0;
  for (var cid = this.firstChar; cid < this.next; ++cid) {
    while (len < cid) {
      out.writeShort(0);
      len++;
    }
    var old_gid = this$1.ncid2ogid[cid];
    if (old_gid) {
      var new_gid = this$1.ogid2ngid[old_gid];
      out.writeShort(new_gid);
    } else {
      out.writeShort(0);
    }
    len++;
  }
  return out.get();
};
var TTFFont = function TTFFont2(rawData, name2) {
  var self = this;
  var data = self.contents = BinaryStream(rawData);
  if (data.readString(4) == "ttcf") {
    var offset;
    var parse3 = function() {
      data.offset(offset);
      self.parse();
    };
    if (!name2) {
      throw new Error("Must specify a name for TTC files");
    }
    data.readLong();
    var numFonts = data.readLong();
    for (var i = 0; i < numFonts; ++i) {
      offset = data.readLong();
      data.saveExcursion(parse3);
      if (self.psName == name2) {
        return;
      }
    }
    throw new Error("Font " + name2 + " not found in collection");
  } else {
    data.offset(0);
    self.parse();
  }
};
TTFFont.prototype.parse = function parse2() {
  var dir = this.directory = new Directory(this.contents);
  this.head = dir.readTable("head", HeadTable);
  this.loca = dir.readTable("loca", LocaTable);
  this.hhea = dir.readTable("hhea", HheaTable);
  this.maxp = dir.readTable("maxp", MaxpTable);
  this.hmtx = dir.readTable("hmtx", HmtxTable);
  this.glyf = dir.readTable("glyf", GlyfTable);
  this.name = dir.readTable("name", NameTable);
  this.post = dir.readTable("post", PostTable);
  this.cmap = dir.readTable("cmap", CmapTable);
  this.os2 = dir.readTable("OS/2", OS2Table);
  this.psName = this.name.postscriptName;
  this.ascent = this.os2.ascent || this.hhea.ascent;
  this.descent = this.os2.descent || this.hhea.descent;
  this.lineGap = this.os2.lineGap || this.hhea.lineGap;
  this.scale = 1e3 / this.head.unitsPerEm;
};
TTFFont.prototype.widthOfGlyph = function widthOfGlyph(glyph) {
  return this.hmtx.forGlyph(glyph).advance * this.scale;
};
TTFFont.prototype.makeSubset = function makeSubset() {
  return new Subfont(this);
};

// node_modules/@progress/pako-esm/dist/pako-esm5.js
var Z_NO_FLUSH = 0;
var Z_PARTIAL_FLUSH = 1;
var Z_SYNC_FLUSH = 2;
var Z_FULL_FLUSH = 3;
var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_BUF_ERROR = -5;
var Z_DEFAULT_COMPRESSION = -1;
var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY = 0;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN = 2;
var Z_DEFLATED = 8;
function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function assign(obj) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
}
function shrinkBuf(buf, size) {
  if (buf.length === size) {
    return buf;
  }
  if (buf.subarray) {
    return buf.subarray(0, size);
  }
  buf.length = size;
  return buf;
}
var fnTyped = {
  arraySet: function(dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function(chunks) {
    var i, l, len, pos, chunk, result;
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  },
  Buf8: function(size) {
    return new Uint8Array(size);
  },
  Buf16: function(size) {
    return new Uint16Array(size);
  },
  Buf32: function(size) {
    return new Int32Array(size);
  }
};
var fnUntyped = {
  arraySet: function(dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function(chunks) {
    return [].concat.apply([], chunks);
  },
  Buf8: function(size) {
    return new Array(size);
  },
  Buf16: function(size) {
    return new Array(size);
  },
  Buf32: function(size) {
    return new Array(size);
  }
};
var typedOK = function() {
  var supported = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  typedOK = function() {
    return supported;
  };
  return supported;
};
var arraySet = function(dest, src, src_offs, len, dest_offs) {
  arraySet = typedOK() ? fnTyped.arraySet : fnUntyped.arraySet;
  return arraySet(dest, src, src_offs, len, dest_offs);
};
var flattenChunks = function(chunks) {
  flattenChunks = typedOK() ? fnTyped.flattenChunks : fnUntyped.flattenChunks;
  return flattenChunks(chunks);
};
var Buf8 = function(size) {
  Buf8 = typedOK() ? fnTyped.Buf8 : fnUntyped.Buf8;
  return Buf8(size);
};
var Buf16 = function(size) {
  Buf16 = typedOK() ? fnTyped.Buf16 : fnUntyped.Buf16;
  return Buf16(size);
};
var Buf32 = function(size) {
  Buf32 = typedOK() ? fnTyped.Buf32 : fnUntyped.Buf32;
  return Buf32(size);
};
var strApplyOK = function() {
  var result = true;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch (_2) {
    result = false;
  }
  strApplyOK = function() {
    return result;
  };
  return result;
};
var strApplyUintOK = function() {
  var result = true;
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (_2) {
    result = false;
  }
  strApplyUintOK = function() {
    return result;
  };
  return result;
};
var utf8len = function(c) {
  var table = Buf8(256);
  for (var q = 0; q < 256; q++) {
    table[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
  }
  table[254] = table[254] = 1;
  utf8len = function(arg) {
    return table[arg];
  };
  return table[c];
};
function string2buf(str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
}
function _buf2binstring(buf, len) {
  if (len < 65534) {
    if (buf.subarray && strApplyUintOK() || !buf.subarray && strApplyOK()) {
      return String.fromCharCode.apply(null, shrinkBuf(buf, len));
    }
  }
  var result = "";
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}
function buf2binstring(buf) {
  return _buf2binstring(buf, buf.length);
}
function binstring2buf(str) {
  var buf = new Uint8Array(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
}
function buf2string(buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;
  var utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    c_len = utf8len(c);
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return _buf2binstring(utf16buf, out);
}
function utf8border(buf, max) {
  var pos;
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + utf8len(buf[pos]) > max ? pos : max;
}
function adler32(adler, buf, len, pos) {
  var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
}
function makeTable() {
  var c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
}
var crcTable = function() {
  var table = makeTable();
  crcTable = function() {
    return table;
  };
  return table;
};
function crc32(crc, buf, len, pos) {
  var t = crcTable(), end = pos + len;
  crc ^= -1;
  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
}
var BAD = 30;
var TYPE = 12;
function inflate_fast(strm, start) {
  var state2;
  var _in;
  var last2;
  var _out;
  var beg;
  var end;
  var dmax;
  var wsize;
  var whave;
  var wnext;
  var s_window;
  var hold;
  var bits;
  var lcode;
  var dcode;
  var lmask;
  var dmask;
  var here;
  var op;
  var len;
  var dist;
  var from;
  var from_source;
  var input, output;
  state2 = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last2 = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state2.dmax;
  wsize = state2.wsize;
  whave = state2.whave;
  wnext = state2.wnext;
  s_window = state2.window;
  hold = state2.hold;
  bits = state2.bits;
  lcode = state2.lencode;
  dcode = state2.distcode;
  lmask = (1 << state2.lenbits) - 1;
  dmask = (1 << state2.distbits) - 1;
  top: do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }
    here = lcode[hold & lmask];
    dolen: for (; ; ) {
      op = here >>> 24;
      hold >>>= op;
      bits -= op;
      op = here >>> 16 & 255;
      if (op === 0) {
        output[_out++] = here & 65535;
      } else if (op & 16) {
        len = here & 65535;
        op &= 15;
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & (1 << op) - 1;
          hold >>>= op;
          bits -= op;
        }
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];
        dodist: for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op & 16) {
            dist = here & 65535;
            op &= 15;
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & (1 << op) - 1;
            if (dist > dmax) {
              strm.msg = "invalid distance too far back";
              state2.mode = BAD;
              break top;
            }
            hold >>>= op;
            bits -= op;
            op = _out - beg;
            if (dist > op) {
              op = dist - op;
              if (op > whave) {
                if (state2.sane) {
                  strm.msg = "invalid distance too far back";
                  state2.mode = BAD;
                  break top;
                }
              }
              from = 0;
              from_source = s_window;
              if (wnext === 0) {
                from += wsize - op;
                if (op < len) {
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;
                  from_source = output;
                }
              } else if (wnext < op) {
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;
                    from_source = output;
                  }
                }
              } else {
                from += wnext - op;
                if (op < len) {
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            } else {
              from = _out - dist;
              do {
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          } else if ((op & 64) === 0) {
            here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dodist;
          } else {
            strm.msg = "invalid distance code";
            state2.mode = BAD;
            break top;
          }
          break;
        }
      } else if ((op & 64) === 0) {
        here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
        continue dolen;
      } else if (op & 32) {
        state2.mode = TYPE;
        break top;
      } else {
        strm.msg = "invalid literal/length code";
        state2.mode = BAD;
        break top;
      }
      break;
    }
  } while (_in < last2 && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state2.hold = hold;
  state2.bits = bits;
  return;
}
var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var lbase = [
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
];
var lext = [
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
];
var dbase = [
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
];
var dext = [
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
];
function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
  var bits = opts.bits;
  var len = 0;
  var sym = 0;
  var min = 0, max = 0;
  var root = 0;
  var curr = 0;
  var drop = 0;
  var left = 0;
  var used = 0;
  var huff = 0;
  var incr;
  var fill;
  var low;
  var mask3;
  var next;
  var base = null;
  var base_index = 0;
  var end;
  var count = Buf16(MAXBITS + 1);
  var offs = Buf16(MAXBITS + 1);
  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES) {
    base = extra = work;
    end = 19;
  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    base = dbase;
    extra = dext;
    end = -1;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask3 = used - 1;
  if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask3) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      low = huff & mask3;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
}
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var Z_FINISH$1 = 4;
var Z_BLOCK$1 = 5;
var Z_TREES$1 = 6;
var Z_OK$1 = 0;
var Z_STREAM_END$1 = 1;
var Z_NEED_DICT$1 = 2;
var Z_STREAM_ERROR$1 = -2;
var Z_DATA_ERROR$1 = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR$1 = -5;
var Z_DEFLATED$1 = 8;
var HEAD = 1;
var FLAGS = 2;
var TIME = 3;
var OS = 4;
var EXLEN = 5;
var EXTRA = 6;
var NAME = 7;
var COMMENT = 8;
var HCRC = 9;
var DICTID = 10;
var DICT = 11;
var TYPE$1 = 12;
var TYPEDO = 13;
var STORED = 14;
var COPY_ = 15;
var COPY = 16;
var TABLE = 17;
var LENLENS = 18;
var CODELENS = 19;
var LEN_ = 20;
var LEN = 21;
var LENEXT = 22;
var DIST = 23;
var DISTEXT = 24;
var MATCH = 25;
var LIT = 26;
var CHECK = 27;
var LENGTH = 28;
var DONE = 29;
var BAD$1 = 30;
var MEM = 31;
var SYNC = 32;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
function zswap32(q) {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
}
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = Buf16(320);
  this.work = Buf16(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function inflateResetKeep(strm) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state2 = strm.state;
  strm.total_in = strm.total_out = state2.total = 0;
  strm.msg = "";
  if (state2.wrap) {
    strm.adler = state2.wrap & 1;
  }
  state2.mode = HEAD;
  state2.last = 0;
  state2.havedict = 0;
  state2.dmax = 32768;
  state2.head = null;
  state2.hold = 0;
  state2.bits = 0;
  state2.lencode = state2.lendyn = Buf32(ENOUGH_LENS$1);
  state2.distcode = state2.distdyn = Buf32(ENOUGH_DISTS$1);
  state2.sane = 1;
  state2.back = -1;
  return Z_OK$1;
}
function inflateReset(strm) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state2 = strm.state;
  state2.wsize = 0;
  state2.whave = 0;
  state2.wnext = 0;
  return inflateResetKeep(strm);
}
function inflateReset2(strm, windowBits) {
  var wrap2;
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state2 = strm.state;
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else {
    wrap2 = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state2.window !== null && state2.wbits !== windowBits) {
    state2.window = null;
  }
  state2.wrap = wrap2;
  state2.wbits = windowBits;
  return inflateReset(strm);
}
function inflateInit2(strm, windowBits) {
  var ret;
  var state2;
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  state2 = new InflateState();
  strm.state = state2;
  state2.window = null;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
}
var virgin = true;
var lenfix;
var distfix;
function fixedtables(state2) {
  if (virgin) {
    var sym;
    lenfix = Buf32(512);
    distfix = Buf32(32);
    sym = 0;
    while (sym < 144) {
      state2.lens[sym++] = 8;
    }
    while (sym < 256) {
      state2.lens[sym++] = 9;
    }
    while (sym < 280) {
      state2.lens[sym++] = 7;
    }
    while (sym < 288) {
      state2.lens[sym++] = 8;
    }
    inflate_table(LENS$1, state2.lens, 0, 288, lenfix, 0, state2.work, {
      bits: 9
    });
    sym = 0;
    while (sym < 32) {
      state2.lens[sym++] = 5;
    }
    inflate_table(DISTS$1, state2.lens, 0, 32, distfix, 0, state2.work, {
      bits: 5
    });
    virgin = false;
  }
  state2.lencode = lenfix;
  state2.lenbits = 9;
  state2.distcode = distfix;
  state2.distbits = 5;
}
function updatewindow(strm, src, end, copy) {
  var dist;
  var state2 = strm.state;
  if (state2.window === null) {
    state2.wsize = 1 << state2.wbits;
    state2.wnext = 0;
    state2.whave = 0;
    state2.window = Buf8(state2.wsize);
  }
  if (copy >= state2.wsize) {
    arraySet(state2.window, src, end - state2.wsize, state2.wsize, 0);
    state2.wnext = 0;
    state2.whave = state2.wsize;
  } else {
    dist = state2.wsize - state2.wnext;
    if (dist > copy) {
      dist = copy;
    }
    arraySet(state2.window, src, end - copy, dist, state2.wnext);
    copy -= dist;
    if (copy) {
      arraySet(state2.window, src, end - copy, copy, 0);
      state2.wnext = copy;
      state2.whave = state2.wsize;
    } else {
      state2.wnext += dist;
      if (state2.wnext === state2.wsize) {
        state2.wnext = 0;
      }
      if (state2.whave < state2.wsize) {
        state2.whave += dist;
      }
    }
  }
  return 0;
}
function inflate(strm, flush) {
  var state2;
  var input, output;
  var next;
  var put;
  var have, left;
  var hold;
  var bits;
  var _in, _out;
  var copy;
  var from;
  var from_source;
  var here = 0;
  var here_bits, here_op, here_val;
  var last_bits, last_op, last_val;
  var len;
  var ret;
  var hbuf = Buf8(4);
  var opts;
  var n;
  var order = (
    /* permutation of code lengths */
    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
  );
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state2 = strm.state;
  if (state2.mode === TYPE$1) {
    state2.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state2.hold;
  bits = state2.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state2.mode) {
        case HEAD:
          if (state2.wrap === 0) {
            state2.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.wrap & 2 && hold === 35615) {
            state2.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32(state2.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state2.mode = FLAGS;
            break;
          }
          state2.flags = 0;
          if (state2.head) {
            state2.head.done = false;
          }
          if (!(state2.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state2.mode = BAD$1;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED$1) {
            strm.msg = "unknown compression method";
            state2.mode = BAD$1;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state2.wbits === 0) {
            state2.wbits = len;
          } else if (len > state2.wbits) {
            strm.msg = "invalid window size";
            state2.mode = BAD$1;
            break;
          }
          state2.dmax = 1 << len;
          strm.adler = state2.check = 1;
          state2.mode = hold & 512 ? DICTID : TYPE$1;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.flags = hold;
          if ((state2.flags & 255) !== Z_DEFLATED$1) {
            strm.msg = "unknown compression method";
            state2.mode = BAD$1;
            break;
          }
          if (state2.flags & 57344) {
            strm.msg = "unknown header flags set";
            state2.mode = BAD$1;
            break;
          }
          if (state2.head) {
            state2.head.text = hold >> 8 & 1;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = TIME;
        /* falls through */
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.time = hold;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state2.check = crc32(state2.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = OS;
        /* falls through */
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.xflags = hold & 255;
            state2.head.os = hold >> 8;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = EXLEN;
        /* falls through */
        case EXLEN:
          if (state2.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.length = hold;
            if (state2.head) {
              state2.head.extra_len = hold;
            }
            if (state2.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc32(state2.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state2.head) {
            state2.head.extra = null;
          }
          state2.mode = EXTRA;
        /* falls through */
        case EXTRA:
          if (state2.flags & 1024) {
            copy = state2.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state2.head) {
                len = state2.head.extra_len - state2.length;
                if (!state2.head.extra) {
                  state2.head.extra = new Array(state2.head.extra_len);
                }
                arraySet(
                  state2.head.extra,
                  input,
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  copy,
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state2.flags & 512) {
                state2.check = crc32(state2.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state2.length -= copy;
            }
            if (state2.length) {
              break inf_leave;
            }
          }
          state2.length = 0;
          state2.mode = NAME;
        /* falls through */
        case NAME:
          if (state2.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state2.flags & 512) {
              state2.check = crc32(state2.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.name = null;
          }
          state2.length = 0;
          state2.mode = COMMENT;
        /* falls through */
        case COMMENT:
          if (state2.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state2.flags & 512) {
              state2.check = crc32(state2.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.comment = null;
          }
          state2.mode = HCRC;
        /* falls through */
        case HCRC:
          if (state2.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state2.check & 65535)) {
              strm.msg = "header crc mismatch";
              state2.mode = BAD$1;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state2.head) {
            state2.head.hcrc = state2.flags >> 9 & 1;
            state2.head.done = true;
          }
          strm.adler = state2.check = 0;
          state2.mode = TYPE$1;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state2.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state2.mode = DICT;
        /* falls through */
        case DICT:
          if (state2.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state2.check = 1;
          state2.mode = TYPE$1;
        /* falls through */
        case TYPE$1:
          if (flush === Z_BLOCK$1 || flush === Z_TREES$1) {
            break inf_leave;
          }
        /* falls through */
        case TYPEDO:
          if (state2.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state2.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state2.mode = STORED;
              break;
            case 1:
              fixedtables(state2);
              state2.mode = LEN_;
              if (flush === Z_TREES$1) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state2.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state2.mode = BAD$1;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state2.mode = BAD$1;
            break;
          }
          state2.length = hold & 65535;
          hold = 0;
          bits = 0;
          state2.mode = COPY_;
          if (flush === Z_TREES$1) {
            break inf_leave;
          }
        /* falls through */
        case COPY_:
          state2.mode = COPY;
        /* falls through */
        case COPY:
          copy = state2.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            arraySet(output, input, next, copy, put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state2.length -= copy;
            break;
          }
          state2.mode = TYPE$1;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state2.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state2.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state2.nlen > 286 || state2.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state2.mode = BAD$1;
            break;
          }
          state2.have = 0;
          state2.mode = LENLENS;
        /* falls through */
        case LENLENS:
          while (state2.have < state2.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.lens[order[state2.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state2.have < 19) {
            state2.lens[order[state2.have++]] = 0;
          }
          state2.lencode = state2.lendyn;
          state2.lenbits = 7;
          opts = {
            bits: state2.lenbits
          };
          ret = inflate_table(CODES$1, state2.lens, 0, 19, state2.lencode, 0, state2.work, opts);
          state2.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state2.mode = BAD$1;
            break;
          }
          state2.have = 0;
          state2.mode = CODELENS;
        /* falls through */
        case CODELENS:
          while (state2.have < state2.nlen + state2.ndist) {
            for (; ; ) {
              here = state2.lencode[hold & (1 << state2.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state2.lens[state2.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state2.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state2.mode = BAD$1;
                  break;
                }
                len = state2.lens[state2.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state2.have + copy > state2.nlen + state2.ndist) {
                strm.msg = "invalid bit length repeat";
                state2.mode = BAD$1;
                break;
              }
              while (copy--) {
                state2.lens[state2.have++] = len;
              }
            }
          }
          if (state2.mode === BAD$1) {
            break;
          }
          if (state2.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state2.mode = BAD$1;
            break;
          }
          state2.lenbits = 9;
          opts = {
            bits: state2.lenbits
          };
          ret = inflate_table(LENS$1, state2.lens, 0, state2.nlen, state2.lencode, 0, state2.work, opts);
          state2.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state2.mode = BAD$1;
            break;
          }
          state2.distbits = 6;
          state2.distcode = state2.distdyn;
          opts = {
            bits: state2.distbits
          };
          ret = inflate_table(DISTS$1, state2.lens, state2.nlen, state2.ndist, state2.distcode, 0, state2.work, opts);
          state2.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state2.mode = BAD$1;
            break;
          }
          state2.mode = LEN_;
          if (flush === Z_TREES$1) {
            break inf_leave;
          }
        /* falls through */
        case LEN_:
          state2.mode = LEN;
        /* falls through */
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            inflate_fast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state2.hold;
            bits = state2.bits;
            if (state2.mode === TYPE$1) {
              state2.back = -1;
            }
            break;
          }
          state2.back = 0;
          for (; ; ) {
            here = state2.lencode[hold & (1 << state2.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          state2.length = here_val;
          if (here_op === 0) {
            state2.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state2.back = -1;
            state2.mode = TYPE$1;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state2.mode = BAD$1;
            break;
          }
          state2.extra = here_op & 15;
          state2.mode = LENEXT;
        /* falls through */
        case LENEXT:
          if (state2.extra) {
            n = state2.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.length += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          state2.was = state2.length;
          state2.mode = DIST;
        /* falls through */
        case DIST:
          for (; ; ) {
            here = state2.distcode[hold & (1 << state2.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state2.mode = BAD$1;
            break;
          }
          state2.offset = here_val;
          state2.extra = here_op & 15;
          state2.mode = DISTEXT;
        /* falls through */
        case DISTEXT:
          if (state2.extra) {
            n = state2.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.offset += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          if (state2.offset > state2.dmax) {
            strm.msg = "invalid distance too far back";
            state2.mode = BAD$1;
            break;
          }
          state2.mode = MATCH;
        /* falls through */
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state2.offset > copy) {
            copy = state2.offset - copy;
            if (copy > state2.whave) {
              if (state2.sane) {
                strm.msg = "invalid distance too far back";
                state2.mode = BAD$1;
                break;
              }
            }
            if (copy > state2.wnext) {
              copy -= state2.wnext;
              from = state2.wsize - copy;
            } else {
              from = state2.wnext - copy;
            }
            if (copy > state2.length) {
              copy = state2.length;
            }
            from_source = state2.window;
          } else {
            from_source = output;
            from = put - state2.offset;
            copy = state2.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state2.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state2.length === 0) {
            state2.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state2.length;
          left--;
          state2.mode = LEN;
          break;
        case CHECK:
          if (state2.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state2.total += _out;
            if (_out) {
              strm.adler = state2.check = /*UPDATE(state.check, put - _out, _out);*/
              state2.flags ? crc32(state2.check, output, _out, put - _out) : adler32(state2.check, output, _out, put - _out);
            }
            _out = left;
            if ((state2.flags ? hold : zswap32(hold)) !== state2.check) {
              strm.msg = "incorrect data check";
              state2.mode = BAD$1;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = LENGTH;
        /* falls through */
        case LENGTH:
          if (state2.wrap && state2.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state2.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state2.mode = BAD$1;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = DONE;
        /* falls through */
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD$1:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR;
        case SYNC:
        /* falls through */
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state2.hold = hold;
  state2.bits = bits;
  if (state2.wsize || _out !== strm.avail_out && state2.mode < BAD$1 && (state2.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state2.total += _out;
  if (state2.wrap && _out) {
    strm.adler = state2.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state2.flags ? crc32(state2.check, output, _out, strm.next_out - _out) : adler32(state2.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state2.bits + (state2.last ? 64 : 0) + (state2.mode === TYPE$1 ? 128 : 0) + (state2.mode === LEN_ || state2.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR$1;
  }
  return ret;
}
function inflateEnd(strm) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  var state2 = strm.state;
  if (state2.window) {
    state2.window = null;
  }
  strm.state = null;
  return Z_OK$1;
}
function inflateGetHeader(strm, head) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state2 = strm.state;
  if ((state2.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state2.head = head;
  head.done = false;
  return Z_OK$1;
}
function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var state2;
  var dictid;
  var ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state2 = strm.state;
  if (state2.wrap !== 0 && state2.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state2.mode === DICT) {
    dictid = 1;
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state2.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state2.mode = MEM;
    return Z_MEM_ERROR;
  }
  state2.havedict = 1;
  return Z_OK$1;
}
var msg = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var toString4 = Object.prototype.toString;
var Inflate = function Inflate2(options2) {
  if (!(this instanceof Inflate2)) {
    return new Inflate2(options2);
  }
  this.options = assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ""
  }, options2 || {});
  var opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options2 && options2.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new ZStream();
  this.strm.avail_out = 0;
  var status = inflateInit2(this.strm, opt.windowBits);
  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }
  this.header = new GZheader();
  inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = string2buf(opt.dictionary);
    } else if (toString4.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
    }
  }
};
Inflate.prototype.push = function push2(data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict2;
  var allowBufError = false;
  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (typeof data === "string") {
    strm.input = binstring2buf(data);
  } else if (toString4.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  do {
    if (strm.avail_out === 0) {
      strm.output = Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate(strm, Z_NO_FLUSH);
    if (status === Z_NEED_DICT && dictionary) {
      if (typeof dictionary === "string") {
        dict2 = string2buf(dictionary);
      } else if (toString4.call(dictionary) === "[object ArrayBuffer]") {
        dict2 = new Uint8Array(dictionary);
      } else {
        dict2 = dictionary;
      }
      status = inflateSetDictionary(this.strm, dict2);
    }
    if (status === Z_BUF_ERROR && allowBufError === true) {
      status = Z_OK;
      allowBufError = false;
    }
    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
        if (this.options.to === "string") {
          next_out_utf8 = utf8border(strm.output, strm.next_out);
          tail = strm.next_out - next_out_utf8;
          utf8str = buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) {
            arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
          }
          this.onData(utf8str);
        } else {
          this.onData(shrinkBuf(strm.output, strm.next_out));
        }
      }
    }
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
  if (status === Z_STREAM_END) {
    _mode = Z_FINISH;
  }
  if (_mode === Z_FINISH) {
    status = inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }
  return true;
};
Inflate.prototype.onData = function onData(chunk) {
  this.chunks.push(chunk);
};
Inflate.prototype.onEnd = function onEnd(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function zero(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
);
var extra_dbits = (
  /* extra bits for each distance code */
  [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
);
var extra_blbits = (
  /* extra bits for each bit length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
);
var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
var DIST_CODE_LEN = 512;
var static_ltree;
var static_dtree;
var _dist_code;
var _length_code;
var base_length;
var base_dist;
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}
function put_short(s, w) {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
}
function send_bits(s, value, length) {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
}
function send_code(s, c, tree) {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
}
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}
function gen_bitlen(s, desc) {
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h;
  var n, m;
  var bits;
  var xbits;
  var f;
  var overflow = 0;
  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
}
function gen_codes(tree, max_code, bl_count) {
  var next_code = new Array(MAX_BITS + 1);
  var code = 0;
  var bits;
  var n;
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  for (n = 0; n <= max_code; n++) {
    var len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
}
function tr_static_init() {
  var n;
  var bits;
  var length;
  var code;
  var dist;
  var bl_count = new Array(MAX_BITS + 1);
  static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  _dist_code = new Array(DIST_CODE_LEN);
  zero(_dist_code);
  _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero(_length_code);
  base_length = new Array(LENGTH_CODES);
  zero(base_length);
  base_dist = new Array(D_CODES);
  zero(base_dist);
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES + 1, bl_count);
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
}
function init_block(s) {
  var n;
  for (n = 0; n < L_CODES; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}
function bi_windup(s) {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}
function copy_block(s, buf, len, header) {
  bi_windup(s);
  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
  arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
}
function pqdownheap(s, tree, k) {
  var v = s.heap[k];
  var j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
}
function compress_block(s, ltree, dtree) {
  var dist;
  var lc;
  var lx = 0;
  var code;
  var extra;
  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (lx < s.last_lit);
  }
  send_code(s, END_BLOCK, ltree);
}
function build_tree(s, desc) {
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n, m;
  var max_code = -1;
  var node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
}
function scan_tree(s, tree, max_code) {
  var n;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function send_tree(s, tree, max_code) {
  var n;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function build_bl_tree(s) {
  var max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
}
function send_all_trees(s, lcodes, dcodes, blcodes) {
  var rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
}
function detect_data_type(s) {
  var black_mask = 4093624447;
  var n;
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
}
var static_init_done = false;
function _tr_init(s) {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
}
function _tr_stored_block(s, buf, stored_len, last2) {
  send_bits(s, (STORED_BLOCK << 1) + (last2 ? 1 : 0), 3);
  copy_block(s, buf, stored_len, true);
}
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}
function _tr_flush_block(s, buf, stored_len, last2) {
  var opt_lenb, static_lenb;
  var max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block(s, buf, stored_len, last2);
  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last2 ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last2 ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last2) {
    bi_windup(s);
  }
}
function _tr_tally(s, dist, lc) {
  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
  s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
  s.last_lit++;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.last_lit === s.lit_bufsize - 1;
}
var MAX_MEM_LEVEL = 9;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var MIN_LOOKAHEAD = MAX_MATCH$1 + MIN_MATCH$1 + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}
function rank(f) {
  return (f << 1) - (f > 4 ? 9 : 0);
}
function zero$1(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
function flush_pending(strm) {
  var s = strm.state;
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}
function flush_block_only(s, last2) {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last2);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}
function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}
function putShortMSB(s, b) {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
}
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
}
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;
  var scan = s.strstart;
  var match2;
  var len;
  var best_len = s.prev_length;
  var nice_match = s.nice_match;
  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  var _win = s.window;
  var wmask = s.w_mask;
  var prev = s.prev;
  var strend = s.strstart + MAX_MATCH$1;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match2 = cur_match;
    if (_win[match2 + best_len] !== scan_end || _win[match2 + best_len - 1] !== scan_end1 || _win[match2] !== _win[scan] || _win[++match2] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match2++;
    do {
    } while (_win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && scan < strend);
    len = MAX_MATCH$1 - (strend - scan);
    scan = strend - MAX_MATCH$1;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);
      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH$1) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
      while (s.insert) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH$1 - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH$1) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
}
function deflate_stored(s, flush) {
  var max_block_size = 65535;
  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s.lookahead <= 1) {
      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.strstart += s.lookahead;
    s.lookahead = 0;
    var max_start = s.block_start + max_block_size;
    if (s.strstart === 0 || s.strstart >= max_start) {
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.strstart > s.block_start) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_NEED_MORE;
}
function deflate_fast(s, flush) {
  var hash_head;
  var bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH$1) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$1 - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH$1) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$1);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH$1) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$1 - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_slow(s, flush) {
  var hash_head;
  var bflush;
  var max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH$1) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$1 - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH$1 - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH$1 && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH$1 - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH$1 && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH$1;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$1);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$1 - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH$1 - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_rle(s, flush) {
  var bflush;
  var prev;
  var scan, strend;
  var _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH$1) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH$1 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH$1 && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH$1;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH$1 - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH$1) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH$1);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_huff(s, flush) {
  var bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configurationTable = function() {
  var table = [
    /*      good lazy nice chain */
    new Config(0, 0, 0, 0, deflate_stored),
    /* 0 store only */
    new Config(4, 4, 8, 4, deflate_fast),
    /* 1 max speed, no lazy matches */
    new Config(4, 5, 16, 8, deflate_fast),
    /* 2 */
    new Config(4, 6, 32, 32, deflate_fast),
    /* 3 */
    new Config(4, 4, 16, 16, deflate_slow),
    /* 4 lazy matches */
    new Config(8, 16, 32, 32, deflate_slow),
    /* 5 */
    new Config(8, 16, 128, 128, deflate_slow),
    /* 6 */
    new Config(8, 32, 128, 256, deflate_slow),
    /* 7 */
    new Config(32, 128, 258, 1024, deflate_slow),
    /* 8 */
    new Config(32, 258, 258, 4096, deflate_slow)
    /* 9 max compression */
  ];
  configurationTable = function() {
    return table;
  };
  return table;
};
function lm_init(s) {
  s.window_size = 2 * s.w_size;
  zero$1(s.head);
  var table = configurationTable();
  s.max_lazy_match = table[s.level].max_lazy;
  s.good_match = table[s.level].good_length;
  s.nice_match = table[s.level].nice_length;
  s.max_chain_length = table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH$1 - 1;
  s.match_available = 0;
  s.ins_h = 0;
}
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = Buf16(HEAP_SIZE$1 * 2);
  this.dyn_dtree = Buf16((2 * D_CODES$1 + 1) * 2);
  this.bl_tree = Buf16((2 * BL_CODES$1 + 1) * 2);
  zero$1(this.dyn_ltree);
  zero$1(this.dyn_dtree);
  zero$1(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = Buf16(MAX_BITS$1 + 1);
  this.heap = Buf16(2 * L_CODES$1 + 1);
  zero$1(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = Buf16(2 * L_CODES$1 + 1);
  zero$1(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
function deflateResetKeep(strm) {
  var s;
  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = Z_NO_FLUSH;
  _tr_init(s);
  return Z_OK;
}
function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}
function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR;
  }
  strm.state.gzhead = head;
  return Z_OK;
}
function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    return Z_STREAM_ERROR;
  }
  var wrap2 = 1;
  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap2 = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  var s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.wrap = wrap2;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH$1 - 1) / MIN_MATCH$1);
  s.window = Buf8(s.w_size * 2);
  s.head = Buf16(s.hash_size);
  s.prev = Buf16(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = Buf8(s.pending_buf_size);
  s.d_buf = 1 * s.lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
}
function deflate(strm, flush) {
  var old_flush, s;
  var beg, val;
  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }
  s = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }
  s.strm = strm;
  old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.status === INIT_STATE) {
    if (s.wrap === 2) {
      strm.adler = 0;
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) {
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      } else {
        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
        put_byte(s, s.gzhead.time & 255);
        put_byte(s, s.gzhead.time >> 8 & 255);
        put_byte(s, s.gzhead.time >> 16 & 255);
        put_byte(s, s.gzhead.time >> 24 & 255);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 255);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 255);
          put_byte(s, s.gzhead.extra.length >> 8 & 255);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    } else {
      var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
      var level_flags = -1;
      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      s.status = BUSY_STATE;
      putShortMSB(s, header);
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      beg = s.pending;
      while (s.gzindex < (s.gzhead.extra.length & 65535)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 255);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    } else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    } else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    } else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        strm.adler = 0;
        s.status = BUSY_STATE;
      }
    } else {
      s.status = BUSY_STATE;
    }
  }
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configurationTable()[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH) {
          zero$1(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK;
      }
    }
  }
  if (flush !== Z_FINISH) {
    return Z_OK;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}
function deflateEnd(strm) {
  var status;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR);
  }
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var s;
  var str, n;
  var wrap2;
  var avail;
  var next;
  var input;
  var tmpDict;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  s = strm.state;
  wrap2 = s.wrap;
  if (wrap2 === 2 || wrap2 === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR;
  }
  if (wrap2 === 1) {
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap2 === 0) {
      zero$1(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    tmpDict = Buf8(s.w_size);
    arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH$1) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH$1 - 1);
    do {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH$1 - 1]) & s.hash_mask;
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH$1 - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH$1 - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap2;
  return Z_OK;
}
var toString$1 = Object.prototype.toString;
var Deflate = function Deflate2(options2) {
  this.options = assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ""
  }, options2 || {});
  var opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new ZStream();
  this.strm.avail_out = 0;
  var status = deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }
  if (opt.header) {
    deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    var dict2;
    if (typeof opt.dictionary === "string") {
      dict2 = string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict2 = new Uint8Array(opt.dictionary);
    } else {
      dict2 = opt.dictionary;
    }
    status = deflateSetDictionary(this.strm, dict2);
    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }
    this._dict_set = true;
  }
};
Deflate.prototype.push = function push3(data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;
  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (typeof data === "string") {
    strm.input = string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  do {
    if (strm.avail_out === 0) {
      strm.output = Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = deflate(strm, _mode);
    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
      if (this.options.to === "string") {
        this.onData(buf2binstring(shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
  if (_mode === Z_FINISH) {
    status = deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }
  return true;
};
Deflate.prototype.onData = function onData2(chunk) {
  this.chunks.push(chunk);
};
Deflate.prototype.onEnd = function onEnd2(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options2) {
  var deflator = new Deflate(options2);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || msg[deflator.err];
  }
  return deflator.result;
}

// node_modules/@progress/kendo-drawing/dist/es/pdf/deflate.js
var deflate2 = deflate$1;
function supportsDeflate() {
  return true;
}

// node_modules/@progress/kendo-drawing/dist/es/pdf/core.js
var browser4 = support_default.browser;
var NL = "\n";
var RESOURCE_COUNTER = 0;
var PATTERN_COUNTER = 0;
var PAPER_SIZE = {
  a0: [2383.94, 3370.39],
  a1: [1683.78, 2383.94],
  a2: [1190.55, 1683.78],
  a3: [841.89, 1190.55],
  a4: [595.28, 841.89],
  a5: [419.53, 595.28],
  a6: [297.64, 419.53],
  a7: [209.76, 297.64],
  a8: [147.4, 209.76],
  a9: [104.88, 147.4],
  a10: [73.7, 104.88],
  b0: [2834.65, 4008.19],
  b1: [2004.09, 2834.65],
  b2: [1417.32, 2004.09],
  b3: [1000.63, 1417.32],
  b4: [708.66, 1000.63],
  b5: [498.9, 708.66],
  b6: [354.33, 498.9],
  b7: [249.45, 354.33],
  b8: [175.75, 249.45],
  b9: [124.72, 175.75],
  b10: [87.87, 124.72],
  c0: [2599.37, 3676.54],
  c1: [1836.85, 2599.37],
  c2: [1298.27, 1836.85],
  c3: [918.43, 1298.27],
  c4: [649.13, 918.43],
  c5: [459.21, 649.13],
  c6: [323.15, 459.21],
  c7: [229.61, 323.15],
  c8: [161.57, 229.61],
  c9: [113.39, 161.57],
  c10: [79.37, 113.39],
  executive: [521.86, 756],
  folio: [612, 936],
  legal: [612, 1008],
  letter: [612, 792],
  tabloid: [792, 1224]
};
function makeOutput() {
  var indentLevel = 0, output = BinaryStream();
  function out() {
    var arguments$1 = arguments;
    for (var i = 0; i < arguments.length; ++i) {
      var x = arguments$1[i];
      if (x === void 0) {
        throw new Error("Cannot output undefined to PDF");
      } else if (x instanceof PDFValue) {
        x.beforeRender(out);
        x.render(out);
      } else if (isArray(x)) {
        renderArray(x, out);
      } else if (isDate2(x)) {
        renderDate(x, out);
      } else if (typeof x == "number") {
        if (isNaN(x)) {
          throw new Error("Cannot output NaN to PDF");
        }
        var num = x.toFixed(7);
        if (num.indexOf(".") >= 0) {
          num = num.replace(/\.?0+$/, "");
        }
        if (num == "-0") {
          num = "0";
        }
        output.writeString(num);
      } else if (/string|boolean/.test(typeof x)) {
        output.writeString(String(x));
      } else if (typeof x.get == "function") {
        output.write(x.get());
      } else if (typeof x == "object") {
        if (!x) {
          output.writeString("null");
        } else {
          out(new PDFDictionary(x));
        }
      }
    }
  }
  out.writeData = function(data) {
    output.write(data);
  };
  out.withIndent = function(f) {
    ++indentLevel;
    f(out);
    --indentLevel;
  };
  out.indent = function() {
    out(NL, pad2("", indentLevel * 2, "  "));
    out.apply(null, arguments);
  };
  out.offset = function() {
    return output.offset();
  };
  out.toString = function() {
    throw new Error("FIX CALLER");
  };
  out.get = function() {
    return output.get();
  };
  out.stream = function() {
    return output;
  };
  return out;
}
function wrapObject(value, id2) {
  var beforeRender2 = value.beforeRender;
  var renderValue = value.render;
  value.beforeRender = function() {
  };
  value.render = function(out) {
    out(id2, " 0 R");
  };
  value.renderFull = function(out) {
    value._offset = out.offset();
    out(id2, " 0 obj ");
    beforeRender2.call(value, out);
    renderValue.call(value, out);
    out(" endobj");
  };
}
function getPaperOptions(getOption) {
  if (typeof getOption != "function") {
    var options2 = getOption;
    getOption = function(key, def) {
      return key in options2 ? options2[key] : def;
    };
  }
  var paperSize = getOption("paperSize", PAPER_SIZE.a4);
  if (!paperSize) {
    return {};
  }
  if (typeof paperSize == "string") {
    paperSize = PAPER_SIZE[paperSize.toLowerCase()];
    if (paperSize == null) {
      throw new Error("Unknown paper size");
    }
  }
  paperSize[0] = unitsToPoints(paperSize[0]);
  paperSize[1] = unitsToPoints(paperSize[1]);
  if (getOption("landscape", false)) {
    paperSize = [Math.max(paperSize[0], paperSize[1]), Math.min(paperSize[0], paperSize[1])];
  }
  var margin = getOption("margin");
  if (margin) {
    if (typeof margin == "string" || typeof margin == "number") {
      margin = unitsToPoints(margin, 0);
      margin = {
        left: margin,
        top: margin,
        right: margin,
        bottom: margin
      };
    } else {
      margin = {
        left: unitsToPoints(margin.left, 0),
        top: unitsToPoints(margin.top, 0),
        right: unitsToPoints(margin.right, 0),
        bottom: unitsToPoints(margin.bottom, 0)
      };
    }
    if (getOption("addMargin")) {
      paperSize[0] += margin.left + margin.right;
      paperSize[1] += margin.top + margin.bottom;
    }
  }
  return {
    paperSize,
    margin
  };
}
var FONT_CACHE = {
  "Times-Roman": true,
  "Times-Bold": true,
  "Times-Italic": true,
  "Times-BoldItalic": true,
  "Helvetica": true,
  "Helvetica-Bold": true,
  "Helvetica-Oblique": true,
  "Helvetica-BoldOblique": true,
  "Courier": true,
  "Courier-Bold": true,
  "Courier-Oblique": true,
  "Courier-BoldOblique": true,
  "Symbol": true,
  "ZapfDingbats": true
};
function loadBinary(url, cont) {
  var m;
  if (browser4.msie && (m = /^data:.*?;base64,/i.exec(url))) {
    cont(base64ToUint8Array(url.substr(m[0].length)));
    return;
  }
  function error2() {
    if (window.console) {
      if (window.console.error) {
        window.console.error("Cannot load URL: %s", url);
      } else {
        window.console.log("Cannot load URL: %s", url);
      }
    }
    cont(null);
  }
  var req = new XMLHttpRequest();
  req.open("GET", url, true);
  if (HAS_TYPED_ARRAYS) {
    req.responseType = "arraybuffer";
  }
  req.onload = function() {
    if (req.status == 200 || req.status == 304) {
      if (HAS_TYPED_ARRAYS) {
        cont(new Uint8Array(req.response));
      } else {
        cont(new window.VBArray(req.responseBody).toArray());
      }
    } else {
      error2();
    }
  };
  req.onerror = error2;
  req.send(null);
}
function loadFont(url, cont) {
  var font = FONT_CACHE[url];
  if (font) {
    cont(font);
  } else {
    loadBinary(url, function(data) {
      if (data == null) {
        throw new Error("Cannot load font from " + url);
      } else {
        var font2 = new TTFFont(data);
        FONT_CACHE[url] = font2;
        cont(font2);
      }
    });
  }
}
var IMAGE_CACHE = {};
function clearImageCache() {
  IMAGE_CACHE = {};
}
function loadImage(url, size, cont, options2) {
  var img = IMAGE_CACHE[url], bloburl, blob;
  if (img) {
    cont(img);
  } else {
    img = new Image();
    if (!/^data:/i.test(url)) {
      img.crossOrigin = "Anonymous";
    }
    if (HAS_TYPED_ARRAYS && !/^data:/i.test(url)) {
      var xhr = new XMLHttpRequest();
      xhr.onload = function() {
        blob = xhr.response;
        if (browser4.mozilla && blob.type == "image/svg+xml") {
          var reader = new FileReader();
          reader.onload = function() {
            var doc = new window.DOMParser().parseFromString(this.result, "image/svg+xml");
            var svg = doc.documentElement;
            if (svg.getAttribute("width") && svg.getAttribute("height")) {
              bloburl = URL.createObjectURL(blob);
              _load(bloburl);
            } else {
              svg.setAttribute("width", size.width);
              svg.setAttribute("height", size.height);
              var xml = new window.XMLSerializer().serializeToString(svg);
              var dataURL = "data:image/svg+xml;base64," + encodeBase64(xml);
              _load(dataURL);
            }
          };
          reader.readAsText(blob);
        } else {
          bloburl = URL.createObjectURL(blob);
          _load(bloburl);
        }
      };
      xhr.onerror = _onerror;
      xhr.open("GET", url, true);
      xhr.responseType = "blob";
      xhr.send();
    } else {
      _load(url);
    }
  }
  function _load(url2) {
    img.src = url2;
    if (img.complete && !browser4.msie) {
      _onload.call(img);
    } else {
      img.onload = _onload;
      img.onerror = _onerror;
    }
  }
  function _trycanvas() {
    if (!size) {
      size = {
        width: img.width,
        height: img.height
      };
    }
    var canvas = document.createElement("canvas");
    canvas.width = size.width;
    canvas.height = size.height;
    var ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, size.width, size.height);
    var imgdata;
    try {
      imgdata = ctx.getImageData(0, 0, size.width, size.height);
    } catch (ex) {
      _onerror();
      return;
    } finally {
      if (bloburl) {
        URL.revokeObjectURL(bloburl);
      }
    }
    var hasAlpha = false, rgb = BinaryStream(), alpha = BinaryStream();
    var rawbytes = imgdata.data;
    var i = 0;
    while (i < rawbytes.length) {
      rgb.writeByte(rawbytes[i++]);
      rgb.writeByte(rawbytes[i++]);
      rgb.writeByte(rawbytes[i++]);
      var a = rawbytes[i++];
      if (a < 255) {
        hasAlpha = true;
      }
      alpha.writeByte(a);
    }
    if (hasAlpha || options2.keepPNG) {
      img = new PDFRawImage(size.width, size.height, rgb, alpha);
    } else {
      var data = canvas.toDataURL("image/jpeg", options2.jpegQuality);
      data = data.substr(data.indexOf(";base64,") + 8);
      var stream2 = BinaryStream();
      stream2.writeBase64(data);
      img = new PDFJpegImage(stream2);
    }
    cont(IMAGE_CACHE[url] = img);
  }
  function _onerror() {
    cont(IMAGE_CACHE[url] = "ERROR");
  }
  function _onload() {
    if (size) {
      var svg = blob && blob.type === "image/svg+xml" || /^data:image\/svg\+xml;/i.test(this.src.substring(0, 19));
      var upscale = size.width >= img.width || size.height >= img.height;
      if (!svg && upscale) {
        size = null;
      }
    }
    if (!size && blob && /^image\/jpe?g$/i.test(blob.type)) {
      var reader = new FileReader();
      reader.onload = function() {
        try {
          var img2 = new PDFJpegImage(BinaryStream(new Uint8Array(this.result)));
          URL.revokeObjectURL(bloburl);
          cont(IMAGE_CACHE[url] = img2);
        } catch (ex) {
          _trycanvas();
        }
      };
      reader.readAsArrayBuffer(blob);
    } else {
      _trycanvas();
    }
  }
}
function manyLoader(loadOne) {
  return function(urls, callback) {
    var n = urls.length, i = n;
    if (n === 0) {
      return callback();
    }
    function next() {
      if (--n === 0) {
        callback();
      }
    }
    while (i-- > 0) {
      loadOne(urls[i], next);
    }
  };
}
var loadFonts = manyLoader(loadFont);
var loadImages = function(images, callback, options2) {
  options2 = Object.assign({
    jpegQuality: 0.92,
    keepPNG: false
  }, options2);
  var urls = Object.keys(images), n = urls.length;
  if (n === 0) {
    return callback();
  }
  function next() {
    if (--n === 0) {
      callback();
    }
  }
  urls.forEach(function(url) {
    loadImage(url, images[url], next, options2);
  });
};
var PDFDocument = function PDFDocument2(options2) {
  var self = this;
  var out = makeOutput();
  var objcount = 0;
  var objects = [];
  function getOption(name2, defval) {
    return options2 && options2[name2] != null ? options2[name2] : defval;
  }
  self.getOption = getOption;
  self.attach = function(value) {
    if (objects.indexOf(value) < 0) {
      wrapObject(value, ++objcount);
      objects.push(value);
    }
    return value;
  };
  self.pages = [];
  self.FONTS = {};
  self.PATTERNS = {};
  self.IMAGES = {};
  self.GRAD_COL_FUNCTIONS = {};
  self.GRAD_OPC_FUNCTIONS = {};
  self.GRAD_COL = {};
  self.GRAD_OPC = {};
  var catalog = self.attach(new PDFCatalog());
  var pageTree = self.attach(new PDFPageTree());
  if (getOption("autoPrint")) {
    var nameTree = {};
    nameTree.JavaScript = new PDFDictionary({
      Names: [new PDFString("JS"), self.attach(new PDFDictionary({
        S: _("JavaScript"),
        JS: new PDFString("print(true);")
      }))]
    });
    catalog.props.Names = new PDFDictionary(nameTree);
  }
  catalog.setPages(pageTree);
  var info = self.attach(new PDFDictionary({
    Producer: new PDFString(getOption("producer", "Kendo UI PDF Generator"), true),
    // XXX: kendo.version?
    Title: new PDFString(getOption("title", ""), true),
    Author: new PDFString(getOption("author", ""), true),
    Subject: new PDFString(getOption("subject", ""), true),
    Keywords: new PDFString(getOption("keywords", ""), true),
    Creator: new PDFString(getOption("creator", "Kendo UI PDF Generator"), true),
    CreationDate: getOption("date", /* @__PURE__ */ new Date())
  }));
  self.addPage = function(options3) {
    var paperOptions = getPaperOptions(function(name2, defval) {
      return options3 && options3[name2] != null ? options3[name2] : defval;
    });
    var paperSize = paperOptions.paperSize;
    var margin = paperOptions.margin;
    var contentWidth = paperSize[0];
    var contentHeight = paperSize[1];
    if (margin) {
      contentWidth -= margin.left + margin.right;
      contentHeight -= margin.top + margin.bottom;
    }
    var content = new PDFStream(makeOutput(), null, true);
    var props = {
      Contents: self.attach(content),
      Parent: pageTree,
      MediaBox: [0, 0, paperSize[0], paperSize[1]]
    };
    var page = new PDFPage(self, props);
    page._content = content;
    pageTree.addPage(self.attach(page));
    page.transform(1, 0, 0, -1, 0, paperSize[1]);
    if (margin) {
      page.translate(margin.left, margin.top);
      page.rect(0, 0, contentWidth, contentHeight);
      page.clip();
    }
    self.pages.push(page);
    return page;
  };
  self.render = function() {
    var i;
    out("%PDF-1.4", NL, "%ÂÁÚÏÎ", NL, NL);
    for (i = 0; i < objects.length; ++i) {
      objects[i].renderFull(out);
      out(NL, NL);
    }
    var xrefOffset = out.offset();
    out("xref", NL, 0, " ", objects.length + 1, NL);
    out("0000000000 65535 f ", NL);
    for (i = 0; i < objects.length; ++i) {
      out(zeropad(objects[i]._offset, 10), " 00000 n ", NL);
    }
    out(NL);
    out("trailer", NL);
    out(new PDFDictionary({
      Size: objects.length + 1,
      Root: catalog,
      Info: info
    }), NL, NL);
    out("startxref", NL, xrefOffset, NL);
    out("%%EOF", NL);
    return out.stream().offset(0);
  };
  self.loadFonts = loadFonts;
  self.loadImages = loadImages;
};
PDFDocument.prototype.getFont = function getFont(url) {
  var font = this.FONTS[url];
  if (!font) {
    font = FONT_CACHE[url];
    if (!font) {
      throw new Error("Font " + url + " has not been loaded");
    }
    if (font === true) {
      font = this.attach(new PDFStandardFont(url));
    } else {
      font = this.attach(new PDFFont(this, font));
    }
    this.FONTS[url] = font;
  }
  return font;
};
PDFDocument.prototype.getPattern = function getPattern(fill, page, drawPattern2) {
  var pattern = this.PATTERNS[fill.id];
  if (!pattern) {
    pattern = this.attach(new PDFPattern(fill, page, drawPattern2));
    this.PATTERNS[fill.id] = pattern;
  }
  return pattern;
};
PDFDocument.prototype.getImage = function getImage(url) {
  var img = this.IMAGES[url];
  if (!img) {
    img = IMAGE_CACHE[url];
    if (!img) {
      throw new Error("Image " + url + " has not been loaded");
    }
    if (img === "ERROR") {
      return null;
    }
    img = this.IMAGES[url] = this.attach(img.asStream(this));
  }
  return img;
};
PDFDocument.prototype.getOpacityGS = function getOpacityGS(opacity, forStroke) {
  var id2 = parseFloat(opacity).toFixed(3);
  opacity = parseFloat(id2);
  id2 += forStroke ? "S" : "F";
  var cache = this._opacityGSCache || (this._opacityGSCache = {});
  var gs = cache[id2];
  if (!gs) {
    var props = {
      Type: _("ExtGState")
    };
    if (forStroke) {
      props.CA = opacity;
    } else {
      props.ca = opacity;
    }
    gs = this.attach(new PDFDictionary(props));
    gs._resourceName = _("GS" + ++RESOURCE_COUNTER);
    cache[id2] = gs;
  }
  return gs;
};
PDFDocument.prototype.dict = function dict(props) {
  return new PDFDictionary(props);
};
PDFDocument.prototype.name = function name(str) {
  return _(str);
};
PDFDocument.prototype.stream = function stream(props, content) {
  return new PDFStream(content, props);
};
function pad2(str, len, ch) {
  while (str.length < len) {
    str = ch + str;
  }
  return str;
}
function zeropad(n, len) {
  return pad2(String(n), len, "0");
}
function hasOwnProperty2(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
var isArray = Array.isArray || function(obj) {
  return obj instanceof Array;
};
function isDate2(obj) {
  return obj instanceof Date;
}
function renderArray(a, out) {
  out("[");
  if (a.length > 0) {
    out.withIndent(function() {
      for (var i = 0; i < a.length; ++i) {
        if (i > 0 && i % 8 === 0) {
          out.indent(a[i]);
        } else {
          out(" ", a[i]);
        }
      }
    });
  }
  out(" ]");
}
function renderDate(date, out) {
  out("(D:", zeropad(date.getUTCFullYear(), 4), zeropad(date.getUTCMonth() + 1, 2), zeropad(date.getUTCDate(), 2), zeropad(date.getUTCHours(), 2), zeropad(date.getUTCMinutes(), 2), zeropad(date.getUTCSeconds(), 2), "Z)");
}
function mm2pt(mm) {
  return mm * (72 / 25.4);
}
function cm2pt(cm) {
  return mm2pt(cm * 10);
}
function in2pt(inch) {
  return inch * 72;
}
function unitsToPoints(x, def) {
  if (typeof x == "number") {
    return x;
  }
  if (typeof x == "string") {
    var m;
    m = /^\s*([0-9.]+)\s*(mm|cm|in|pt)\s*$/.exec(x);
    if (m) {
      var num = parseFloat(m[1]);
      if (!isNaN(num)) {
        if (m[2] == "pt") {
          return num;
        }
        return {
          "mm": mm2pt,
          "cm": cm2pt,
          "in": in2pt
        }[m[2]](num);
      }
    }
  }
  if (def != null) {
    return def;
  }
  throw new Error("Can't parse unit: " + x);
}
var PDFValue = function PDFValue2() {
};
PDFValue.prototype.beforeRender = function beforeRender() {
};
var PDFString = function(PDFValue3) {
  function PDFString2(value, utf16be) {
    PDFValue3.call(this);
    this.value = value;
    this.utf16be = Boolean(utf16be);
  }
  if (PDFValue3) PDFString2.__proto__ = PDFValue3;
  PDFString2.prototype = Object.create(PDFValue3 && PDFValue3.prototype);
  PDFString2.prototype.constructor = PDFString2;
  PDFString2.prototype.render = function render4(out) {
    var txt = this.value;
    if (this.utf16be) {
      txt = BOM + encodeUTF16BE(txt);
      txt = txt.replace(/([\(\)\\])/g, "\\$1");
      out("(", txt, ")");
    } else {
      var data = [40];
      for (var i = 0; i < txt.length; ++i) {
        var code = txt.charCodeAt(i) & 255;
        if (code == 40 || code == 41 || code == 92) {
          data.push(92);
        }
        data.push(code);
      }
      data.push(41);
      out.writeData(data);
    }
  };
  PDFString2.prototype.toString = function toString5() {
    return this.value;
  };
  return PDFString2;
}(PDFValue);
var PDFHexString = function(PDFString2) {
  function PDFHexString2(value) {
    PDFString2.call(this, value);
    this.value = value;
  }
  if (PDFString2) PDFHexString2.__proto__ = PDFString2;
  PDFHexString2.prototype = Object.create(PDFString2 && PDFString2.prototype);
  PDFHexString2.prototype.constructor = PDFHexString2;
  PDFHexString2.prototype.render = function render4(out) {
    var this$1 = this;
    out("<");
    for (var i = 0; i < this.value.length; ++i) {
      out(zeropad(this$1.value.charCodeAt(i).toString(16), 4));
    }
    out(">");
  };
  return PDFHexString2;
}(PDFString);
var PDFName = function(PDFValue3) {
  function PDFName2(name2) {
    PDFValue3.call(this);
    this.name = name2;
  }
  if (PDFValue3) PDFName2.__proto__ = PDFValue3;
  PDFName2.prototype = Object.create(PDFValue3 && PDFValue3.prototype);
  PDFName2.prototype.constructor = PDFName2;
  PDFName2.get = function get(name2) {
    return _(name2);
  };
  PDFName2.prototype.render = function render4(out) {
    out("/" + this.escape());
  };
  PDFName2.prototype.escape = function escape() {
    return this.name.replace(/[^\x21-\x7E]/g, function(c) {
      return "#" + zeropad(c.charCodeAt(0).toString(16), 2);
    });
  };
  PDFName2.prototype.toString = function toString5() {
    return this.name;
  };
  return PDFName2;
}(PDFValue);
function _(name2) {
  return new PDFName(name2);
}
var PDFDictionary = function(PDFValue3) {
  function PDFDictionary2(props) {
    PDFValue3.call(this);
    this.props = props;
  }
  if (PDFValue3) PDFDictionary2.__proto__ = PDFValue3;
  PDFDictionary2.prototype = Object.create(PDFValue3 && PDFValue3.prototype);
  PDFDictionary2.prototype.constructor = PDFDictionary2;
  PDFDictionary2.prototype.render = function render4(out) {
    var props = this.props, empty = true;
    out("<<");
    out.withIndent(function() {
      for (var i in props) {
        if (hasOwnProperty2(props, i) && !/^_/.test(i)) {
          empty = false;
          out.indent(_(i), " ", props[i]);
        }
      }
    });
    if (!empty) {
      out.indent();
    }
    out(">>");
  };
  return PDFDictionary2;
}(PDFValue);
var PDFStream = function(PDFValue3) {
  function PDFStream2(data, props, compress) {
    PDFValue3.call(this);
    if (typeof data == "string") {
      var tmp = BinaryStream();
      tmp.write(data);
      data = tmp;
    }
    this.data = data;
    this.props = props || {};
    this.compress = compress;
  }
  if (PDFValue3) PDFStream2.__proto__ = PDFValue3;
  PDFStream2.prototype = Object.create(PDFValue3 && PDFValue3.prototype);
  PDFStream2.prototype.constructor = PDFStream2;
  PDFStream2.prototype.render = function render4(out) {
    var data = this.data.get(), props = this.props;
    if (this.compress && supportsDeflate()) {
      if (!props.Filter) {
        props.Filter = [];
      } else if (!(props.Filter instanceof Array)) {
        props.Filter = [props.Filter];
      }
      props.Filter.unshift(_("FlateDecode"));
      data = deflate2(data);
    }
    props.Length = data.length;
    out(new PDFDictionary(props), " stream", NL);
    out.writeData(data);
    out(NL, "endstream");
  };
  return PDFStream2;
}(PDFValue);
var PDFCatalog = function(PDFDictionary2) {
  function PDFCatalog2() {
    PDFDictionary2.call(this, {
      Type: _("Catalog")
    });
  }
  if (PDFDictionary2) PDFCatalog2.__proto__ = PDFDictionary2;
  PDFCatalog2.prototype = Object.create(PDFDictionary2 && PDFDictionary2.prototype);
  PDFCatalog2.prototype.constructor = PDFCatalog2;
  PDFCatalog2.prototype.setPages = function setPages(pagesObj) {
    this.props.Pages = pagesObj;
  };
  return PDFCatalog2;
}(PDFDictionary);
var PDFPageTree = function(PDFDictionary2) {
  function PDFPageTree2() {
    PDFDictionary2.call(this, {
      Type: _("Pages"),
      Kids: [],
      Count: 0
    });
  }
  if (PDFDictionary2) PDFPageTree2.__proto__ = PDFDictionary2;
  PDFPageTree2.prototype = Object.create(PDFDictionary2 && PDFDictionary2.prototype);
  PDFPageTree2.prototype.constructor = PDFPageTree2;
  PDFPageTree2.prototype.addPage = function addPage(pageObj) {
    this.props.Kids.push(pageObj);
    this.props.Count++;
  };
  return PDFPageTree2;
}(PDFDictionary);
var SOF_CODES = [192, 193, 194, 195, 197, 198, 199, 201, 202, 203, 205, 206, 207];
var PDFJpegImage = function PDFJpegImage2(data) {
  data.offset(0);
  var width, height, colorSpace, bitsPerComponent;
  var soi = data.readShort();
  if (soi != 65496) {
    throw new Error("Invalid JPEG image");
  }
  while (!data.eof()) {
    var ff = data.readByte();
    if (ff != 255) {
      throw new Error("Invalid JPEG image");
    }
    var marker = data.readByte();
    var length = data.readShort();
    if (SOF_CODES.indexOf(marker) >= 0) {
      bitsPerComponent = data.readByte();
      height = data.readShort();
      width = data.readShort();
      colorSpace = data.readByte();
      break;
    }
    data.skip(length - 2);
  }
  if (colorSpace == null) {
    throw new Error("Invalid JPEG image");
  }
  var props = {
    Type: _("XObject"),
    Subtype: _("Image"),
    Width: width,
    Height: height,
    BitsPerComponent: bitsPerComponent,
    Filter: _("DCTDecode")
  };
  switch (colorSpace) {
    case 1:
      props.ColorSpace = _("DeviceGray");
      break;
    case 3:
      props.ColorSpace = _("DeviceRGB");
      break;
    case 4:
      props.ColorSpace = _("DeviceCMYK");
      props.Decode = [1, 0, 1, 0, 1, 0, 1, 0];
      break;
  }
  this.asStream = function() {
    data.offset(0);
    var stream2 = new PDFStream(data, props);
    stream2._resourceName = _("I" + ++RESOURCE_COUNTER);
    return stream2;
  };
};
var PDFRawImage = function PDFRawImage2(width, height, rgb, alpha) {
  this.asStream = function(pdf) {
    var mask3 = new PDFStream(alpha, {
      Type: _("XObject"),
      Subtype: _("Image"),
      Width: width,
      Height: height,
      BitsPerComponent: 8,
      ColorSpace: _("DeviceGray")
    }, true);
    var stream2 = new PDFStream(rgb, {
      Type: _("XObject"),
      Subtype: _("Image"),
      Width: width,
      Height: height,
      BitsPerComponent: 8,
      ColorSpace: _("DeviceRGB"),
      SMask: pdf.attach(mask3)
    }, true);
    stream2._resourceName = _("I" + ++RESOURCE_COUNTER);
    return stream2;
  };
};
var PDFPattern = function(PDFDictionary2) {
  function PDFPattern2(fill, curPage, drawPattern2) {
    var ref = fill.size();
    var width = ref.width;
    var height = ref.height;
    var page = new PDFPage(curPage._pdf, {});
    page._content = new PDFStream(makeOutput(), null, true);
    drawPattern2(fill, page, {});
    curPage._xResources = Object.assign(curPage._xResources, page._xResources);
    curPage._fontResources = Object.assign(curPage._fontResources, page._fontResources);
    curPage._gsResources = Object.assign(curPage._gsResources, page._gsResources);
    PDFDictionary2.call(this, {
      Type: _("Pattern"),
      PatternType: 1,
      PaintType: 1,
      TilingType: 1,
      BBox: [0, 0, width, height],
      XStep: width,
      YStep: height,
      Matrix: [1, 0, 0, -1, 0, height],
      Resources: {
        ExtGState: new PDFDictionary2(page._gsResources),
        XObject: new PDFDictionary2(page._xResources),
        Font: new PDFDictionary2(page._fontResources)
      }
    });
    this._resourceName = _("P" + ++PATTERN_COUNTER);
    this.data = page._content.data;
    this.compress = true;
  }
  if (PDFDictionary2) PDFPattern2.__proto__ = PDFDictionary2;
  PDFPattern2.prototype = Object.create(PDFDictionary2 && PDFDictionary2.prototype);
  PDFPattern2.prototype.constructor = PDFPattern2;
  PDFPattern2.prototype.render = function render4(out) {
    PDFStream.prototype.render.call(this, out);
  };
  return PDFPattern2;
}(PDFDictionary);
var PDFStandardFont = function(PDFDictionary2) {
  function PDFStandardFont2(name2) {
    PDFDictionary2.call(this, {
      Type: _("Font"),
      Subtype: _("Type1"),
      BaseFont: _(name2)
    });
    this._resourceName = _("F" + ++RESOURCE_COUNTER);
  }
  if (PDFDictionary2) PDFStandardFont2.__proto__ = PDFDictionary2;
  PDFStandardFont2.prototype = Object.create(PDFDictionary2 && PDFDictionary2.prototype);
  PDFStandardFont2.prototype.constructor = PDFStandardFont2;
  PDFStandardFont2.prototype.encodeText = function encodeText2(str) {
    return new PDFString(String(str));
  };
  return PDFStandardFont2;
}(PDFDictionary);
var PDFFont = function(PDFDictionary2) {
  function PDFFont2(pdf, font, props) {
    PDFDictionary2.call(this, {});
    props = this.props;
    props.Type = _("Font");
    props.Subtype = _("Type0");
    props.Encoding = _("Identity-H");
    this._pdf = pdf;
    this._font = font;
    this._sub = font.makeSubset();
    this._resourceName = _("F" + ++RESOURCE_COUNTER);
    var head = font.head;
    this.name = font.psName;
    var scale = this.scale = font.scale;
    this.bbox = [head.xMin * scale, head.yMin * scale, head.xMax * scale, head.yMax * scale];
    this.italicAngle = font.post.italicAngle;
    this.ascent = font.ascent * scale;
    this.descent = font.descent * scale;
    this.lineGap = font.lineGap * scale;
    this.capHeight = font.os2.capHeight || this.ascent;
    this.xHeight = font.os2.xHeight || 0;
    this.stemV = 0;
    this.familyClass = (font.os2.familyClass || 0) >> 8;
    this.isSerif = this.familyClass >= 1 && this.familyClass <= 7;
    this.isScript = this.familyClass == 10;
    this.flags = (font.post.isFixedPitch ? 1 : 0) | (this.isSerif ? 1 << 1 : 0) | (this.isScript ? 1 << 3 : 0) | (this.italicAngle !== 0 ? 1 << 6 : 0) | 1 << 5;
  }
  if (PDFDictionary2) PDFFont2.__proto__ = PDFDictionary2;
  PDFFont2.prototype = Object.create(PDFDictionary2 && PDFDictionary2.prototype);
  PDFFont2.prototype.constructor = PDFFont2;
  PDFFont2.prototype.encodeText = function encodeText2(text) {
    return new PDFHexString(this._sub.encodeText(String(text)));
  };
  PDFFont2.prototype.getTextWidth = function getTextWidth(fontSize, text) {
    var this$1 = this;
    var width = 0, codeMap = this._font.cmap.codeMap;
    for (var i = 0; i < text.length; ++i) {
      var glyphId = codeMap[text.charCodeAt(i)];
      width += this$1._font.widthOfGlyph(glyphId || 0);
    }
    return width * fontSize / 1e3;
  };
  PDFFont2.prototype.beforeRender = function beforeRender2() {
    var self = this;
    var sub = self._sub;
    var data = sub.render();
    var fontStream = new PDFStream(BinaryStream(data), {
      Length1: data.length
    }, true);
    var descriptor = self._pdf.attach(new PDFDictionary2({
      Type: _("FontDescriptor"),
      FontName: _(self._sub.psName),
      FontBBox: self.bbox,
      Flags: self.flags,
      StemV: self.stemV,
      ItalicAngle: self.italicAngle,
      Ascent: self.ascent,
      Descent: self.descent,
      CapHeight: self.capHeight,
      XHeight: self.xHeight,
      FontFile2: self._pdf.attach(fontStream)
    }));
    var cmap = sub.ncid2ogid;
    var firstChar = sub.firstChar;
    var lastChar = sub.lastChar;
    var charWidths = [];
    (function loop(i, chunk) {
      if (i <= lastChar) {
        var gid = cmap[i];
        if (gid == null) {
          loop(i + 1);
        } else {
          if (!chunk) {
            charWidths.push(i, chunk = []);
          }
          chunk.push(self._font.widthOfGlyph(gid));
          loop(i + 1, chunk);
        }
      }
    })(firstChar);
    var descendant = new PDFDictionary2({
      Type: _("Font"),
      Subtype: _("CIDFontType2"),
      BaseFont: _(self._sub.psName),
      CIDSystemInfo: new PDFDictionary2({
        Registry: new PDFString("Adobe"),
        Ordering: new PDFString("Identity"),
        Supplement: 0
      }),
      FontDescriptor: descriptor,
      FirstChar: firstChar,
      LastChar: lastChar,
      DW: Math.round(self._font.widthOfGlyph(0)),
      W: charWidths,
      CIDToGIDMap: self._pdf.attach(self._makeCidToGidMap())
    });
    var dict2 = self.props;
    dict2.BaseFont = _(self._sub.psName);
    dict2.DescendantFonts = [self._pdf.attach(descendant)];
    var unimap = new PDFToUnicodeCmap(firstChar, lastChar, sub.subset);
    var unimapStream = new PDFStream(makeOutput(), null, true);
    unimapStream.data(unimap);
    dict2.ToUnicode = self._pdf.attach(unimapStream);
  };
  PDFFont2.prototype._makeCidToGidMap = function _makeCidToGidMap() {
    return new PDFStream(BinaryStream(this._sub.cidToGidMap()), null, true);
  };
  return PDFFont2;
}(PDFDictionary);
var PDFToUnicodeCmap = function(PDFValue3) {
  function PDFToUnicodeCmap2(firstChar, lastChar, map2) {
    PDFValue3.call(this);
    this.firstChar = firstChar;
    this.lastChar = lastChar;
    this.map = map2;
  }
  if (PDFValue3) PDFToUnicodeCmap2.__proto__ = PDFValue3;
  PDFToUnicodeCmap2.prototype = Object.create(PDFValue3 && PDFValue3.prototype);
  PDFToUnicodeCmap2.prototype.constructor = PDFToUnicodeCmap2;
  PDFToUnicodeCmap2.prototype.render = function render4(out) {
    out.indent("/CIDInit /ProcSet findresource begin");
    out.indent("12 dict begin");
    out.indent("begincmap");
    out.indent("/CIDSystemInfo <<");
    out.indent("  /Registry (Adobe)");
    out.indent("  /Ordering (UCS)");
    out.indent("  /Supplement 0");
    out.indent(">> def");
    out.indent("/CMapName /Adobe-Identity-UCS def");
    out.indent("/CMapType 2 def");
    out.indent("1 begincodespacerange");
    out.indent("  <0000><ffff>");
    out.indent("endcodespacerange");
    var self = this;
    out.indent(self.lastChar - self.firstChar + 1, " beginbfchar");
    out.withIndent(function() {
      for (var code = self.firstChar; code <= self.lastChar; ++code) {
        var unicode = self.map[code];
        var str = ucs2encode([unicode]);
        out.indent("<", zeropad(code.toString(16), 4), ">", "<");
        for (var i = 0; i < str.length; ++i) {
          out(zeropad(str.charCodeAt(i).toString(16), 4));
        }
        out(">");
      }
    });
    out.indent("endbfchar");
    out.indent("endcmap");
    out.indent("CMapName currentdict /CMap defineresource pop");
    out.indent("end");
    out.indent("end");
  };
  return PDFToUnicodeCmap2;
}(PDFValue);
function makeHash(a) {
  return a.map(function(x) {
    return isArray(x) ? makeHash(x) : typeof x == "number" ? (Math.round(x * 1e3) / 1e3).toFixed(3) : x;
  }).join(" ");
}
function cacheColorGradientFunction(pdf, r1, g1, b1, r2, g2, b2) {
  var hash = makeHash([r1, g1, b1, r2, g2, b2]);
  var func = pdf.GRAD_COL_FUNCTIONS[hash];
  if (!func) {
    func = pdf.GRAD_COL_FUNCTIONS[hash] = pdf.attach(new PDFDictionary({
      FunctionType: 2,
      Domain: [0, 1],
      Range: [0, 1, 0, 1, 0, 1],
      N: 1,
      C0: [r1, g1, b1],
      C1: [r2, g2, b2]
    }));
  }
  return func;
}
function cacheOpacityGradientFunction(pdf, a1, a2) {
  var hash = makeHash([a1, a2]);
  var func = pdf.GRAD_OPC_FUNCTIONS[hash];
  if (!func) {
    func = pdf.GRAD_OPC_FUNCTIONS[hash] = pdf.attach(new PDFDictionary({
      FunctionType: 2,
      Domain: [0, 1],
      Range: [0, 1],
      N: 1,
      C0: [a1],
      C1: [a2]
    }));
  }
  return func;
}
function makeGradientFunctions(pdf, stops) {
  var hasAlpha = false;
  var opacities = [];
  var colors2 = [];
  var offsets = [];
  var encode = [];
  var i, prev, cur, prevColor, curColor;
  for (i = 1; i < stops.length; ++i) {
    prev = stops[i - 1];
    cur = stops[i];
    prevColor = prev.color;
    curColor = cur.color;
    colors2.push(cacheColorGradientFunction(pdf, prevColor.r, prevColor.g, prevColor.b, curColor.r, curColor.g, curColor.b));
    if (prevColor.a < 1 || curColor.a < 1) {
      hasAlpha = true;
    }
    offsets.push(cur.offset);
    encode.push(0, 1);
  }
  if (hasAlpha) {
    for (i = 1; i < stops.length; ++i) {
      prev = stops[i - 1];
      cur = stops[i];
      prevColor = prev.color;
      curColor = cur.color;
      opacities.push(cacheOpacityGradientFunction(pdf, prevColor.a, curColor.a));
    }
  }
  offsets.pop();
  return {
    hasAlpha,
    colors: assemble(colors2),
    opacities: hasAlpha ? assemble(opacities) : null
  };
  function assemble(funcs) {
    if (funcs.length == 1) {
      return funcs[0];
    }
    return {
      FunctionType: 3,
      Functions: funcs,
      Domain: [0, 1],
      Bounds: offsets,
      Encode: encode
    };
  }
}
function cacheColorGradient(pdf, isRadial, stops, coords, funcs, box) {
  var shading, hash;
  if (!box) {
    var a = [isRadial].concat(coords);
    stops.forEach(function(x) {
      a.push(x.offset, x.color.r, x.color.g, x.color.b);
    });
    hash = makeHash(a);
    shading = pdf.GRAD_COL[hash];
  }
  if (!shading) {
    shading = new PDFDictionary({
      Type: _("Shading"),
      ShadingType: isRadial ? 3 : 2,
      ColorSpace: _("DeviceRGB"),
      Coords: coords,
      Domain: [0, 1],
      Function: funcs,
      Extend: [true, true]
    });
    pdf.attach(shading);
    shading._resourceName = "S" + ++RESOURCE_COUNTER;
    if (hash) {
      pdf.GRAD_COL[hash] = shading;
    }
  }
  return shading;
}
function cacheOpacityGradient(pdf, isRadial, stops, coords, funcs, box) {
  var opacity, hash;
  if (!box) {
    var a = [isRadial].concat(coords);
    stops.forEach(function(x) {
      a.push(x.offset, x.color.a);
    });
    hash = makeHash(a);
    opacity = pdf.GRAD_OPC[hash];
  }
  if (!opacity) {
    opacity = new PDFDictionary({
      Type: _("ExtGState"),
      AIS: false,
      CA: 1,
      ca: 1,
      SMask: {
        Type: _("Mask"),
        S: _("Luminosity"),
        G: pdf.attach(new PDFStream("/a0 gs /s0 sh", {
          Type: _("XObject"),
          Subtype: _("Form"),
          FormType: 1,
          BBox: box ? [box.left, box.top + box.height, box.left + box.width, box.top] : [0, 1, 1, 0],
          Group: {
            Type: _("Group"),
            S: _("Transparency"),
            CS: _("DeviceGray"),
            I: true
          },
          Resources: {
            ExtGState: {
              a0: {
                CA: 1,
                ca: 1
              }
            },
            Shading: {
              s0: {
                ColorSpace: _("DeviceGray"),
                Coords: coords,
                Domain: [0, 1],
                ShadingType: isRadial ? 3 : 2,
                Function: funcs,
                Extend: [true, true]
              }
            }
          }
        }))
      }
    });
    pdf.attach(opacity);
    opacity._resourceName = "O" + ++RESOURCE_COUNTER;
    if (hash) {
      pdf.GRAD_OPC[hash] = opacity;
    }
  }
  return opacity;
}
function cacheGradient(pdf, gradient, box) {
  var isRadial = gradient.type == "radial";
  var funcs = makeGradientFunctions(pdf, gradient.stops);
  var coords = isRadial ? [gradient.start.x, gradient.start.y, gradient.start.r, gradient.end.x, gradient.end.y, gradient.end.r] : [gradient.start.x, gradient.start.y, gradient.end.x, gradient.end.y];
  var shading = cacheColorGradient(pdf, isRadial, gradient.stops, coords, funcs.colors, gradient.userSpace && box);
  var opacity = funcs.hasAlpha ? cacheOpacityGradient(pdf, isRadial, gradient.stops, coords, funcs.opacities, gradient.userSpace && box) : null;
  return {
    hasAlpha: funcs.hasAlpha,
    shading,
    opacity
  };
}
var PDFPage = function(PDFDictionary2) {
  function PDFPage2(pdf, props) {
    PDFDictionary2.call(this, props);
    this._pdf = pdf;
    this._rcount = 0;
    this._textMode = false;
    this._fontResources = {};
    this._gsResources = {};
    this._xResources = {};
    this._patResources = {};
    this._shResources = {};
    this._opacity = 1;
    this._matrix = [1, 0, 0, 1, 0, 0];
    this._annotations = [];
    this._font = null;
    this._fontSize = null;
    this._contextStack = [];
    props = this.props;
    props.Type = _("Page");
    props.ProcSet = [_("PDF"), _("Text"), _("ImageB"), _("ImageC"), _("ImageI")];
    props.Resources = new PDFDictionary2({
      Font: new PDFDictionary2(this._fontResources),
      ExtGState: new PDFDictionary2(this._gsResources),
      XObject: new PDFDictionary2(this._xResources),
      Pattern: new PDFDictionary2(this._patResources),
      Shading: new PDFDictionary2(this._shResources)
    });
    props.Annots = this._annotations;
  }
  if (PDFDictionary2) PDFPage2.__proto__ = PDFDictionary2;
  PDFPage2.prototype = Object.create(PDFDictionary2 && PDFDictionary2.prototype);
  PDFPage2.prototype.constructor = PDFPage2;
  PDFPage2.prototype._out = function _out() {
    this._content.data.apply(null, arguments);
  };
  PDFPage2.prototype.transform = function transform3(a, b, c, d, e, f) {
    if (!isIdentityMatrix(arguments)) {
      this._matrix = mmul(arguments, this._matrix);
      this._out(a, " ", b, " ", c, " ", d, " ", e, " ", f, " cm");
      this._out(NL);
    }
  };
  PDFPage2.prototype.translate = function translate(dx, dy) {
    this.transform(1, 0, 0, 1, dx, dy);
  };
  PDFPage2.prototype.scale = function scale(sx, sy) {
    this.transform(sx, 0, 0, sy, 0, 0);
  };
  PDFPage2.prototype.rotate = function rotate(angle) {
    var cos = Math.cos(angle), sin = Math.sin(angle);
    this.transform(cos, sin, -sin, cos, 0, 0);
  };
  PDFPage2.prototype.beginText = function beginText() {
    this._textMode = true;
    this._out("BT", NL);
  };
  PDFPage2.prototype.endText = function endText() {
    this._textMode = false;
    this._out("ET", NL);
  };
  PDFPage2.prototype._requireTextMode = function _requireTextMode() {
    if (!this._textMode) {
      throw new Error("Text mode required; call page.beginText() first");
    }
  };
  PDFPage2.prototype._requireFont = function _requireFont() {
    if (!this._font) {
      throw new Error("No font selected; call page.setFont() first");
    }
  };
  PDFPage2.prototype.setFont = function setFont(font, size) {
    this._requireTextMode();
    if (font == null) {
      font = this._font;
    } else if (!(font instanceof PDFFont)) {
      font = this._pdf.getFont(font);
    }
    if (size == null) {
      size = this._fontSize;
    }
    this._fontResources[font._resourceName] = font;
    this._font = font;
    this._fontSize = size;
    this._out(font._resourceName, " ", size, " Tf", NL);
  };
  PDFPage2.prototype.setTextLeading = function setTextLeading(size) {
    this._requireTextMode();
    this._out(size, " TL", NL);
  };
  PDFPage2.prototype.setTextRenderingMode = function setTextRenderingMode(mode) {
    this._requireTextMode();
    this._out(mode, " Tr", NL);
  };
  PDFPage2.prototype.showText = function showText(text, requestedWidth) {
    this._requireFont();
    if (text.length > 1 && requestedWidth && this._font instanceof PDFFont) {
      var outputWidth = this._font.getTextWidth(this._fontSize, text);
      var scale = requestedWidth / outputWidth * 100;
      this._out(scale, " Tz ");
    }
    this._out(this._font.encodeText(text), " Tj", NL);
  };
  PDFPage2.prototype.showTextNL = function showTextNL(text) {
    this._requireFont();
    this._out(this._font.encodeText(text), " '", NL);
  };
  PDFPage2.prototype.addLink = function addLink(uri, box) {
    var ll = this._toPage({
      x: box.left,
      y: box.bottom
    });
    var ur = this._toPage({
      x: box.right,
      y: box.top
    });
    this._annotations.push(new PDFDictionary2({
      Type: _("Annot"),
      Subtype: _("Link"),
      Rect: [ll.x, ll.y, ur.x, ur.y],
      Border: [0, 0, 0],
      A: new PDFDictionary2({
        Type: _("Action"),
        S: _("URI"),
        URI: new PDFString(uri)
      })
    }));
  };
  PDFPage2.prototype.setStrokeColor = function setStrokeColor(r, g, b) {
    this._out(r, " ", g, " ", b, " RG", NL);
  };
  PDFPage2.prototype.setOpacity = function setOpacity(opacity) {
    this.setFillOpacity(opacity);
    this.setStrokeOpacity(opacity);
    this._opacity *= opacity;
  };
  PDFPage2.prototype.setStrokeOpacity = function setStrokeOpacity(opacity) {
    if (opacity < 1) {
      var gs = this._pdf.getOpacityGS(this._opacity * opacity, true);
      this._gsResources[gs._resourceName] = gs;
      this._out(gs._resourceName, " gs", NL);
    }
  };
  PDFPage2.prototype.setFillColor = function setFillColor(r, g, b) {
    this._out(r, " ", g, " ", b, " rg", NL);
  };
  PDFPage2.prototype.pattern = function pattern(fill, box, drawPattern2) {
    var pattern2 = this._pdf.getPattern(fill, this, drawPattern2);
    this._patResources[pattern2._resourceName] = pattern2;
    this._out("/Pattern cs", NL);
    this._out(pattern2._resourceName, " scn", NL);
    this.rect(box.left, box.top, box.width, box.height);
    this.fill();
  };
  PDFPage2.prototype.setFillOpacity = function setFillOpacity(opacity) {
    if (opacity < 1) {
      var gs = this._pdf.getOpacityGS(this._opacity * opacity, false);
      this._gsResources[gs._resourceName] = gs;
      this._out(gs._resourceName, " gs", NL);
    }
  };
  PDFPage2.prototype.gradient = function gradient(gradient$1, box) {
    this.save();
    this.rect(box.left, box.top, box.width, box.height);
    this.clip();
    if (!gradient$1.userSpace) {
      this.transform(box.width, 0, 0, box.height, box.left, box.top);
    }
    var g = cacheGradient(this._pdf, gradient$1, box);
    var sname = g.shading._resourceName, oname;
    this._shResources[sname] = g.shading;
    if (g.hasAlpha) {
      oname = g.opacity._resourceName;
      this._gsResources[oname] = g.opacity;
      this._out("/" + oname + " gs ");
    }
    this._out("/" + sname + " sh", NL);
    this.restore();
  };
  PDFPage2.prototype.setDashPattern = function setDashPattern(dashArray, dashPhase) {
    this._out(dashArray, " ", dashPhase, " d", NL);
  };
  PDFPage2.prototype.setLineWidth = function setLineWidth(width) {
    this._out(width, " w", NL);
  };
  PDFPage2.prototype.setLineCap = function setLineCap(lineCap) {
    this._out(lineCap, " J", NL);
  };
  PDFPage2.prototype.setLineJoin = function setLineJoin(lineJoin) {
    this._out(lineJoin, " j", NL);
  };
  PDFPage2.prototype.setMitterLimit = function setMitterLimit(mitterLimit) {
    this._out(mitterLimit, " M", NL);
  };
  PDFPage2.prototype.save = function save() {
    this._contextStack.push(this._context());
    this._out("q", NL);
  };
  PDFPage2.prototype.restore = function restore() {
    this._out("Q", NL);
    this._context(this._contextStack.pop());
  };
  PDFPage2.prototype.moveTo = function moveTo(x, y) {
    this._out(x, " ", y, " m", NL);
  };
  PDFPage2.prototype.lineTo = function lineTo(x, y) {
    this._out(x, " ", y, " l", NL);
  };
  PDFPage2.prototype.bezier = function bezier(x1, y1, x2, y2, x3, y3) {
    this._out(x1, " ", y1, " ", x2, " ", y2, " ", x3, " ", y3, " c", NL);
  };
  PDFPage2.prototype.bezier1 = function bezier1(x1, y1, x3, y3) {
    this._out(x1, " ", y1, " ", x3, " ", y3, " y", NL);
  };
  PDFPage2.prototype.bezier2 = function bezier2(x2, y2, x3, y3) {
    this._out(x2, " ", y2, " ", x3, " ", y3, " v", NL);
  };
  PDFPage2.prototype.close = function close2() {
    this._out("h", NL);
  };
  PDFPage2.prototype.rect = function rect(x, y, w, h) {
    this._out(x, " ", y, " ", w, " ", h, " re", NL);
  };
  PDFPage2.prototype.ellipse = function ellipse(x, y, rx, ry) {
    function _X(v) {
      return x + v;
    }
    function _Y(v) {
      return y + v;
    }
    var k = 0.5522847498307936;
    this.moveTo(_X(0), _Y(ry));
    this.bezier(_X(rx * k), _Y(ry), _X(rx), _Y(ry * k), _X(rx), _Y(0));
    this.bezier(_X(rx), _Y(-ry * k), _X(rx * k), _Y(-ry), _X(0), _Y(-ry));
    this.bezier(_X(-rx * k), _Y(-ry), _X(-rx), _Y(-ry * k), _X(-rx), _Y(0));
    this.bezier(_X(-rx), _Y(ry * k), _X(-rx * k), _Y(ry), _X(0), _Y(ry));
  };
  PDFPage2.prototype.circle = function circle(x, y, r) {
    this.ellipse(x, y, r, r);
  };
  PDFPage2.prototype.stroke = function stroke() {
    this._out("S", NL);
  };
  PDFPage2.prototype.nop = function nop() {
    this._out("n", NL);
  };
  PDFPage2.prototype.clip = function clip() {
    this._out("W n", NL);
  };
  PDFPage2.prototype.clipStroke = function clipStroke() {
    this._out("W S", NL);
  };
  PDFPage2.prototype.closeStroke = function closeStroke() {
    this._out("s", NL);
  };
  PDFPage2.prototype.fill = function fill() {
    this._out("f", NL);
  };
  PDFPage2.prototype.fillStroke = function fillStroke() {
    this._out("B", NL);
  };
  PDFPage2.prototype.drawImage = function drawImage2(url) {
    var img = this._pdf.getImage(url);
    if (img) {
      this._xResources[img._resourceName] = img;
      this._out(img._resourceName, " Do", NL);
    }
  };
  PDFPage2.prototype.comment = function comment(txt) {
    var self = this;
    txt.split(/\r?\n/g).forEach(function(line2) {
      self._out("% ", line2, NL);
    });
  };
  PDFPage2.prototype._context = function _context(val) {
    if (val != null) {
      this._opacity = val.opacity;
      this._matrix = val.matrix;
    } else {
      return {
        opacity: this._opacity,
        matrix: this._matrix
      };
    }
  };
  PDFPage2.prototype._toPage = function _toPage(p) {
    var m = this._matrix;
    var a = m[0], b = m[1], c = m[2], d = m[3], e = m[4], f = m[5];
    return {
      x: a * p.x + c * p.y + e,
      y: b * p.x + d * p.y + f
    };
  };
  return PDFPage2;
}(PDFDictionary);
function unquote(str) {
  return str.replace(/^\s*(['"])(.*)\1\s*$/, "$2");
}
function parseFontDef(fontdef) {
  var rx = /^\s*((normal|italic)\s+)?((normal|small-caps)\s+)?((normal|bold|\d+)\s+)?(([0-9.]+)(px|pt))(\/(([0-9.]+)(px|pt)|normal))?\s+(.*?)\s*$/i;
  var m = rx.exec(fontdef);
  if (!m) {
    return {
      fontSize: 12,
      fontFamily: "sans-serif"
    };
  }
  var fontSize = m[8] ? parseInt(m[8], 10) : 12;
  return {
    italic: m[2] && m[2].toLowerCase() == "italic",
    variant: m[4],
    bold: m[6] && /bold|700/i.test(m[6]),
    fontSize,
    lineHeight: m[12] ? m[12] == "normal" ? fontSize : parseInt(m[12], 10) : null,
    fontFamily: m[14].split(/\s*,\s*/g).map(unquote)
  };
}
function getFontURL(style2) {
  function mkFamily(name3) {
    if (style2.bold) {
      name3 += "|bold";
    }
    if (style2.italic) {
      name3 += "|italic";
    }
    return name3.toLowerCase();
  }
  var fontFamily = style2.fontFamily;
  var name2, url;
  if (fontFamily instanceof Array) {
    for (var i = 0; i < fontFamily.length; ++i) {
      name2 = mkFamily(fontFamily[i]);
      url = FONT_MAPPINGS[name2];
      if (url) {
        break;
      }
    }
  } else {
    url = FONT_MAPPINGS[fontFamily.toLowerCase()];
  }
  while (typeof url == "function") {
    url = url();
  }
  if (!url) {
    url = "Times-Roman";
  }
  return url;
}
var FONT_MAPPINGS = {
  "serif": "Times-Roman",
  "serif|bold": "Times-Bold",
  "serif|italic": "Times-Italic",
  "serif|bold|italic": "Times-BoldItalic",
  "sans-serif": "Helvetica",
  "sans-serif|bold": "Helvetica-Bold",
  "sans-serif|italic": "Helvetica-Oblique",
  "sans-serif|bold|italic": "Helvetica-BoldOblique",
  "monospace": "Courier",
  "monospace|bold": "Courier-Bold",
  "monospace|italic": "Courier-Oblique",
  "monospace|bold|italic": "Courier-BoldOblique",
  "zapfdingbats": "ZapfDingbats",
  "zapfdingbats|bold": "ZapfDingbats",
  "zapfdingbats|italic": "ZapfDingbats",
  "zapfdingbats|bold|italic": "ZapfDingbats"
};
function fontAlias(alias, name2) {
  alias = alias.toLowerCase();
  FONT_MAPPINGS[alias] = function() {
    return FONT_MAPPINGS[name2];
  };
  FONT_MAPPINGS[alias + "|bold"] = function() {
    return FONT_MAPPINGS[name2 + "|bold"];
  };
  FONT_MAPPINGS[alias + "|italic"] = function() {
    return FONT_MAPPINGS[name2 + "|italic"];
  };
  FONT_MAPPINGS[alias + "|bold|italic"] = function() {
    return FONT_MAPPINGS[name2 + "|bold|italic"];
  };
}
fontAlias("Times New Roman", "serif");
fontAlias("Courier New", "monospace");
fontAlias("Arial", "sans-serif");
fontAlias("Helvetica", "sans-serif");
fontAlias("Verdana", "sans-serif");
fontAlias("Tahoma", "sans-serif");
fontAlias("Georgia", "sans-serif");
fontAlias("Monaco", "monospace");
fontAlias("Andale Mono", "monospace");
function defineFont(name2, url) {
  if (arguments.length == 1) {
    for (var i in name2) {
      if (hasOwnProperty2(name2, i)) {
        defineFont(i, name2[i]);
      }
    }
  } else {
    name2 = name2.toLowerCase();
    FONT_MAPPINGS[name2] = url;
    switch (name2) {
      case "dejavu sans":
        FONT_MAPPINGS["sans-serif"] = url;
        break;
      case "dejavu sans|bold":
        FONT_MAPPINGS["sans-serif|bold"] = url;
        break;
      case "dejavu sans|italic":
        FONT_MAPPINGS["sans-serif|italic"] = url;
        break;
      case "dejavu sans|bold|italic":
        FONT_MAPPINGS["sans-serif|bold|italic"] = url;
        break;
      case "dejavu serif":
        FONT_MAPPINGS["serif"] = url;
        break;
      case "dejavu serif|bold":
        FONT_MAPPINGS["serif|bold"] = url;
        break;
      case "dejavu serif|italic":
        FONT_MAPPINGS["serif|italic"] = url;
        break;
      case "dejavu serif|bold|italic":
        FONT_MAPPINGS["serif|bold|italic"] = url;
        break;
      case "dejavu mono":
        FONT_MAPPINGS["monospace"] = url;
        break;
      case "dejavu mono|bold":
        FONT_MAPPINGS["monospace|bold"] = url;
        break;
      case "dejavu mono|italic":
        FONT_MAPPINGS["monospace|italic"] = url;
        break;
      case "dejavu mono|bold|italic":
        FONT_MAPPINGS["monospace|bold|italic"] = url;
        break;
    }
  }
}
function mmul(a, b) {
  var a1 = a[0], b1 = a[1], c1 = a[2], d1 = a[3], e1 = a[4], f1 = a[5];
  var a2 = b[0], b2 = b[1], c2 = b[2], d2 = b[3], e2 = b[4], f2 = b[5];
  return [a1 * a2 + b1 * c2, a1 * b2 + b1 * d2, c1 * a2 + d1 * c2, c1 * b2 + d1 * d2, e1 * a2 + f1 * c2 + e2, e1 * b2 + f1 * d2 + f2];
}
function isIdentityMatrix(m) {
  return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0;
}
var TEXT_RENDERING_MODE = {
  fill: 0,
  stroke: 1,
  fillAndStroke: 2,
  invisible: 3,
  fillAndClip: 4,
  strokeAndClip: 5,
  fillStrokeClip: 6,
  clip: 7
};

// node_modules/@progress/kendo-drawing/dist/es/pdf/drawing.js
var DEFAULT_IMAGE_DPI = 300;
var TEXT_RENDERING_MODE2 = TEXT_RENDERING_MODE;
var DASH_PATTERNS = {
  dash: [4],
  dashDot: [4, 2, 1, 2],
  dot: [1, 2],
  longDash: [8, 2],
  longDashDot: [8, 2, 1, 2],
  longDashDotDot: [8, 2, 1, 2, 1, 2],
  solid: []
};
var LINE_CAP = {
  butt: 0,
  round: 1,
  square: 2
};
var LINE_JOIN = {
  miter: 0,
  round: 1,
  bevel: 2
};
function render3(group, callback) {
  var fonts = [], images = {}, options2 = group.options;
  function getOption(name2, defval, hash) {
    if (!hash) {
      hash = options2;
    }
    if (hash.pdf && hash.pdf[name2] != null) {
      return hash.pdf[name2];
    }
    return defval;
  }
  var multiPage = getOption("multiPage");
  var imgDPI = getOption("imgDPI", DEFAULT_IMAGE_DPI);
  clearImageCache();
  var handlers = {
    Image: function(element) {
      var url = element.src();
      var size = element.bbox().size;
      if (imgDPI) {
        var prev = images[url];
        size = {
          width: Math.ceil(size.width * imgDPI / 72),
          height: Math.ceil(size.height * imgDPI / 72)
        };
        if (prev) {
          size.width = Math.max(prev.width, size.width);
          size.height = Math.max(prev.height, size.height);
        }
      }
      images[url] = size;
    },
    Text: function(element) {
      var style2 = parseFontDef(element.options.font);
      var url = getFontURL(style2);
      if (fonts.indexOf(url) < 0) {
        fonts.push(url);
      }
    }
  };
  group.traverse(function(element) {
    dispatch(handlers, element);
    var fill = element.fill && element.fill();
    if (fill instanceof Pattern) {
      fill.traverse(function(child) {
        dispatch(handlers, child);
      });
    }
  });
  function doIt() {
    if (--count > 0) {
      return;
    }
    var pdf = new PDFDocument({
      producer: getOption("producer"),
      title: getOption("title"),
      author: getOption("author"),
      subject: getOption("subject"),
      keywords: getOption("keywords"),
      creator: getOption("creator"),
      date: getOption("date"),
      autoPrint: getOption("autoPrint")
    });
    function drawPage(group2) {
      var options3 = group2.options;
      var tmp = optimize(group2);
      var bbox = tmp.bbox;
      group2 = tmp.root;
      var paperSize = getOption("paperSize", getOption("paperSize", "auto"), options3), addMargin = false;
      if (paperSize == "auto") {
        if (bbox) {
          var size = bbox.getSize();
          paperSize = [size.width, size.height];
          addMargin = true;
          var origin = bbox.getOrigin();
          tmp = new group_default();
          tmp.transform(new matrix_default(1, 0, 0, 1, -origin.x, -origin.y));
          tmp.append(group2);
          group2 = tmp;
        } else {
          paperSize = "A4";
        }
      }
      var page;
      page = pdf.addPage({
        paperSize,
        margin: getOption("margin", getOption("margin"), options3),
        addMargin,
        landscape: getOption("landscape", getOption("landscape", false), options3)
      });
      drawElement(group2, page, pdf);
    }
    if (multiPage) {
      group.children.forEach(drawPage);
    } else {
      drawPage(group);
    }
    callback(pdf.render(), pdf);
  }
  var count = 2;
  loadFonts(fonts, doIt);
  loadImages(images, doIt, {
    jpegQuality: getOption("jpegQuality", 0.92),
    keepPNG: getOption("keepPNG", false)
  });
}
function toDataURL(group, callback) {
  render3(group, function(data) {
    callback("data:application/pdf;base64," + data.base64());
  });
}
function dispatch(handlers, element) {
  var handler = handlers[element.nodeType];
  if (handler) {
    return handler.call.apply(handler, arguments);
  }
  return element;
}
function drawElement(element, page, pdf) {
  if (element.options._pdfDebug) {
    page.comment("BEGIN: " + element.options._pdfDebug);
  }
  var transform3 = element.transform();
  var opacity = element.opacity();
  page.save();
  if (opacity != null && opacity < 1) {
    page.setOpacity(opacity);
  }
  setStrokeOptions(element, page, pdf);
  setFillOptions(element, page, pdf);
  if (transform3) {
    var m = transform3.matrix();
    page.transform(m.a, m.b, m.c, m.d, m.e, m.f);
  }
  setClipping(element, page, pdf);
  dispatch({
    Path: drawPath,
    MultiPath: drawMultiPath,
    Circle: drawCircle,
    Arc: drawArc,
    Text: drawText,
    Image: drawImage,
    Group: drawGroup,
    Rect: drawRect
  }, element, page, pdf);
  page.restore();
  if (element.options._pdfDebug) {
    page.comment("END: " + element.options._pdfDebug);
  }
}
function setStrokeOptions(element, page) {
  var stroke = element.stroke && element.stroke();
  if (!stroke) {
    return;
  }
  var color = stroke.color;
  if (color) {
    color = parseColor2(color);
    if (color == null) {
      return;
    }
    page.setStrokeColor(color.r, color.g, color.b);
    if (color.a != 1) {
      page.setStrokeOpacity(color.a);
    }
  }
  var width = stroke.width;
  if (width != null) {
    if (width === 0) {
      return;
    }
    page.setLineWidth(width);
  }
  var dashType = stroke.dashType;
  if (dashType) {
    page.setDashPattern(DASH_PATTERNS[dashType], 0);
  }
  var lineCap = stroke.lineCap;
  if (lineCap) {
    page.setLineCap(LINE_CAP[lineCap]);
  }
  var lineJoin = stroke.lineJoin;
  if (lineJoin) {
    page.setLineJoin(LINE_JOIN[lineJoin]);
  }
  var opacity = stroke.opacity;
  if (opacity != null) {
    page.setStrokeOpacity(opacity);
  }
}
function setFillOptions(element, page) {
  var fill = element.fill && element.fill();
  if (!fill) {
    return;
  }
  if (fill instanceof gradient_default || fill instanceof Pattern) {
    return;
  }
  var color = fill.color;
  if (color) {
    color = parseColor2(color);
    if (color == null) {
      return;
    }
    page.setFillColor(color.r, color.g, color.b);
    if (color.a != 1) {
      page.setFillOpacity(color.a);
    }
  }
  var opacity = fill.opacity;
  if (opacity != null) {
    page.setFillOpacity(opacity);
  }
}
function setClipping(element, page, pdf) {
  var clip = element.clip();
  if (clip) {
    _drawPath(clip, page, pdf);
    page.clip();
  }
}
function shouldDraw(thing) {
  return thing && (thing instanceof gradient_default || thing instanceof Pattern || thing.color && !/^(none|transparent)$/i.test(thing.color) && (thing.width == null || thing.width > 0) && (thing.opacity == null || thing.opacity > 0));
}
function maybeGradient(element, page, pdf, stroke) {
  var fill = element.fill();
  if (fill instanceof gradient_default) {
    if (stroke) {
      page.clipStroke();
    } else {
      page.clip();
    }
    var isRadial = fill instanceof radial_gradient_default;
    var start, end;
    if (isRadial) {
      start = {
        x: fill.center().x,
        y: fill.center().y,
        r: 0
      };
      end = {
        x: fill.center().x,
        y: fill.center().y,
        r: fill.radius()
      };
    } else {
      start = {
        x: fill.start().x,
        y: fill.start().y
      };
      end = {
        x: fill.end().x,
        y: fill.end().y
      };
    }
    var stops = fill.stops.elements().map(function(stop) {
      var offset = stop.offset();
      if (/%$/.test(offset)) {
        offset = parseFloat(offset) / 100;
      } else {
        offset = parseFloat(offset);
      }
      var color = parseColor2(stop.color());
      color.a *= stop.opacity();
      return {
        offset,
        color
      };
    });
    stops.unshift(stops[0]);
    stops.push(stops[stops.length - 1]);
    var gradient = {
      userSpace: fill.userSpace(),
      type: isRadial ? "radial" : "linear",
      start,
      end,
      stops
    };
    var box = element.rawBBox();
    var tl = box.topLeft(), size = box.getSize();
    box = {
      left: tl.x,
      top: tl.y,
      width: size.width,
      height: size.height
    };
    page.gradient(gradient, box);
    return true;
  }
}
function maybePattern(element, page, pdf, stroke) {
  var fill = element.fill();
  if (fill instanceof Pattern) {
    if (stroke) {
      page.clipStroke();
    } else {
      page.clip();
    }
    var box = element.rawBBox();
    var tl = box.topLeft(), size = box.getSize();
    var strokeWidth = element.stroke() ? element.stroke().width : 0;
    page.pattern(fill, {
      left: tl.x + strokeWidth / 2,
      top: tl.y + strokeWidth / 2,
      width: size.width - strokeWidth,
      height: size.height - strokeWidth
    }, drawPattern);
    return true;
  }
}
function maybeFillStroke(element, page, pdf) {
  if (shouldDraw(element.fill()) && shouldDraw(element.stroke())) {
    if (!maybeGradient(element, page, pdf, true) && !maybePattern(element, page, pdf, true)) {
      page.fillStroke();
    }
  } else if (shouldDraw(element.fill())) {
    if (!maybeGradient(element, page, pdf, false) && !maybePattern(element, page, pdf, false)) {
      page.fill();
    }
  } else if (shouldDraw(element.stroke())) {
    page.stroke();
  } else {
    page.nop();
  }
}
function maybeDrawRect(path, page) {
  var segments = path.segments;
  if (segments.length == 4 && path.options.closed) {
    var a = [];
    for (var i = 0; i < segments.length; ++i) {
      if (segments[i].controlIn()) {
        return false;
      }
      a[i] = segments[i].anchor();
    }
    var isRect = a[0].y == a[1].y && a[1].x == a[2].x && a[2].y == a[3].y && a[3].x == a[0].x || a[0].x == a[1].x && a[1].y == a[2].y && a[2].x == a[3].x && a[3].y == a[0].y;
    if (isRect) {
      page.rect(
        a[0].x,
        a[0].y,
        a[2].x - a[0].x,
        a[2].y - a[0].y
        /*height*/
      );
      return true;
    }
  }
}
function _drawPath(element, page, pdf) {
  var segments = element.segments;
  if (segments.length === 0) {
    return;
  }
  if (!maybeDrawRect(element, page, pdf)) {
    for (var prev, i = 0; i < segments.length; ++i) {
      var seg = segments[i];
      var anchor = seg.anchor();
      if (!prev) {
        page.moveTo(anchor.x, anchor.y);
      } else {
        var prevOut = prev.controlOut();
        var controlIn = seg.controlIn();
        if (prevOut && controlIn) {
          page.bezier(prevOut.x, prevOut.y, controlIn.x, controlIn.y, anchor.x, anchor.y);
        } else {
          page.lineTo(anchor.x, anchor.y);
        }
      }
      prev = seg;
    }
    if (element.options.closed) {
      page.close();
    }
  }
}
function drawPath(element, page, pdf) {
  _drawPath(element, page, pdf);
  maybeFillStroke(element, page, pdf);
}
function drawMultiPath(element, page, pdf) {
  var paths = element.paths;
  for (var i = 0; i < paths.length; ++i) {
    _drawPath(paths[i], page, pdf);
  }
  maybeFillStroke(element, page, pdf);
}
function drawCircle(element, page, pdf) {
  var g = element.geometry();
  page.circle(g.center.x, g.center.y, g.radius);
  maybeFillStroke(element, page, pdf);
}
function drawArc(element, page, pdf) {
  var points3 = element.geometry().curvePoints();
  page.moveTo(points3[0].x, points3[0].y);
  for (var i = 1; i < points3.length; ) {
    page.bezier(points3[i].x, points3[i++].y, points3[i].x, points3[i++].y, points3[i].x, points3[i++].y);
  }
  maybeFillStroke(element, page, pdf);
}
function drawText(element, page) {
  var style2 = parseFontDef(element.options.font);
  var pos = element._position;
  var mode;
  page.transform(1, 0, 0, -1, pos.x, pos.y + style2.fontSize);
  var draw = function(renderMode) {
    page.beginText();
    page.setFont(getFontURL(style2), style2.fontSize);
    page.setTextRenderingMode(renderMode);
    page.showText(element.content(), element._pdfRect ? element._pdfRect.width() : null);
  };
  if (element.fill() && element.stroke()) {
    mode = TEXT_RENDERING_MODE2.fillAndStroke;
    if (element.options.paintOrder === "stroke") {
      draw(TEXT_RENDERING_MODE2.stroke);
      mode = TEXT_RENDERING_MODE2.fill;
    }
  } else if (element.fill()) {
    mode = TEXT_RENDERING_MODE2.fill;
  } else if (element.stroke()) {
    mode = TEXT_RENDERING_MODE2.stroke;
  }
  draw(mode);
  page.endText();
}
function drawPattern(pattern, page, pdf) {
  var children = pattern.children;
  for (var i = 0; i < children.length; ++i) {
    drawElement(children[i], page, pdf);
  }
}
function drawGroup(element, page, pdf) {
  if (element._pdfLink) {
    page.addLink(element._pdfLink.url, element._pdfLink);
  }
  var children = element.children;
  for (var i = 0; i < children.length; ++i) {
    drawElement(children[i], page, pdf);
  }
}
function drawImage(element, page) {
  var url = element.src();
  if (!url) {
    return;
  }
  var rect = element.rect();
  var tl = rect.getOrigin();
  var sz = rect.getSize();
  page.transform(sz.width, 0, 0, -sz.height, tl.x, tl.y + sz.height);
  page.drawImage(url);
}
function drawRect(element, page, pdf) {
  var geometry = element.geometry();
  var ref = geometry.cornerRadius;
  var rx = ref[0];
  var ry = ref[1];
  if (rx === 0 && ry === 0) {
    page.rect(geometry.origin.x, geometry.origin.y, geometry.size.width, geometry.size.height);
    maybeFillStroke(element, page, pdf);
  } else {
    drawPath(Path.fromRect(geometry, element.options), page, pdf);
  }
}
function parseColor2(value) {
  var color = parseColor(value, true);
  return color ? color.toRGB() : null;
}
function optimize(root) {
  var clipbox = false;
  var matrix = matrix_default.unit();
  var currentBox = null;
  var changed;
  do {
    changed = false;
    root = opt(root);
  } while (root && changed);
  return {
    root,
    bbox: currentBox
  };
  function change(newShape) {
    changed = true;
    return newShape;
  }
  function visible(shape) {
    return shape.visible() && shape.opacity() > 0 && (shouldDraw(shape.fill()) || shouldDraw(shape.stroke()));
  }
  function optArray(a) {
    var b = [];
    for (var i = 0; i < a.length; ++i) {
      var el = opt(a[i]);
      if (el != null) {
        b.push(el);
      }
    }
    return b;
  }
  function withClipping(shape, f) {
    var saveclipbox = clipbox;
    var savematrix = matrix;
    if (shape.transform()) {
      matrix = matrix.multiplyCopy(shape.transform().matrix());
    }
    var clip = shape.clip();
    if (clip && typeof clip.bbox === "function") {
      clip = clip.bbox();
      if (clip) {
        clip = clip.bbox(matrix);
        clipbox = clipbox ? rect_default.intersect(clipbox, clip) : clip;
      }
    }
    try {
      return f();
    } finally {
      clipbox = saveclipbox;
      matrix = savematrix;
    }
  }
  function inClipbox(shape) {
    if (clipbox == null) {
      return false;
    }
    var box = shape.rawBBox();
    if (box) {
      box = box.bbox(matrix);
    }
    if (clipbox && box) {
      box = rect_default.intersect(box, clipbox);
    }
    return box;
  }
  function opt(shape) {
    return withClipping(shape, function() {
      if (!(shape instanceof group_default || shape instanceof MultiPath)) {
        var box = inClipbox(shape);
        if (!box) {
          return change(null);
        }
        currentBox = currentBox ? rect_default.union(currentBox, box) : box;
      }
      return dispatch({
        Path: function(shape2) {
          if (shape2.segments.length === 0 || !visible(shape2)) {
            return change(null);
          }
          return shape2;
        },
        MultiPath: function(shape2) {
          if (!visible(shape2)) {
            return change(null);
          }
          var el = new MultiPath(shape2.options);
          el.paths = optArray(shape2.paths);
          if (el.paths.length === 0) {
            return change(null);
          }
          return el;
        },
        Circle: function(shape2) {
          if (!visible(shape2)) {
            return change(null);
          }
          return shape2;
        },
        Arc: function(shape2) {
          if (!visible(shape2)) {
            return change(null);
          }
          return shape2;
        },
        Text: function(shape2) {
          if (!/\S/.test(shape2.content()) || !visible(shape2)) {
            return change(null);
          }
          return shape2;
        },
        Image: function(shape2) {
          if (!(shape2.visible() && shape2.opacity() > 0)) {
            return change(null);
          }
          return shape2;
        },
        Group: function(shape2) {
          if (!(shape2.visible() && shape2.opacity() > 0)) {
            return change(null);
          }
          var el = new group_default(shape2.options);
          el.children = optArray(shape2.children);
          el._pdfLink = shape2._pdfLink;
          if (shape2 !== root && el.children.length === 0 && !shape2._pdfLink) {
            return change(null);
          }
          return el;
        },
        Rect: function(shape2) {
          if (!visible(shape2)) {
            return change(null);
          }
          return shape2;
        }
      }, shape);
    });
  }
}
function exportPDF(group, options2) {
  var promise = createPromise();
  for (var i in options2) {
    if (i == "margin" && group.options.pdf && group.options.pdf._ignoreMargin) {
      continue;
    }
    group.options.set("pdf." + i, options2[i]);
  }
  toDataURL(group, promise.resolve);
  return promise;
}

// node_modules/@progress/kendo-drawing/dist/es/html/core.js
var browser5 = support_default.browser || {};
function slice2(thing) {
  return Array.prototype.slice.call(thing);
}
var KENDO_PSEUDO_ELEMENT = "KENDO-PSEUDO-ELEMENT";
var KENDO_BULLET_TYPE = "data-kendo-bullet-type";
var IMAGE_CACHE2 = {};
var nodeInfo = {};
nodeInfo._root = nodeInfo;
var inBrowser = typeof window !== "undefined";
var microsoft = inBrowser ? browser5.msie || browser5.edge : false;
var TextRect = function(Text2) {
  function TextRect2(str, rect, options2) {
    Text2.call(this, str, rect.getOrigin(), options2);
    this._pdfRect = rect;
  }
  if (Text2) TextRect2.__proto__ = Text2;
  TextRect2.prototype = Object.create(Text2 && Text2.prototype);
  TextRect2.prototype.constructor = TextRect2;
  TextRect2.prototype.rect = function rect() {
    return this._pdfRect;
  };
  TextRect2.prototype.rawBBox = function rawBBox() {
    return this._pdfRect;
  };
  return TextRect2;
}(text_default);
function addClass(el, cls) {
  if (el.classList) {
    el.classList.add(cls);
  } else {
    el.className += " " + cls;
  }
}
function removeClass(el, cls) {
  if (el.classList) {
    el.classList.remove(cls);
  } else {
    el.className = el.className.split(/\s+/).reduce(function(a, word) {
      if (word != cls) {
        a.push(word);
      }
      return a;
    }, []).join(" ");
  }
}
function setCSS(el, styles) {
  Object.keys(styles).forEach(function(key) {
    el.style[key] = styles[key];
  });
}
var matches = typeof Element !== "undefined" && Element.prototype && function(p) {
  if (p.matches) {
    return function(el, selector) {
      return el.matches(selector);
    };
  }
  if (p.webkitMatchesSelector) {
    return function(el, selector) {
      return el.webkitMatchesSelector(selector);
    };
  }
  if (p.mozMatchesSelector) {
    return function(el, selector) {
      return el.mozMatchesSelector(selector);
    };
  }
  if (p.msMatchesSelector) {
    return function(el, selector) {
      return el.msMatchesSelector(selector);
    };
  }
  return function(s) {
    return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
  };
}(Element.prototype);
function closest2(el, selector) {
  if (el.closest) {
    return el.closest(selector);
  }
  while (el && !/^\[object (?:HTML)?Document\]$/.test(String(el))) {
    if (el.nodeType == 1 && matches(el, selector)) {
      return el;
    }
    el = el.parentNode;
  }
}
var cloneNodes = function($) {
  if ($) {
    return function cloneNodes2(el) {
      var clone = el.cloneNode(false);
      if (el.nodeType == 1) {
        var $el = $(el), $clone = $(clone), i;
        var data = $el.data();
        for (i in data) {
          $clone.data(i, data[i]);
        }
        if (/^canvas$/i.test(el.tagName)) {
          clone.getContext("2d").drawImage(el, 0, 0);
        } else if (/^(?:input|select|textarea|option)$/i.test(el.tagName)) {
          clone.removeAttribute("id");
          clone.removeAttribute("name");
          if (!/^textarea$/i.test(el.tagName)) {
            clone.value = el.value;
          }
          clone.checked = el.checked;
          clone.selected = el.selected;
        }
        if (el._kendoExportVisual) {
          clone._kendoExportVisual = el._kendoExportVisual;
        }
        for (i = el.firstChild; i; i = i.nextSibling) {
          clone.appendChild(cloneNodes2(i));
        }
      }
      return clone;
    };
  } else {
    return function cloneNodes2(el) {
      var clone = function dive(node) {
        var clone2 = node.cloneNode(false);
        if (node._kendoExportVisual) {
          clone2._kendoExportVisual = node._kendoExportVisual;
        }
        for (var i = node.firstChild; i; i = i.nextSibling) {
          clone2.appendChild(dive(i));
        }
        return clone2;
      }(el);
      var canvases = el.querySelectorAll("canvas");
      if (canvases.length) {
        slice2(clone.querySelectorAll("canvas")).forEach(function(canvas, i) {
          canvas.getContext("2d").drawImage(canvases[i], 0, 0);
        });
      }
      var orig = el.querySelectorAll("input, select, textarea, option");
      slice2(clone.querySelectorAll("input, select, textarea, option")).forEach(function(el2, i) {
        el2.removeAttribute("id");
        el2.removeAttribute("name");
        if (!/^textarea$/i.test(el2.tagName)) {
          el2.value = orig[i].value;
        }
        el2.checked = orig[i].checked;
        el2.selected = orig[i].selected;
      });
      return clone;
    };
  }
}(typeof window !== "undefined" && window.kendo && window.kendo.jQuery);
function getXY(thing) {
  if (typeof thing == "number") {
    return {
      x: thing,
      y: thing
    };
  }
  if (Array.isArray(thing)) {
    return {
      x: thing[0],
      y: thing[1]
    };
  }
  return {
    x: thing.x,
    y: thing.y
  };
}
function drawDOM(element, options2) {
  if (!options2) {
    options2 = {};
  }
  var promise = createPromise();
  if (!element) {
    return promise.reject("No element to export");
  }
  if (typeof window.getComputedStyle != "function") {
    throw new Error("window.getComputedStyle is missing.  You are using an unsupported browser, or running in IE8 compatibility mode.  Drawing HTML is supported in Chrome, Firefox, Safari and IE9+.");
  }
  defineFont(getFontFaces(element.ownerDocument));
  var scale = getXY(options2.scale || 1);
  function doOne(element2) {
    var group = new group_default();
    var pos = element2.getBoundingClientRect();
    setTransform(group, [scale.x, 0, 0, scale.y, -pos.left * scale.x, -pos.top * scale.y]);
    nodeInfo._clipbox = false;
    nodeInfo._matrix = matrix_default.unit();
    nodeInfo._stackingContext = {
      element: element2,
      group
    };
    if (options2.avoidLinks === true) {
      nodeInfo._avoidLinks = "a";
    } else {
      nodeInfo._avoidLinks = options2.avoidLinks;
    }
    addClass(element2, "k-pdf-export");
    renderElement(element2, group);
    removeClass(element2, "k-pdf-export");
    return group;
  }
  cacheImages([element], function() {
    var forceBreak = options2 && options2.forcePageBreak;
    var hasPaperSize = options2 && options2.paperSize && options2.paperSize != "auto";
    var paperOptions = getPaperOptions(function(key, def) {
      if (key == "paperSize") {
        return hasPaperSize ? options2[key] : "A4";
      }
      return key in options2 ? options2[key] : def;
    });
    var pageWidth = hasPaperSize && paperOptions.paperSize[0];
    var pageHeight = hasPaperSize && paperOptions.paperSize[1];
    var margin = options2.margin && paperOptions.margin;
    var hasMargin = Boolean(margin);
    if (forceBreak || pageHeight) {
      if (!margin) {
        margin = {
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        };
      }
      if (pageWidth) {
        pageWidth /= scale.x;
      }
      if (pageHeight) {
        pageHeight /= scale.y;
      }
      margin.left /= scale.x;
      margin.right /= scale.x;
      margin.top /= scale.y;
      margin.bottom /= scale.y;
      var group = new group_default({
        pdf: {
          multiPage: true,
          paperSize: hasPaperSize ? paperOptions.paperSize : "auto",
          _ignoreMargin: hasMargin
          // HACK!  see exportPDF in pdf/drawing.js
        }
      });
      handlePageBreaks(function(x) {
        if (options2.progress) {
          var canceled = false, pageNum = 0;
          (function next() {
            if (pageNum < x.pages.length) {
              var page = doOne(x.pages[pageNum]);
              group.append(page);
              options2.progress({
                page,
                pageNum: ++pageNum,
                totalPages: x.pages.length,
                cancel: function() {
                  canceled = true;
                }
              });
              if (!canceled) {
                setTimeout(next);
              } else {
                x.container.parentNode.removeChild(x.container);
              }
            } else {
              x.container.parentNode.removeChild(x.container);
              promise.resolve(group);
            }
          })();
        } else {
          x.pages.forEach(function(page) {
            group.append(doOne(page));
          });
          x.container.parentNode.removeChild(x.container);
          promise.resolve(group);
        }
      }, element, forceBreak, pageWidth ? pageWidth - margin.left - margin.right : null, pageHeight ? pageHeight - margin.top - margin.bottom : null, margin, options2);
    } else {
      promise.resolve(doOne(element));
    }
  });
  function makeTemplate(template2) {
    if (template2 != null) {
      if (typeof template2 == "string") {
        template2 = template(template2.replace(/^\s+|\s+$/g, ""));
      }
      if (typeof template2 == "function") {
        return function(data) {
          var el = template2(data);
          if (el && typeof el == "string") {
            var div = document.createElement("div");
            setInnerHTML(div, el);
            el = div.firstElementChild;
          }
          return el;
        };
      }
      return function() {
        return template2.cloneNode(true);
      };
    }
  }
  function handlePageBreaks(callback, element2, forceBreak, pageWidth, pageHeight, margin, options3) {
    var template2 = makeTemplate(options3.template);
    var doc = element2.ownerDocument;
    var pages = [];
    var copy = options3._destructive ? element2 : cloneNodes(element2);
    var container = doc.createElement("KENDO-PDF-DOCUMENT");
    var adjust = 0;
    slice2(copy.querySelectorAll("tfoot")).forEach(function(tfoot) {
      tfoot.parentNode.appendChild(tfoot);
    });
    slice2(copy.querySelectorAll("ol")).forEach(function(ol) {
      slice2(ol.children).forEach(function(li, index) {
        li.setAttribute("kendo-split-index", index);
      });
    });
    setCSS(container, {
      display: "block",
      position: "absolute",
      boxSizing: "content-box",
      left: "-10000px",
      top: "-10000px"
    });
    if (pageWidth) {
      setCSS(container, {
        width: pageWidth + "px",
        paddingLeft: margin.left + "px",
        paddingRight: margin.right + "px"
      });
      setCSS(copy, {
        overflow: "hidden"
      });
    }
    element2.parentNode.insertBefore(container, element2);
    container.appendChild(copy);
    if (options3.beforePageBreak) {
      whenImagesAreActuallyLoaded([container], function() {
        options3.beforePageBreak(container, doPageBreak);
      });
    } else {
      whenImagesAreActuallyLoaded([container], doPageBreak);
    }
    function doPageBreak() {
      if (forceBreak != "-" || pageHeight) {
        splitElement(copy);
      }
      {
        var page = makePage();
        copy.parentNode.insertBefore(page, copy);
        page.appendChild(copy);
      }
      if (template2) {
        pages.forEach(function(page2, i) {
          var el = template2({
            element: page2,
            pageNum: i + 1,
            totalPages: pages.length
          });
          if (el) {
            page2.appendChild(el);
          }
        });
      }
      cacheImages(pages, callback.bind(null, {
        pages,
        container
      }));
    }
    function keepTogether(el) {
      if (options3.keepTogether && matches(el, options3.keepTogether) && el.offsetHeight <= pageHeight - adjust) {
        return true;
      }
      var tag = el.tagName;
      if (/^h[1-6]$/i.test(tag) && el.offsetHeight >= pageHeight - adjust) {
        return false;
      }
      return el.getAttribute("data-kendo-chart") || /^(?:img|tr|thead|th|tfoot|iframe|svg|object|canvas|input|textarea|select|video|h[1-6])/i.test(el.tagName);
    }
    function splitElement(element3) {
      if (element3.tagName == "TABLE") {
        setCSS(element3, {
          tableLayout: "fixed"
        });
      }
      if (keepTogether(element3)) {
        return;
      }
      var style2 = getComputedStyle2(element3);
      var bottomPadding = parseFloat(getPropertyValue(style2, "padding-bottom"));
      var bottomBorder = parseFloat(getPropertyValue(style2, "border-bottom-width"));
      var saveAdjust = adjust;
      adjust += bottomPadding + bottomBorder;
      var isFirst = true;
      for (var el = element3.firstChild; el; el = el.nextSibling) {
        if (el.nodeType == 1) {
          isFirst = false;
          if (matches(el, forceBreak)) {
            breakAtElement(el);
            continue;
          }
          if (!pageHeight) {
            splitElement(el);
            continue;
          }
          if (!/^(?:static|relative)$/.test(getPropertyValue(getComputedStyle2(el), "position"))) {
            continue;
          }
          var fall = fallsOnMargin(el);
          if (fall == 1) {
            breakAtElement(el);
          } else if (fall) {
            if (keepTogether(el)) {
              breakAtElement(el);
            } else {
              splitElement(el);
            }
          } else {
            splitElement(el);
          }
        } else if (el.nodeType == 3 && pageHeight) {
          splitText(el, isFirst);
          isFirst = false;
        }
      }
      adjust = saveAdjust;
    }
    function firstInParent(el) {
      var p = el.parentNode, first = p.firstChild;
      if (el === first) {
        return true;
      }
      if (el === p.children[0]) {
        if (first.nodeType == 7 || first.nodeType == 8) {
          return true;
        }
        if (first.nodeType == 3) {
          return !/\S/.test(first.data);
        }
      }
      return false;
    }
    function breakAtElement(el) {
      if (el.nodeType == 1 && el !== copy && firstInParent(el)) {
        return breakAtElement(el.parentNode);
      }
      var table, colgroup, thead, grid, gridHead;
      table = closest2(el, "table");
      colgroup = table && table.querySelector("colgroup");
      if (options3.repeatHeaders) {
        thead = table && table.querySelector("thead");
        grid = closest2(el, ".k-grid");
        if (grid && grid.querySelector(".k-auto-scrollable")) {
          gridHead = grid.querySelector(".k-grid-header");
        }
      }
      var page = makePage();
      var range = doc.createRange();
      range.setStartBefore(copy);
      range.setEndBefore(el);
      page.appendChild(range.extractContents());
      copy.parentNode.insertBefore(page, copy);
      preventBulletOnListItem(el.parentNode);
      if (table) {
        table = closest2(el, "table");
        if (options3.repeatHeaders && thead) {
          table.insertBefore(thead.cloneNode(true), table.firstChild);
        }
        if (colgroup) {
          table.insertBefore(colgroup.cloneNode(true), table.firstChild);
        }
      }
      if (options3.repeatHeaders && gridHead) {
        grid = closest2(el, ".k-grid");
        grid.insertBefore(gridHead.cloneNode(true), grid.firstChild);
      }
    }
    function makePage() {
      var page = doc.createElement("KENDO-PDF-PAGE");
      setCSS(page, {
        display: "block",
        boxSizing: "content-box",
        width: pageWidth ? pageWidth + "px" : "auto",
        padding: margin.top + "px " + margin.right + "px " + margin.bottom + "px " + margin.left + "px",
        // allow absolutely positioned elements to be relative to current page
        position: "relative",
        // without the following we might affect layout of subsequent pages
        height: pageHeight ? pageHeight + "px" : "auto",
        overflow: pageHeight || pageWidth ? "hidden" : "visible",
        clear: "both"
      });
      if (options3 && options3.pageClassName) {
        page.className = options3.pageClassName;
      }
      pages.push(page);
      return page;
    }
    function fallsOnMargin(thing) {
      var box = thing.getBoundingClientRect();
      if (box.width === 0 || box.height === 0) {
        return 0;
      }
      var top = copy.getBoundingClientRect().top;
      var available = pageHeight - adjust;
      return box.height > available ? 3 : box.top - top > available ? 1 : box.bottom - top > available ? 2 : 0;
    }
    function splitText(node, isFirst) {
      if (!/\S/.test(node.data)) {
        return;
      }
      var len = node.data.length;
      var range = doc.createRange();
      range.selectNodeContents(node);
      var fall = fallsOnMargin(range);
      if (!fall) {
        return;
      }
      var nextnode = node;
      if (fall == 1) {
        if (isFirst) {
          breakAtElement(node.parentNode);
        } else {
          breakAtElement(node);
        }
      } else {
        (function findEOP(min, pos, max) {
          range.setEnd(node, pos);
          if (min == pos || pos == max) {
            return pos;
          }
          if (fallsOnMargin(range)) {
            return findEOP(min, min + pos >> 1, pos);
          } else {
            return findEOP(pos, pos + max >> 1, max);
          }
        })(0, len >> 1, len);
        if (!/\S/.test(range.toString()) && isFirst) {
          breakAtElement(node.parentNode);
        } else {
          nextnode = node.splitText(range.endOffset);
          var page = makePage();
          range.setStartBefore(copy);
          page.appendChild(range.extractContents());
          copy.parentNode.insertBefore(page, copy);
          preventBulletOnListItem(nextnode.parentNode);
        }
      }
      splitText(nextnode);
    }
    function preventBulletOnListItem(el) {
      var li = closest2(el, "li");
      if (li) {
        li.setAttribute("kendo-no-bullet", "1");
        preventBulletOnListItem(li.parentNode);
      }
    }
  }
  return promise;
}
var parseBackgroundImage = /* @__PURE__ */ function() {
  var tok_linear_gradient = /^((-webkit-|-moz-|-o-|-ms-)?linear-gradient\s*)\(/;
  var tok_percent = /^([-0-9.]+%)/;
  var tok_length = /^([-0-9.]+px)/;
  var tok_keyword = /^(left|right|top|bottom|to|center)\W/;
  var tok_angle = /^([-0-9.]+(deg|grad|rad|turn)|0)/;
  var tok_whitespace = /^(\s+)/;
  var tok_popen = /^(\()/;
  var tok_pclose = /^(\))/;
  var tok_comma = /^(,)/;
  var tok_url = /^(url)\(/;
  var tok_content = /^(.*?)\)/;
  var cache1 = {}, cache2 = {};
  function parse3(input) {
    var orig = input;
    if (hasOwnProperty3(cache1, orig)) {
      return cache1[orig];
    }
    function skip_ws() {
      var m = tok_whitespace.exec(input);
      if (m) {
        input = input.substr(m[1].length);
      }
    }
    function read(token3) {
      skip_ws();
      var m = token3.exec(input);
      if (m) {
        input = input.substr(m[1].length);
        return m[1];
      }
    }
    function read_stop() {
      var color = parseColor(input, true);
      var length, percent;
      if (color) {
        var match2 = /^#[0-9a-f]+/i.exec(input) || /^rgba?\(.*?\)/i.exec(input) || /^..*?\b/.exec(input);
        input = input.substr(match2[0].length);
        color = color.toRGB();
        if (!(length = read(tok_length))) {
          percent = read(tok_percent);
        }
        return {
          color,
          length,
          percent
        };
      }
    }
    function read_linear_gradient(propName) {
      var angle;
      var to1, to2;
      var stops = [];
      var reverse = false;
      if (read(tok_popen)) {
        angle = read(tok_angle);
        if (angle == "0") {
          angle = "0deg";
        }
        if (angle) {
          angle = parseAngle(angle);
          read(tok_comma);
        } else {
          to1 = read(tok_keyword);
          if (to1 == "to") {
            to1 = read(tok_keyword);
          } else if (to1 && /^-/.test(propName)) {
            reverse = true;
          }
          to2 = read(tok_keyword);
          read(tok_comma);
        }
        if (/-moz-/.test(propName) && angle == null && to1 == null) {
          var x = read(tok_percent), y = read(tok_percent);
          reverse = true;
          if (x == "0%") {
            to1 = "left";
          } else if (x == "100%") {
            to1 = "right";
          }
          if (y == "0%") {
            to2 = "top";
          } else if (y == "100%") {
            to2 = "bottom";
          }
          read(tok_comma);
        }
        while (input && !read(tok_pclose)) {
          var stop = read_stop();
          if (!stop) {
            break;
          }
          stops.push(stop);
          read(tok_comma);
        }
        return {
          type: "linear",
          angle,
          to: to1 && to2 ? to1 + " " + to2 : to1 ? to1 : to2 ? to2 : null,
          stops,
          reverse
        };
      }
    }
    function read_url() {
      if (read(tok_popen)) {
        var url = read(tok_content);
        url = url.replace(/^['"]+|["']+$/g, "");
        read(tok_pclose);
        return {
          type: "url",
          url
        };
      }
    }
    var tok;
    if (tok = read(tok_linear_gradient)) {
      tok = read_linear_gradient(tok);
    } else if (tok = read(tok_url)) {
      tok = read_url();
    }
    return cache1[orig] = tok || {
      type: "none"
    };
  }
  return function(input) {
    if (hasOwnProperty3(cache2, input)) {
      return cache2[input];
    }
    return cache2[input] = splitProperty(input).map(parse3);
  };
}();
var splitProperty = /* @__PURE__ */ function() {
  var cache = {};
  return function(input, separator) {
    if (!separator) {
      separator = /^\s*,\s*/;
    }
    var cacheKey = input + separator;
    if (hasOwnProperty3(cache, cacheKey)) {
      return cache[cacheKey];
    }
    var ret = [];
    var last2 = 0, pos = 0;
    var in_paren = 0;
    var in_string = false;
    var m;
    function looking_at(rx) {
      return m = rx.exec(input.substr(pos));
    }
    function trim(str) {
      return str.replace(/^\s+|\s+$/g, "");
    }
    while (pos < input.length) {
      if (!in_string && looking_at(/^[\(\[\{]/)) {
        in_paren++;
        pos++;
      } else if (!in_string && looking_at(/^[\)\]\}]/)) {
        in_paren--;
        pos++;
      } else if (!in_string && looking_at(/^[\"\']/)) {
        in_string = m[0];
        pos++;
      } else if (in_string == "'" && looking_at(/^\\\'/)) {
        pos += 2;
      } else if (in_string == '"' && looking_at(/^\\\"/)) {
        pos += 2;
      } else if (in_string == "'" && looking_at(/^\'/)) {
        in_string = false;
        pos++;
      } else if (in_string == '"' && looking_at(/^\"/)) {
        in_string = false;
        pos++;
      } else if (looking_at(separator)) {
        if (!in_string && !in_paren && pos > last2) {
          ret.push(trim(input.substring(last2, pos)));
          last2 = pos + m[0].length;
        }
        pos += m[0].length;
      } else {
        pos++;
      }
    }
    if (last2 < pos) {
      ret.push(trim(input.substring(last2, pos)));
    }
    return cache[cacheKey] = ret;
  };
}();
var getFontURL2 = /* @__PURE__ */ function(cache) {
  return function(el) {
    var url = cache[el];
    if (!url) {
      var m;
      if (m = /url\((['"]?)([^'")]*?)\1\)\s+format\((['"]?)truetype\3\)/.exec(el)) {
        url = cache[el] = m[2];
      } else if (m = /url\((['"]?)([^'")]*?\.ttf)\1\)/.exec(el)) {
        url = cache[el] = m[2];
      }
    }
    return url;
  };
}(/* @__PURE__ */ Object.create(null));
var getFontHeight = /* @__PURE__ */ function(cache) {
  return function(font) {
    var height = cache[font];
    if (height == null) {
      height = cache[font] = measureText("Mapq", {
        font
      }).height;
    }
    return height;
  };
}(/* @__PURE__ */ Object.create(null));
function getFontFaces(doc) {
  if (doc == null) {
    doc = document;
  }
  var result = {};
  for (var i = 0; i < doc.styleSheets.length; ++i) {
    doStylesheet(doc.styleSheets[i]);
  }
  return result;
  function doStylesheet(ss) {
    if (ss) {
      var rules = null;
      try {
        rules = ss.cssRules;
      } catch (ex) {
      }
      if (rules) {
        addRules(ss, rules);
      }
    }
  }
  function findFonts(rule) {
    var src = getPropertyValue(rule.style, "src");
    if (src) {
      return splitProperty(src).reduce(function(a, el) {
        var font2 = getFontURL2(el);
        if (font2) {
          a.push(font2);
        }
        return a;
      }, []);
    } else {
      var font = getFontURL2(rule.cssText);
      return font ? [font] : [];
    }
  }
  function addRules(styleSheet, rules) {
    for (var i2 = 0; i2 < rules.length; ++i2) {
      var r = rules[i2];
      switch (r.type) {
        case 3:
          doStylesheet(r.styleSheet);
          break;
        case 5:
          var style2 = r.style;
          var family = splitProperty(getPropertyValue(style2, "font-family"));
          var bold = /^([56789]00|bold)$/i.test(getPropertyValue(style2, "font-weight"));
          var italic = "italic" == getPropertyValue(style2, "font-style");
          var src = findFonts(r);
          if (src.length > 0) {
            addRule(styleSheet, family, bold, italic, src[0]);
          }
      }
    }
  }
  function addRule(styleSheet, names, bold, italic, url) {
    if (!/^data:/i.test(url)) {
      if (!(/^[^\/:]+:\/\//.test(url) || /^\//.test(url))) {
        url = String(styleSheet.href).replace(/[^\/]*$/, "") + url;
      }
    }
    names.forEach(function(name2) {
      name2 = name2.replace(/^(['"]?)(.*?)\1$/, "$2");
      if (bold) {
        name2 += "|bold";
      }
      if (italic) {
        name2 += "|italic";
      }
      result[name2] = url;
    });
  }
}
function hasOwnProperty3(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function getCounter(name2) {
  name2 = "_counter_" + name2;
  return nodeInfo[name2];
}
function getAllCounters(name2) {
  var values = [], p = nodeInfo;
  name2 = "_counter_" + name2;
  while (p) {
    if (hasOwnProperty3(p, name2)) {
      values.push(p[name2]);
    }
    p = Object.getPrototypeOf(p);
  }
  return values.reverse();
}
function incCounter(name2, inc) {
  var p = nodeInfo;
  name2 = "_counter_" + name2;
  while (p && !hasOwnProperty3(p, name2)) {
    p = Object.getPrototypeOf(p);
  }
  if (!p) {
    p = nodeInfo._root;
  }
  p[name2] = (p[name2] || 0) + (inc == null ? 1 : inc);
}
function resetCounter(name2, val) {
  name2 = "_counter_" + name2;
  nodeInfo[name2] = val == null ? 0 : val;
}
function doCounters(a, f, def) {
  for (var i = 0; i < a.length; ) {
    var name2 = a[i++];
    var val = parseFloat(a[i]);
    if (isNaN(val)) {
      f(name2, def);
    } else {
      f(name2, val);
      ++i;
    }
  }
}
function updateCounters(style2) {
  var counterReset = getPropertyValue(style2, "counter-reset");
  if (counterReset) {
    doCounters(splitProperty(counterReset, /^\s+/), resetCounter, 0);
  }
  var counterIncrement = getPropertyValue(style2, "counter-increment");
  if (counterIncrement) {
    doCounters(splitProperty(counterIncrement, /^\s+/), incCounter, 1);
  }
}
function parseColor3(str, css) {
  var color = parseColor(str, true);
  if (color) {
    color = color.toRGB();
    if (css) {
      color = color.toCssRgba();
    } else if (color.a === 0) {
      color = null;
    }
  }
  return color;
}
function whenImagesAreActuallyLoaded(elements, callback) {
  var pending = 0;
  var done = false;
  elements.forEach(function(el) {
    var images = el.querySelectorAll("img");
    for (var i = 0; i < images.length; ++i) {
      var img = images[i];
      if (!img.complete) {
        pending++;
        img.onload = img.onerror = next;
      }
    }
  });
  if (!pending) {
    next();
  }
  function next() {
    if (!done && --pending <= 0) {
      callback();
      done = true;
    }
  }
}
function cacheImages(elements, callback) {
  var urls = [];
  function add2(url) {
    if (!IMAGE_CACHE2[url]) {
      IMAGE_CACHE2[url] = true;
      urls.push(url);
    }
  }
  elements.forEach(function dive(element) {
    if (/^img$/i.test(element.tagName)) {
      add2(element.src);
    }
    parseBackgroundImage(getPropertyValue(getComputedStyle2(element), "background-image")).forEach(function(bg) {
      if (bg.type == "url") {
        add2(bg.url);
      }
    });
    if (element.children) {
      slice2(element.children).forEach(dive);
    }
  });
  var count = urls.length;
  function next() {
    if (--count <= 0) {
      whenImagesAreActuallyLoaded(elements, callback);
    }
  }
  if (count === 0) {
    next();
  }
  urls.forEach(function(url) {
    var img = IMAGE_CACHE2[url] = new window.Image();
    if (!/^data:/i.test(url)) {
      img.crossOrigin = "Anonymous";
    }
    img.src = url;
    if (img.complete) {
      next();
    } else {
      img.onload = next;
      img.onerror = function() {
        IMAGE_CACHE2[url] = null;
        next();
      };
    }
  });
}
function alphaNumeral(n) {
  var result = "";
  do {
    var r = n % 26;
    result = String.fromCharCode(97 + r) + result;
    n = Math.floor(n / 26);
  } while (n > 0);
  return result;
}
function pushNodeInfo(element, style2, group) {
  nodeInfo = Object.create(nodeInfo);
  nodeInfo[element.tagName.toLowerCase()] = {
    element,
    style: style2
  };
  var decoration = getPropertyValue(style2, "text-decoration");
  if (decoration && decoration != "none") {
    var color = getPropertyValue(style2, "text-decoration-color");
    decoration.split(/\s+/g).forEach(function(name2) {
      if (!nodeInfo[name2]) {
        nodeInfo[name2] = color;
        if (name2 == "underline") {
          var offset = getPropertyValue(style2, "text-underline-offset");
          if (offset != "auto") {
            nodeInfo["underline-offset"] = parseFloat(offset);
          }
        }
      }
    });
  }
  if (createsStackingContext(style2)) {
    nodeInfo._stackingContext = {
      element,
      group
    };
  }
}
function popNodeInfo() {
  nodeInfo = Object.getPrototypeOf(nodeInfo);
}
function updateClipbox(path) {
  if (nodeInfo._clipbox != null) {
    var box = path.bbox(nodeInfo._matrix);
    if (nodeInfo._clipbox) {
      nodeInfo._clipbox = rect_default.intersect(nodeInfo._clipbox, box);
    } else {
      nodeInfo._clipbox = box;
    }
  }
}
function emptyClipbox() {
  var cb = nodeInfo._clipbox;
  if (cb == null) {
    return true;
  }
  if (cb) {
    return cb.width() === 0 || cb.height() === 0;
  }
}
function createsStackingContext(style2) {
  function prop(name2) {
    return getPropertyValue(style2, name2);
  }
  if (prop("transform") != "none" || prop("position") != "static" || prop("z-index") != "auto" || prop("opacity") < 1) {
    return true;
  }
}
function getComputedStyle2(element, pseudoElt) {
  return window.getComputedStyle(element, pseudoElt || null);
}
function getPropertyValue(style2, prop, defa) {
  var val = style2.getPropertyValue(prop);
  if (val == null || val === "") {
    if (browser5.webkit) {
      val = style2.getPropertyValue("-webkit-" + prop);
    } else if (browser5.mozilla) {
      val = style2.getPropertyValue("-moz-" + prop);
    } else if (browser5.opera) {
      val = style2.getPropertyValue("-o-" + prop);
    } else if (microsoft) {
      val = style2.getPropertyValue("-ms-" + prop);
    }
  }
  if (arguments.length > 2 && (val == null || val === "")) {
    return defa;
  } else {
    return val;
  }
}
function pleaseSetPropertyValue(style2, prop, value, important) {
  style2.setProperty(prop, value, important);
  if (browser5.webkit) {
    style2.setProperty("-webkit-" + prop, value, important);
  } else if (browser5.mozilla) {
    style2.setProperty("-moz-" + prop, value, important);
  } else if (browser5.opera) {
    style2.setProperty("-o-" + prop, value, important);
  } else if (microsoft) {
    style2.setProperty("-ms-" + prop, value, important);
    prop = "ms" + prop.replace(/(^|-)([a-z])/g, function(s, p1, p2) {
      return p1 + p2.toUpperCase();
    });
    style2[prop] = value;
  }
}
function getBorder(style2, side) {
  side = "border-" + side;
  return {
    width: parseFloat(getPropertyValue(style2, side + "-width")),
    style: getPropertyValue(style2, side + "-style"),
    color: parseColor3(getPropertyValue(style2, side + "-color"), true)
  };
}
function saveStyle(element, func) {
  var prev = element.style.cssText;
  var result = func();
  setStyle(element, prev);
  return result;
}
function getBorderRadius(style2, side) {
  var r = getPropertyValue(style2, "border-" + side + "-radius").split(/\s+/g).map(parseFloat);
  if (r.length == 1) {
    r.push(r[0]);
  }
  return sanitizeRadius({
    x: r[0],
    y: r[1]
  });
}
function getContentBox(element) {
  var box = element.getBoundingClientRect();
  box = innerBox(box, "border-*-width", element);
  box = innerBox(box, "padding-*", element);
  return box;
}
function innerBox(box, prop, element) {
  var style2, wt, wr, wb, wl;
  if (typeof prop == "string") {
    style2 = getComputedStyle2(element);
    wt = parseFloat(getPropertyValue(style2, prop.replace("*", "top")));
    wr = parseFloat(getPropertyValue(style2, prop.replace("*", "right")));
    wb = parseFloat(getPropertyValue(style2, prop.replace("*", "bottom")));
    wl = parseFloat(getPropertyValue(style2, prop.replace("*", "left")));
  } else if (typeof prop == "number") {
    wt = wr = wb = wl = prop;
  }
  return {
    top: box.top + wt,
    right: box.right - wr,
    bottom: box.bottom - wb,
    left: box.left + wl,
    width: box.right - box.left - wr - wl,
    height: box.bottom - box.top - wb - wt
  };
}
function getTransform(style2) {
  var transform3 = getPropertyValue(style2, "transform");
  if (transform3 == "none") {
    return null;
  }
  var matrix = /^\s*matrix\(\s*(.*?)\s*\)\s*$/.exec(transform3);
  if (matrix) {
    var origin = getPropertyValue(style2, "transform-origin");
    matrix = matrix[1].split(/\s*,\s*/g).map(parseFloat);
    origin = origin.split(/\s+/g).map(parseFloat);
    return {
      matrix,
      origin
    };
  }
}
function radiansToDegrees(radians) {
  return 180 * radians / Math.PI % 360;
}
function parseAngle(angle) {
  var num = parseFloat(angle);
  if (/grad$/.test(angle)) {
    return Math.PI * num / 200;
  } else if (/rad$/.test(angle)) {
    return num;
  } else if (/turn$/.test(angle)) {
    return Math.PI * num * 2;
  } else if (/deg$/.test(angle)) {
    return Math.PI * num / 180;
  }
}
function setTransform(shape, m) {
  m = new matrix_default(m[0], m[1], m[2], m[3], m[4], m[5]);
  shape.transform(m);
  return m;
}
function setClipping2(shape, clipPath) {
  shape.clip(clipPath);
}
function addArcToPath(path, x, y, options2) {
  var points3 = new arc_default([x, y], options2).curvePoints(), i = 1;
  while (i < points3.length) {
    path.curveTo(points3[i++], points3[i++], points3[i++]);
  }
}
function sanitizeRadius(r) {
  if (r.x <= 0 || r.y <= 0) {
    r.x = r.y = 0;
  }
  return r;
}
function adjustBorderRadiusForBox(box, rTL, rTR, rBR, rBL) {
  var tl_x = Math.max(0, rTL.x), tl_y = Math.max(0, rTL.y);
  var tr_x = Math.max(0, rTR.x), tr_y = Math.max(0, rTR.y);
  var br_x = Math.max(0, rBR.x), br_y = Math.max(0, rBR.y);
  var bl_x = Math.max(0, rBL.x), bl_y = Math.max(0, rBL.y);
  var f = Math.min(box.width / (tl_x + tr_x), box.height / (tr_y + br_y), box.width / (br_x + bl_x), box.height / (bl_y + tl_y));
  if (f < 1) {
    tl_x *= f;
    tl_y *= f;
    tr_x *= f;
    tr_y *= f;
    br_x *= f;
    br_y *= f;
    bl_x *= f;
    bl_y *= f;
  }
  return {
    tl: {
      x: tl_x,
      y: tl_y
    },
    tr: {
      x: tr_x,
      y: tr_y
    },
    br: {
      x: br_x,
      y: br_y
    },
    bl: {
      x: bl_x,
      y: bl_y
    }
  };
}
function elementRoundBox(element, box, type) {
  var style2 = getComputedStyle2(element);
  var rTL = getBorderRadius(style2, "top-left");
  var rTR = getBorderRadius(style2, "top-right");
  var rBL = getBorderRadius(style2, "bottom-left");
  var rBR = getBorderRadius(style2, "bottom-right");
  if (type == "padding" || type == "content") {
    var bt = getBorder(style2, "top");
    var br = getBorder(style2, "right");
    var bb = getBorder(style2, "bottom");
    var bl = getBorder(style2, "left");
    rTL.x -= bl.width;
    rTL.y -= bt.width;
    rTR.x -= br.width;
    rTR.y -= bt.width;
    rBR.x -= br.width;
    rBR.y -= bb.width;
    rBL.x -= bl.width;
    rBL.y -= bb.width;
    if (type == "content") {
      var pt = parseFloat(getPropertyValue(style2, "padding-top"));
      var pr = parseFloat(getPropertyValue(style2, "padding-right"));
      var pb = parseFloat(getPropertyValue(style2, "padding-bottom"));
      var pl = parseFloat(getPropertyValue(style2, "padding-left"));
      rTL.x -= pl;
      rTL.y -= pt;
      rTR.x -= pr;
      rTR.y -= pt;
      rBR.x -= pr;
      rBR.y -= pb;
      rBL.x -= pl;
      rBL.y -= pb;
    }
  }
  if (typeof type == "number") {
    rTL.x -= type;
    rTL.y -= type;
    rTR.x -= type;
    rTR.y -= type;
    rBR.x -= type;
    rBR.y -= type;
    rBL.x -= type;
    rBL.y -= type;
  }
  return roundBox(box, rTL, rTR, rBR, rBL);
}
function roundBox(box, rTL0, rTR0, rBR0, rBL0) {
  var tmp = adjustBorderRadiusForBox(box, rTL0, rTR0, rBR0, rBL0);
  var rTL = tmp.tl;
  var rTR = tmp.tr;
  var rBR = tmp.br;
  var rBL = tmp.bl;
  var path = new Path({
    fill: null,
    stroke: null
  });
  path.moveTo(box.left, box.top + rTL.y);
  if (rTL.x) {
    addArcToPath(path, box.left + rTL.x, box.top + rTL.y, {
      startAngle: -180,
      endAngle: -90,
      radiusX: rTL.x,
      radiusY: rTL.y
    });
  }
  path.lineTo(box.right - rTR.x, box.top);
  if (rTR.x) {
    addArcToPath(path, box.right - rTR.x, box.top + rTR.y, {
      startAngle: -90,
      endAngle: 0,
      radiusX: rTR.x,
      radiusY: rTR.y
    });
  }
  path.lineTo(box.right, box.bottom - rBR.y);
  if (rBR.x) {
    addArcToPath(path, box.right - rBR.x, box.bottom - rBR.y, {
      startAngle: 0,
      endAngle: 90,
      radiusX: rBR.x,
      radiusY: rBR.y
    });
  }
  path.lineTo(box.left + rBL.x, box.bottom);
  if (rBL.x) {
    addArcToPath(path, box.left + rBL.x, box.bottom - rBL.y, {
      startAngle: 90,
      endAngle: 180,
      radiusX: rBL.x,
      radiusY: rBL.y
    });
  }
  return path.close();
}
function formatCounter(val, style2) {
  var str = String(parseFloat(val));
  switch (style2) {
    case "decimal-leading-zero":
      if (str.length < 2) {
        str = "0" + str;
      }
      return str;
    case "lower-roman":
      return arabicToRoman(val).toLowerCase();
    case "upper-roman":
      return arabicToRoman(val).toUpperCase();
    case "lower-latin":
    case "lower-alpha":
      return alphaNumeral(val - 1);
    case "upper-latin":
    case "upper-alpha":
      return alphaNumeral(val - 1).toUpperCase();
    default:
      return str;
  }
}
function evalPseudoElementContent(element, content) {
  function displayCounter(name2, style2, separator) {
    if (!separator) {
      return formatCounter(getCounter(name2) || 0, style2);
    }
    separator = separator.replace(/^\s*(["'])(.*)\1\s*$/, "$2");
    return getAllCounters(name2).map(function(val) {
      return formatCounter(val, style2);
    }).join(separator);
  }
  var a = splitProperty(content, /^\s+/);
  var result = [], m;
  a.forEach(function(el) {
    var tmp;
    if (m = /^\s*(["'])(.*)\1\s*$/.exec(el)) {
      result.push(m[2].replace(/\\([0-9a-f]{4})/gi, function(s, p) {
        return String.fromCharCode(parseInt(p, 16));
      }));
    } else if (m = /^\s*counter\((.*?)\)\s*$/.exec(el)) {
      tmp = splitProperty(m[1]);
      result.push(displayCounter(tmp[0], tmp[1]));
    } else if (m = /^\s*counters\((.*?)\)\s*$/.exec(el)) {
      tmp = splitProperty(m[1]);
      result.push(displayCounter(tmp[0], tmp[2], tmp[1]));
    } else if (m = /^\s*attr\((.*?)\)\s*$/.exec(el)) {
      result.push(element.getAttribute(m[1]) || "");
    } else {
      result.push(el);
    }
  });
  return result.join("");
}
function getCssText(style2) {
  if (style2.cssText) {
    return style2.cssText;
  }
  var result = [];
  for (var i = 0; i < style2.length; ++i) {
    result.push(style2[i] + ": " + getPropertyValue(style2, style2[i]));
  }
  return result.join(";\n");
}
function _renderWithPseudoElements(element, group) {
  if (element.tagName == KENDO_PSEUDO_ELEMENT) {
    _renderElement(element, group);
    return;
  }
  var fake = [];
  function pseudo(kind, place) {
    var style2 = getComputedStyle2(element, kind), content = style2.content;
    updateCounters(style2);
    if (content && content != "normal" && content != "none" && style2.width != "0px") {
      var psel = element.ownerDocument.createElement(KENDO_PSEUDO_ELEMENT);
      setStyle(psel, getCssText(style2));
      psel.textContent = evalPseudoElementContent(element, content);
      element.insertBefore(psel, place);
      fake.push(psel);
    }
  }
  pseudo(":before", element.firstChild);
  pseudo(":after", null);
  if (fake.length > 0) {
    var saveClass = element.className;
    element.className += " kendo-pdf-hide-pseudo-elements";
    _renderElement(element, group);
    element.className = saveClass;
    fake.forEach(function(el) {
      element.removeChild(el);
    });
  } else {
    _renderElement(element, group);
  }
}
function _renderElement(element, group) {
  var style2 = getComputedStyle2(element);
  var top = getBorder(style2, "top");
  var right = getBorder(style2, "right");
  var bottom = getBorder(style2, "bottom");
  var left = getBorder(style2, "left");
  var rTL0 = getBorderRadius(style2, "top-left");
  var rTR0 = getBorderRadius(style2, "top-right");
  var rBL0 = getBorderRadius(style2, "bottom-left");
  var rBR0 = getBorderRadius(style2, "bottom-right");
  var dir = getPropertyValue(style2, "direction");
  var backgroundColor = getPropertyValue(style2, "background-color");
  backgroundColor = parseColor3(backgroundColor);
  var backgroundImage = parseBackgroundImage(getPropertyValue(style2, "background-image"));
  var backgroundRepeat = splitProperty(getPropertyValue(style2, "background-repeat"));
  var backgroundPosition = splitProperty(getPropertyValue(style2, "background-position"));
  var backgroundOrigin = splitProperty(getPropertyValue(style2, "background-origin"));
  var backgroundSize = splitProperty(getPropertyValue(style2, "background-size"));
  var textOverflow, saveTextOverflow;
  if (microsoft) {
    textOverflow = style2.textOverflow;
    if (textOverflow == "ellipsis") {
      saveTextOverflow = element.style.textOverflow;
      element.style.textOverflow = "clip";
    }
  }
  if (browser5.msie && browser5.version < 10) {
    backgroundPosition = splitProperty(element.currentStyle.backgroundPosition);
  }
  var innerbox = innerBox(element.getBoundingClientRect(), "border-*-width", element);
  (function() {
    var clip = getPropertyValue(style2, "clip");
    var m = /^\s*rect\((.*)\)\s*$/.exec(clip);
    if (m) {
      var a = m[1].split(/[ ,]+/g);
      var top2 = a[0] == "auto" ? innerbox.top : parseFloat(a[0]) + innerbox.top;
      var right2 = a[1] == "auto" ? innerbox.right : parseFloat(a[1]) + innerbox.left;
      var bottom2 = a[2] == "auto" ? innerbox.bottom : parseFloat(a[2]) + innerbox.top;
      var left2 = a[3] == "auto" ? innerbox.left : parseFloat(a[3]) + innerbox.left;
      var tmp = new group_default();
      var clipPath = new Path().moveTo(left2, top2).lineTo(right2, top2).lineTo(right2, bottom2).lineTo(left2, bottom2).close();
      setClipping2(tmp, clipPath);
      group.append(tmp);
      group = tmp;
      updateClipbox(clipPath);
    }
  })();
  var boxes, i, cells;
  var display = getPropertyValue(style2, "display");
  if (display == "table-row") {
    boxes = [];
    for (i = 0, cells = element.children; i < cells.length; ++i) {
      boxes.push(cells[i].getBoundingClientRect());
    }
  } else {
    boxes = element.getClientRects();
    if (boxes.length == 1) {
      boxes = [element.getBoundingClientRect()];
    }
  }
  boxes = adjustBoxes(boxes);
  for (i = 0; i < boxes.length; ++i) {
    drawOneBox(boxes[i], i === 0, i == boxes.length - 1);
  }
  if (element.tagName == "A" && element.href && !/^#?$/.test(element.getAttribute("href"))) {
    if (!nodeInfo._avoidLinks || !matches(element, nodeInfo._avoidLinks)) {
      var r = document.createRange();
      r.selectNodeContents(element);
      slice2(r.getClientRects()).forEach(function(box) {
        var g = new group_default();
        g._pdfLink = {
          url: element.href,
          top: box.top,
          right: box.right,
          bottom: box.bottom,
          left: box.left
        };
        group.append(g);
      });
    }
  }
  if (boxes.length > 0 && display == "list-item" && !element.getAttribute("kendo-no-bullet")) {
    drawBullet(boxes[0]);
  }
  (function() {
    function clipit() {
      var clipPath = elementRoundBox(element, innerbox, "padding");
      var tmp = new group_default();
      setClipping2(tmp, clipPath);
      group.append(tmp);
      group = tmp;
      updateClipbox(clipPath);
    }
    if (isFormField(element)) {
      clipit();
    } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style2, "overflow"))) {
      clipit();
    } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style2, "overflow-x"))) {
      clipit();
    } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style2, "overflow-y"))) {
      clipit();
    }
  })();
  if (!maybeRenderWidget(element, group) && !maybeRenderBullet(element, group)) {
    renderContents(element, group);
  }
  if (microsoft && textOverflow == "ellipsis") {
    element.style.textOverflow = saveTextOverflow;
  }
  return group;
  function adjustBoxes(boxes2) {
    if (/^td$/i.test(element.tagName)) {
      var table = nodeInfo.table;
      if (table && getPropertyValue(table.style, "border-collapse") == "collapse") {
        var tableBorderLeft = getBorder(table.style, "left").width;
        var tableBorderTop = getBorder(table.style, "top").width;
        if (tableBorderLeft === 0 && tableBorderTop === 0) {
          return boxes2;
        }
        var tableBox = table.element.getBoundingClientRect();
        var firstCell = table.element.rows[0].cells[0];
        var firstCellBox = firstCell.getBoundingClientRect();
        if (firstCellBox.top == tableBox.top || firstCellBox.left == tableBox.left) {
          return slice2(boxes2).map(function(box) {
            return {
              left: box.left + tableBorderLeft,
              top: box.top + tableBorderTop,
              right: box.right + tableBorderLeft,
              bottom: box.bottom + tableBorderTop,
              height: box.height,
              width: box.width
            };
          });
        }
      }
    }
    return boxes2;
  }
  function drawEdge(color, len, Wtop, Wleft, Wright, rl, rr, transform3) {
    if (Wtop <= 0) {
      return;
    }
    var path, edge = new group_default();
    setTransform(edge, transform3);
    group.append(edge);
    sanitizeRadius(rl);
    sanitizeRadius(rr);
    path = new Path({
      fill: {
        color
      },
      stroke: null
    });
    edge.append(path);
    path.moveTo(rl.x ? Math.max(rl.x, Wleft) : 0, 0).lineTo(len - (rr.x ? Math.max(rr.x, Wright) : 0), 0).lineTo(len - Math.max(rr.x, Wright), Wtop).lineTo(Math.max(rl.x, Wleft), Wtop).close();
    if (rl.x) {
      drawRoundCorner(Wleft, rl, [-1, 0, 0, 1, rl.x, 0]);
    }
    if (rr.x) {
      drawRoundCorner(Wright, rr, [1, 0, 0, 1, len - rr.x, 0]);
    }
    function drawRoundCorner(Wright2, r2, transform4) {
      var angle = Math.PI / 2 * Wright2 / (Wright2 + Wtop);
      var ri = {
        x: r2.x - Wright2,
        y: r2.y - Wtop
      };
      var path2 = new Path({
        fill: {
          color
        },
        stroke: null
      }).moveTo(0, 0);
      setTransform(path2, transform4);
      addArcToPath(path2, 0, r2.y, {
        startAngle: -90,
        endAngle: -radiansToDegrees(angle),
        radiusX: r2.x,
        radiusY: r2.y
      });
      if (ri.x > 0 && ri.y > 0) {
        path2.lineTo(ri.x * Math.cos(angle), r2.y - ri.y * Math.sin(angle));
        addArcToPath(path2, 0, r2.y, {
          startAngle: -radiansToDegrees(angle),
          endAngle: -90,
          radiusX: ri.x,
          radiusY: ri.y,
          anticlockwise: true
        });
      } else if (ri.x > 0) {
        path2.lineTo(ri.x, Wtop).lineTo(0, Wtop);
      } else {
        path2.lineTo(ri.x, Wtop).lineTo(ri.x, 0);
      }
      edge.append(path2.close());
    }
  }
  function drawBackground2(box) {
    var background = new group_default();
    setClipping2(background, roundBox(box, rTL0, rTR0, rBR0, rBL0));
    group.append(background);
    if (backgroundColor) {
      var path = new Path({
        fill: {
          color: backgroundColor.toCssRgba()
        },
        stroke: null
      });
      path.moveTo(box.left, box.top).lineTo(box.right, box.top).lineTo(box.right, box.bottom).lineTo(box.left, box.bottom).close();
      background.append(path);
    }
    for (var i2 = backgroundImage.length; --i2 >= 0; ) {
      drawOneBackground(background, box, backgroundImage[i2], backgroundRepeat[i2 % backgroundRepeat.length], backgroundPosition[i2 % backgroundPosition.length], backgroundOrigin[i2 % backgroundOrigin.length], backgroundSize[i2 % backgroundSize.length]);
    }
  }
  function drawOneBackground(group2, box, background, backgroundRepeat2, backgroundPosition2, backgroundOrigin2, backgroundSize2) {
    if (!background || background == "none") {
      return;
    }
    if (background.type == "url") {
      var img = IMAGE_CACHE2[background.url];
      if (img && img.width > 0 && img.height > 0) {
        drawBackgroundImage(group2, box, img.width, img.height, function(group3, rect) {
          group3.append(new image_default(background.url, rect));
        });
      }
    } else if (background.type == "linear") {
      drawBackgroundImage(group2, box, box.width, box.height, gradientRenderer(background));
    } else {
      return;
    }
    function drawBackgroundImage(group3, box2, img_width, img_height, renderBG) {
      var aspect_ratio = img_width / img_height, f;
      var orgBox = box2;
      if (backgroundOrigin2 == "content-box") {
        orgBox = innerBox(orgBox, "border-*-width", element);
        orgBox = innerBox(orgBox, "padding-*", element);
      } else if (backgroundOrigin2 == "padding-box") {
        orgBox = innerBox(orgBox, "border-*-width", element);
      }
      if (!/^\s*auto(\s+auto)?\s*$/.test(backgroundSize2)) {
        if (backgroundSize2 == "contain") {
          f = Math.min(orgBox.width / img_width, orgBox.height / img_height);
          img_width *= f;
          img_height *= f;
        } else if (backgroundSize2 == "cover") {
          f = Math.max(orgBox.width / img_width, orgBox.height / img_height);
          img_width *= f;
          img_height *= f;
        } else {
          var size = backgroundSize2.split(/\s+/g);
          if (/%$/.test(size[0])) {
            img_width = orgBox.width * parseFloat(size[0]) / 100;
          } else {
            img_width = parseFloat(size[0]);
          }
          if (size.length == 1 || size[1] == "auto") {
            img_height = img_width / aspect_ratio;
          } else if (/%$/.test(size[1])) {
            img_height = orgBox.height * parseFloat(size[1]) / 100;
          } else {
            img_height = parseFloat(size[1]);
          }
        }
      }
      var pos = String(backgroundPosition2);
      switch (pos) {
        case "bottom":
          pos = "50% 100%";
          break;
        case "top":
          pos = "50% 0";
          break;
        case "left":
          pos = "0 50%";
          break;
        case "right":
          pos = "100% 50%";
          break;
        case "center":
          pos = "50% 50%";
          break;
      }
      pos = pos.split(/\s+/);
      if (pos.length == 1) {
        pos[1] = "50%";
      }
      if (/%$/.test(pos[0])) {
        pos[0] = parseFloat(pos[0]) / 100 * (orgBox.width - img_width);
      } else {
        pos[0] = parseFloat(pos[0]);
      }
      if (/%$/.test(pos[1])) {
        pos[1] = parseFloat(pos[1]) / 100 * (orgBox.height - img_height);
      } else {
        pos[1] = parseFloat(pos[1]);
      }
      var rect = new rect_default([orgBox.left + pos[0], orgBox.top + pos[1]], [img_width, img_height]);
      function rewX() {
        while (rect.origin.x > box2.left) {
          rect.origin.x -= img_width;
        }
      }
      function rewY() {
        while (rect.origin.y > box2.top) {
          rect.origin.y -= img_height;
        }
      }
      function repeatX() {
        while (rect.origin.x < box2.right) {
          renderBG(group3, rect.clone());
          rect.origin.x += img_width;
        }
      }
      if (backgroundRepeat2 == "no-repeat") {
        renderBG(group3, rect);
      } else if (backgroundRepeat2 == "repeat-x") {
        rewX();
        repeatX();
      } else if (backgroundRepeat2 == "repeat-y") {
        rewY();
        while (rect.origin.y < box2.bottom) {
          renderBG(group3, rect.clone());
          rect.origin.y += img_height;
        }
      } else if (backgroundRepeat2 == "repeat") {
        rewX();
        rewY();
        var origin = rect.origin.clone();
        while (rect.origin.y < box2.bottom) {
          rect.origin.x = origin.x;
          repeatX();
          rect.origin.y += img_height;
        }
      }
    }
  }
  function drawBullet() {
    var listStyleType = getPropertyValue(style2, "list-style-type");
    if (listStyleType == "none") {
      return;
    }
    var listStylePosition = getPropertyValue(style2, "list-style-position");
    function _drawBullet(f) {
      saveStyle(element, function() {
        element.style.position = "relative";
        var bullet = element.ownerDocument.createElement(KENDO_PSEUDO_ELEMENT);
        bullet.style.position = "absolute";
        bullet.style.boxSizing = "border-box";
        if (listStylePosition == "outside") {
          bullet.style.width = "6em";
          bullet.style.left = "-6.8em";
          bullet.style.textAlign = "right";
        } else {
          bullet.style.left = "0px";
        }
        f(bullet);
        element.insertBefore(bullet, element.firstChild);
        renderElement(bullet, group);
        element.removeChild(bullet);
      });
    }
    function elementIndex(f) {
      var a = element.parentNode.children;
      var k = element.getAttribute("kendo-split-index");
      if (k != null) {
        return f(k | 0, a.length);
      }
      for (var i2 = 0; i2 < a.length; ++i2) {
        if (a[i2] === element) {
          return f(i2, a.length);
        }
      }
    }
    switch (listStyleType) {
      case "circle":
      case "disc":
      case "square":
        _drawBullet(function(bullet) {
          bullet.innerHTML = "&nbsp;";
          bullet.setAttribute(KENDO_BULLET_TYPE, listStyleType);
        });
        break;
      case "decimal":
      case "decimal-leading-zero":
        _drawBullet(function(bullet) {
          elementIndex(function(idx2) {
            ++idx2;
            if (listStyleType == "decimal-leading-zero" && idx2 < 10) {
              idx2 = "0" + idx2;
            }
            bullet.innerHTML = idx2 + ".";
          });
        });
        break;
      case "lower-roman":
      case "upper-roman":
        _drawBullet(function(bullet) {
          elementIndex(function(idx2) {
            idx2 = arabicToRoman(idx2 + 1);
            if (listStyleType == "upper-roman") {
              idx2 = idx2.toUpperCase();
            }
            bullet.innerHTML = idx2 + ".";
          });
        });
        break;
      case "lower-latin":
      case "lower-alpha":
      case "upper-latin":
      case "upper-alpha":
        _drawBullet(function(bullet) {
          elementIndex(function(idx2) {
            idx2 = alphaNumeral(idx2);
            if (/^upper/i.test(listStyleType)) {
              idx2 = idx2.toUpperCase();
            }
            bullet.innerHTML = idx2 + ".";
          });
        });
        break;
    }
  }
  function drawOneBox(box, isFirst, isLast) {
    if (box.width === 0 || box.height === 0) {
      return;
    }
    drawBackground2(box);
    var shouldDrawLeft = left.width > 0 && (isFirst && dir == "ltr" || isLast && dir == "rtl");
    var shouldDrawRight = right.width > 0 && (isLast && dir == "ltr" || isFirst && dir == "rtl");
    if (top.width === 0 && left.width === 0 && right.width === 0 && bottom.width === 0) {
      return;
    }
    if (top.color == right.color && top.color == bottom.color && top.color == left.color) {
      if (top.width == right.width && top.width == bottom.width && top.width == left.width) {
        if (shouldDrawLeft && shouldDrawRight) {
          box = innerBox(box, top.width / 2);
          var path = elementRoundBox(element, box, top.width / 2);
          path.options.stroke = {
            color: top.color,
            width: top.width
          };
          group.append(path);
          return;
        }
      }
    }
    if (rTL0.x === 0 && rTR0.x === 0 && rBR0.x === 0 && rBL0.x === 0) {
      if (top.width < 2 && left.width < 2 && right.width < 2 && bottom.width < 2) {
        if (top.width > 0) {
          group.append(new Path({
            stroke: {
              width: top.width,
              color: top.color
            }
          }).moveTo(box.left, box.top + top.width / 2).lineTo(box.right, box.top + top.width / 2));
        }
        if (bottom.width > 0) {
          group.append(new Path({
            stroke: {
              width: bottom.width,
              color: bottom.color
            }
          }).moveTo(box.left, box.bottom - bottom.width / 2).lineTo(box.right, box.bottom - bottom.width / 2));
        }
        if (shouldDrawLeft) {
          group.append(new Path({
            stroke: {
              width: left.width,
              color: left.color
            }
          }).moveTo(box.left + left.width / 2, box.top).lineTo(box.left + left.width / 2, box.bottom));
        }
        if (shouldDrawRight) {
          group.append(new Path({
            stroke: {
              width: right.width,
              color: right.color
            }
          }).moveTo(box.right - right.width / 2, box.top).lineTo(box.right - right.width / 2, box.bottom));
        }
        return;
      }
    }
    var tmp = adjustBorderRadiusForBox(box, rTL0, rTR0, rBR0, rBL0);
    var rTL = tmp.tl;
    var rTR = tmp.tr;
    var rBR = tmp.br;
    var rBL = tmp.bl;
    drawEdge(top.color, box.width, top.width, left.width, right.width, rTL, rTR, [1, 0, 0, 1, box.left, box.top]);
    drawEdge(bottom.color, box.width, bottom.width, right.width, left.width, rBR, rBL, [-1, 0, 0, -1, box.right, box.bottom]);
    function inv(p) {
      return {
        x: p.y,
        y: p.x
      };
    }
    drawEdge(left.color, box.height, left.width, bottom.width, top.width, inv(rBL), inv(rTL), [0, -1, 1, 0, box.left, box.bottom]);
    drawEdge(right.color, box.height, right.width, top.width, bottom.width, inv(rTR), inv(rBR), [0, 1, -1, 0, box.right, box.top]);
  }
}
function gradientRenderer(gradient) {
  return function(group, rect) {
    var width = rect.width(), height = rect.height();
    switch (gradient.type) {
      case "linear":
        var angle = gradient.angle != null ? gradient.angle : Math.PI;
        switch (gradient.to) {
          case "top":
            angle = 0;
            break;
          case "left":
            angle = -Math.PI / 2;
            break;
          case "bottom":
            angle = Math.PI;
            break;
          case "right":
            angle = Math.PI / 2;
            break;
          case "top left":
          case "left top":
            angle = -Math.atan2(height, width);
            break;
          case "top right":
          case "right top":
            angle = Math.atan2(height, width);
            break;
          case "bottom left":
          case "left bottom":
            angle = Math.PI + Math.atan2(height, width);
            break;
          case "bottom right":
          case "right bottom":
            angle = Math.PI - Math.atan2(height, width);
            break;
        }
        if (gradient.reverse) {
          angle -= Math.PI;
        }
        angle %= 2 * Math.PI;
        if (angle < 0) {
          angle += 2 * Math.PI;
        }
        var pxlen = Math.abs(width * Math.sin(angle)) + Math.abs(height * Math.cos(angle));
        var scaledAngle = Math.atan(width * Math.tan(angle) / height);
        var sin = Math.sin(scaledAngle), cos = Math.cos(scaledAngle);
        var len = Math.abs(sin) + Math.abs(cos);
        var x = len / 2 * sin;
        var y = len / 2 * cos;
        if (angle > Math.PI / 2 && angle <= 3 * Math.PI / 2) {
          x = -x;
          y = -y;
        }
        var implicit = [], right = 0;
        var stops = gradient.stops.map(function(s, i) {
          var offset = s.percent;
          if (offset) {
            offset = parseFloat(offset) / 100;
          } else if (s.length) {
            offset = parseFloat(s.length) / pxlen;
          } else if (i === 0) {
            offset = 0;
          } else if (i == gradient.stops.length - 1) {
            offset = 1;
          }
          var stop = {
            color: s.color.toCssRgba(),
            offset
          };
          if (offset != null) {
            right = offset;
            implicit.forEach(function(s2, i2) {
              var stop2 = s2.stop;
              stop2.offset = s2.left + (right - s2.left) * (i2 + 1) / (implicit.length + 1);
            });
            implicit = [];
          } else {
            implicit.push({
              left: right,
              stop
            });
          }
          return stop;
        });
        var start = [0.5 - x, 0.5 + y];
        var end = [0.5 + x, 0.5 - y];
        group.append(Path.fromRect(rect).stroke(null).fill(new linear_gradient_default({
          start,
          end,
          stops,
          userSpace: false
        })));
        break;
      case "radial":
        if (window.console && window.console.log) {
          window.console.log("Radial gradients are not yet supported in HTML renderer");
        }
        break;
    }
  };
}
function maybeRenderWidget(element, group) {
  var visual;
  if (element._kendoExportVisual) {
    var rect = element.getBoundingClientRect();
    var size = {
      width: rect.width,
      height: rect.height
    };
    visual = element._kendoExportVisual(size);
  } else if (window.kendo && window.kendo.jQuery && element.getAttribute(window.kendo.attr("role"))) {
    var widget = window.kendo.widgetInstance(window.kendo.jQuery(element));
    if (widget && (widget.exportDOMVisual || widget.exportVisual)) {
      if (widget.exportDOMVisual) {
        visual = widget.exportDOMVisual();
      } else {
        visual = widget.exportVisual();
      }
    }
  }
  if (!visual) {
    return false;
  }
  var wrap2 = new group_default();
  wrap2.children.push(visual);
  var bbox = element.getBoundingClientRect();
  wrap2.transform(transform().translate(bbox.left, bbox.top));
  group.append(wrap2);
  return true;
}
function maybeRenderBullet(element, group) {
  var bulletType = element.getAttribute(KENDO_BULLET_TYPE);
  if (!bulletType) {
    return false;
  }
  var box = element.getBoundingClientRect();
  var color = getComputedStyle2(element).color;
  if (bulletType === "square") {
    var rectSize = box.height / 5;
    group.append(new rect_default2(new rect_default([box.right - rectSize, box.top + box.height / 2.1], [rectSize, rectSize])).fill(color).stroke(color));
  } else {
    var radius = box.height / 7;
    var center = [box.right - radius, box.top + (box.height + radius) / 2];
    var circle = new circle_default2(new circle_default(center, radius));
    if (bulletType === "circle") {
      circle.stroke(color, 0.5);
    } else {
      circle.fill(color).stroke(null);
    }
    group.append(circle);
  }
  return true;
}
function renderImage(element, url, group) {
  var box = getContentBox(element);
  var rect = new rect_default([box.left, box.top], [box.width, box.height]);
  var image = new image_default(url, rect);
  setClipping2(image, elementRoundBox(element, box, "content"));
  group.append(image);
}
function zIndexSort(a, b) {
  var sa = getComputedStyle2(a);
  var sb = getComputedStyle2(b);
  var za = parseFloat(getPropertyValue(sa, "z-index"));
  var zb = parseFloat(getPropertyValue(sb, "z-index"));
  var pa = getPropertyValue(sa, "position");
  var pb = getPropertyValue(sb, "position");
  if (isNaN(za) && isNaN(zb)) {
    if (/static|absolute/.test(pa) && /static|absolute/.test(pb)) {
      return 0;
    }
    if (pa == "static") {
      return -1;
    }
    if (pb == "static") {
      return 1;
    }
    return 0;
  }
  if (isNaN(za)) {
    return zb === 0 ? 0 : zb > 0 ? -1 : 1;
  }
  if (isNaN(zb)) {
    return za === 0 ? 0 : za > 0 ? 1 : -1;
  }
  return parseFloat(za) - parseFloat(zb);
}
function isFormField(element) {
  return /^(?:textarea|select|input)$/i.test(element.tagName);
}
function getSelectedOption(element) {
  if (element.selectedOptions && element.selectedOptions.length > 0) {
    return element.selectedOptions[0];
  }
  return element.options[element.selectedIndex];
}
function renderCheckbox(element, group) {
  var style2 = getComputedStyle2(element);
  var color = getPropertyValue(style2, "color");
  var box = element.getBoundingClientRect();
  if (element.type == "checkbox") {
    group.append(Path.fromRect(new rect_default([box.left + 1, box.top + 1], [box.width - 2, box.height - 2])).stroke(color, 1));
    if (element.checked) {
      group.append(new Path().stroke(color, 1.2).moveTo(box.left + 0.22 * box.width, box.top + 0.55 * box.height).lineTo(box.left + 0.45 * box.width, box.top + 0.75 * box.height).lineTo(box.left + 0.78 * box.width, box.top + 0.22 * box.width));
    }
  } else {
    group.append(new circle_default2(new circle_default([(box.left + box.right) / 2, (box.top + box.bottom) / 2], Math.min(box.width - 2, box.height - 2) / 2)).stroke(color, 1));
    if (element.checked) {
      group.append(new circle_default2(new circle_default([(box.left + box.right) / 2, (box.top + box.bottom) / 2], Math.min(box.width - 8, box.height - 8) / 2)).fill(color).stroke(null));
    }
  }
}
function renderFormField(element, group) {
  var tag = element.tagName.toLowerCase();
  if (tag == "input" && (element.type == "checkbox" || element.type == "radio")) {
    return renderCheckbox(element, group);
  }
  var p = element.parentNode;
  var doc = element.ownerDocument;
  var el = doc.createElement(KENDO_PSEUDO_ELEMENT);
  var option;
  setStyle(el, getCssText(getComputedStyle2(element)));
  if (tag == "input") {
    el.style.whiteSpace = "pre";
  }
  if (tag == "select" || tag == "textarea") {
    el.style.overflow = "auto";
  }
  if (tag == "select") {
    if (element.multiple) {
      for (var i = 0; i < element.options.length; ++i) {
        option = doc.createElement(KENDO_PSEUDO_ELEMENT);
        setStyle(option, getCssText(getComputedStyle2(element.options[i])));
        option.style.display = "block";
        option.textContent = element.options[i].textContent;
        el.appendChild(option);
      }
    } else {
      option = getSelectedOption(element);
      if (option) {
        el.textContent = option.textContent;
      }
    }
  } else {
    el.textContent = element.value;
  }
  p.insertBefore(el, element);
  el.scrollLeft = element.scrollLeft;
  el.scrollTop = element.scrollTop;
  element.style.display = "none";
  renderContents(el, group);
  element.style.display = "";
  p.removeChild(el);
}
function serializeSVG(element) {
  var serializer = new window.XMLSerializer();
  var xml = serializer.serializeToString(element);
  if (browser5.mozilla && !(element.getAttribute("width") && element.getAttribute("height"))) {
    var doc = new window.DOMParser().parseFromString(xml, "image/svg+xml");
    var svg = doc.documentElement;
    var box = getContentBox(element);
    svg.setAttribute("width", box.width);
    svg.setAttribute("height", box.height);
    xml = serializer.serializeToString(svg);
  }
  return xml;
}
function renderContents(element, group) {
  if (nodeInfo._stackingContext.element === element) {
    nodeInfo._stackingContext.group = group;
  }
  switch (element.tagName.toLowerCase()) {
    case "img":
      renderImage(element, element.src, group);
      break;
    case "svg":
      var xml = serializeSVG(element);
      var dataURL = "data:image/svg+xml;base64," + encodeBase64(xml);
      renderImage(element, dataURL, group);
      break;
    case "canvas":
      try {
        renderImage(element, element.toDataURL("image/png"), group);
      } catch (ex) {
      }
      break;
    case "textarea":
    case "input":
    case "select":
      renderFormField(element, group);
      break;
    default:
      var children = [], floats = [], positioned = [];
      for (var i = element.firstChild; i; i = i.nextSibling) {
        switch (i.nodeType) {
          case 3:
            if (/\S/.test(i.data)) {
              renderText(element, i, group);
            }
            break;
          case 1:
            var style2 = getComputedStyle2(i);
            var floating = getPropertyValue(style2, "float");
            var position = getPropertyValue(style2, "position");
            if (position != "static") {
              positioned.push(i);
            } else if (floating != "none") {
              floats.push(i);
            } else {
              children.push(i);
            }
            break;
        }
      }
      mergeSort(children, zIndexSort).forEach(function(el) {
        renderElement(el, group);
      });
      mergeSort(floats, zIndexSort).forEach(function(el) {
        renderElement(el, group);
      });
      mergeSort(positioned, zIndexSort).forEach(function(el) {
        renderElement(el, group);
      });
  }
}
function renderText(element, node, group) {
  if (emptyClipbox()) {
    return;
  }
  var style2 = getComputedStyle2(element);
  if (parseFloat(getPropertyValue(style2, "text-indent")) < -500) {
    return;
  }
  var text = node.data;
  var start = 0;
  var end = text.search(/\S\s*$/) + 1;
  if (!end) {
    return;
  }
  var fontSize = getPropertyValue(style2, "font-size");
  var lineHeight = getPropertyValue(style2, "line-height");
  var font = [
    getPropertyValue(style2, "font-style"),
    getPropertyValue(style2, "font-variant"),
    getPropertyValue(style2, "font-weight"),
    fontSize,
    // no need for line height here; it breaks layout in FF
    getPropertyValue(style2, "font-family")
  ].join(" ");
  fontSize = parseFloat(fontSize);
  lineHeight = parseFloat(lineHeight);
  if (fontSize === 0 || isNaN(fontSize)) {
    return;
  }
  var color = getPropertyValue(style2, "color");
  var range = element.ownerDocument.createRange();
  var align2 = getPropertyValue(style2, "text-align");
  var isJustified = align2 == "justify";
  var columnCount = getPropertyValue(style2, "column-count", 1);
  var whiteSpace = getPropertyValue(style2, "white-space");
  var textTransform = getPropertyValue(style2, "text-transform");
  var estimateLineLength = element.getBoundingClientRect().width / fontSize * 5;
  if (estimateLineLength === 0) {
    estimateLineLength = 500;
  }
  var prevLineBottom = null;
  var underline = nodeInfo["underline"];
  var lineThrough = nodeInfo["line-through"];
  var overline = nodeInfo["overline"];
  var underlineOffset = nodeInfo["underline-offset"];
  if (underline) {
    forEachRect(decorateUnder);
  }
  while (!doChunk()) {
  }
  if (lineThrough || overline) {
    forEachRect(decorateOver);
  }
  return;
  function forEachRect(callback) {
    range.selectNode(node);
    var clientRects = slice2(range.getClientRects());
    forEachRect = function(cb) {
      return clientRects.forEach(cb);
    };
    forEachRect(callback);
  }
  function actuallyGetRangeBoundingRect(range2) {
    if (microsoft || browser5.chrome || browser5.safari) {
      var rectangles = range2.getClientRects(), box = {
        top: Infinity,
        right: -Infinity,
        bottom: -Infinity,
        left: Infinity
      }, done = false;
      for (var i = 0; i < rectangles.length; ++i) {
        var b = rectangles[i];
        if (b.width <= 1 || b.bottom === prevLineBottom) {
          continue;
        }
        box.left = Math.min(b.left, box.left);
        box.top = Math.min(b.top, box.top);
        box.right = Math.max(b.right, box.right);
        box.bottom = Math.max(b.bottom, box.bottom);
        done = true;
      }
      if (!done) {
        return range2.getBoundingClientRect();
      }
      box.width = box.right - box.left;
      box.height = box.bottom - box.top;
      return box;
    }
    return range2.getBoundingClientRect();
  }
  function doChunk() {
    var origStart = start;
    var box, pos = text.substr(start).search(/\S/);
    start += pos;
    if (pos < 0 || start >= end) {
      return true;
    }
    range.setStart(node, start);
    range.setEnd(node, start + 1);
    box = actuallyGetRangeBoundingRect(range);
    var found = false;
    if (isJustified || columnCount > 1) {
      pos = text.substr(start).search(/\s/);
      if (pos >= 0) {
        range.setEnd(node, start + pos);
        var r = actuallyGetRangeBoundingRect(range);
        if (r.bottom == box.bottom) {
          box = r;
          found = true;
          start += pos;
        }
      }
    }
    if (!found) {
      pos = function findEOL(min, eol, max) {
        range.setEnd(node, eol);
        var r2 = actuallyGetRangeBoundingRect(range);
        if (r2.bottom != box.bottom && min < eol) {
          return findEOL(min, min + eol >> 1, eol);
        } else if (r2.right != box.right) {
          box = r2;
          if (eol < max) {
            return findEOL(eol, eol + max >> 1, max);
          } else {
            return eol;
          }
        } else {
          return eol;
        }
      }(start, Math.min(end, start + estimateLineLength), end);
      if (pos == start) {
        return true;
      }
      start = pos;
      pos = range.toString().search(/\s+$/);
      if (pos === 0) {
        return false;
      }
      if (pos > 0) {
        range.setEnd(node, range.startOffset + pos);
        box = actuallyGetRangeBoundingRect(range);
      }
    }
    if (microsoft) {
      box = range.getClientRects()[0];
    }
    var str = range.toString();
    if (!/^(?:pre|pre-wrap)$/i.test(whiteSpace)) {
      str = str.replace(/\s+/g, " ");
    } else if (/\t/.test(str)) {
      var cc = 0;
      for (pos = origStart; pos < range.startOffset; ++pos) {
        var code = text.charCodeAt(pos);
        if (code == 9) {
          cc += 8 - cc % 8;
        } else if (code == 10 || code == 13) {
          cc = 0;
        } else {
          cc++;
        }
      }
      while ((pos = str.search("	")) >= 0) {
        var indent = "        ".substr(0, 8 - (cc + pos) % 8);
        str = str.substr(0, pos) + indent + str.substr(pos + 1);
      }
    }
    if (!found) {
      prevLineBottom = box.bottom;
    }
    drawText2(str, box);
  }
  function drawText2(str, box) {
    if (microsoft && !isNaN(lineHeight)) {
      var height = getFontHeight(font);
      var top = (box.top + box.bottom - height) / 2;
      box = {
        top,
        right: box.right,
        bottom: top + height,
        left: box.left,
        height,
        width: box.right - box.left
      };
    }
    switch (textTransform) {
      case "uppercase":
        str = str.toUpperCase();
        break;
      case "lowercase":
        str = str.toLowerCase();
        break;
      case "capitalize":
        str = str.replace(/(?:^|\s)\S/g, function(l) {
          return l.toUpperCase();
        });
        break;
    }
    var text2 = new TextRect(str, new rect_default([box.left, box.top], [box.width, box.height]), {
      font,
      fill: {
        color
      }
    });
    group.append(text2);
  }
  function drawTextLine(lineWidth, textBox, color2, ypos) {
    if (color2) {
      var path = new Path({
        stroke: {
          width: lineWidth,
          color: color2
        }
      });
      ypos -= lineWidth;
      path.moveTo(textBox.left, ypos).lineTo(textBox.right, ypos);
      group.append(path);
    }
  }
  function decorateOver(box) {
    var width = fontSize / 12;
    drawTextLine(width, box, lineThrough, box.bottom - box.height / 2.7);
    drawTextLine(width, box, overline, box.top);
  }
  function decorateUnder(box) {
    var width = fontSize / 12;
    var underlinePos = box.bottom;
    if (underlineOffset != null) {
      underlinePos += underlineOffset;
    } else {
      underlinePos += width;
    }
    drawTextLine(width, box, underline, underlinePos);
  }
}
function groupInStackingContext(element, group, zIndex) {
  var main;
  if (zIndex != "auto") {
    main = nodeInfo._stackingContext.group;
    zIndex = parseFloat(zIndex);
  } else {
    main = group;
    zIndex = 0;
  }
  var a = main.children;
  for (var i = 0; i < a.length; ++i) {
    if (a[i]._dom_zIndex != null && a[i]._dom_zIndex > zIndex) {
      break;
    }
  }
  var tmp = new group_default();
  main.insert(i, tmp);
  tmp._dom_zIndex = zIndex;
  if (main !== group) {
    if (nodeInfo._clipbox) {
      var m = nodeInfo._matrix.invert();
      var r = nodeInfo._clipbox.transformCopy(m);
      setClipping2(tmp, Path.fromRect(r));
    }
  }
  return tmp;
}
function renderElement(element, container) {
  var style2 = getComputedStyle2(element);
  updateCounters(style2);
  if (/^(style|script|link|meta|iframe|col|colgroup)$/i.test(element.tagName)) {
    return;
  }
  if (nodeInfo._clipbox == null) {
    return;
  }
  var opacity = parseFloat(getPropertyValue(style2, "opacity"));
  var visibility = getPropertyValue(style2, "visibility");
  var display = getPropertyValue(style2, "display");
  if (opacity === 0 || visibility == "hidden" || display == "none") {
    return;
  }
  var tr = getTransform(style2);
  var group;
  var zIndex = getPropertyValue(style2, "z-index");
  if ((tr || opacity < 1) && zIndex == "auto") {
    zIndex = 0;
  }
  group = groupInStackingContext(element, container, zIndex);
  if (opacity < 1) {
    group.opacity(opacity * group.opacity());
  }
  pushNodeInfo(element, style2, group);
  if (!tr) {
    _renderWithPseudoElements(element, group);
  } else {
    saveStyle(element, function() {
      pleaseSetPropertyValue(element.style, "transform", "none", "important");
      pleaseSetPropertyValue(element.style, "transition", "none", "important");
      if (getPropertyValue(style2, "position") == "static") {
        pleaseSetPropertyValue(element.style, "position", "relative", "important");
      }
      var bbox = element.getBoundingClientRect();
      var x = bbox.left + tr.origin[0];
      var y = bbox.top + tr.origin[1];
      var m = [1, 0, 0, 1, -x, -y];
      m = mmul2(m, tr.matrix);
      m = mmul2(m, [1, 0, 0, 1, x, y]);
      m = setTransform(group, m);
      nodeInfo._matrix = nodeInfo._matrix.multiplyCopy(m);
      _renderWithPseudoElements(element, group);
    });
  }
  popNodeInfo();
}
function mmul2(a, b) {
  var a1 = a[0], b1 = a[1], c1 = a[2], d1 = a[3], e1 = a[4], f1 = a[5];
  var a2 = b[0], b2 = b[1], c2 = b[2], d2 = b[3], e2 = b[4], f2 = b[5];
  return [a1 * a2 + b1 * c2, a1 * b2 + b1 * d2, c1 * a2 + d1 * c2, c1 * b2 + d1 * d2, e1 * a2 + f1 * c2 + e2, e1 * b2 + f1 * d2 + f2];
}

// node_modules/@progress/kendo-inputs-common/dist/es/maskedtextbox/parsing/result.js
var ResultType;
(function(ResultType3) {
  ResultType3[ResultType3["Literal"] = 0] = "Literal";
  ResultType3[ResultType3["Mask"] = 1] = "Mask";
  ResultType3[ResultType3["Undefined"] = 2] = "Undefined";
})(ResultType || (ResultType = {}));
var Result = (
  /** @class */
  function() {
    function Result3(value, rest, type) {
      if (type === void 0) {
        type = ResultType.Undefined;
      }
      this.value = value;
      this.rest = rest;
      this.type = type;
    }
    Result3.prototype.map = function(fn) {
      return new Result3(fn(this.value), this.rest);
    };
    Result3.prototype.chain = function(fn) {
      return fn(this.value, this.rest);
    };
    Result3.prototype.fold = function(s, _2) {
      return s(this.value, this.rest);
    };
    Result3.prototype.concat = function(r) {
      return this.map(function(vs, _2) {
        return r.chain(function(v, __) {
          return vs.concat([v]);
        });
      });
    };
    Result3.prototype.toString = function() {
      return "Result({ value: '" + this.value + "', rest: " + this.rest + " })";
    };
    return Result3;
  }()
);

// node_modules/@progress/kendo-inputs-common/dist/es/maskedtextbox/parsing/stream.js
var Stream = (
  /** @class */
  function() {
    function Stream3(input, control) {
      if (input === void 0) {
        input = [];
      }
      if (control === void 0) {
        control = [];
      }
      this.input = input;
      this.control = control;
      this.inputCursor = 0;
      this.controlCursor = 0;
    }
    Stream3.prototype.eof = function() {
      return this.inputCursor >= this.input.length;
    };
    Stream3.prototype.next = function() {
      return {
        char: this.input[this.inputCursor++],
        control: this.control[this.controlCursor++]
      };
    };
    Stream3.prototype.peek = function() {
      return {
        char: this.input[this.inputCursor],
        control: this.control[this.controlCursor]
      };
    };
    Stream3.prototype.eat_input = function() {
      this.inputCursor++;
    };
    Stream3.prototype.eat_control = function() {
      this.controlCursor++;
    };
    Stream3.prototype.eat = function() {
      this.inputCursor++;
      this.controlCursor++;
    };
    return Stream3;
  }()
);

// node_modules/@progress/kendo-inputs-common/dist/es/maskedtextbox/parsing/parsers.js
var toArray2 = function(value) {
  return (value || "").split("");
};
var ESCAPE_CHARACTER = "\\";
var Parser = (
  /** @class */
  function() {
    function Parser3(parse3) {
      this.parse = parse3;
    }
    Parser3.prototype.run = function(input, control) {
      if (control === void 0) {
        control = "";
      }
      if (input instanceof Stream) {
        return this.parse(input);
      } else {
        return this.parse(new Stream(toArray2(input), toArray2(control)));
      }
    };
    Parser3.prototype.map = function(f) {
      var _this = this;
      return new Parser3(function(stream2) {
        return _this.parse(stream2).map(f);
      });
    };
    Parser3.prototype.chain = function(f) {
      var _this = this;
      return new Parser3(function(stream2) {
        return _this.parse(stream2).chain(function(v, s) {
          return f(v).run(s);
        });
      });
    };
    Parser3.prototype.isLiteral = function(c) {
      return this.run(c).type === ResultType.Literal;
    };
    return Parser3;
  }()
);
var mask = function(_a2) {
  var prompt = _a2.prompt, promptPlaceholder = _a2.promptPlaceholder;
  return function(rule) {
    return new Parser(function(stream2) {
      while (!stream2.eof()) {
        var _a3 = stream2.peek(), char = _a3.char, control = _a3.control;
        if (char === control && control === prompt) {
          stream2.eat();
          return new Result(prompt, stream2, ResultType.Mask);
        }
        if (rule.test(char)) {
          stream2.eat();
          return new Result(char, stream2, ResultType.Mask);
        }
        if (char === promptPlaceholder) {
          stream2.eat();
          return new Result(prompt, stream2, ResultType.Mask);
        }
        stream2.eat_input();
      }
      stream2.eat();
      return new Result(prompt, stream2, ResultType.Mask);
    });
  };
};
var literal = function(_token) {
  return new Parser(function(stream2) {
    var char = stream2.peek().char;
    if (char === _token) {
      stream2.eat();
      return new Result(_token, stream2, ResultType.Literal);
    }
    return new Result(_token, stream2, ResultType.Literal);
  });
};
var unmask = function(prompt) {
  return function(rule) {
    return new Parser(function(stream2) {
      while (!stream2.eof()) {
        var _a2 = stream2.peek(), char = _a2.char, control = _a2.control;
        if (char === prompt && control === prompt) {
          stream2.eat();
          return new Result(char, stream2);
        }
        if (rule.test(char)) {
          stream2.eat();
          return new Result(char, stream2);
        }
        stream2.eat_input();
      }
      stream2.eat();
      return new Result("", stream2);
    });
  };
};
var unliteral = function(_token) {
  return new Parser(function(stream2) {
    if (stream2.eof()) {
      return new Result("", stream2);
    }
    var char = stream2.peek().char;
    if (char === _token) {
      stream2.eat();
    }
    return new Result(_token, stream2);
  });
};
var token = function(rules, creator) {
  return new Parser(function(stream2) {
    var char = stream2.next().char;
    var rule = rules[char];
    if (char === ESCAPE_CHARACTER) {
      char = stream2.next().char;
      return new Result(creator.literal(char), stream2);
    }
    if (!rule) {
      return new Result(creator.literal(char), stream2);
    }
    return new Result(creator.mask(rule), stream2);
  });
};
var rawMask = function(_a2) {
  var prompt = _a2.prompt, promptPlaceholder = _a2.promptPlaceholder;
  return new Parser(function(stream2) {
    var char = stream2.next().char;
    if (char === prompt) {
      return new Result(promptPlaceholder, stream2);
    }
    return new Result(char, stream2);
  });
};
var rawLiteral = function(includeLiterals) {
  return new Parser(function(stream2) {
    var char = stream2.next().char;
    if (includeLiterals) {
      return new Result(char, stream2);
    }
    return new Result("", stream2);
  });
};

// node_modules/@progress/kendo-inputs-common/dist/es/maskedtextbox/parsing/combinators.js
var always = function(value) {
  return new Parser(function(stream2) {
    return new Result(value, stream2);
  });
};
var append2 = function(p1, p2) {
  return p1.chain(function(vs) {
    return p2.map(function(v) {
      return vs.concat([v]);
    });
  });
};
var sequence = function(list) {
  return list.reduce(function(acc, parser) {
    return append2(acc, parser);
  }, always([]));
};
var greedy = function(parser) {
  return new Parser(function(stream2) {
    var result = new Result([], stream2);
    while (!stream2.eof()) {
      result = result.concat(parser.run(stream2));
    }
    return result;
  });
};

// node_modules/@progress/kendo-inputs-common/dist/es/maskedtextbox/masking.service.js
var MaskingService = (
  /** @class */
  function() {
    function MaskingService3() {
      this.rules = {};
      this.prompt = "_";
      this.mask = "";
      this.promptPlaceholder = " ";
      this.includeLiterals = false;
      this.maskTokens = [];
      this.unmaskTokens = [];
      this.rawTokens = [];
      this.validationTokens = [];
    }
    MaskingService3.prototype.update = function(_a2) {
      var _b = _a2.mask, mask3 = _b === void 0 ? "" : _b, _c = _a2.prompt, prompt = _c === void 0 ? "" : _c, _d = _a2.promptPlaceholder, promptPlaceholder = _d === void 0 ? " " : _d, _e = _a2.rules, rules = _e === void 0 ? {} : _e, _f = _a2.includeLiterals, includeLiterals = _f === void 0 ? false : _f;
      this.mask = mask3;
      this.prompt = prompt;
      this.promptPlaceholder = promptPlaceholder;
      this.rules = rules;
      this.includeLiterals = includeLiterals;
      this.tokenize();
    };
    MaskingService3.prototype.validationValue = function(maskedValue) {
      if (maskedValue === void 0) {
        maskedValue = "";
      }
      var value = maskedValue;
      sequence(this.validationTokens).run(maskedValue).fold(function(unmasked) {
        value = unmasked.join("");
      });
      return value;
    };
    MaskingService3.prototype.rawValue = function(maskedValue) {
      if (maskedValue === void 0) {
        maskedValue = "";
      }
      var value = maskedValue;
      if (!this.rawTokens.length) {
        return value;
      }
      sequence(this.rawTokens).run(maskedValue).fold(function(unmasked) {
        value = unmasked.join("");
      });
      return value;
    };
    MaskingService3.prototype.maskRaw = function(rawValue) {
      if (rawValue === void 0) {
        rawValue = "";
      }
      var value = rawValue;
      if (!this.maskTokens.length) {
        return value;
      }
      sequence(this.maskTokens).run(rawValue).fold(function(masked) {
        value = masked.join("");
      });
      return value;
    };
    MaskingService3.prototype.maskInput = function(input, control, splitPoint) {
      if (input.length < control.length) {
        return this.maskRemoved(input, control, splitPoint);
      }
      return this.maskInserted(input, control, splitPoint);
    };
    MaskingService3.prototype.maskInRange = function(pasted, oldValue, start, end) {
      var value = "";
      var selection = end;
      var beforeChange = oldValue.split("").slice(0, start);
      var afterChange = oldValue.split("").slice(end);
      sequence(this.maskTokens.slice(start, end)).run(pasted).fold(function(masked) {
        value = beforeChange.concat(masked).concat(afterChange).join("");
      });
      return {
        selection,
        value
      };
    };
    MaskingService3.prototype.maskRemoved = function(input, control, splitPoint) {
      var _this = this;
      var value = "";
      var selection = splitPoint;
      var unchanged = input.split("").slice(splitPoint);
      var changed = input.split("").slice(0, splitPoint).join("");
      var take2 = this.maskTokens.length - (input.length - splitPoint);
      sequence(this.maskTokens.slice(0, take2)).run(changed, control).fold(function(masked) {
        selection = _this.adjustPosition(masked, selection);
        value = masked.concat(unchanged).join("");
      });
      return {
        selection,
        value
      };
    };
    MaskingService3.prototype.adjustPosition = function(input, selection) {
      var caretChar = input[selection];
      var isLiteral = this.maskTokens[selection].isLiteral(caretChar);
      if (!isLiteral && caretChar !== this.prompt) {
        return selection + 1;
      }
      return selection;
    };
    MaskingService3.prototype.maskInserted = function(input, control, splitPoint) {
      var _this = this;
      var value = "";
      var selection = splitPoint;
      var changed = input.slice(0, splitPoint);
      sequence(this.unmaskTokens).run(changed, control).chain(function(unmasked) {
        selection = unmasked.join("").length;
        var unchanged = control.slice(selection);
        return sequence(_this.maskTokens).run(unmasked.join("") + unchanged, control);
      }).fold(function(masked) {
        value = masked.join("");
      });
      return {
        selection,
        value
      };
    };
    Object.defineProperty(MaskingService3.prototype, "maskTokenCreator", {
      get: function() {
        var _a2 = this, prompt = _a2.prompt, promptPlaceholder = _a2.promptPlaceholder;
        return {
          literal: function(rule) {
            return literal(rule);
          },
          mask: function(rule) {
            return mask({
              prompt,
              promptPlaceholder
            })(rule);
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MaskingService3.prototype, "unmaskTokenCreator", {
      get: function() {
        var _this = this;
        return {
          literal: function(rule) {
            return unliteral(rule);
          },
          mask: function(rule) {
            return unmask(_this.prompt)(rule);
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MaskingService3.prototype, "rawTokenCreator", {
      get: function() {
        var _a2 = this, prompt = _a2.prompt, promptPlaceholder = _a2.promptPlaceholder, includeLiterals = _a2.includeLiterals;
        return {
          literal: function(_2) {
            return rawLiteral(includeLiterals);
          },
          mask: function(_2) {
            return rawMask({
              prompt,
              promptPlaceholder
            });
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MaskingService3.prototype, "validationTokenCreator", {
      get: function() {
        var prompt = this.prompt;
        return {
          literal: function(_2) {
            return rawLiteral(false);
          },
          mask: function(_2) {
            return rawMask({
              prompt,
              promptPlaceholder: ""
            });
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MaskingService3.prototype.tokenize = function() {
      var _this = this;
      greedy(token(this.rules, this.maskTokenCreator)).run(this.mask).fold(function(tokens, _2) {
        _this.maskTokens = tokens;
      });
      greedy(token(this.rules, this.unmaskTokenCreator)).run(this.mask).fold(function(tokens, _2) {
        _this.unmaskTokens = tokens;
      });
      greedy(token(this.rules, this.rawTokenCreator)).run(this.mask).fold(function(tokens, _2) {
        _this.rawTokens = tokens;
      });
      greedy(token(this.rules, this.validationTokenCreator)).run(this.mask).fold(function(tokens, _2) {
        _this.validationTokens = tokens;
      });
    };
    return MaskingService3;
  }()
);

// node_modules/@progress/kendo-inputs-common/dist/es/common/drawing-utils.js
var _a = drawing_exports.util;
var elementOffset2 = _a.elementOffset;
var limitValue2 = _a.limitValue;

// node_modules/@progress/kendo-inputs-common/dist/es/signature/signature-pad.js
var Point2 = geometry_exports.Point;
var Rect3 = geometry_exports.Rect;
var transform2 = geometry_exports.transform;
var noop3 = function() {
};
var DECIMAL_DIGITS = 3;
var DEFAULT_COLOR = "#000";
var DEFAULT_BACKGROUND_COLOR = "#fff";
var DEFAULT_PRECISION = 1;
var DEFAULT_SAMPLING_RATE = 200;
var DEFAULT_STROKE_WIDTH = 1;
var DEFAULT_WIDTH = 750;
var DEFAULT_HEIGHT = 250;
var DEFAULT_SCALE = 1;
var DEFAULT_EXPORT_SCALE = 6;
var SignaturePad = (
  /** @class */
  function() {
    function SignaturePad2(element, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      this.element = element;
      this.lastMoveTime = 0;
      this.resolveColors(options2);
      this.options = Object.assign({
        scale: DEFAULT_SCALE,
        precision: DEFAULT_PRECISION,
        samplingRate: DEFAULT_SAMPLING_RATE,
        smooth: options2.smooth !== false,
        color: DEFAULT_COLOR,
        backgroundColor: DEFAULT_BACKGROUND_COLOR,
        strokeWidth: DEFAULT_STROKE_WIDTH,
        onChange: noop3,
        onDraw: noop3,
        onDrawEnd: noop3
      }, options2, {
        color: this.color,
        backgroundColor: this.backgroundColor
      });
      this.pathOptions = {
        stroke: {
          color: this.options.color,
          width: this.options.strokeWidth,
          lineCap: "round",
          lineJoin: "round"
        }
      };
      this.initSurface();
      this.attachEvents();
    }
    SignaturePad2.prototype.destroy = function() {
      this.detachEvents();
    };
    SignaturePad2.prototype.clear = function() {
      this.rootGroup.clear();
      this.path = null;
    };
    SignaturePad2.prototype.readThemeColors = function() {
      var themeColor;
      var themeBackgroundColor;
      if (typeof document !== "undefined") {
        var themeElement = this.element.closest(".k-signature") || this.element;
        var computedStyle = themeElement.ownerDocument.defaultView.getComputedStyle(themeElement);
        themeColor = computedStyle.color;
        themeBackgroundColor = computedStyle.backgroundColor;
      }
      this.themeColor = themeColor || this.themeColor || DEFAULT_COLOR;
      this.themeBackgroundColor = themeBackgroundColor || this.themeBackgroundColor || DEFAULT_BACKGROUND_COLOR;
    };
    SignaturePad2.prototype.resolveColors = function(options2) {
      this.readThemeColors();
      this.color = options2.color || (this.options || {}).color || this.themeColor;
      this.backgroundColor = options2.backgroundColor || (this.options || {}).backgroundColor || this.themeBackgroundColor;
    };
    Object.defineProperty(SignaturePad2.prototype, "isDrawing", {
      get: function() {
        return Boolean(this.points);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SignaturePad2.prototype, "pathData", {
      get: function() {
        var _a2;
        return (_a2 = this.path) === null || _a2 === void 0 ? void 0 : _a2.toString(DECIMAL_DIGITS);
      },
      set: function(value) {
        this.clear();
        this.path = MultiPath.parse(value, this.pathOptions);
        this.rootGroup.append(this.path);
      },
      enumerable: false,
      configurable: true
    });
    SignaturePad2.prototype.loadImage = function(data, size) {
      if (size === void 0) {
        size = [];
      }
      if (!data) {
        this.clear();
        return;
      }
      var _a2 = this.size, width = _a2[0], height = _a2[1];
      var contentWidth = width / this.options.scale;
      var contentHeight = height / this.options.scale;
      var importWidth = size[0] || contentWidth * DEFAULT_EXPORT_SCALE;
      var importHeight = size[1] || contentHeight * DEFAULT_EXPORT_SCALE;
      var scaleX = contentWidth / importWidth;
      var scaleY = contentHeight / importHeight;
      var scale = Math.min(scaleX, scaleY);
      var img = new image_default(data, new geometry_exports.Rect([0, 0], [importWidth, importHeight]));
      img.transform(transform2().scale(scale, scale));
      this.clear();
      this.rootGroup.append(img);
    };
    SignaturePad2.prototype.exportImage = function(options2) {
      var _a2;
      var _b = this.size, width = _b[0], height = _b[1];
      var contentWidth = width / this.options.scale;
      var contentHeight = height / this.options.scale;
      var exportWidth = (options2 === null || options2 === void 0 ? void 0 : options2.width) || contentWidth * DEFAULT_EXPORT_SCALE;
      var exportHeight = (options2 === null || options2 === void 0 ? void 0 : options2.height) || contentHeight * DEFAULT_EXPORT_SCALE;
      var scaleX = exportWidth / contentWidth;
      var scaleY = exportHeight / contentHeight;
      var scale = Math.min(scaleX, scaleY);
      var exportRect = new Rect3([0, 0], [exportWidth, exportHeight]);
      var exportGroup2 = new group_default({
        clip: Path.fromRect(exportRect)
      });
      var contentGroup = new group_default({
        transform: transform2().scale(scale, scale)
      });
      var frame = Path.fromRect(exportRect, {
        fill: {
          color: this.options.backgroundColor
        }
      });
      exportGroup2.append(frame);
      exportGroup2.append(contentGroup);
      (_a2 = contentGroup.children).push.apply(_a2, this.rootGroup.children);
      return exportImage(exportGroup2, Object.assign({
        width: exportWidth,
        height: exportHeight
      }, options2));
    };
    SignaturePad2.prototype.resize = function() {
      this.surface.resize(true);
    };
    SignaturePad2.prototype.setOptions = function(options2) {
      this.resolveColors(options2);
      Object.assign(this.options, options2, {
        color: this.color,
        backgroundColor: this.backgroundColor
      });
      this.pathOptions.stroke.color = this.options.color;
      this.pathOptions.stroke.width = this.options.strokeWidth;
      if (this.path) {
        this.path.options.set("stroke.color", this.options.color);
        this.path.options.set("stroke.width", this.options.strokeWidth);
      }
      this.background.options.set("fill.color", this.options.backgroundColor);
    };
    SignaturePad2.prototype.initSurface = function() {
      this.surface = surface_default4.create(this.element, {
        type: "canvas"
      });
      this.element.style.touchAction = "none";
      var scale = this.options.scale;
      this.rootGroup = new group_default({
        transform: transform2().scale(scale, scale)
      });
      var width = this.element.offsetWidth || DEFAULT_WIDTH;
      var height = this.element.offsetHeight || DEFAULT_HEIGHT;
      this.size = [width, height];
      this.background = Path.fromRect(new Rect3([0, 0], this.size), {
        fill: {
          color: this.options.backgroundColor
        }
      });
      this.surface.draw(this.background);
      this.surface.draw(this.rootGroup);
    };
    SignaturePad2.prototype.attachEvents = function() {
      this.onPointerDown = this.onPointerDown.bind(this);
      this.onPointerMove = this.onPointerMove.bind(this);
      this.onPointerUp = this.onPointerUp.bind(this);
      this.onDragStart = this.onDragStart.bind(this);
      this.element.addEventListener("pointerdown", this.onPointerDown);
      this.element.addEventListener("pointerup", this.onPointerUp);
      this.element.addEventListener("dragstart", this.onDragStart);
    };
    SignaturePad2.prototype.detachEvents = function() {
      this.element.removeEventListener("pointerdown", this.onPointerDown);
      this.detachPointerMove();
      this.element.removeEventListener("pointerup", this.onPointerUp);
      this.element.removeEventListener("dragstart", this.onDragStart);
    };
    SignaturePad2.prototype.attachPointerMove = function() {
      this.element.addEventListener("pointermove", this.onPointerMove);
    };
    SignaturePad2.prototype.detachPointerMove = function() {
      this.element.removeEventListener("pointermove", this.onPointerMove);
    };
    SignaturePad2.prototype.touchPoint = function(e) {
      var offset = elementOffset2(this.element);
      var pageX = e.pageX;
      var pageY = e.pageY;
      var scale = 1 / this.options.scale;
      return new Point2(pageX - offset.left, pageY - offset.top).scale(scale, scale);
    };
    SignaturePad2.prototype.onDragStart = function(e) {
      e.preventDefault();
    };
    SignaturePad2.prototype.onPointerDown = function(e) {
      if (this.options.readonly || !e.isPrimary || !isMainButton(e)) {
        return;
      }
      this.detachPointerMove();
      this.attachPointerMove();
      if (!this.path) {
        this.path = new MultiPath(this.pathOptions);
        this.rootGroup.append(this.path);
      }
      this.options.onDraw();
      this.element.setPointerCapture(e.pointerId);
      var point2 = this.touchPoint(e);
      this.points = [point2];
      this.path.moveTo(point2);
    };
    SignaturePad2.prototype.onPointerMove = function(e) {
      if (!this.points || !this.path || !e.isPrimary) {
        return;
      }
      var now2 = (/* @__PURE__ */ new Date()).getTime();
      var elapsed = now2 - this.lastMoveTime;
      var minTimeDelta = 1e3 / limitValue2(this.options.samplingRate, 1, 1e4);
      if (elapsed < minTimeDelta) {
        return;
      } else {
        this.lastMoveTime = now2;
      }
      var point2 = this.touchPoint(e);
      var lastPoint = this.points[this.points.length - 1];
      var minDelta = 1 / limitValue2(this.options.precision, 0.01, 100);
      if (point2.distanceTo(lastPoint) < minDelta) {
        return;
      }
      this.points.push(point2);
      this.path.lineTo(point2);
    };
    SignaturePad2.prototype.onPointerUp = function(e) {
      if (!e.isPrimary || !this.path || !this.points || this.options.readonly) {
        return;
      }
      this.detachPointerMove();
      if (this.options.smooth) {
        var segments = Path.curveFromPoints(this.points);
        this.path.paths.splice(this.path.paths.length - 1, 1, segments);
      }
      this.points = null;
      this.options.onDrawEnd();
      this.options.onChange(this.pathData);
    };
    return SignaturePad2;
  }()
);
function isMainButton(e) {
  return typeof e.button !== "number" || e.button === 0;
}

// node_modules/@progress/kendo-angular-dialog/fesm2022/progress-kendo-angular-dialog.mjs
var _c03 = ["*"];
function DialogActionsComponent_ng_content_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 0, ["*ngIf", "!actions"]);
  }
}
function DialogActionsComponent_ng_container_1_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "span", 6);
    ɵɵelementContainerEnd();
  }
}
function DialogActionsComponent_ng_container_1_ng_container_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 7);
    ɵɵlistener("click", function DialogActionsComponent_ng_container_1_ng_container_1_ng_template_2_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r1);
      const action_r2 = ɵɵnextContext().$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onButtonClick(action_r2, $event));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const action_r2 = ɵɵnextContext().$implicit;
    ɵɵproperty("disabled", action_r2.disabled)("fillMode", action_r2.fillMode)("themeColor", action_r2.themeColor)("ngClass", action_r2.cssClass)("svgIcon", action_r2.svgIcon)("icon", action_r2.icon);
    ɵɵattribute("aria-label", action_r2.text);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", action_r2.text, " ");
  }
}
function DialogActionsComponent_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, DialogActionsComponent_ng_container_1_ng_container_1_ng_container_1_Template, 2, 0, "ng-container", 3)(2, DialogActionsComponent_ng_container_1_ng_container_1_ng_template_2_Template, 2, 8, "ng-template", null, 1, ɵɵtemplateRefExtractor);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const action_r2 = ctx.$implicit;
    const defaultAction_r4 = ɵɵreference(3);
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.isDivider(action_r2))("ngIfElse", defaultAction_r4);
  }
}
function DialogActionsComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, DialogActionsComponent_ng_container_1_ng_container_1_Template, 4, 2, "ng-container", 5);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2.actionsArray);
  }
}
function DialogActionsComponent_ng_template_2_Template(rf, ctx) {
}
var _c16 = ["dialog"];
var _c22 = [[["kendo-dialog-titlebar"]], "*", [["kendo-dialog-actions"]]];
var _c32 = ["kendo-dialog-titlebar", "*", "kendo-dialog-actions"];
function DialogComponent_kendo_dialog_titlebar_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-dialog-titlebar", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("closeTitle", ctx_r0.closeTitle)("id", ctx_r0.titleId);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.title);
  }
}
function DialogComponent_ng_content_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 0, ["*ngIf", "!title"]);
  }
}
function DialogComponent_ng_content_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 1, ["*ngIf", "!contentTemplate"]);
  }
}
function DialogComponent_8_ng_template_0_Template(rf, ctx) {
}
function DialogComponent_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DialogComponent_8_ng_template_0_Template, 0, 0, "ng-template", 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.contentTemplate);
  }
}
function DialogComponent_ng_content_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "!actions"]);
  }
}
function DialogComponent_kendo_dialog_actions_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-dialog-actions", 11);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("actions", ctx_r0.actions)("layout", ctx_r0.actionsLayout);
  }
}
function DialogComponent_div_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 12);
  }
}
var _c42 = (a0) => ({
  "$implicit": a0
});
function WindowTitleBarComponent_ng_content_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 0, ["*ngIf", "!template"]);
  }
}
function WindowTitleBarComponent_1_ng_template_0_Template(rf, ctx) {
}
function WindowTitleBarComponent_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, WindowTitleBarComponent_1_ng_template_0_Template, 0, 0, "ng-template", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.template)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c42, ctx_r0.service));
  }
}
var _c52 = ["kendoWindowCloseAction", ""];
function WindowCloseActionDirective_kendo_icon_wrapper_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r0.xIcon);
  }
}
function WindowCloseActionDirective_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵelement(1, "img", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function WindowCloseActionDirective_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c62 = ["kendoWindowRestoreAction", ""];
function WindowRestoreActionDirective_kendo_icon_wrapper_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r0.windowRestoreIcon);
  }
}
function WindowRestoreActionDirective_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵelement(1, "img", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function WindowRestoreActionDirective_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c72 = ["kendoWindowMaximizeAction", ""];
function WindowMaximizeActionDirective_kendo_icon_wrapper_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r0.windowIcon);
  }
}
function WindowMaximizeActionDirective_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵelement(1, "img", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function WindowMaximizeActionDirective_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c82 = ["kendoWindowMinimizeAction", ""];
function WindowMinimizeActionDirective_kendo_icon_wrapper_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r0.windowMinimizeIcon);
  }
}
function WindowMinimizeActionDirective_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵelement(1, "img", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function WindowMinimizeActionDirective_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c92 = [[["kendo-window-titlebar"]], "*"];
var _c102 = ["kendo-window-titlebar", "*"];
function WindowComponent_kendo_window_titlebar_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-window-titlebar", 6)(1, "span", 7);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "div", 8);
    ɵɵelement(4, "button", 9)(5, "button", 10)(6, "button", 11)(7, "button", 12);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("template", ctx_r0.titleBarTemplate)("id", ctx_r0.titleId);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.title);
    ɵɵadvance(2);
    ɵɵattribute("title", ctx_r0.minimizeButtonTitle)("aria-label", ctx_r0.minimizeButtonTitle);
    ɵɵadvance();
    ɵɵattribute("title", ctx_r0.maximizeButtonTitle)("aria-label", ctx_r0.maximizeButtonTitle);
    ɵɵadvance();
    ɵɵattribute("title", ctx_r0.restoreButtonTitle)("aria-label", ctx_r0.restoreButtonTitle);
    ɵɵadvance();
    ɵɵattribute("title", ctx_r0.closeButtonTitle)("aria-label", ctx_r0.closeButtonTitle);
  }
}
function WindowComponent_ng_content_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 0, ["*ngIf", "!showDefaultTitleBar"]);
  }
}
function WindowComponent_div_4_ng_content_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 1, ["*ngIf", "!contentTemplate"]);
  }
}
function WindowComponent_div_4_2_ng_template_0_Template(rf, ctx) {
}
function WindowComponent_div_4_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, WindowComponent_div_4_2_ng_template_0_Template, 0, 0, "ng-template", 14);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.contentTemplate);
  }
}
function WindowComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 13);
    ɵɵtemplate(1, WindowComponent_div_4_ng_content_1_Template, 1, 0, "ng-content", 2)(2, WindowComponent_div_4_2_Template, 1, 1, null, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("hidden", ctx_r0.state === "minimized" && ctx_r0.keepContent);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.contentTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.contentTemplate);
  }
}
function WindowComponent_ng_template_5_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 16);
  }
  if (rf & 2) {
    const dir_r2 = ctx.$implicit;
    ɵɵproperty("direction", dir_r2);
  }
}
function WindowComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, WindowComponent_ng_template_5_div_0_Template, 1, 1, "div", 15);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngForOf", ctx_r0.resizeDirections);
  }
}
function WindowComponent_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 17);
  }
}
var DialogActionsComponent = class _DialogActionsComponent {
  el;
  /**
   * Allows the declarative specification of the actions.
   */
  set actions(value) {
    if (value instanceof TemplateRef) {
      this.actionsTemplate = value;
    } else if (Array.isArray(value)) {
      this.actionsArray = value;
    } else {
      throw new Error('"actions" must be either TemplateRef or DialogAction[] instance.');
    }
  }
  /**
   * @hidden
   */
  actionsArray;
  /**
   * @hidden
   */
  actionsTemplate;
  /**
   * Specifies the possible layout of the action buttons.
   * @default 'stretched'
   */
  layout = "stretched";
  /**
   * Fires when the user clicks an action button.
   */
  action = new EventEmitter();
  hostClasses = true;
  get startClassName() {
    return this.layout === "start";
  }
  get centerClassName() {
    return this.layout === "center";
  }
  get endClassName() {
    return this.layout === "end";
  }
  get stretchedClassName() {
    return this.layout === "stretched";
  }
  constructor(el) {
    this.el = el;
  }
  /**
   * @hidden
   */
  onButtonClick(action, _e) {
    this.action.emit(action);
  }
  /**
   * @hidden
   */
  isDivider(action) {
    return action === "spacer";
  }
  static ɵfac = function DialogActionsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DialogActionsComponent)(ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DialogActionsComponent,
    selectors: [["kendo-dialog-actions"]],
    hostVars: 16,
    hostBindings: function DialogActionsComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-actions", ctx.hostClasses)("k-actions-horizontal", ctx.hostClasses)("k-window-actions", ctx.hostClasses)("k-dialog-actions", ctx.hostClasses)("k-actions-start", ctx.startClassName)("k-actions-center", ctx.centerClassName)("k-actions-end", ctx.endClassName)("k-actions-stretched", ctx.stretchedClassName);
      }
    },
    inputs: {
      actions: "actions",
      layout: "layout"
    },
    outputs: {
      action: "action"
    },
    ngContentSelectors: _c03,
    decls: 4,
    vars: 4,
    consts: [["actionTemplate", ""], ["defaultAction", ""], [4, "ngIf"], [4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet"], [4, "ngFor", "ngForOf"], [1, "k-spacer"], ["type", "button", "kendoButton", "", 3, "click", "disabled", "fillMode", "themeColor", "ngClass", "svgIcon", "icon"]],
    template: function DialogActionsComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, DialogActionsComponent_ng_content_0_Template, 1, 0, "ng-content", 2)(1, DialogActionsComponent_ng_container_1_Template, 2, 1, "ng-container", 3)(2, DialogActionsComponent_ng_template_2_Template, 0, 0, "ng-template", 4, 0, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const actionTemplate_r5 = ɵɵreference(3);
        ɵɵproperty("ngIf", !ctx.actions);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.actionsArray)("ngIfElse", actionTemplate_r5);
        ɵɵadvance();
        ɵɵproperty("ngTemplateOutlet", ctx.actionsTemplate);
      }
    },
    dependencies: [NgIf, NgForOf, NgClass, NgTemplateOutlet, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DialogActionsComponent, [{
    type: Component,
    args: [{
      selector: "kendo-dialog-actions",
      template: `
        <ng-content *ngIf="!actions"></ng-content>
        <ng-container *ngIf="actionsArray; else actionTemplate">
            <ng-container *ngFor="let action of actionsArray">
                <ng-container *ngIf="isDivider(action); else defaultAction">
                    <span class="k-spacer"></span>
                </ng-container>
                <ng-template #defaultAction>
                    <button
                        type="button"
                        kendoButton
                        [disabled]="action.disabled"
                        [fillMode]="action.fillMode"
                        [themeColor]="action.themeColor"
                        [ngClass]="action.cssClass"
                        (click)="onButtonClick(action, $event)"
                        [attr.aria-label]="action.text"
                        [svgIcon]="action.svgIcon"
                        [icon]="action.icon"
                    >
                        {{ action.text }}
                    </button>
                </ng-template>
            </ng-container>
        </ng-container>
        <ng-template #actionTemplate [ngTemplateOutlet]="actionsTemplate"></ng-template>
    `,
      standalone: true,
      imports: [NgIf, NgForOf, NgClass, NgTemplateOutlet, KENDO_BUTTON]
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    actions: [{
      type: Input
    }],
    layout: [{
      type: Input
    }],
    action: [{
      type: Output
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-actions"]
    }, {
      type: HostBinding,
      args: ["class.k-actions-horizontal"]
    }, {
      type: HostBinding,
      args: ["class.k-window-actions"]
    }, {
      type: HostBinding,
      args: ["class.k-dialog-actions"]
    }],
    startClassName: [{
      type: HostBinding,
      args: ["class.k-actions-start"]
    }],
    centerClassName: [{
      type: HostBinding,
      args: ["class.k-actions-center"]
    }],
    endClassName: [{
      type: HostBinding,
      args: ["class.k-actions-end"]
    }],
    stretchedClassName: [{
      type: HostBinding,
      args: ["class.k-actions-stretched"]
    }]
  });
})();
var PreventableEvent3 = class {
  prevented = false;
  /**
   * @hidden
   */
  constructor() {
  }
  /**
   * Prevents the default action for a specified event.
   * In this way, the source component suppresses the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * If the event is prevented by any of its subscribers, returns `true`.
   *
   * @returns `true` if the default action was prevented. Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
};
var DIALOG_LOCALIZATION_SERVICE = new InjectionToken("Dialog LocalizationService");
var TitleBarLocalizationService = class _TitleBarLocalizationService extends LocalizationService {
  dialogLocalization;
  constructor(prefix, messageService, rtl, dialogLocalization) {
    super(prefix, messageService, rtl);
    this.dialogLocalization = dialogLocalization;
  }
  get(shortKey) {
    if (this.dialogLocalization) {
      return this.dialogLocalization.get(shortKey);
    }
    return super.get(shortKey);
  }
  static ɵfac = function TitleBarLocalizationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TitleBarLocalizationService)(ɵɵinject(L10N_PREFIX), ɵɵinject(MessageService, 8), ɵɵinject(RTL, 8), ɵɵinject(DIALOG_LOCALIZATION_SERVICE, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _TitleBarLocalizationService,
    factory: _TitleBarLocalizationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TitleBarLocalizationService, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [L10N_PREFIX]
      }]
    }, {
      type: MessageService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [RTL]
      }]
    }, {
      type: LocalizationService,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [DIALOG_LOCALIZATION_SERVICE]
      }]
    }];
  }, null);
})();
var Messages = class _Messages extends ComponentMessages {
  /**
   * The title of the close button.
   */
  closeTitle;
  /**
   * The title of the restore button.
   */
  restoreTitle;
  /**
   * The title of the maximize button.
   */
  maximizeTitle;
  /**
   * The title of the minimize button.
   */
  minimizeTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMessages_BaseFactory;
    return function Messages_Factory(__ngFactoryType__) {
      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵɵgetInheritedFactory(_Messages)))(__ngFactoryType__ || _Messages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _Messages,
    selectors: [["kendo-dialog-messages-base"]],
    inputs: {
      closeTitle: "closeTitle",
      restoreTitle: "restoreTitle",
      maximizeTitle: "maximizeTitle",
      minimizeTitle: "minimizeTitle"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Messages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-dialog-messages-base"
    }]
  }], null, {
    closeTitle: [{
      type: Input
    }],
    restoreTitle: [{
      type: Input
    }],
    maximizeTitle: [{
      type: Input
    }],
    minimizeTitle: [{
      type: Input
    }]
  });
})();
var LocalizedMessagesDirective = class _LocalizedMessagesDirective extends Messages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedMessagesDirective,
    selectors: [["", "kendoDialogLocalizedMessages", ""], ["", "kendoWindowLocalizedMessages", ""], ["", "kendoDialogTitleBarLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: Messages,
      useExisting: forwardRef(() => _LocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: Messages,
        useExisting: forwardRef(() => LocalizedMessagesDirective)
      }],
      selector: `
    [kendoDialogLocalizedMessages],
    [kendoWindowLocalizedMessages],
    [kendoDialogTitleBarLocalizedMessages]
  `,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var DialogTitleBarComponent = class _DialogTitleBarComponent {
  zone;
  hostElement;
  localizationService;
  /**
   * Fires when the close button of the title-bar is clicked.
   */
  close = new EventEmitter();
  /**
   * @hidden
   */
  id;
  /**
   * @hidden
   */
  closeTitle;
  get className() {
    return true;
  }
  /**
   * @hidden
   */
  xIcon = xIcon;
  constructor(zone, hostElement, localizationService) {
    this.zone = zone;
    this.hostElement = hostElement;
    this.localizationService = localizationService;
  }
  get closeButtonTitle() {
    return this.closeTitle || this.localizationService.get("closeTitle");
  }
  ngAfterViewInit() {
    this.zone.onStable.pipe(take(1)).subscribe(() => {
      const element = this.hostElement.nativeElement.querySelector(".k-dialog-title");
      element.setAttribute("id", this.id);
    });
  }
  /**
   * @hidden
   */
  onCloseClick(e) {
    e.preventDefault();
    const eventArgs = new PreventableEvent3();
    this.close.emit(eventArgs);
  }
  static ɵfac = function DialogTitleBarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DialogTitleBarComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LocalizationService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DialogTitleBarComponent,
    selectors: [["kendo-dialog-titlebar"]],
    hostVars: 4,
    hostBindings: function DialogTitleBarComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-window-titlebar", ctx.className)("k-dialog-titlebar", ctx.className);
      }
    },
    inputs: {
      id: "id",
      closeTitle: "closeTitle"
    },
    outputs: {
      close: "close"
    },
    features: [ɵɵProvidersFeature([TitleBarLocalizationService, {
      provide: LocalizationService,
      useExisting: TitleBarLocalizationService
    }, {
      provide: L10N_PREFIX,
      useValue: "kendo.dialog"
    }])],
    ngContentSelectors: _c03,
    decls: 5,
    vars: 3,
    consts: () => {
      let i18n_0;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_0 = goog.getMsg("Close");
        i18n_0 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_0;
      } else {
        i18n_0 = $localize`:kendo.dialog.closeTitle|The title of the close button:Close`;
      }
      return [["kendoDialogTitleBarLocalizedMessages", "", "closeTitle", i18n_0], [1, "k-window-title", "k-dialog-title"], [1, "k-window-titlebar-actions", "k-dialog-titlebar-actions"], ["kendoButton", "", "fillMode", "flat", "type", "button", "icon", "close", 1, "k-window-titlebar-action", "k-dialog-titlebar-action", 3, "click", "svgIcon"]];
    },
    template: function DialogTitleBarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementContainerStart(0, 0);
        ɵɵelementStart(1, "span", 1);
        ɵɵprojection(2);
        ɵɵelementEnd();
        ɵɵelementStart(3, "div", 2)(4, "button", 3);
        ɵɵlistener("click", function DialogTitleBarComponent_Template_button_click_4_listener($event) {
          return ctx.onCloseClick($event);
        });
        ɵɵelementEnd()();
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵadvance(4);
        ɵɵproperty("svgIcon", ctx.xIcon);
        ɵɵattribute("title", ctx.closeButtonTitle)("aria-label", ctx.closeButtonTitle);
      }
    },
    dependencies: [LocalizedMessagesDirective, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DialogTitleBarComponent, [{
    type: Component,
    args: [{
      selector: "kendo-dialog-titlebar",
      providers: [TitleBarLocalizationService, {
        provide: LocalizationService,
        useExisting: TitleBarLocalizationService
      }, {
        provide: L10N_PREFIX,
        useValue: "kendo.dialog"
      }],
      template: `
         <ng-container
            kendoDialogTitleBarLocalizedMessages
            i18n-closeTitle="kendo.dialog.closeTitle|The title of the close button"
            closeTitle="Close"
        >
            <span class="k-window-title k-dialog-title">
                <ng-content></ng-content>
            </span>

            <div class="k-window-titlebar-actions k-dialog-titlebar-actions">
                <button
                    kendoButton
                    fillMode="flat"
                    type="button"
                    [attr.title]="closeButtonTitle"
                    [attr.aria-label]="closeButtonTitle"
                    icon="close"
                    [svgIcon]="xIcon"
                    class="k-window-titlebar-action k-dialog-titlebar-action"
                    (click)="onCloseClick($event)"
                >
                </button>
            </div>
        </ng-container>
    `,
      standalone: true,
      imports: [LocalizedMessagesDirective, ButtonComponent]
    }]
  }], function() {
    return [{
      type: NgZone
    }, {
      type: ElementRef
    }, {
      type: LocalizationService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    close: [{
      type: Output
    }],
    id: [{
      type: Input
    }],
    closeTitle: [{
      type: Input
    }],
    className: [{
      type: HostBinding,
      args: ["class.k-window-titlebar"]
    }, {
      type: HostBinding,
      args: ["class.k-dialog-titlebar"]
    }]
  });
})();
var packageMetadata4 = {
  name: "@progress/kendo-angular-dialog",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 1745303853,
  version: "18.5.2",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var isPresent4 = (value) => value !== null && value !== void 0;
var isTruthy = (value) => !!value;
var toClassList = (classNames) => String(classNames).trim().split(" ");
var focusableRegex = /^(?:a|input|select|textarea|button|object)$/i;
var Keys2;
(function(Keys3) {
  Keys3[Keys3["esc"] = 27] = "esc";
  Keys3[Keys3["tab"] = 9] = "tab";
  Keys3[Keys3["enter"] = 13] = "enter";
  Keys3[Keys3["space"] = 32] = "space";
  Keys3[Keys3["ctrl"] = 17] = "ctrl";
  Keys3[Keys3["shift"] = 16] = "shift";
  Keys3[Keys3["left"] = 37] = "left";
  Keys3[Keys3["up"] = 38] = "up";
  Keys3[Keys3["right"] = 39] = "right";
  Keys3[Keys3["down"] = 40] = "down";
})(Keys2 || (Keys2 = {}));
var DIALOG_ELEMENTS_HANDLING_ESC_KEY = "k-dialog-wrapper k-actions k-dialog-titlebar-action";
var DIALOG_ELEMENTS_HANDLING_ARROWS = "k-actions";
var WINDOW_CLASSES = "k-window";
var WINDOW_ELEMENTS_HANDLING_ESC_KEY = "k-window k-window-titlebar-action";
var hasClasses = (element, classNames) => {
  const namesList = toClassList(classNames);
  return Boolean(toClassList(element.className).find((className) => namesList.indexOf(className) >= 0));
};
var isVisible = (element) => {
  const rect = element.getBoundingClientRect();
  return !!(rect.width && rect.height) && window.getComputedStyle(element).visibility !== "hidden";
};
var isFocusable2 = (element, checkVisibility = true) => {
  if (element.tagName) {
    const tagName = element.tagName.toLowerCase();
    const tabIndex = element.getAttribute("tabIndex");
    const validTabIndex = tabIndex !== null && !isNaN(tabIndex) && tabIndex > -1;
    let focusable = false;
    if (focusableRegex.test(tagName)) {
      focusable = !element.disabled;
    } else {
      focusable = validTabIndex;
    }
    return focusable && (!checkVisibility || isVisible(element));
  }
  return false;
};
var parseCSSClassNames2 = (value) => {
  if (isObject(value)) {
    return parseObjectClassNames(value);
  }
  if (isString2(value)) {
    return parseStringClassNames(value);
  }
  if (Array.isArray(value)) {
    return parseArrayClassNames(value);
  }
};
var parseObjectClassNames = (value) => {
  const classes = [];
  Object.keys(value).forEach((className) => {
    const currentClassName = splitStringToArray(className);
    if (value[className] && currentClassName[0]) {
      classes.push(...currentClassName);
    }
  });
  return classes;
};
var parseStringClassNames = (value) => {
  const classes = [];
  const classesArray = splitStringToArray(value);
  classesArray.forEach((className) => {
    classes.push(className);
  });
  return classes;
};
var parseArrayClassNames = (value) => {
  const classes = [];
  value.forEach((className) => {
    const current = splitStringToArray(className);
    if (current[0]) {
      classes.push(...current);
    }
  });
  return classes;
};
var preventDefault2 = ({
  originalEvent: event
}) => {
  event.stopPropagation();
  event.preventDefault();
};
var RESIZE_DIRECTIONS = ["n", "e", "s", "w", "se", "sw", "ne", "nw"];
var OFFSET_STYLES = ["top", "left", "width", "height"];
var isString2 = (value) => value instanceof String || typeof value === "string";
var isObject = (value) => isPresent4(value) && !Array.isArray(value) && typeof value === "object";
var isNumber2 = (value) => typeof value === "number" && isFinite(value);
var createValueWithUnit = (value) => value + (isNumber2(value) ? "px" : "");
var splitStringToArray = (value) => value.trim().replace(/\s+/g, " ").split(" ");
var findPrimaryButton = (buttons) => {
  for (let i = buttons.length - 1; i >= 0; i--) {
    const classList = buttons[i].classList;
    for (let j = 0; j < classList.length; j++) {
      if (classList[j].endsWith("-primary")) {
        return buttons[i];
      }
    }
  }
};
var DialogCloseResult = class {
};
function animations(duration, direction, animationType) {
  switch (animationType) {
    case "slide": {
      const translate = direction === "left" || direction === "right" ? "translateX" : "translateY";
      const start = direction === "right" || direction === "down" ? -100 : 100;
      const end = 0;
      return [style({
        transform: `${translate}(${start}%)`
      }), animate(`${duration}ms ease-in`, style({
        transform: `${translate}(${end}%)`
      }))];
    }
    case "expand": {
      const scale = direction === "up" || direction === "down" ? "scaleY" : "scaleX";
      const startScale = 0;
      const endScale = 1;
      let origin;
      if (direction === "down") {
        origin = "top";
      } else if (direction === "left") {
        origin = "right";
      } else if (direction === "right") {
        origin = "left";
      } else {
        origin = "bottom";
      }
      return [style({
        transform: `${scale}(${startScale})`,
        transformOrigin: origin
      }), animate(`${duration}ms ease-in`, style({
        transform: `${scale}(${endScale})`
      }))];
    }
    case "zoom": {
      const startZoom = 0;
      const endZoom = 1;
      return [animate(duration, keyframes([style({
        transform: `scale(${startZoom})`
      }), style({
        transform: `scale(${endZoom})`
      })]))];
    }
    case "fade": {
      const startFade = 0;
      const endFade = 1;
      return [animate(duration, keyframes([style({
        opacity: `${startFade}`
      }), style({
        opacity: `${endFade}`
      })]))];
    }
    case "translate":
      return [style({
        transform: "translate(0, -10%)"
      }), animate(`${duration}ms cubic-bezier(.2, 1, .2, 1)`)];
    default:
      return [style({
        transform: "translate(0, -10%)"
      }), animate(`${duration}ms cubic-bezier(.2, 1, .2, 1)`)];
  }
}
var createPlayer = (builder, animation, animatedElement) => {
  const factory = builder.build(animation);
  let player = factory.create(animatedElement);
  player.onDone(() => {
    if (player) {
      player.destroy();
      player = null;
    }
  });
  return player;
};
var animateContent = (animation, defAnimationConfig, animatedElement, builder) => {
  let animationConfig = defAnimationConfig;
  if (typeof animation !== "boolean") {
    animationConfig = animation;
    animationConfig.duration = animationConfig.duration ? animationConfig.duration : defAnimationConfig.duration;
  }
  const animationSpecs = animations(animationConfig.duration, animationConfig.direction, animationConfig.type);
  const player = createPlayer(builder, animationSpecs, animatedElement);
  player.play();
};
var DEFAULT_ANIMATION_CONFIG2 = {
  duration: 300,
  type: "translate"
};
var DialogComponent = class _DialogComponent {
  wrapper;
  renderer;
  cdr;
  ngZone;
  builder;
  /**
   * Specifies the action buttons that will be rendered.
   */
  actions;
  /**
   * Specifies the layout of the action buttons in the Dialog.
   * This option is only applicable if the action buttons are specified through the `actions` options.
   *
   * @default 'stretched'
   */
  actionsLayout = "stretched";
  /**
   * Specifies the query selector used to set the initial focus ([see examples]({% slug initial_focus_dialog %})).
   */
  autoFocusedElement;
  /**
   * Specifies the text that is rendered in the title bar.
   */
  title;
  /**
   * Specifies the width of the Dialog.
   * A numeric value sets the width in pixels.
   * A string value sets the width in arbitrary units&mdash;for example, `50%`.
   */
  width;
  /**
   * Specifies the minimum width of the Dialog.
   * A numeric value sets the minimum width in pixels.
   * A string value sets the minimum width in arbitrary units&mdash;for example, `50%`.
   */
  minWidth;
  /**
   * Specifies the maximum width of the Dialog.
   * A numeric value sets the maximum width in pixels.
   * A string value sets the maximum width in arbitrary units&mdash;for example, `50%`.
   */
  maxWidth;
  /**
   * Specifies the height of the Dialog.
   * A numeric value sets the height in pixels.
   * A string value sets the height in arbitrary units&mdash;for example, `50%`.
   */
  height;
  /**
   * Specifies the minimum height of the Dialog.
   * A numeric value sets the minimum height in pixels.
   * A string value sets the minimum height in arbitrary units&mdash;for example, `50%`.
   */
  minHeight;
  /**
   * Specifies the maximum height of the Dialog.
   * A numeric value sets the maximum height in pixels.
   * A string value sets the maximum height in arbitrary units&mdash;for example, `50%`.
   */
  maxHeight;
  /**
   * Configures the Dialog opening animation ([see example]({% slug animations_dialog %})).
   * By default the animation type is set to `translate` and its duration is `300ms`.
   *
   * @default true
   */
  animation = true;
  /**
   * The Dialog allows you to specify predefined theme colors.
   * The theme color will be applied as a background and border color to the titlebar while also amending the text color accordingly.
   *
   * The possible values are:
   * * `primary`
   * * `dark`
   * * `light`
   */
  set themeColor(themeColor) {
    this.handleThemeColorClass(this.themeColor, themeColor);
    this._themeColor = themeColor;
  }
  get themeColor() {
    return this._themeColor;
  }
  /**
   * @hidden
   */
  set htmlAttributes(attributes) {
    setHTMLAttributes(attributes, this.renderer, this.wrapper.nativeElement);
    const el = this.wrapper.nativeElement;
    const dir = el.getAttribute("dir");
    const tIndex = el.getAttribute("tabindex");
    if (this.direction !== dir && dir) {
      this.direction = dir;
    }
    if (this.tabIndex !== tIndex && tIndex) {
      this.tabIndex = tIndex;
    }
    this._htmlAttributes = attributes;
  }
  get htmlAttributes() {
    return this._htmlAttributes;
  }
  /**
   * @hidden
   */
  set cssClass(classes) {
    this.setServiceClasses(this._cssClass, classes);
    this._cssClass = classes;
  }
  get cssClass() {
    return this._cssClass;
  }
  /**
   * @hidden
   */
  contentTemplate;
  /**
   * @hidden
   */
  titleId = null;
  /**
   * @hidden
   */
  contentId = null;
  /**
   * @hidden
   */
  closeTitle;
  /**
   * @hidden
   */
  showLicenseWatermark = false;
  /**
   * Fires when the user clicks an action button of the Dialog.
   * The event is fired only when the action buttons are specified through the `actions` options.
   */
  action = new EventEmitter();
  /**
   * Fires when the user clicks the **Close** button of the Dialog or the **ESC** key.
   */
  close = new EventEmitter();
  get dir() {
    return this.direction;
  }
  tabIndex = 0;
  titlebarContent;
  titlebarView;
  actionsView;
  dialog;
  _htmlAttributes;
  _cssClass;
  _themeColor = null;
  direction;
  subscriptions = [];
  domSubs = new Subscription();
  constructor(wrapper, renderer, localization, cdr, ngZone, builder) {
    this.wrapper = wrapper;
    this.renderer = renderer;
    this.cdr = cdr;
    this.ngZone = ngZone;
    this.builder = builder;
    const isValid = validatePackage(packageMetadata4);
    this.showLicenseWatermark = shouldShowValidationUI(isValid);
    this.direction = localization.rtl ? "rtl" : "ltr";
    this.subscriptions.push(localization.changes.subscribe(({
      rtl
    }) => this.direction = rtl ? "rtl" : "ltr"));
    this.titleId = this.generateTitleId();
    this.contentId = this.generateContentId();
  }
  ngAfterContentInit() {
    this.bubble("close", this.titlebarContent.first);
    this.renderer.setAttribute(this.wrapper.nativeElement.querySelector(".k-dialog"), "aria-describedby", this.contentId);
    if (this.titlebarContent.first) {
      this.titlebarContent.first.id = this.titleId;
    } else {
      this.subscriptions.push(this.titlebarContent.changes.subscribe(() => {
        if (isPresent4(this.titlebarContent.first)) {
          this.titlebarContent.first.id = this.titleId;
          this.ngZone.onStable.pipe(take(1)).subscribe(() => {
            this.bubble("close", this.titlebarContent.first);
            this.renderer.setAttribute(this.wrapper.nativeElement.querySelector(".k-dialog"), "aria-labelledby", this.titleId);
          });
        }
      }));
    }
  }
  ngAfterViewInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      this.handleInitialFocus();
    });
    this.bubble("close", this.titlebarView.first);
    this.bubble("action", this.actionsView);
    if (this.titlebarView.first || this.titlebarContent.first) {
      this.renderer.setAttribute(this.wrapper.nativeElement.querySelector(".k-dialog"), "aria-labelledby", this.titleId);
    } else {
      this.subscriptions.push(this.titlebarView.changes.subscribe(() => {
        if (isPresent4(this.titlebarView.first)) {
          this.titlebarView.first.id = this.titleId;
          this.ngZone.onStable.pipe(take(1)).subscribe(() => {
            this.bubble("close", this.titlebarView.first);
            this.renderer.setAttribute(this.wrapper.nativeElement.querySelector(".k-dialog"), "aria-labelledby", this.titleId);
          });
        }
      }));
    }
    this.initDomEvents();
    this.handleThemeColorClass(null, this.themeColor);
  }
  ngOnInit() {
    if (this.animation) {
      animateContent(this.animation, DEFAULT_ANIMATION_CONFIG2, this.dialog.nativeElement, this.builder);
    }
    this.renderer.removeAttribute(this.wrapper.nativeElement, "title");
    this.cdr.detectChanges();
  }
  ngOnDestroy() {
    this.subscriptions.forEach((s) => s.unsubscribe());
    this.subscriptions = [];
    if (this.domSubs) {
      this.domSubs.unsubscribe();
    }
  }
  /**
   * Focuses the wrapper of the Dialog component.
   */
  focus() {
    const wrapper = this.wrapper.nativeElement;
    if (isPresent4(wrapper)) {
      wrapper.focus();
    }
  }
  initDomEvents() {
    if (!this.wrapper) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      this.domSubs.add(this.renderer.listen(this.wrapper.nativeElement, "keydown", (ev) => {
        this.onKeyDown(ev);
      }));
    });
  }
  onKeyDown(event) {
    const target = event.target;
    const parent = target.parentElement;
    if (hasClasses(target, DIALOG_ELEMENTS_HANDLING_ESC_KEY) || hasClasses(parent, DIALOG_ELEMENTS_HANDLING_ESC_KEY)) {
      if (event.keyCode === Keys2.esc) {
        this.ngZone.run(() => {
          this.close.emit(new DialogCloseResult());
        });
      }
    }
    if (hasClasses(target, "k-button") && hasClasses(parent, DIALOG_ELEMENTS_HANDLING_ARROWS) && (event.keyCode === Keys2.left || event.keyCode === Keys2.right)) {
      this.ngZone.run(() => {
        this.handleActionButtonFocus(parent, event.keyCode);
      });
    }
    if (event.keyCode === Keys2.tab) {
      this.ngZone.run(() => {
        this.keepFocusWithinComponent(target, event);
      });
    }
  }
  setServiceClasses(prevValue, value) {
    const el = this.wrapper.nativeElement;
    if (prevValue) {
      parseCSSClassNames2(prevValue).forEach((className) => {
        this.renderer.removeClass(el, className);
      });
    }
    if (value) {
      parseCSSClassNames2(value).forEach((className) => {
        this.renderer.addClass(el, className);
      });
    }
  }
  /**
   * @hidden
   */
  handleInitialFocus() {
    const wrapper = this.wrapper.nativeElement;
    const primaryButton = this.findPrimary(wrapper);
    if (this.autoFocusedElement) {
      const initiallyFocusedElement = wrapper.querySelector(this.autoFocusedElement);
      if (initiallyFocusedElement) {
        initiallyFocusedElement.focus();
      }
    } else if (this.shouldFocusPrimary(primaryButton)) {
      primaryButton.focus();
    } else {
      wrapper.focus();
    }
  }
  /**
   * @hidden
   */
  findPrimary(wrapper) {
    const actionBtns = wrapper.querySelectorAll(".k-actions .k-button");
    return findPrimaryButton(actionBtns);
  }
  /**
   * @hidden
   */
  handleActionButtonFocus(parent, key) {
    const focusableActionButtons = this.getAllFocusableChildren(parent);
    for (let i = 0; i < focusableActionButtons.length; i++) {
      const current = focusableActionButtons[i];
      if (current === document.activeElement) {
        if (key === Keys2.left && i > 0) {
          focusableActionButtons[i - 1].focus();
          break;
        }
        if (key === Keys2.right && i < focusableActionButtons.length - 1) {
          focusableActionButtons[i + 1].focus();
          break;
        }
      }
    }
  }
  /**
   * @hidden
   */
  keepFocusWithinComponent(target, event) {
    const wrapper = this.wrapper.nativeElement;
    const [firstFocusable, lastFocusable] = this.getFirstAndLastFocusable(wrapper);
    const tabAfterLastFocusable = !event.shiftKey && target === lastFocusable;
    const shiftTabAfterFirstFocusable = event.shiftKey && target === firstFocusable;
    if (tabAfterLastFocusable) {
      event.preventDefault();
      firstFocusable.focus();
    }
    if (shiftTabAfterFirstFocusable) {
      event.preventDefault();
      lastFocusable.focus();
    }
  }
  /**
   * @hidden
   */
  shouldFocusPrimary(el) {
    return isPresent4(el) && isFocusable2(el);
  }
  /**
   * @hidden
   */
  getAllFocusableChildren(parent) {
    return parent.querySelectorAll(focusableSelector);
  }
  /**
   * @hidden
   */
  getFirstAndLastFocusable(parent) {
    const all = this.getAllFocusableChildren(parent);
    const firstFocusable = all.length > 0 ? all[0] : parent;
    const lastFocusable = all.length > 0 ? all[all.length - 1] : parent;
    return [firstFocusable, lastFocusable];
  }
  /**
   * @hidden
   */
  generateTitleId() {
    return "kendo-dialog-title-" + Math.ceil(Math.random() * 1e6).toString();
  }
  /**
   * @hidden
   */
  generateContentId() {
    return "kendo-dialog-content-" + Math.ceil(Math.random() * 1e6).toString();
  }
  get wrapperClass() {
    return true;
  }
  get styles() {
    const styles = {};
    if (this.width) {
      styles.width = createValueWithUnit(this.width);
    }
    if (this.height) {
      styles.height = createValueWithUnit(this.height);
    }
    if (this.minWidth) {
      styles.minWidth = createValueWithUnit(this.minWidth);
    }
    if (this.maxWidth) {
      styles.maxWidth = createValueWithUnit(this.maxWidth);
    }
    if (this.minHeight) {
      styles.minHeight = createValueWithUnit(this.minHeight);
    }
    if (this.maxHeight) {
      styles.maxHeight = createValueWithUnit(this.maxHeight);
    }
    return styles;
  }
  bubble(eventName, component) {
    if (component) {
      const emit = (e) => this[eventName].emit(e);
      const s = component[eventName].subscribe(emit);
      this.subscriptions.push(s);
    }
  }
  handleThemeColorClass(previousValue, currentValue) {
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      const dialog = this.dialog.nativeElement;
      if (previousValue) {
        const classToRemove = `k-dialog-${previousValue}`;
        this.renderer.removeClass(dialog, classToRemove);
      }
      if (currentValue) {
        const classToAdd = `k-dialog-${currentValue}`;
        this.renderer.addClass(dialog, classToAdd);
      }
    });
  }
  static ɵfac = function DialogComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DialogComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(AnimationBuilder));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DialogComponent,
    selectors: [["kendo-dialog"]],
    contentQueries: function DialogComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, DialogTitleBarComponent, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.titlebarContent = _t);
      }
    },
    viewQuery: function DialogComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(DialogActionsComponent, 5);
        ɵɵviewQuery(_c16, 7);
        ɵɵviewQuery(DialogTitleBarComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionsView = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dialog = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.titlebarView = _t);
      }
    },
    hostVars: 4,
    hostBindings: function DialogComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.dir)("tabIndex", ctx.tabIndex);
        ɵɵclassProp("k-dialog-wrapper", ctx.wrapperClass);
      }
    },
    inputs: {
      actions: "actions",
      actionsLayout: "actionsLayout",
      autoFocusedElement: "autoFocusedElement",
      title: "title",
      width: "width",
      minWidth: "minWidth",
      maxWidth: "maxWidth",
      height: "height",
      minHeight: "minHeight",
      maxHeight: "maxHeight",
      animation: "animation",
      themeColor: "themeColor"
    },
    outputs: {
      action: "action",
      close: "close"
    },
    exportAs: ["kendoDialog"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: DIALOG_LOCALIZATION_SERVICE,
      useExisting: LocalizationService
    }, {
      provide: L10N_PREFIX,
      useValue: "kendo.dialog"
    }])],
    ngContentSelectors: _c32,
    decls: 12,
    vars: 10,
    consts: () => {
      let i18n_1;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_1 = goog.getMsg("Close");
        i18n_1 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_1;
      } else {
        i18n_1 = $localize`:kendo.dialog.closeTitle|The title of the close button:Close`;
      }
      return [["dialog", ""], ["kendoDialogLocalizedMessages", "", "closeTitle", i18n_1], [1, "k-overlay"], ["role", "dialog", "aria-modal", "true", 1, "k-window", "k-dialog", 3, "ngStyle"], [3, "closeTitle", "id", 4, "ngIf"], [4, "ngIf"], [1, "k-window-content", "k-dialog-content", 3, "id"], [3, "actions", "layout", 4, "ngIf"], ["kendoWatermarkOverlay", "", 4, "ngIf"], [3, "closeTitle", "id"], [3, "ngTemplateOutlet"], [3, "actions", "layout"], ["kendoWatermarkOverlay", ""]];
    },
    template: function DialogComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c22);
        ɵɵelementContainerStart(0, 1);
        ɵɵelement(1, "div", 2);
        ɵɵelementStart(2, "div", 3, 0);
        ɵɵtemplate(4, DialogComponent_kendo_dialog_titlebar_4_Template, 2, 3, "kendo-dialog-titlebar", 4)(5, DialogComponent_ng_content_5_Template, 1, 0, "ng-content", 5);
        ɵɵelementStart(6, "div", 6);
        ɵɵtemplate(7, DialogComponent_ng_content_7_Template, 1, 0, "ng-content", 5)(8, DialogComponent_8_Template, 1, 1, null, 5);
        ɵɵelementEnd();
        ɵɵtemplate(9, DialogComponent_ng_content_9_Template, 1, 0, "ng-content", 5)(10, DialogComponent_kendo_dialog_actions_10_Template, 1, 2, "kendo-dialog-actions", 7)(11, DialogComponent_div_11_Template, 1, 0, "div", 8);
        ɵɵelementEnd();
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("@overlayAppear", void 0);
        ɵɵadvance();
        ɵɵproperty("ngStyle", ctx.styles);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.title);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.title);
        ɵɵadvance();
        ɵɵproperty("id", ctx.contentId);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.contentTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.contentTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.actions);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.actions);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showLicenseWatermark);
      }
    },
    dependencies: [LocalizedMessagesDirective, NgStyle, NgIf, DialogTitleBarComponent, NgTemplateOutlet, DialogActionsComponent, WatermarkOverlayComponent],
    encapsulation: 2,
    data: {
      animation: [trigger("overlayAppear", [state("in", style({
        opacity: 1
      })), transition("void => *", [style({
        opacity: 0.1
      }), animate(".3s cubic-bezier(.2, .6, .4, 1)")])])]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DialogComponent, [{
    type: Component,
    args: [{
      animations: [trigger("overlayAppear", [state("in", style({
        opacity: 1
      })), transition("void => *", [style({
        opacity: 0.1
      }), animate(".3s cubic-bezier(.2, .6, .4, 1)")])])],
      exportAs: "kendoDialog",
      providers: [LocalizationService, {
        provide: DIALOG_LOCALIZATION_SERVICE,
        useExisting: LocalizationService
      }, {
        provide: L10N_PREFIX,
        useValue: "kendo.dialog"
      }],
      selector: "kendo-dialog",
      template: `
        <ng-container
            kendoDialogLocalizedMessages
            i18n-closeTitle="kendo.dialog.closeTitle|The title of the close button"
            closeTitle="Close"
        >
            <div class="k-overlay" @overlayAppear></div>

            <div #dialog class="k-window k-dialog" role="dialog" aria-modal="true" [ngStyle]="styles">
                <kendo-dialog-titlebar *ngIf="title" [closeTitle]="closeTitle" [id]="titleId">{{ title }}</kendo-dialog-titlebar>
                <ng-content select="kendo-dialog-titlebar" *ngIf="!title"></ng-content>

                <div [id]="contentId" class="k-window-content k-dialog-content">
                    <ng-content *ngIf="!contentTemplate"></ng-content>
                    <ng-template [ngTemplateOutlet]="contentTemplate" *ngIf="contentTemplate"></ng-template>
                </div>

                <ng-content select="kendo-dialog-actions" *ngIf="!actions"></ng-content>
                <kendo-dialog-actions *ngIf="actions" [actions]="actions" [layout]="actionsLayout"> </kendo-dialog-actions>

                <div kendoWatermarkOverlay *ngIf="showLicenseWatermark"></div>
            </div>
        </ng-container>
    `,
      standalone: true,
      imports: [LocalizedMessagesDirective, NgStyle, NgIf, DialogTitleBarComponent, NgTemplateOutlet, DialogActionsComponent, WatermarkOverlayComponent]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: NgZone
    }, {
      type: AnimationBuilder
    }];
  }, {
    actions: [{
      type: Input
    }],
    actionsLayout: [{
      type: Input
    }],
    autoFocusedElement: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    minWidth: [{
      type: Input
    }],
    maxWidth: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    minHeight: [{
      type: Input
    }],
    maxHeight: [{
      type: Input
    }],
    animation: [{
      type: Input
    }],
    themeColor: [{
      type: Input
    }],
    action: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    tabIndex: [{
      type: HostBinding,
      args: ["attr.tabIndex"]
    }],
    titlebarContent: [{
      type: ContentChildren,
      args: [DialogTitleBarComponent, {
        descendants: false
      }]
    }],
    titlebarView: [{
      type: ViewChildren,
      args: [DialogTitleBarComponent]
    }],
    actionsView: [{
      type: ViewChild,
      args: [DialogActionsComponent, {
        static: false
      }]
    }],
    dialog: [{
      type: ViewChild,
      args: ["dialog", {
        static: true
      }]
    }],
    wrapperClass: [{
      type: HostBinding,
      args: ["class.k-dialog-wrapper"]
    }]
  });
})();
var DialogRef = class {
  /**
   * Emits events when the Dialog is closed either through the **Close** button of the title bar or through the action buttons.
   * If the **Close** button of the title bar is clicked, `DialogResult` is a `DialogCloseResult` instance.
   * If the Dialog is closed through the action buttons, `DialogResult` contains the object that was passed when the Dialog was opened.
   * When `close` is called with an argument, the result is the passed argument.
   */
  result;
  /**
   * A reference to the Dialog instance.
   */
  dialog;
  /**
   * A reference to the child component of the Dialog.
   * Available when the Dialog is opened with [component content](slug:service_dialog#toc-rendering-the-content-area).
   */
  content;
  /**
   * Closes the Dialog programmatically.
   *
   * When called without a value, the result Observable emits an empty `DialogCloseResult` object.
   *
   * When called with a value, the result Observable emits the provided value.
   *
   * Usage Examples:
   * ```typescript
   * // Close without arguments: Returns an empty `DialogCloseResult` object.
   * dialogRef.close();
   *
   * // Simulate clicking an action button: Pass a `DialogAction` object.
   * dialogRef.close({ text: 'OK', primary: true });
   *
   * // Return custom data: Pass a custom object.
   * dialogRef.close({ success: true, data: { id: 123 } });
   * ```
   */
  close;
};
var DialogContentBase = class _DialogContentBase {
  dialog;
  /**
   * @hidden
   */
  dialogTitleBar;
  /**
   * @hidden
   */
  dialogActions;
  constructor(dialog) {
    this.dialog = dialog;
  }
  /**
   * @hidden
   */
  ngAfterViewInit() {
    if (this.dialogTitleBar) {
      this.dialogTitleBar.close.pipe(filter((e) => !e.isDefaultPrevented())).subscribe(() => {
        this.dialog.close();
      });
    }
    if (this.dialogActions) {
      if (this.dialogActions.actions) {
        this.dialogActions.action.subscribe((action) => this.dialog.dialog.instance.action.emit(action));
      }
    }
  }
  static ɵfac = function DialogContentBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DialogContentBase)(ɵɵdirectiveInject(DialogRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DialogContentBase,
    viewQuery: function DialogContentBase_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(DialogTitleBarComponent, 5);
        ɵɵviewQuery(DialogActionsComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dialogTitleBar = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dialogActions = _t.first);
      }
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DialogContentBase, [{
    type: Directive
  }], function() {
    return [{
      type: DialogRef
    }];
  }, {
    dialogTitleBar: [{
      type: ViewChild,
      args: [DialogTitleBarComponent, {
        static: false
      }]
    }],
    dialogActions: [{
      type: ViewChild,
      args: [DialogActionsComponent, {
        static: false
      }]
    }]
  });
})();
var DialogContainerService = class _DialogContainerService {
  static container = null;
  set container(container) {
    _DialogContainerService.container = container;
  }
  get container() {
    return _DialogContainerService.container;
  }
  static ɵfac = function DialogContainerService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DialogContainerService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DialogContainerService,
    factory: _DialogContainerService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DialogContainerService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var isNotComponent$1 = (component) => isString2(component) || component instanceof TemplateRef;
var DialogInjector = class {
  getDialogRef;
  parentInjector;
  constructor(getDialogRef, parentInjector) {
    this.getDialogRef = getDialogRef;
    this.parentInjector = parentInjector;
  }
  get(token3, notFoundValue) {
    if (token3 === DialogRef) {
      return this.getDialogRef();
    }
    return this.parentInjector.get(token3, notFoundValue);
  }
};
var DialogService = class _DialogService {
  resolver;
  containerService;
  constructor(resolver, containerService) {
    this.resolver = resolver;
    this.containerService = containerService;
  }
  /**
   * Opens a Dialog window. Requires an element in the application that uses the
   * [`kendoDialogContainer`]({% slug api_dialog_dialogcontainerdirective %}) directive.
   * Created Dialogs will be mounted in the DOM directly after that element.
   *
   * @param {DialogAction} options - The options that define the Dialog.
   * @returns {DialogRef} - A reference to the Dialog object and the convenience properties.
   *
   * @example
   *
   * ```ts-no-run
   * _@Component({
   *   selector: 'my-app',
   *   template: `
   *     <button kendoButton (click)="open()">Harmless button</button>
   *     <div kendoDialogContainer></div>
   *   `
   * })
   * export class AppComponent {
   *     constructor( private dialogService: DialogService ) {}
   *
   *     public open() {
   *         var dialog = this.dialogService.open({
   *           title: "Please confirm",
   *           content: "Are you sure?",
   *           actions: [
   *             { text: "No" },
   *             { text: "Yes", themeColor: 'primary' }
   *           ]
   *         });
   *
   *         dialog.result.subscribe((result) => {
   *           if (result instanceof DialogCloseResult) {
   *             console.log("close");
   *           } else {
   *             console.log("action", result);
   *           }
   *         });
   *     }
   * }
   * ```
   *
   */
  open(options2) {
    const factory = this.resolver.resolveComponentFactory(DialogComponent);
    const container = options2.appendTo || this.containerService.container;
    if (!container) {
      throw new Error(`
Cannot attach dialog to the page.
Add an element that uses the kendoDialogContainer directive, or set the 'appendTo' property.
See https://www.telerik.com/kendo-angular-ui/components/dialogs/dialog/service/.
          `);
    }
    const dialogRef = {
      close: () => {
      },
      content: null,
      dialog: null,
      result: null
    };
    return this.initializeDialog(options2.content, factory, container, dialogRef, options2);
  }
  initializeDialog(component, factory, container, dialogRef, options2) {
    const content = this.contentFrom(component, container, dialogRef);
    const dialog = container.createComponent(factory, void 0, void 0, content.nodes);
    dialogRef.dialog = dialog;
    dialog.changeDetectorRef.markForCheck();
    this.applyOptions(dialog.instance, options2);
    const apiClose = new Subject();
    const close2 = (e) => {
      if (e instanceof PreventableEvent3) {
        e = new DialogCloseResult();
      }
      apiClose.next(e || new DialogCloseResult());
      if (content.componentRef) {
        content.componentRef.destroy();
      }
      dialog.destroy();
    };
    const result = merge(
      apiClose,
      // triggered when the titlebar or actions are defined in DialogSettings
      merge(dialog.instance.close, dialog.instance.action).pipe(map((e) => e instanceof PreventableEvent3 ? new DialogCloseResult() : e), filter((e) => {
        if (options2.preventAction) {
          const dialogRefParameter = isNotComponent$1(component) ? void 0 : dialogRef;
          return !options2.preventAction(e, dialogRefParameter);
        }
        return true;
      }))
    ).pipe(
      take(1),
      // Takes care for multiple subscriptions:
      // We subscribe internaly and the user may subscribe to get a close result - dialog.result.subscribe().
      // This causes multiple subscriptions to the same source and thus multiple emissions. share() solves that.
      share()
    );
    result.subscribe(close2);
    dialogRef.close = close2;
    dialogRef.result = result;
    if (component && isDevMode()) {
      const hasContentTitle = content.nodes[0] && content.nodes[0].length > 0;
      const hasContentActions = content.nodes[2] && content.nodes[2].length > 0;
      const multipleTitles = options2.title && hasContentTitle;
      const multipleActions = options2.actions && hasContentActions;
      if (component.prototype instanceof DialogContentBase) {
        if (multipleTitles || multipleActions) {
          console.warn(`
                    Multiple Title and/or Actions configurations detected.
                    When using a component as content, provide the title and actions either in the component's markup
                    or via the title and actions properties of the DialogSettings object, but not both.
                    See https://www.telerik.com/kendo-angular-ui/components/dialogs/dialog/service/#toc-passing-title-content-and-actions-as-a-single-component'`);
        }
      } else {
        if (hasContentTitle || hasContentActions) {
          console.warn(`
                    When Title and/or Actions markup is provided in content component's template,
                    the component needs to inherit the DialogContentBase class to ensure that close and result events are properly hooked.
                    See https://www.telerik.com/kendo-angular-ui/components/dialogs/dialog/service/#toc-passing-title-content-and-actions-as-a-single-component'`);
        }
      }
    }
    return dialogRef;
  }
  applyOptions(instance4, options2) {
    instance4.title = options2.title;
    instance4.actions = options2.actions;
    instance4.actionsLayout = options2.actionsLayout || "stretched";
    instance4.width = options2.width;
    instance4.minWidth = options2.minWidth;
    instance4.maxWidth = options2.maxWidth;
    instance4.height = options2.height;
    instance4.minHeight = options2.minHeight;
    instance4.maxHeight = options2.maxHeight;
    instance4.autoFocusedElement = options2.autoFocusedElement;
    instance4.themeColor = options2.themeColor != void 0 ? options2.themeColor : null;
    instance4.closeTitle = options2.closeTitle;
    instance4.cssClass = options2.cssClass;
    instance4.htmlAttributes = options2.htmlAttributes;
    instance4.animation = options2.animation !== void 0 ? options2.animation : true;
    if (options2.content instanceof TemplateRef) {
      instance4.contentTemplate = options2.content;
    }
  }
  contentFrom(content, container, dialogRef) {
    const renderer = container.injector.get(Renderer2);
    let nodes = [];
    let titleNodes = [];
    let actionNodes = [];
    let componentRef = null;
    if (typeof content === "string") {
      nodes = [renderer.createText(content)];
    } else if (content && !(content instanceof TemplateRef)) {
      const injector = new DialogInjector(() => dialogRef, container.injector);
      const factory = this.resolver.resolveComponentFactory(content);
      componentRef = container.createComponent(factory, void 0, injector);
      titleNodes = Array.from(componentRef.location.nativeElement.querySelectorAll("kendo-dialog-titlebar"));
      nodes = [componentRef.location.nativeElement];
      actionNodes = Array.from(componentRef.location.nativeElement.querySelectorAll("kendo-dialog-actions"));
      dialogRef.content = componentRef;
    }
    return {
      componentRef,
      nodes: [
        titleNodes,
        nodes,
        actionNodes
        // <ng-content select="kendo-dialog-actions">
      ]
    };
  }
  static ɵfac = function DialogService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DialogService)(ɵɵinject(ComponentFactoryResolver$1), ɵɵinject(DialogContainerService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DialogService,
    factory: _DialogService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DialogService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: ComponentFactoryResolver$1
    }, {
      type: DialogContainerService,
      decorators: [{
        type: Inject,
        args: [DialogContainerService]
      }]
    }];
  }, null);
})();
var newZIndex = 10002;
var DEFAULT_OPTIONS3 = {
  draggable: true,
  height: null,
  left: null,
  minHeight: 100,
  minWidth: 120,
  position: "absolute",
  resizable: true,
  state: "default",
  top: null,
  width: null
};
var createMoveStream = (el, ev) => (mouseDown) => {
  return el.kendoDrag.pipe(takeUntil(el.kendoRelease.pipe(tap(() => {
    ev.emit();
  }))), map(({
    pageX,
    pageY
  }) => ({
    originalX: mouseDown.pageX,
    originalY: mouseDown.pageY,
    pageX,
    pageY
  })));
};
var DragResizeService = class _DragResizeService {
  ngZone;
  close = new EventEmitter();
  focus = new EventEmitter();
  change = new EventEmitter();
  stateChange = new EventEmitter();
  dragStart = new EventEmitter();
  dragEnd = new EventEmitter();
  resizeStart = new EventEmitter();
  resizeEnd = new EventEmitter();
  options = Object.assign({}, DEFAULT_OPTIONS3);
  restoreOptions;
  window;
  lastAction = null;
  subscriptions = new Subscription();
  dragSubscription = new Subscription();
  constructor(ngZone) {
    this.ngZone = ngZone;
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
    if (this.dragSubscription) {
      this.dragSubscription.unsubscribe();
    }
  }
  init(el) {
    const state2 = this.options.state;
    const options2 = this.options;
    this.window = el;
    if (state2 !== "default") {
      this.restoreOptions = Object.assign({}, options2);
    }
    if (state2 === "minimized") {
      options2.height = 0;
      options2.minHeight = 0;
    }
    if (state2 === "maximized") {
      options2.position = "fixed";
    }
  }
  onDrag(el) {
    this.subscriptions.add(this.ngZone.runOutsideAngular(() => {
      let startPosition;
      let dragStarted;
      this.dragSubscription = el.kendoPress.pipe(tap((ev) => {
        if (!ev.isTouch) {
          preventDefault2(ev);
        }
        this.focus.emit();
        startPosition = this.currentPosition();
        dragStarted = false;
      }), switchMap(createMoveStream(el, this.dragEnd))).subscribe(({
        pageX,
        pageY,
        originalX,
        originalY
      }) => {
        if (!dragStarted) {
          this.ensureWidth();
          this.dragStart.emit();
          dragStarted = true;
        }
        this.handleDrag({
          originalX,
          originalY,
          pageX,
          pageY,
          startPosition
        });
      });
    }));
  }
  handleDrag({
    originalX,
    originalY,
    pageX,
    pageY,
    startPosition
  }) {
    this.options.left = startPosition.x + pageX - originalX;
    this.options.top = startPosition.y + pageY - originalY;
    if (this.options.state === "minimized" && isPresent4(this.restoreOptions)) {
      this.restoreOptions.left = this.options.left;
      this.restoreOptions.top = this.options.top;
    }
    this.change.emit({
      left: startPosition.x + pageX - originalX,
      top: startPosition.y + pageY - originalY
    });
  }
  onResize(handle, direction) {
    this.subscriptions.add(this.ngZone.runOutsideAngular(() => {
      let startOffsetAndPosition;
      let resizeStarted = false;
      handle.kendoPress.pipe(tap((ev) => {
        preventDefault2(ev);
        this.focus.emit();
        startOffsetAndPosition = this.currentOffsetAndPosition();
        resizeStarted = false;
      }), switchMap(createMoveStream(handle, this.resizeEnd))).subscribe(({
        pageX,
        pageY,
        originalX,
        originalY
      }) => {
        if (!resizeStarted) {
          this.resizeStart.emit(direction);
          resizeStarted = true;
        }
        const deltaX = pageX - originalX;
        const deltaY = pageY - originalY;
        this.handleResize(startOffsetAndPosition, direction, deltaX, deltaY);
      });
    }));
  }
  handleResize(initial, dir, deltaX, deltaY) {
    const old = this.options;
    const ev = {};
    if (dir.indexOf("e") >= 0) {
      const newWidth = initial.width + deltaX;
      if (newWidth !== old.width && newWidth >= old.minWidth) {
        ev.width = newWidth;
      }
    }
    if (dir.indexOf("n") >= 0) {
      const newHeight = initial.height - deltaY;
      const newTop = initial.y + deltaY;
      if (newHeight !== old.height && newHeight >= old.minHeight && newTop !== old.top) {
        ev.height = newHeight;
        ev.top = newTop;
      }
    }
    if (dir.indexOf("s") >= 0) {
      const newHeight = initial.height + deltaY;
      if (newHeight !== old.height && newHeight >= old.minHeight) {
        ev.height = newHeight;
      }
    }
    if (dir.indexOf("w") >= 0) {
      const newLeft = initial.x + deltaX;
      const newWidth = initial.width - deltaX;
      if (newWidth !== old.width && newWidth >= old.minWidth && newLeft !== old.left) {
        ev.width = newWidth;
        ev.left = newLeft;
      }
    }
    if (isPresent4(ev.width) || isPresent4(ev.height)) {
      OFFSET_STYLES.forEach((style2) => {
        if (isPresent4(ev[style2])) {
          this.options[style2] = ev[style2];
        }
      });
      this.change.emit(ev);
    }
  }
  restoreAction() {
    this.lastAction = "restore";
    this.defaultState();
  }
  defaultState() {
    if (isPresent4(this.restoreOptions)) {
      this.options = Object.assign({}, this.restoreOptions);
    }
    this.options.state = "default";
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      if (!isPresent4(this.options.left) || !isPresent4(this.options.top)) {
        this.center();
      }
    });
    this.stateChange.emit("default");
  }
  storeOptions() {
    this.restoreOptions = Object.assign({}, this.options);
  }
  maximizeAction() {
    this.lastAction = "maximize";
    this.maximizeState();
  }
  maximizeState() {
    this.storeOptions();
    const wnd = this.windowViewPort;
    this.options = Object.assign({}, this.options, {
      height: wnd.height,
      left: 0,
      position: "fixed",
      state: "maximized",
      top: 0,
      width: wnd.width
    });
    this.stateChange.emit("maximized");
  }
  minimizeAction() {
    this.lastAction = "minimize";
    this.minimizeState();
  }
  minimizeState() {
    this.storeOptions();
    this.options = Object.assign({}, this.options, {
      height: null,
      minHeight: 0,
      state: "minimized"
    });
    this.stateChange.emit("minimized");
  }
  /**
   * Handles manual changes of the 'state' property.
   * Required to distinguish them from action clicks.
   */
  applyManualState() {
    const state2 = this.options.state;
    switch (state2) {
      case "default":
        this.clearHeight();
        this.defaultState();
        break;
      case "maximized":
        this.clearHeight();
        this.maximizeState();
        break;
      case "minimized":
        this.minimizeState();
        break;
      default:
        break;
    }
  }
  closeAction() {
    this.close.emit();
  }
  ensureWidth() {
    const windowOffset = offset_default(this.window.nativeElement);
    if (!isPresent4(this.options.width)) {
      this.options.width = windowOffset.width;
      this.change.emit({
        width: windowOffset.width
      });
    }
  }
  clearHeight() {
    if (this.options.height === 0) {
      delete this.options.height;
    }
    if (this.options.minHeight === 0) {
      delete this.options.minHeight;
    }
  }
  center() {
    if (this.options.state === "maximized") {
      return;
    }
    const scroll = scrollPosition(this.window.nativeElement);
    const wnd = this.windowViewPort;
    const wrapper = offset_default(this.window.nativeElement);
    const ev = {};
    if (!isPresent4(this.options.left)) {
      this.options.left = scroll.x + Math.max(0, (wnd.width - wrapper.width) / 2);
      ev.left = this.options.left;
    }
    if (!isPresent4(this.options.top)) {
      this.options.top = scroll.y + Math.max(0, (wnd.height - wrapper.height) / 2);
      ev.top = this.options.top;
    }
    this.change.emit(ev);
  }
  currentOffsetAndPosition() {
    const o = this.options;
    const off = offset_default(this.window.nativeElement);
    return Object.assign({}, this.currentPosition(), {
      height: o.height ? o.height : off.height,
      width: o.width ? o.width : off.width
    });
  }
  currentPosition() {
    const o = this.options;
    if (!o.top || !o.left) {
      this.setPosition();
    }
    return {
      x: this.options.left,
      y: this.options.top
    };
  }
  setPosition() {
    const wrapper = position_with_scroll_default(this.window.nativeElement, document_default(this.window.nativeElement));
    this.options.left = wrapper.left;
    this.options.top = wrapper.top;
  }
  setRestoreOption(style2, value) {
    if (isPresent4(this.restoreOptions)) {
      this.restoreOptions[style2] = value;
    }
  }
  get nextPossibleZIndex() {
    return newZIndex;
  }
  get nextZIndex() {
    return newZIndex++;
  }
  get windowViewPort() {
    return windowViewport(this.window.nativeElement);
  }
  static ɵfac = function DragResizeService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragResizeService)(ɵɵinject(NgZone));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DragResizeService,
    factory: _DragResizeService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragResizeService, [{
    type: Injectable
  }], function() {
    return [{
      type: NgZone
    }];
  }, null);
})();
var ResizeHandleDirective = class _ResizeHandleDirective {
  draggable;
  el;
  renderer;
  service;
  direction;
  get hostClass() {
    return true;
  }
  subscriptions = new Subscription();
  constructor(draggable, el, renderer, service) {
    this.draggable = draggable;
    this.el = el;
    this.renderer = renderer;
    this.service = service;
  }
  ngOnInit() {
    this.setDisplay();
    this.renderer.addClass(this.el.nativeElement, "k-resize-" + this.direction);
    this.subscriptions.add(of(this.draggable).subscribe((handle) => {
      this.service.onResize(handle, this.direction);
    }));
    this.subscriptions.add(this.service.resizeStart.subscribe((dir) => {
      if (dir !== this.direction) {
        this.setDisplay("none");
      }
    }));
    this.subscriptions.add(this.service.dragStart.subscribe(() => {
      this.setDisplay("none");
    }));
    this.subscriptions.add(merge(this.service.resizeEnd, this.service.dragEnd).subscribe(() => {
      this.setDisplay("block");
    }));
    this.subscriptions.add(this.service.stateChange.subscribe((state2) => {
      this.setDisplay(state2 === "default" ? "block" : "none");
    }));
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  setDisplay(value = "block") {
    this.renderer.setStyle(this.el.nativeElement, "display", this.service.options.state === "default" ? value : "none");
  }
  static ɵfac = function ResizeHandleDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ResizeHandleDirective)(ɵɵdirectiveInject(DraggableDirective, 1), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DragResizeService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ResizeHandleDirective,
    selectors: [["", "kendoWindowResizeHandle", ""]],
    hostVars: 2,
    hostBindings: function ResizeHandleDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-resize-handle", ctx.hostClass);
      }
    },
    inputs: {
      direction: "direction"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResizeHandleDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoWindowResizeHandle]",
      standalone: true
    }]
  }], function() {
    return [{
      type: DraggableDirective,
      decorators: [{
        type: Host
      }]
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: DragResizeService
    }];
  }, {
    direction: [{
      type: Input
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-resize-handle"]
    }]
  });
})();
var WindowTitleBarComponent = class _WindowTitleBarComponent {
  el;
  ngZone;
  /**
   * @hidden
   */
  template;
  /**
   * @hidden
   */
  id;
  /**
   * @hidden
   */
  service;
  dragDirective;
  dragSubscription;
  stateSubscription;
  constructor(el, service, ngZone) {
    this.el = el;
    this.ngZone = ngZone;
    this.service = service;
  }
  ngOnInit() {
    this.dragDirective = new DraggableDirective(this.el, this.ngZone);
    this.dragDirective.ngOnInit();
    if (this.isDraggable) {
      this.subscribeDrag();
    }
    this.subscribeStateChange();
  }
  ngAfterViewInit() {
    const element = this.el.nativeElement.querySelector(".k-window-title");
    if (isPresent4(element)) {
      element.setAttribute("id", this.id);
    }
  }
  ngOnDestroy() {
    this.dragDirective.ngOnDestroy();
    this.unsubscribeDrag();
    this.unsubscribeState();
  }
  /**
   * @hidden
   */
  subscribeDrag() {
    this.unsubscribeDrag();
    this.dragSubscription = of(this.dragDirective).subscribe((titleBar) => {
      this.service.onDrag(titleBar);
    });
  }
  /**
   * @hidden
   */
  subscribeStateChange() {
    this.stateSubscription = this.service.stateChange.subscribe((state2) => {
      if (this.service.options.draggable) {
        if (state2 === "maximized") {
          this.unsubscribeDrag();
        } else {
          this.subscribeDrag();
        }
      }
    });
  }
  /**
   * @hidden
   */
  unsubscribeDrag() {
    if (this.dragSubscription) {
      this.service.dragSubscription.unsubscribe();
      this.dragSubscription.unsubscribe();
      this.dragSubscription = null;
    }
  }
  /**
   * @hidden
   */
  unsubscribeState() {
    if (this.stateSubscription) {
      this.stateSubscription.unsubscribe();
      this.stateSubscription = null;
    }
  }
  get className() {
    return true;
  }
  get touchAction() {
    if (this.isDraggable) {
      return "none";
    }
  }
  /**
   * @hidden
   */
  handle(ev) {
    const target = ev.target;
    const state2 = this.service.options.state;
    if (!hasClasses(target, "k-icon") && !isFocusable2(target, false) && this.service.options.resizable) {
      if (state2 === "default") {
        this.service.maximizeAction();
      } else if (state2 === "maximized") {
        this.service.restoreAction();
      }
    }
  }
  get isDraggable() {
    const options2 = this.service.options;
    return options2.draggable && options2.state !== "maximized";
  }
  static ɵfac = function WindowTitleBarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _WindowTitleBarComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DragResizeService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _WindowTitleBarComponent,
    selectors: [["kendo-window-titlebar"]],
    hostVars: 4,
    hostBindings: function WindowTitleBarComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("dblclick", function WindowTitleBarComponent_dblclick_HostBindingHandler($event) {
          return ctx.handle($event);
        });
      }
      if (rf & 2) {
        ɵɵstyleProp("touch-action", ctx.touchAction);
        ɵɵclassProp("k-window-titlebar", ctx.className);
      }
    },
    inputs: {
      template: "template",
      id: "id"
    },
    ngContentSelectors: _c03,
    decls: 2,
    vars: 2,
    consts: [[4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function WindowTitleBarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, WindowTitleBarComponent_ng_content_0_Template, 1, 0, "ng-content", 0)(1, WindowTitleBarComponent_1_Template, 1, 4, null, 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", !ctx.template);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.template);
      }
    },
    dependencies: [NgIf, NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WindowTitleBarComponent, [{
    type: Component,
    args: [{
      selector: "kendo-window-titlebar",
      template: `
	<ng-content *ngIf="!template"></ng-content>
	<ng-template
		[ngTemplateOutlet]="template"
		[ngTemplateOutletContext]="{'$implicit': service}" *ngIf="template">
	</ng-template>
	`,
      standalone: true,
      imports: [NgIf, NgTemplateOutlet]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: DragResizeService
    }, {
      type: NgZone
    }];
  }, {
    template: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    className: [{
      type: HostBinding,
      args: ["class.k-window-titlebar"]
    }],
    touchAction: [{
      type: HostBinding,
      args: ["style.touch-action"]
    }],
    handle: [{
      type: HostListener,
      args: ["dblclick", ["$event"]]
    }]
  });
})();
var NavigationService = class _NavigationService {
  window;
  ngZone;
  constructor(window2, ngZone) {
    this.window = window2;
    this.ngZone = ngZone;
  }
  process(ev) {
    const key = ev.keyCode;
    const target = ev.target;
    switch (key) {
      case Keys2.up:
      case Keys2.down:
      case Keys2.left:
      case Keys2.right: {
        if (hasClasses(target, WINDOW_CLASSES)) {
          ev.preventDefault();
          this.ngZone.run(() => {
            this.handleArrow(key, ev);
          });
        }
        break;
      }
      case Keys2.esc:
        if (hasClasses(target, WINDOW_ELEMENTS_HANDLING_ESC_KEY)) {
          this.ngZone.run(() => {
            this.handleEscape();
          });
        }
        break;
      default:
        break;
    }
  }
  handleArrow(key, ev) {
    const options2 = this.window.options;
    if (ev.altKey) {
      this.handleStateChange(key, options2.state);
      return;
    }
    if ((ev.ctrlKey || ev.metaKey) && options2.state === "default") {
      this.handleResize(key);
    } else {
      this.handleDrag(key);
    }
  }
  handleEscape() {
    this.window.closeAction();
  }
  handleDrag(key) {
    const options2 = this.window.options;
    if (!options2.draggable) {
      return;
    }
    const offset = this.window.currentOffsetAndPosition();
    const restoreOptions = this.window.restoreOptions;
    const ev = {};
    let delta = 10;
    if (key === Keys2.left || key === Keys2.up) {
      delta *= -1;
    }
    switch (key) {
      case Keys2.left:
      case Keys2.right: {
        ev.left = offset.x + delta;
        options2.left = ev.left;
        break;
      }
      case Keys2.up:
      case Keys2.down: {
        ev.top = offset.y + delta;
        options2.top = ev.top;
        break;
      }
      default:
        break;
    }
    if (options2.state === "minimized" && isPresent4(restoreOptions)) {
      restoreOptions.left = options2.left;
      restoreOptions.top = options2.top;
    }
    this.window.change.emit(ev);
  }
  handleResize(key) {
    const options2 = this.window.options;
    if (!options2.resizable) {
      return;
    }
    const offset = this.window.currentOffsetAndPosition();
    let newWidth;
    let newHeight;
    const ev = {};
    let delta = 10;
    if (key === Keys2.left || key === Keys2.up) {
      delta *= -1;
    }
    switch (key) {
      case Keys2.left:
      case Keys2.right: {
        newWidth = offset.width + delta;
        if (newWidth !== options2.width && newWidth >= options2.minWidth) {
          ev.width = newWidth;
        }
        break;
      }
      case Keys2.up:
      case Keys2.down: {
        newHeight = offset.height + delta;
        if (newHeight !== options2.height && newHeight >= options2.minHeight) {
          ev.height = newHeight;
        }
        break;
      }
      default:
        break;
    }
    if (isPresent4(ev.width) || isPresent4(ev.height)) {
      OFFSET_STYLES.forEach((style2) => {
        if (isPresent4(ev[style2])) {
          this.window.options[style2] = ev[style2];
        }
      });
      this.window.change.emit(ev);
    }
  }
  handleStateChange(key, state2) {
    if (state2 === "minimized" && key === Keys2.up || state2 === "maximized" && key === Keys2.down) {
      this.window.restoreAction();
      return;
    }
    if (state2 === "default") {
      if (key === Keys2.up) {
        this.window.maximizeAction();
      } else if (key === Keys2.down) {
        this.window.minimizeAction();
      }
    }
  }
  static ɵfac = function NavigationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NavigationService)(ɵɵinject(DragResizeService), ɵɵinject(NgZone));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _NavigationService,
    factory: _NavigationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationService, [{
    type: Injectable
  }], function() {
    return [{
      type: DragResizeService
    }, {
      type: NgZone
    }];
  }, null);
})();
var WindowCloseActionDirective = class _WindowCloseActionDirective extends ButtonComponent {
  /**
   * @hidden
   */
  window;
  /**
   * @hidden
   */
  xIcon = xIcon;
  buttonType = "button";
  buttonClass = true;
  constructor(el, renderer, _service, localization, ngZone) {
    super(el, renderer, null, localization, ngZone);
    this.window = _service;
    this.fillMode = "flat";
    this.icon = "x";
  }
  /**
   * @hidden
   */
  onClick() {
    if (!this.isDisabled) {
      this.window.closeAction();
    }
  }
  static ɵfac = function WindowCloseActionDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _WindowCloseActionDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DragResizeService, 8), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _WindowCloseActionDirective,
    selectors: [["button", "kendoWindowCloseAction", ""]],
    hostVars: 3,
    hostBindings: function WindowCloseActionDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function WindowCloseActionDirective_click_HostBindingHandler() {
          return ctx.onClick();
        });
      }
      if (rf & 2) {
        ɵɵattribute("type", ctx.buttonType);
        ɵɵclassProp("k-window-titlebar-action", ctx.buttonClass);
      }
    },
    inputs: {
      window: "window"
    },
    exportAs: ["kendoWindowCloseAction"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.button"
    }]), ɵɵInheritDefinitionFeature],
    attrs: _c52,
    ngContentSelectors: _c03,
    decls: 5,
    vars: 3,
    consts: [["innerCssClass", "k-button-icon", "name", "close", 3, "svgIcon", 4, "ngIf"], ["class", "k-button-icon k-icon", 4, "ngIf"], ["class", "k-button-icon", 3, "ngClass", 4, "ngIf"], [1, "k-button-text"], ["innerCssClass", "k-button-icon", "name", "close", 3, "svgIcon"], [1, "k-button-icon", "k-icon"], ["role", "presentation", 1, "k-image", 3, "src"], [1, "k-button-icon", 3, "ngClass"]],
    template: function WindowCloseActionDirective_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, WindowCloseActionDirective_kendo_icon_wrapper_0_Template, 1, 1, "kendo-icon-wrapper", 0)(1, WindowCloseActionDirective_span_1_Template, 2, 1, "span", 1)(2, WindowCloseActionDirective_span_2_Template, 1, 1, "span", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵprojection(4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", !ctx.imageUrl && !ctx.iconClass);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.imageUrl);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.iconClass);
      }
    },
    dependencies: [NgIf, IconWrapperComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WindowCloseActionDirective, [{
    type: Component,
    args: [{
      exportAs: "kendoWindowCloseAction",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.button"
      }],
      selector: "button[kendoWindowCloseAction]",
      template: `
        <kendo-icon-wrapper
            *ngIf="!imageUrl && !iconClass"
            innerCssClass="k-button-icon"
            name="close"
            [svgIcon]="xIcon">
        </kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent, NgClass]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: DragResizeService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: LocalizationService
    }, {
      type: NgZone
    }];
  }, {
    window: [{
      type: Input
    }],
    buttonType: [{
      type: HostBinding,
      args: ["attr.type"]
    }],
    buttonClass: [{
      type: HostBinding,
      args: ["class.k-window-titlebar-action"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var WindowRestoreActionDirective = class _WindowRestoreActionDirective extends ButtonComponent {
  /**
   * @hidden
   */
  window;
  /**
   * @hidden
   */
  windowRestoreIcon = windowRestoreIcon;
  buttonType = "button";
  buttonClass = true;
  constructor(el, renderer, _service, localization, ngZone) {
    super(el, renderer, null, localization, ngZone);
    this.window = _service;
    this.fillMode = "flat";
    this.icon = "window-restore";
  }
  /**
   * @hidden
   */
  onClick() {
    if (!this.isDisabled) {
      this.window.restoreAction();
    }
  }
  get visible() {
    return this.window.options.state === "default" ? "none" : "inline-flex";
  }
  static ɵfac = function WindowRestoreActionDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _WindowRestoreActionDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DragResizeService, 8), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _WindowRestoreActionDirective,
    selectors: [["button", "kendoWindowRestoreAction", ""]],
    hostVars: 5,
    hostBindings: function WindowRestoreActionDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function WindowRestoreActionDirective_click_HostBindingHandler() {
          return ctx.onClick();
        });
      }
      if (rf & 2) {
        ɵɵattribute("type", ctx.buttonType);
        ɵɵstyleProp("display", ctx.visible);
        ɵɵclassProp("k-window-titlebar-action", ctx.buttonClass);
      }
    },
    inputs: {
      window: "window"
    },
    exportAs: ["kendoWindowRestoreAction"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.button"
    }]), ɵɵInheritDefinitionFeature],
    attrs: _c62,
    ngContentSelectors: _c03,
    decls: 5,
    vars: 3,
    consts: [["innerCssClass", "k-button-icon", "name", "window-restore", 3, "svgIcon", 4, "ngIf"], ["class", "k-button-icon k-icon", 4, "ngIf"], ["class", "k-button-icon", 3, "ngClass", 4, "ngIf"], [1, "k-button-text"], ["innerCssClass", "k-button-icon", "name", "window-restore", 3, "svgIcon"], [1, "k-button-icon", "k-icon"], ["role", "presentation", 1, "k-image", 3, "src"], [1, "k-button-icon", 3, "ngClass"]],
    template: function WindowRestoreActionDirective_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, WindowRestoreActionDirective_kendo_icon_wrapper_0_Template, 1, 1, "kendo-icon-wrapper", 0)(1, WindowRestoreActionDirective_span_1_Template, 2, 1, "span", 1)(2, WindowRestoreActionDirective_span_2_Template, 1, 1, "span", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵprojection(4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", !ctx.imageUrl && !ctx.iconClass);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.imageUrl);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.iconClass);
      }
    },
    dependencies: [NgIf, IconWrapperComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WindowRestoreActionDirective, [{
    type: Component,
    args: [{
      exportAs: "kendoWindowRestoreAction",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.button"
      }],
      selector: "button[kendoWindowRestoreAction]",
      template: `
        <kendo-icon-wrapper
            *ngIf="!imageUrl && !iconClass"
            innerCssClass="k-button-icon"
            name="window-restore"
            [svgIcon]="windowRestoreIcon">
        </kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent, NgClass]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: DragResizeService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: LocalizationService
    }, {
      type: NgZone
    }];
  }, {
    window: [{
      type: Input
    }],
    buttonType: [{
      type: HostBinding,
      args: ["attr.type"]
    }],
    buttonClass: [{
      type: HostBinding,
      args: ["class.k-window-titlebar-action"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }],
    visible: [{
      type: HostBinding,
      args: ["style.display"]
    }]
  });
})();
var WindowMaximizeActionDirective = class _WindowMaximizeActionDirective extends ButtonComponent {
  /**
   * @hidden
   */
  window;
  buttonType = "button";
  buttonClass = true;
  /**
   * @hidden
   */
  windowIcon = windowIcon;
  constructor(el, renderer, _service, localization, ngZone) {
    super(el, renderer, null, localization, ngZone);
    this.window = _service;
    this.fillMode = "flat";
    this.icon = "window";
  }
  /**
   * @hidden
   */
  onClick() {
    if (!this.isDisabled) {
      this.window.maximizeAction();
    }
  }
  get visible() {
    return this.window.options.state === "default" ? "inline-flex" : "none";
  }
  static ɵfac = function WindowMaximizeActionDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _WindowMaximizeActionDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DragResizeService, 8), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _WindowMaximizeActionDirective,
    selectors: [["button", "kendoWindowMaximizeAction", ""]],
    hostVars: 5,
    hostBindings: function WindowMaximizeActionDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function WindowMaximizeActionDirective_click_HostBindingHandler() {
          return ctx.onClick();
        });
      }
      if (rf & 2) {
        ɵɵattribute("type", ctx.buttonType);
        ɵɵstyleProp("display", ctx.visible);
        ɵɵclassProp("k-window-titlebar-action", ctx.buttonClass);
      }
    },
    inputs: {
      window: "window"
    },
    exportAs: ["kendoWindowMaximizeAction"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.button"
    }]), ɵɵInheritDefinitionFeature],
    attrs: _c72,
    ngContentSelectors: _c03,
    decls: 5,
    vars: 3,
    consts: [["innerCssClass", "k-button-icon", "name", "window", 3, "svgIcon", 4, "ngIf"], ["class", "k-button-icon k-icon", 4, "ngIf"], ["class", "k-button-icon", 3, "ngClass", 4, "ngIf"], [1, "k-button-text"], ["innerCssClass", "k-button-icon", "name", "window", 3, "svgIcon"], [1, "k-button-icon", "k-icon"], ["role", "presentation", 1, "k-image", 3, "src"], [1, "k-button-icon", 3, "ngClass"]],
    template: function WindowMaximizeActionDirective_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, WindowMaximizeActionDirective_kendo_icon_wrapper_0_Template, 1, 1, "kendo-icon-wrapper", 0)(1, WindowMaximizeActionDirective_span_1_Template, 2, 1, "span", 1)(2, WindowMaximizeActionDirective_span_2_Template, 1, 1, "span", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵprojection(4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", !ctx.imageUrl && !ctx.iconClass);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.imageUrl);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.iconClass);
      }
    },
    dependencies: [NgIf, IconWrapperComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WindowMaximizeActionDirective, [{
    type: Component,
    args: [{
      exportAs: "kendoWindowMaximizeAction",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.button"
      }],
      selector: "button[kendoWindowMaximizeAction]",
      template: `
        <kendo-icon-wrapper
            *ngIf="!imageUrl && !iconClass"
            innerCssClass="k-button-icon"
            name="window"
            [svgIcon]="windowIcon">
        </kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent, NgClass]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: DragResizeService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: LocalizationService
    }, {
      type: NgZone
    }];
  }, {
    window: [{
      type: Input
    }],
    buttonType: [{
      type: HostBinding,
      args: ["attr.type"]
    }],
    buttonClass: [{
      type: HostBinding,
      args: ["class.k-window-titlebar-action"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }],
    visible: [{
      type: HostBinding,
      args: ["style.display"]
    }]
  });
})();
var WindowMinimizeActionDirective = class _WindowMinimizeActionDirective extends ButtonComponent {
  /**
   * @hidden
   */
  window;
  buttonType = "button";
  buttonClass = true;
  /**
   * @hidden
   */
  windowMinimizeIcon = windowMinimizeIcon;
  constructor(el, renderer, _service, localization, ngZone) {
    super(el, renderer, null, localization, ngZone);
    this.window = _service;
    this.fillMode = "flat";
    this.icon = "window-minimize";
  }
  /**
   * @hidden
   */
  onClick() {
    if (!this.isDisabled) {
      this.window.minimizeAction();
    }
  }
  get visible() {
    return this.window.options.state === "default" ? "inline-flex" : "none";
  }
  static ɵfac = function WindowMinimizeActionDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _WindowMinimizeActionDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DragResizeService, 8), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _WindowMinimizeActionDirective,
    selectors: [["button", "kendoWindowMinimizeAction", ""]],
    hostVars: 5,
    hostBindings: function WindowMinimizeActionDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function WindowMinimizeActionDirective_click_HostBindingHandler() {
          return ctx.onClick();
        });
      }
      if (rf & 2) {
        ɵɵattribute("type", ctx.buttonType);
        ɵɵstyleProp("display", ctx.visible);
        ɵɵclassProp("k-window-titlebar-action", ctx.buttonClass);
      }
    },
    inputs: {
      window: "window"
    },
    exportAs: ["kendoWindowMinimizeAction"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.button"
    }]), ɵɵInheritDefinitionFeature],
    attrs: _c82,
    ngContentSelectors: _c03,
    decls: 5,
    vars: 3,
    consts: [["innerCssClass", "k-button-icon", "name", "window-minimize", 3, "svgIcon", 4, "ngIf"], ["class", "k-button-icon k-icon", 4, "ngIf"], ["class", "k-button-icon", 3, "ngClass", 4, "ngIf"], [1, "k-button-text"], ["innerCssClass", "k-button-icon", "name", "window-minimize", 3, "svgIcon"], [1, "k-button-icon", "k-icon"], ["role", "presentation", 1, "k-image", 3, "src"], [1, "k-button-icon", 3, "ngClass"]],
    template: function WindowMinimizeActionDirective_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, WindowMinimizeActionDirective_kendo_icon_wrapper_0_Template, 1, 1, "kendo-icon-wrapper", 0)(1, WindowMinimizeActionDirective_span_1_Template, 2, 1, "span", 1)(2, WindowMinimizeActionDirective_span_2_Template, 1, 1, "span", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵprojection(4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", !ctx.imageUrl && !ctx.iconClass);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.imageUrl);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.iconClass);
      }
    },
    dependencies: [NgIf, IconWrapperComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WindowMinimizeActionDirective, [{
    type: Component,
    args: [{
      exportAs: "kendoWindowMinimizeAction",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.button"
      }],
      selector: "button[kendoWindowMinimizeAction]",
      template: `
        <kendo-icon-wrapper
            *ngIf="!imageUrl && !iconClass"
            innerCssClass="k-button-icon"
            name="window-minimize"
            [svgIcon]="windowMinimizeIcon">
        </kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent, NgClass]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: DragResizeService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: LocalizationService
    }, {
      type: NgZone
    }];
  }, {
    window: [{
      type: Input
    }],
    buttonType: [{
      type: HostBinding,
      args: ["attr.type"]
    }],
    buttonClass: [{
      type: HostBinding,
      args: ["class.k-window-titlebar-action"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }],
    visible: [{
      type: HostBinding,
      args: ["style.display"]
    }]
  });
})();
var WindowComponent = class _WindowComponent {
  el;
  renderer;
  service;
  navigation;
  ngZone;
  localization;
  /**
   * Specifies the query selector used to set the initial focus ([see examples]({% slug initial_focus_window %})).
   */
  autoFocusedElement;
  /**
   * Specifies the text that is rendered in the title bar.
   */
  title;
  /**
   * Specifies whether the user will be able to drag the component.
   * @default true
   */
  set draggable(value) {
    this.options.draggable = value;
  }
  get draggable() {
    return this.options.draggable;
  }
  /**
   * Specifies whether the user will be able to resize the component.
   * @default true
   */
  set resizable(value) {
    this.options.resizable = value;
  }
  get resizable() {
    return this.options.resizable;
  }
  /**
   * The Window allows you to specify predefined theme colors.
   * The theme color will be applied as a background and border color to the titlebar while also amending the text color accordingly.
   *
   * The possible values are:
   * * `primary`
   * * `dark`
   * * `light`
   */
  set themeColor(themeColor) {
    this.handleThemeColorClass(this.themeColor, themeColor);
    this._themeColor = themeColor;
  }
  get themeColor() {
    return this._themeColor;
  }
  /**
   * @hidden
   */
  set cssClass(classes) {
    this.setServiceClasses(this._cssClass, classes);
    this._cssClass = classes;
  }
  get cssClass() {
    return this._cssClass;
  }
  /**
   * @hidden
   */
  set htmlAttributes(attributes) {
    setHTMLAttributes(attributes, this.renderer, this.el.nativeElement);
    const el = this.el.nativeElement;
    const dir = el.getAttribute("dir");
    const tIndex = el.getAttribute("tabindex");
    if (this.direction !== dir) {
      this.direction = dir;
    }
    if (this.tabIndex !== tIndex) {
      this.tabIndex = tIndex;
    }
    this._htmlAttributes = attributes;
  }
  get htmlAttributes() {
    return this._htmlAttributes;
  }
  /**
   * Specifies if the content of the component is persisted in the DOM when minimized.
   * @default false
   */
  keepContent = false;
  /**
   * Specifies the initial state of the component.
   * If not specified, the value is set to `default`.
   *
   * The possible values are:
   * * `minimized`
   * * `maximized`
   * * `default`
   */
  set state(value) {
    this.options.state = value;
  }
  get state() {
    return this.options.state;
  }
  /**
   * Specifies the minimum width of the component.
   * The `minWidth` property has to be set in pixels.
   * @default 120
   */
  set minWidth(value) {
    this.setOption("minWidth", value);
  }
  get minWidth() {
    return this.options.minWidth;
  }
  /**
   * Specifies the minimum height of the Window.
   * The `minHeight` property has to be set in pixels.
   * @default 100
   */
  set minHeight(value) {
    this.setOption("minHeight", value);
  }
  get minHeight() {
    return this.options.minHeight;
  }
  /**
   * Specifies the width of the Window.
   * The `width` property has to be set in pixels.
   */
  set width(value) {
    this.setOption("width", value);
  }
  get width() {
    return this.options.width;
  }
  /**
   * Specifies the height of the Window.
   * The `height` property has to be set in pixels.
   */
  set height(value) {
    this.setOption("height", value);
  }
  get height() {
    return this.options.height;
  }
  /**
   * Specifies the initial top offset of the Window.
   * The `top` property has to be set in pixels.
   */
  set top(value) {
    this.setOption("top", value);
  }
  get top() {
    return this.options.top;
  }
  /**
   * Specifies the initial left offset of the Window.
   * Numeric values are treated as pixels.
   */
  set left(value) {
    this.setOption("left", value);
  }
  get left() {
    return this.options.left;
  }
  get closeButtonTitle() {
    if (this.messages && this.messages.closeTitle) {
      return this.messages.closeTitle;
    }
    return this.localization.get("closeTitle");
  }
  get restoreButtonTitle() {
    if (this.messages && this.messages.restoreTitle) {
      return this.messages.restoreTitle;
    }
    return this.localization.get("restoreTitle");
  }
  get maximizeButtonTitle() {
    if (this.messages && this.messages.maximizeTitle) {
      return this.messages.maximizeTitle;
    }
    return this.localization.get("maximizeTitle");
  }
  get minimizeButtonTitle() {
    if (this.messages && this.messages.minimizeTitle) {
      return this.messages.minimizeTitle;
    }
    return this.localization.get("minimizeTitle");
  }
  /**
   * Fires when the user starts to move the Window.
   */
  dragStart = new EventEmitter();
  /**
   * Fires when the Window was moved by the user.
   */
  dragEnd = new EventEmitter();
  /**
   * Fires when the user starts to resize the Window.
   */
  resizeStart = new EventEmitter();
  /**
   * Fires when the Window was resized by the user.
   */
  resizeEnd = new EventEmitter();
  /**
   * Fires when the user closes the Window.
   */
  close = new EventEmitter();
  /**
   * Fires when the `width` property of the component was updated. The event is triggered only after the resizing
   * has ended. The event data contains the new width. Allows a two-way binding of the `width` property.
   */
  widthChange = new EventEmitter();
  /**
   * Fires when the `height` property of the component was updated. The event is triggered only after the resizing
   * has ended. The event data contains the new height. Allows a two-way binding of the `height` property.
   */
  heightChange = new EventEmitter();
  /**
   * Fires when the `top` property of the component was updated. The event is triggered only after the dragging
   * and resizing have ended. The event data contains the new top offset. Allows a two-way binding of the `top` property.
   */
  topChange = new EventEmitter();
  /**
   * Fires when the `left` property of the component was updated. The event is triggered only after the dragging
   * and resizing have ended. The event data contains the new left offset. Allows a two-way binding of the `left` property.
   */
  leftChange = new EventEmitter();
  /**
   * Fires when the `state` property of the component was updated. The event data contains the new state. Allows a
   * two-way binding of the `state` property.
   */
  stateChange = new EventEmitter();
  /**
   * @hidden
   */
  contentTemplate;
  /**
   * @hidden
   */
  titleBarTemplate;
  /**
   * @hidden
   */
  messages = {};
  /**
   * @hidden
   */
  showLicenseWatermark = false;
  tabIndex = 0;
  role = "dialog";
  hostClass = true;
  get dir() {
    return this.direction;
  }
  titleBarView;
  titleBarContent;
  resizeHandles;
  resizeDirections;
  /**
   * @hidden
   */
  titleId = null;
  _htmlAttributes;
  _cssClass;
  _themeColor = null;
  direction;
  draged = false;
  resized = false;
  windowSubscription = new Subscription();
  domSubs = new Subscription();
  localizationChangeSubscription;
  constructor(el, renderer, service, navigation, ngZone, localization) {
    this.el = el;
    this.renderer = renderer;
    this.service = service;
    this.navigation = navigation;
    this.ngZone = ngZone;
    this.localization = localization;
    const isValid = validatePackage(packageMetadata4);
    this.showLicenseWatermark = shouldShowValidationUI(isValid);
    this.direction = this.localization.rtl ? "rtl" : "ltr";
    this.localizationChangeSubscription = this.localization.changes.subscribe(({
      rtl
    }) => this.direction = rtl ? "rtl" : "ltr");
    this.resizeDirections = RESIZE_DIRECTIONS;
    this.subscribeEvents();
    this.titleId = this.generateTitleId();
  }
  ngAfterViewInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.setNextZIndex();
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      this.handleInitialFocus();
    });
    this.ngZone.runOutsideAngular(() => Promise.resolve(null).then(() => this.setInitialOffset()));
    this.initDomEvents();
    if (this.titleBarView || this.titleBarContent) {
      this.renderer.setAttribute(this.el.nativeElement, "aria-labelledby", this.titleId);
    }
    this.handleThemeColorClass(null, this.themeColor);
  }
  ngOnInit() {
    this.renderer.removeAttribute(this.el.nativeElement, "title");
    this.service.init(this.el);
  }
  ngOnChanges(changes) {
    OFFSET_STYLES.forEach((style2) => {
      if (isChanged(style2, changes)) {
        this.setStyle(style2, this.options[style2]);
      }
    });
    if (isChanged("draggable", changes)) {
      const titleBar = isPresent4(this.titleBarContent) ? this.titleBarContent : this.titleBarView;
      if (isTruthy(changes["draggable"].currentValue)) {
        titleBar.subscribeDrag();
      } else {
        titleBar.unsubscribeDrag();
      }
    }
    if (isChanged("state", changes)) {
      if (isPresent4(this.service.lastAction)) {
        this.service.lastAction = null;
      } else {
        this.service.applyManualState();
        this.updateAllOffset();
      }
    }
  }
  ngOnDestroy() {
    if (this.windowSubscription) {
      this.windowSubscription.unsubscribe();
    }
    if (this.domSubs) {
      this.domSubs.unsubscribe();
    }
    this.localizationChangeSubscription.unsubscribe();
  }
  /**
   * Focuses the wrapper of the Window component.
   */
  focus() {
    const wrapper = this.el.nativeElement;
    if (isPresent4(wrapper)) {
      wrapper.focus();
    }
  }
  /**
   * Brings the current Window component on top of other Window components on the page.
   */
  bringToFront() {
    this.setNextZIndex();
  }
  /**
   * Manually updates the `width` or `height` option of the Window.
   * The required style will be applied to the Window wrapper element and the
   * corresponding property of the component instance will be updated.
   * This method is intended to be used for sizing dynamically created components using the
   * [`WindowService`]({% slug api_dialog_windowservice %})
   * @param {WindowDimensionSetting} dimension - The option that will be updated
   * @param {number} value - The value set in pixels
   */
  setDimension(dimension, value) {
    this.setOption(dimension, value);
    this.setStyle(dimension, value);
  }
  /**
   * Manually updates the `top` or `left` offset of the Window.
   * The required style will be applied to the Window wrapper element and the
   * corresponding property of the component instance will be updated.
   * This method is intended to be used for positioning dynamically created components using the
   * [`WindowService`]({% slug api_dialog_windowservice %})
   * @param {WindowOffsetSetting} offset - The option that will be updated
   * @param {number} value - The value set in pixels
   */
  setOffset(offset, value) {
    this.setOption(offset, value);
    this.setStyle(offset, value);
  }
  get showDefaultTitleBar() {
    return !isPresent4(this.titleBarContent);
  }
  get styleMinWidth() {
    return this.minWidth + "px";
  }
  get styleMinHeight() {
    return this.minHeight + "px";
  }
  get stylePosition() {
    return this.options.position;
  }
  get wrapperMaximizedClass() {
    return this.state === "maximized";
  }
  get wrapperMinimizedClass() {
    return this.state === "minimized";
  }
  /**
   * @hidden
   */
  onComponentFocus() {
    this.renderer.addClass(this.el.nativeElement, "k-focus");
    this.setNextZIndex();
  }
  /**
   * @hidden
   */
  onComponentBlur() {
    this.renderer.removeClass(this.el.nativeElement, "k-focus");
  }
  subscribeEvents() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.windowSubscription.add(this.service.focus.subscribe(() => {
      this.el.nativeElement.focus();
    }));
    this.windowSubscription.add(this.service.dragStart.subscribe(() => {
      this.draged = true;
      this.ngZone.run(() => {
        this.dragStart.emit();
      });
    }));
    this.windowSubscription.add(this.service.dragEnd.subscribe(() => {
      if (this.draged) {
        this.draged = false;
        this.ngZone.run(() => {
          this.dragEnd.emit();
        });
      }
    }));
    this.windowSubscription.add(this.service.close.subscribe(() => {
      this.close.emit();
    }));
    this.windowSubscription.add(this.service.resizeStart.subscribe(() => {
      this.resized = true;
      this.ngZone.run(() => {
        this.resizeStart.emit();
      });
    }));
    this.windowSubscription.add(this.service.resizeEnd.subscribe(() => {
      if (this.resized) {
        this.resized = false;
        this.ngZone.run(() => {
          this.resizeEnd.emit();
        });
      }
    }));
    this.windowSubscription.add(this.service.change.subscribe((ev) => {
      OFFSET_STYLES.forEach((style2) => {
        if (isPresent4(ev[style2])) {
          this.setStyle(style2, ev[style2]);
          if (this.state !== "maximized") {
            const emitter = this[style2 + "Change"];
            if (emitter.observers.length) {
              this.ngZone.run(() => {
                emitter.emit(ev[style2]);
              });
            }
          }
        }
      });
    }));
    this.windowSubscription.add(this.service.stateChange.subscribe((state2) => {
      if (isPresent4(this.service.lastAction)) {
        this.updateAllOffset();
        this.stateChange.emit(state2);
      }
    }));
  }
  initDomEvents() {
    if (!this.el) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      this.domSubs.add(this.renderer.listen(this.el.nativeElement, "keydown", (ev) => {
        this.onKeyDown(ev);
      }));
    });
  }
  onKeyDown(event) {
    this.navigation.process(event);
  }
  setServiceClasses(prevValue, value) {
    const el = this.el.nativeElement;
    if (prevValue) {
      parseCSSClassNames2(prevValue).forEach((className) => {
        this.renderer.removeClass(el, className);
      });
    }
    if (value) {
      parseCSSClassNames2(value).forEach((className) => {
        this.renderer.addClass(el, className);
      });
    }
  }
  setNextZIndex() {
    const currentZIndex = this.el.nativeElement.style["z-index"];
    const nextPossibleZIndex = this.service.nextPossibleZIndex;
    if (!currentZIndex || nextPossibleZIndex - currentZIndex > 1) {
      this.renderer.setStyle(this.el.nativeElement, "z-index", this.service.nextZIndex);
    }
  }
  setInitialOffset() {
    if (this.state !== "maximized") {
      this.updateAllOffset();
      if (!isPresent4(this.left) || !isPresent4(this.top)) {
        this.service.center();
      }
    } else {
      const viewPort = this.service.windowViewPort;
      this.setStyle("width", viewPort.width);
      this.setStyle("height", viewPort.height);
      this.setStyle("top", 0);
      this.setStyle("left", 0);
    }
  }
  updateAllOffset() {
    OFFSET_STYLES.forEach((style2) => {
      if (isPresent4(this[style2])) {
        this.setStyle(style2, this[style2]);
      } else {
        this.removeStyle(style2);
      }
    });
  }
  setStyle(style2, value) {
    this.renderer.setStyle(this.el.nativeElement, style2, value + "px");
  }
  removeStyle(style2) {
    this.renderer.removeStyle(this.el.nativeElement, style2);
  }
  get options() {
    return this.service.options;
  }
  setOption(style2, value) {
    if (typeof value !== "number" && typeof value !== "string") {
      return;
    }
    const parsedValue = typeof value === "number" ? value : parseInt(value, 10);
    this.options[style2] = parsedValue;
    this.service.setRestoreOption(style2, parsedValue);
  }
  handleInitialFocus() {
    const wrapper = this.el.nativeElement;
    if (this.autoFocusedElement) {
      const initiallyFocusedElement = wrapper.querySelector(this.autoFocusedElement);
      if (initiallyFocusedElement) {
        initiallyFocusedElement.focus();
      }
    } else {
      this.focus();
    }
  }
  /**
   * @hidden
   */
  generateTitleId() {
    return "kendo-window-title-" + Math.ceil(Math.random() * 1e6).toString();
  }
  handleThemeColorClass(previousValue, currentValue) {
    const wrapper = this.el.nativeElement;
    if (previousValue) {
      const classToRemove = `k-window-${previousValue}`;
      this.renderer.removeClass(wrapper, classToRemove);
    }
    if (currentValue) {
      const classToAdd = `k-window-${currentValue}`;
      this.renderer.addClass(wrapper, classToAdd);
    }
  }
  static ɵfac = function WindowComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _WindowComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DragResizeService), ɵɵdirectiveInject(NavigationService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _WindowComponent,
    selectors: [["kendo-window"]],
    contentQueries: function WindowComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, WindowTitleBarComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.titleBarContent = _t.first);
      }
    },
    viewQuery: function WindowComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(WindowTitleBarComponent, 5);
        ɵɵviewQuery(ResizeHandleDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.titleBarView = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.resizeHandles = _t);
      }
    },
    hostVars: 15,
    hostBindings: function WindowComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("focus", function WindowComponent_focus_HostBindingHandler() {
          return ctx.onComponentFocus();
        })("blur", function WindowComponent_blur_HostBindingHandler() {
          return ctx.onComponentBlur();
        });
      }
      if (rf & 2) {
        ɵɵattribute("tabIndex", ctx.tabIndex)("role", ctx.role)("dir", ctx.dir);
        ɵɵstyleProp("min-width", ctx.styleMinWidth)("min-height", ctx.styleMinHeight)("position", ctx.stylePosition);
        ɵɵclassProp("k-window", ctx.hostClass)("k-window-maximized", ctx.wrapperMaximizedClass)("k-window-minimized", ctx.wrapperMinimizedClass);
      }
    },
    inputs: {
      autoFocusedElement: "autoFocusedElement",
      title: "title",
      draggable: "draggable",
      resizable: "resizable",
      themeColor: "themeColor",
      keepContent: "keepContent",
      state: "state",
      minWidth: "minWidth",
      minHeight: "minHeight",
      width: "width",
      height: "height",
      top: "top",
      left: "left"
    },
    outputs: {
      dragStart: "dragStart",
      dragEnd: "dragEnd",
      resizeStart: "resizeStart",
      resizeEnd: "resizeEnd",
      close: "close",
      widthChange: "widthChange",
      heightChange: "heightChange",
      topChange: "topChange",
      leftChange: "leftChange",
      stateChange: "stateChange"
    },
    exportAs: ["kendoWindow"],
    features: [ɵɵProvidersFeature([DragResizeService, NavigationService, LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.window"
    }]), ɵɵNgOnChangesFeature],
    ngContentSelectors: _c102,
    decls: 7,
    vars: 5,
    consts: () => {
      let i18n_2;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_2 = goog.getMsg("Close");
        i18n_2 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_2;
      } else {
        i18n_2 = $localize`:kendo.window.closeTitle|The title of the close button:Close`;
      }
      let i18n_3;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_3 = goog.getMsg("Restore");
        i18n_3 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_3;
      } else {
        i18n_3 = $localize`:kendo.window.restoreTitle|The title of the restore button:Restore`;
      }
      let i18n_4;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_4 = goog.getMsg("Maximize");
        i18n_4 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_4;
      } else {
        i18n_4 = $localize`:kendo.window.maximizeTitle|The title of the maximize button:Maximize`;
      }
      let i18n_5;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_5 = goog.getMsg("Minimize");
        i18n_5 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_5;
      } else {
        i18n_5 = $localize`:kendo.window.minimizeTitle|The title of the minimize button:Minimize`;
      }
      return [["kendoWindowLocalizedMessages", "", "closeTitle", i18n_2, "restoreTitle", i18n_3, "maximizeTitle", i18n_4, "minimizeTitle", i18n_5], [3, "template", "id", 4, "ngIf"], [4, "ngIf"], ["class", "k-window-content", 3, "hidden", 4, "ngIf"], [3, "ngIf"], ["kendoWatermarkOverlay", "", 4, "ngIf"], [3, "template", "id"], [1, "k-window-title"], [1, "k-window-titlebar-actions"], ["kendoWindowMinimizeAction", ""], ["kendoWindowMaximizeAction", ""], ["kendoWindowRestoreAction", ""], ["kendoWindowCloseAction", ""], [1, "k-window-content", 3, "hidden"], [3, "ngTemplateOutlet"], ["kendoWindowResizeHandle", "", "kendoDraggable", "", 3, "direction", 4, "ngFor", "ngForOf"], ["kendoWindowResizeHandle", "", "kendoDraggable", "", 3, "direction"], ["kendoWatermarkOverlay", ""]];
    },
    template: function WindowComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c92);
        ɵɵelementContainerStart(0, 0)(1);
        ɵɵtemplate(2, WindowComponent_kendo_window_titlebar_2_Template, 8, 11, "kendo-window-titlebar", 1)(3, WindowComponent_ng_content_3_Template, 1, 0, "ng-content", 2)(4, WindowComponent_div_4_Template, 3, 3, "div", 3)(5, WindowComponent_ng_template_5_Template, 1, 1, "ng-template", 4)(6, WindowComponent_div_6_Template, 1, 0, "div", 5);
        ɵɵelementContainerEnd()();
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.showDefaultTitleBar);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.showDefaultTitleBar);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.state !== "minimized" || ctx.keepContent);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.resizable);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showLicenseWatermark);
      }
    },
    dependencies: [LocalizedMessagesDirective, NgIf, WindowTitleBarComponent, WindowMinimizeActionDirective, WindowMaximizeActionDirective, WindowRestoreActionDirective, WindowCloseActionDirective, NgTemplateOutlet, NgForOf, ResizeHandleDirective, DraggableDirective, WatermarkOverlayComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WindowComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoWindow",
      providers: [DragResizeService, NavigationService, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.window"
      }],
      selector: "kendo-window",
      template: `
        <ng-container kendoWindowLocalizedMessages
            i18n-closeTitle="kendo.window.closeTitle|The title of the close button"
            closeTitle="Close"

            i18n-restoreTitle="kendo.window.restoreTitle|The title of the restore button"
            restoreTitle="Restore"

            i18n-maximizeTitle="kendo.window.maximizeTitle|The title of the maximize button"
            maximizeTitle="Maximize"

            i18n-minimizeTitle="kendo.window.minimizeTitle|The title of the minimize button"
            minimizeTitle="Minimize"
        >
        <ng-container>

        <kendo-window-titlebar *ngIf="showDefaultTitleBar" [template]="titleBarTemplate" [id]="titleId">
            <span class="k-window-title">{{ title }}</span>
            <div class="k-window-titlebar-actions">
                <button kendoWindowMinimizeAction  [attr.title]="minimizeButtonTitle" [attr.aria-label]="minimizeButtonTitle"></button>
                <button kendoWindowMaximizeAction [attr.title]="maximizeButtonTitle" [attr.aria-label]="maximizeButtonTitle"></button>
                <button kendoWindowRestoreAction [attr.title]="restoreButtonTitle" [attr.aria-label]="restoreButtonTitle"></button>
                <button kendoWindowCloseAction [attr.title]="closeButtonTitle" [attr.aria-label]="closeButtonTitle"></button>
            </div>
        </kendo-window-titlebar>
        <ng-content select="kendo-window-titlebar" *ngIf="!showDefaultTitleBar"></ng-content>

        <div *ngIf="state !== 'minimized' || keepContent"
            [hidden]="state === 'minimized' && keepContent"
            class="k-window-content"
        >
            <ng-content *ngIf="!contentTemplate"></ng-content>
            <ng-template [ngTemplateOutlet]="contentTemplate" *ngIf="contentTemplate"></ng-template>
        </div>

        <ng-template [ngIf]='resizable'>
            <div *ngFor='let dir of resizeDirections'
                [direction]="dir"
                kendoWindowResizeHandle
                kendoDraggable>
            </div>
        </ng-template>

        <div kendoWatermarkOverlay *ngIf="showLicenseWatermark"></div>
    `,
      standalone: true,
      imports: [LocalizedMessagesDirective, NgIf, WindowTitleBarComponent, WindowMinimizeActionDirective, WindowMaximizeActionDirective, WindowRestoreActionDirective, WindowCloseActionDirective, NgTemplateOutlet, NgForOf, ResizeHandleDirective, DraggableDirective, WatermarkOverlayComponent]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: DragResizeService
    }, {
      type: NavigationService
    }, {
      type: NgZone
    }, {
      type: LocalizationService
    }];
  }, {
    autoFocusedElement: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    draggable: [{
      type: Input
    }],
    resizable: [{
      type: Input
    }],
    themeColor: [{
      type: Input
    }],
    keepContent: [{
      type: Input
    }],
    state: [{
      type: Input
    }],
    minWidth: [{
      type: Input
    }],
    minHeight: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    top: [{
      type: Input
    }],
    left: [{
      type: Input
    }],
    dragStart: [{
      type: Output
    }],
    dragEnd: [{
      type: Output
    }],
    resizeStart: [{
      type: Output
    }],
    resizeEnd: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    widthChange: [{
      type: Output
    }],
    heightChange: [{
      type: Output
    }],
    topChange: [{
      type: Output
    }],
    leftChange: [{
      type: Output
    }],
    stateChange: [{
      type: Output
    }],
    tabIndex: [{
      type: HostBinding,
      args: ["attr.tabIndex"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-window"]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    titleBarView: [{
      type: ViewChild,
      args: [WindowTitleBarComponent, {
        static: false
      }]
    }],
    titleBarContent: [{
      type: ContentChild,
      args: [WindowTitleBarComponent, {
        static: false
      }]
    }],
    resizeHandles: [{
      type: ViewChildren,
      args: [ResizeHandleDirective]
    }],
    styleMinWidth: [{
      type: HostBinding,
      args: ["style.minWidth"]
    }],
    styleMinHeight: [{
      type: HostBinding,
      args: ["style.minHeight"]
    }],
    stylePosition: [{
      type: HostBinding,
      args: ["style.position"]
    }],
    wrapperMaximizedClass: [{
      type: HostBinding,
      args: ["class.k-window-maximized"]
    }],
    wrapperMinimizedClass: [{
      type: HostBinding,
      args: ["class.k-window-minimized"]
    }],
    onComponentFocus: [{
      type: HostListener,
      args: ["focus"]
    }],
    onComponentBlur: [{
      type: HostListener,
      args: ["blur"]
    }]
  });
})();
var WindowCloseResult = class {
};
var WindowRef = class {
  /**
   * A reference to the Window instance.
   */
  window;
  /**
   * A reference to the child component of the Window.
   * Available when the Window is opened with
   * [component content](slug:service_window#toc-rendering-the-content-area).
   */
  content;
  /**
   * Allows you to close the Window by using code.
   * When called with no arguments,
   * the `result` Observable will be of type WindowCloseResult.
   * When called with an argument, the `result` Observable will hold the provided value.
   */
  close;
  /**
   * Emits events when the Window is closed through the **Esc** key, the **Close** button of the title bar or
   * by calling the `close` method.
   * When the Window is closed with the title bar button, **Esc** or by calling `close` with no arguments,
   * the result is of type [WindowCloseResult]({% slug api_dialog_windowcloseresult %}).
   * When `close` is called with an argument, the result is the passed argument.
   */
  result;
};
var WindowContainerService = class _WindowContainerService {
  static container = null;
  set container(container) {
    _WindowContainerService.container = container;
  }
  get container() {
    return _WindowContainerService.container;
  }
  static ɵfac = function WindowContainerService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _WindowContainerService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _WindowContainerService,
    factory: _WindowContainerService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WindowContainerService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var isNotComponent = (component) => isString2(component) || component instanceof TemplateRef;
var WindowInjector = class {
  getWindowRef;
  parentInjector;
  constructor(getWindowRef, parentInjector) {
    this.getWindowRef = getWindowRef;
    this.parentInjector = parentInjector;
  }
  get(token3, notFoundValue) {
    if (token3 === WindowRef) {
      return this.getWindowRef();
    }
    return this.parentInjector.get(token3, notFoundValue);
  }
};
var WindowService = class _WindowService {
  resolver;
  containerService;
  constructor(resolver, containerService) {
    this.resolver = resolver;
    this.containerService = containerService;
  }
  /**
   * Opens a Window component.
   *
   * @param {WindowSettings} settings - The settings that define the Window.
   * @returns {WindowRef} - A reference to the Window object.
   *
   * @example
   *
   * ```ts-no-run
   * _@Component({
   *   selector: 'my-app',
   *   template: `
   *     <button kendoButton (click)="open()">Open window</button>
   *     <div kendoWindowContainer></div>
   *   `
   * })
   * export class AppComponent {
   *     constructor( private windowService: WindowService ) {}
   *
   *     public open() {
   *         var window = this.windowService.open({
   *           title: "My window",
   *           content: "My content!"
   *         });
   *
   *         window.result.subscribe((result) => {
   *           if (result instanceof WindowCloseResult) {
   *             console.log("Window was closed");
   *           }
   *         });
   *     }
   * }
   * ```
   *
   */
  open(settings) {
    const factory = this.resolver.resolveComponentFactory(WindowComponent);
    const container = settings.appendTo || this.containerService.container;
    if (!container) {
      throw new Error(`Cannot attach window to the page.
                Add an element that uses the kendoWindowContainer directive, or set the 'appendTo' property.
                See https://www.telerik.com/kendo-angular-ui/components/dialogs/window/service/
            `);
    }
    const windowRef = {
      close: () => {
      },
      content: null,
      result: null,
      window: null
    };
    const content = this.contentFrom(settings.content, container, windowRef);
    const window2 = container.createComponent(factory, void 0, void 0, content.nodes);
    windowRef.window = window2;
    this.applyOptions(window2.instance, settings);
    const apiClose = new Subject();
    const close2 = (e) => {
      apiClose.next(e || new WindowCloseResult());
      if (content.componentRef) {
        content.componentRef.destroy();
      }
      window2.destroy();
    };
    const result = merge(apiClose, window2.instance.close.pipe(map((e) => e ? e : new WindowCloseResult()), filter((e) => {
      if (settings.preventClose) {
        const windowRefParameter = isNotComponent(settings.content) ? void 0 : windowRef;
        return !settings.preventClose(e, windowRefParameter);
      }
      return true;
    }))).pipe(
      take(1),
      // Takes care for multiple subscriptions:
      // We subscribe internally and the user may subscribe to get a close result - window.result.subscribe().
      // This causes multiple subscriptions to the same source and thus multiple emissions. share() solves that.
      share()
    );
    result.subscribe(close2);
    windowRef.close = close2;
    windowRef.result = result;
    window2.changeDetectorRef.markForCheck();
    return windowRef;
  }
  applyOptions(instance4, options2) {
    if (isPresent4(options2.htmlAttributes)) {
      instance4.htmlAttributes = options2.htmlAttributes;
    }
    if (isPresent4(options2.cssClass)) {
      instance4.cssClass = options2.cssClass;
    }
    if (isPresent4(options2.title)) {
      instance4.title = options2.title;
    }
    if (isPresent4(options2.keepContent)) {
      instance4.keepContent = options2.keepContent;
    }
    if (isPresent4(options2.width)) {
      instance4.width = options2.width;
    }
    if (isPresent4(options2.minWidth)) {
      instance4.minWidth = options2.minWidth;
    }
    if (isPresent4(options2.height)) {
      instance4.height = options2.height;
    }
    if (isPresent4(options2.minHeight)) {
      instance4.minHeight = options2.minHeight;
    }
    if (isPresent4(options2.left)) {
      instance4.left = options2.left;
    }
    if (isPresent4(options2.top)) {
      instance4.top = options2.top;
    }
    if (isPresent4(options2.draggable)) {
      instance4.draggable = options2.draggable;
    }
    if (isPresent4(options2.resizable)) {
      instance4.resizable = options2.resizable;
    }
    if (isPresent4(options2.messages && options2.messages.closeTitle)) {
      instance4.messages.closeTitle = options2.messages.closeTitle;
    }
    if (isPresent4(options2.messages && options2.messages.restoreTitle)) {
      instance4.messages.restoreTitle = options2.messages.restoreTitle;
    }
    if (isPresent4(options2.messages && options2.messages.maximizeTitle)) {
      instance4.messages.maximizeTitle = options2.messages.maximizeTitle;
    }
    if (isPresent4(options2.messages && options2.messages.minimizeTitle)) {
      instance4.messages.minimizeTitle = options2.messages.minimizeTitle;
    }
    if (isPresent4(options2.autoFocusedElement)) {
      instance4.autoFocusedElement = options2.autoFocusedElement;
    }
    if (isPresent4(options2.state)) {
      instance4.state = options2.state;
      if (options2.state === "minimized") {
        instance4.keepContent = true;
      }
    }
    if (isPresent4(options2.themeColor)) {
      instance4.themeColor = options2.themeColor;
    }
    if (options2.content instanceof TemplateRef) {
      instance4.contentTemplate = options2.content;
    }
    if (options2.titleBarContent instanceof TemplateRef) {
      instance4.titleBarTemplate = options2.titleBarContent;
    }
  }
  contentFrom(content, container, windowRef) {
    const renderer = container.injector.get(Renderer2);
    let nodes = [];
    let componentRef = null;
    if (typeof content === "string") {
      nodes = [renderer.createText(content)];
    } else if (content && !(content instanceof TemplateRef)) {
      const injector = new WindowInjector(() => windowRef, container.injector);
      const factory = this.resolver.resolveComponentFactory(content);
      componentRef = container.createComponent(factory, void 0, injector);
      nodes = [componentRef.location.nativeElement];
      windowRef.content = componentRef;
    }
    return {
      componentRef,
      nodes: [
        [],
        nodes
        // Content
      ]
    };
  }
  static ɵfac = function WindowService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _WindowService)(ɵɵinject(ComponentFactoryResolver$1), ɵɵinject(WindowContainerService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _WindowService,
    factory: _WindowService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WindowService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: ComponentFactoryResolver$1
    }, {
      type: WindowContainerService,
      decorators: [{
        type: Inject,
        args: [WindowContainerService]
      }]
    }];
  }, null);
})();
var DialogContainerDirective = class _DialogContainerDirective {
  constructor(container, service) {
    service.container = container;
  }
  static ɵfac = function DialogContainerDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DialogContainerDirective)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(DialogContainerService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DialogContainerDirective,
    selectors: [["", "kendoDialogContainer", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DialogContainerDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDialogContainer]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: DialogContainerService
    }];
  }, null);
})();
var CustomMessagesComponent = class _CustomMessagesComponent extends Messages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function CustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CustomMessagesComponent,
    selectors: [["kendo-dialog-messages"], ["kendo-window-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: Messages,
      useExisting: forwardRef(() => _CustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CustomMessagesComponent, [{
    type: Directive,
    args: [{
      providers: [{
        provide: Messages,
        useExisting: forwardRef(() => CustomMessagesComponent)
      }],
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-dialog-messages, kendo-window-messages",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var WindowContainerDirective = class _WindowContainerDirective {
  constructor(container, service) {
    service.container = container;
  }
  static ɵfac = function WindowContainerDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _WindowContainerDirective)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(WindowContainerService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _WindowContainerDirective,
    selectors: [["", "kendoWindowContainer", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WindowContainerDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoWindowContainer]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: WindowContainerService
    }];
  }, null);
})();
var KENDO_DIALOG = [DialogComponent, DialogTitleBarComponent, DialogContainerDirective, DialogActionsComponent, CustomMessagesComponent];
var KENDO_WINDOW = [WindowComponent, WindowCloseActionDirective, WindowMinimizeActionDirective, WindowMaximizeActionDirective, WindowRestoreActionDirective, WindowTitleBarComponent, WindowContainerDirective, DialogActionsComponent, CustomMessagesComponent];
var KENDO_DIALOGS = [...KENDO_DIALOG, ...KENDO_WINDOW];
var DialogModule = class _DialogModule {
  static ɵfac = function DialogModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DialogModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DialogModule,
    imports: [DialogComponent, DialogTitleBarComponent, DialogContainerDirective, DialogActionsComponent, CustomMessagesComponent],
    exports: [DialogComponent, DialogTitleBarComponent, DialogContainerDirective, DialogActionsComponent, CustomMessagesComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [DialogContainerService, DialogService, IconsService],
    imports: [DialogComponent, DialogTitleBarComponent, DialogActionsComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DialogModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_DIALOG],
      imports: [...KENDO_DIALOG],
      providers: [DialogContainerService, DialogService, IconsService]
    }]
  }], null, null);
})();
var WindowModule = class _WindowModule {
  static ɵfac = function WindowModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _WindowModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _WindowModule,
    imports: [WindowComponent, WindowCloseActionDirective, WindowMinimizeActionDirective, WindowMaximizeActionDirective, WindowRestoreActionDirective, WindowTitleBarComponent, WindowContainerDirective, DialogActionsComponent, CustomMessagesComponent],
    exports: [WindowComponent, WindowCloseActionDirective, WindowMinimizeActionDirective, WindowMaximizeActionDirective, WindowRestoreActionDirective, WindowTitleBarComponent, WindowContainerDirective, DialogActionsComponent, CustomMessagesComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [WindowContainerService, WindowService, IconsService],
    imports: [WindowComponent, WindowCloseActionDirective, WindowMinimizeActionDirective, WindowMaximizeActionDirective, WindowRestoreActionDirective, DialogActionsComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WindowModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_WINDOW],
      exports: [...KENDO_WINDOW],
      providers: [WindowContainerService, WindowService, IconsService]
    }]
  }], null, null);
})();
var DialogsModule = class _DialogsModule {
  static ɵfac = function DialogsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DialogsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DialogsModule,
    imports: [DialogComponent, DialogTitleBarComponent, DialogContainerDirective, DialogActionsComponent, CustomMessagesComponent, WindowComponent, WindowCloseActionDirective, WindowMinimizeActionDirective, WindowMaximizeActionDirective, WindowRestoreActionDirective, WindowTitleBarComponent, WindowContainerDirective, DialogActionsComponent, CustomMessagesComponent],
    exports: [DialogComponent, DialogTitleBarComponent, DialogContainerDirective, DialogActionsComponent, CustomMessagesComponent, WindowComponent, WindowCloseActionDirective, WindowMinimizeActionDirective, WindowMaximizeActionDirective, WindowRestoreActionDirective, WindowTitleBarComponent, WindowContainerDirective, DialogActionsComponent, CustomMessagesComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, DialogService, DialogContainerService, WindowService, WindowContainerService],
    imports: [DialogComponent, DialogTitleBarComponent, DialogActionsComponent, WindowComponent, WindowCloseActionDirective, WindowMinimizeActionDirective, WindowMaximizeActionDirective, WindowRestoreActionDirective, DialogActionsComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DialogsModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_DIALOGS],
      exports: [...KENDO_DIALOGS],
      providers: [IconsService, DialogService, DialogContainerService, WindowService, WindowContainerService]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-angular-inputs/fesm2022/progress-kendo-angular-inputs.mjs
var _c04 = ["wrap"];
var _c17 = ["track"];
var _c23 = ["sliderSelection"];
var _c33 = ["ticks"];
var _c43 = ["tickElement"];
var _c53 = ["kendoSliderTicks", ""];
function SliderTicksComponent_li_0_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 7);
    ɵɵelementContainer(1, 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tick_r1 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    const defaultLabel_r3 = ɵɵreference(2);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.labelTemplate || defaultLabel_r3)("ngTemplateOutletContext", tick_r1);
  }
}
function SliderTicksComponent_li_0_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1, " ");
    ɵɵelementContainerEnd();
  }
}
function SliderTicksComponent_li_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 3, 1);
    ɵɵelementContainerStart(2, 4);
    ɵɵtemplate(3, SliderTicksComponent_li_0_span_3_Template, 2, 2, "span", 5)(4, SliderTicksComponent_li_0_ng_container_4_Template, 2, 0, "ng-container", 6);
    ɵɵelementContainerEnd();
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tick_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵpropertyInterpolate("title", ctx_r1.tickTitle(tick_r1.value));
    ɵɵproperty("ngClass", tick_r1.classes);
    ɵɵadvance(2);
    ɵɵproperty("ngSwitch", tick_r1.large);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", true);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", false);
  }
}
function SliderTicksComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const value_r4 = ctx.value;
    const ctx_r1 = ɵɵnextContext();
    ɵɵtextInterpolate1(" ", ctx_r1.tickTitle(value_r4), " ");
  }
}
var _c63 = ["draghandle"];
var _c73 = ["decreaseButton"];
var _c83 = ["increaseButton"];
var _c93 = (a0, a1) => ({
  click: a0,
  keydown: a1
});
function SliderComponent_button_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "button", 16, 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("icon", ctx_r1.decreaseButtonArrowIcon)("svgIcon", ctx_r1.decreaseButtonArrowSVGIcon)("title", ctx_r1.decrementMessage);
    ɵɵattribute("tabindex", -1);
  }
}
function SliderComponent_ul_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "ul", 17, 5);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("tickTitle", ctx_r1.title)("vertical", ctx_r1.vertical)("step", ctx_r1.smallStep)("largeStep", ctx_r1.largeStep)("min", ctx_r1.min)("max", ctx_r1.max)("labelTemplate", ctx_r1.labelTemplate == null ? null : ctx_r1.labelTemplate.templateRef);
  }
}
function SliderComponent_button_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "button", 18, 6);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("icon", ctx_r1.increaseButtonArrowIcon)("svgIcon", ctx_r1.increaseButtonArrowSVGIcon)("title", ctx_r1.incrementMessage);
    ɵɵattribute("tabindex", -1);
  }
}
var _c103 = ["draghandleStart"];
var _c112 = ["draghandleEnd"];
function RangeSliderComponent_ul_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "ul", 13, 5);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("tickTitle", ctx_r1.title)("vertical", ctx_r1.vertical)("step", ctx_r1.smallStep)("largeStep", ctx_r1.largeStep)("min", ctx_r1.min)("max", ctx_r1.max)("labelTemplate", ctx_r1.labelTemplate == null ? null : ctx_r1.labelTemplate.templateRef);
    ɵɵattribute("aria-hidden", true);
  }
}
var _c122 = ["thumb"];
var _c132 = ["numericInput"];
var _c142 = (a0, a1, a2, a3, a4, a5, a6) => ({
  mousedown: a0,
  dragenter: a1,
  keydown: a2,
  input: a3,
  focus: a4,
  blur: a5,
  paste: a6
});
var _c152 = (a0, a1) => ({
  mouseup: a0,
  mouseleave: a1
});
var _c162 = (a0) => ({
  mousedown: a0
});
function NumericTextBoxComponent_span_2_ng_template_1_Template(rf, ctx) {
}
function NumericTextBoxComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 8);
    ɵɵtemplate(1, NumericTextBoxComponent_span_2_ng_template_1_Template, 0, 0, "ng-template", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.prefixTemplate == null ? null : ctx_r1.prefixTemplate.templateRef);
  }
}
function NumericTextBoxComponent_kendo_input_separator_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-input-separator");
  }
}
function NumericTextBoxComponent_kendo_input_separator_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-input-separator");
  }
}
function NumericTextBoxComponent_span_7_ng_template_1_Template(rf, ctx) {
}
function NumericTextBoxComponent_span_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 10);
    ɵɵtemplate(1, NumericTextBoxComponent_span_7_ng_template_1_Template, 0, 0, "ng-template", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.suffixTemplate == null ? null : ctx_r1.suffixTemplate.templateRef);
  }
}
function NumericTextBoxComponent_span_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 11)(1, "button", 12);
    ɵɵelement(2, "kendo-icon-wrapper", 13);
    ɵɵelementEnd();
    ɵɵelementStart(3, "button", 14);
    ɵɵelement(4, "kendo-icon-wrapper", 15);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction2(15, _c152, ctx_r1.releaseArrow, ctx_r1.releaseArrow));
    ɵɵadvance();
    ɵɵclassProp("k-active", ctx_r1.arrowDirection === ctx_r1.ArrowDirection.Up);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(18, _c162, ctx_r1.increasePress))("title", ctx_r1.incrementTitle);
    ɵɵattribute("aria-hidden", true)("aria-label", ctx_r1.incrementTitle);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.arrowUpIcon);
    ɵɵadvance();
    ɵɵclassProp("k-active", ctx_r1.arrowDirection === ctx_r1.ArrowDirection.Down);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(20, _c162, ctx_r1.decreasePress))("title", ctx_r1.decrementTitle);
    ɵɵattribute("aria-hidden", true)("aria-label", ctx_r1.decrementTitle);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.arrowDownIcon);
  }
}
var _c172 = ["input"];
var _c18 = (a0, a1, a2, a3, a4) => ({
  focus: a0,
  blur: a1,
  click: a2,
  dragstart: a3,
  drop: a4
});
function MaskedTextBoxComponent_span_1_ng_template_1_Template(rf, ctx) {
}
function MaskedTextBoxComponent_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 6);
    ɵɵtemplate(1, MaskedTextBoxComponent_span_1_ng_template_1_Template, 0, 0, "ng-template", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.prefixTemplate == null ? null : ctx_r1.prefixTemplate.templateRef);
  }
}
function MaskedTextBoxComponent_kendo_input_separator_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-input-separator");
  }
}
function MaskedTextBoxComponent_kendo_input_separator_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-input-separator");
  }
}
function MaskedTextBoxComponent_span_6_ng_template_1_Template(rf, ctx) {
}
function MaskedTextBoxComponent_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 8);
    ɵɵtemplate(1, MaskedTextBoxComponent_span_6_ng_template_1_Template, 0, 0, "ng-template", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.suffixTemplate == null ? null : ctx_r1.suffixTemplate.templateRef);
  }
}
var _c19 = (a0, a1) => ({
  blur: a0,
  change: a1
});
var _c20 = (a0, a1, a2) => ({
  focus: a0,
  blur: a1,
  input: a2
});
function TextBoxComponent_span_2_ng_template_1_Template(rf, ctx) {
}
function TextBoxComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 9);
    ɵɵtemplate(1, TextBoxComponent_span_2_ng_template_1_Template, 0, 0, "ng-template", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.prefix == null ? null : ctx_r1.prefix.templateRef);
  }
}
function TextBoxComponent_kendo_input_separator_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-input-separator");
  }
}
function TextBoxComponent_span_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 11);
    ɵɵlistener("click", function TextBoxComponent_span_6_Template_span_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearValue());
    })("mousedown", function TextBoxComponent_span_6_Template_span_mousedown_0_listener($event) {
      ɵɵrestoreView(_r3);
      return ɵɵresetView($event.preventDefault());
    })("keydown.enter", function TextBoxComponent_span_6_Template_span_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearValue($event));
    })("keydown.space", function TextBoxComponent_span_6_Template_span_keydown_space_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearValue($event));
    });
    ɵɵelement(1, "kendo-icon-wrapper", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("tabindex", ctx_r1.tabIndex)("title", ctx_r1.clearTitle());
    ɵɵattribute("aria-label", ctx_r1.clearTitle());
    ɵɵadvance();
    ɵɵproperty("name", ctx_r1.clearButtonClass)("customFontClass", ctx_r1.customClearButtonClasses)("svgIcon", ctx_r1.clearButtonSvgIcon || ctx_r1.svgIcon("xIcon"));
  }
}
function TextBoxComponent_kendo_icon_wrapper_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 13);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r1.errorIconClasses)("customFontClass", ctx_r1.customIconClasses)("svgIcon", ctx_r1.errorSvgIcon || ctx_r1.svgIcon("exclamationCircleIcon"));
  }
}
function TextBoxComponent_kendo_icon_wrapper_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 13);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r1.successIconClasses)("customFontClass", ctx_r1.customSuccessIconClasses)("svgIcon", ctx_r1.successSvgIcon || ctx_r1.svgIcon("checkIcon"));
  }
}
function TextBoxComponent_kendo_input_separator_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-input-separator");
  }
}
function TextBoxComponent_span_10_ng_template_1_Template(rf, ctx) {
}
function TextBoxComponent_span_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 14);
    ɵɵtemplate(1, TextBoxComponent_span_10_ng_template_1_Template, 0, 0, "ng-template", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.suffix == null ? null : ctx_r1.suffix.templateRef);
  }
}
var _c21 = ["opacityInput"];
var _c222 = ["hexInput"];
var _c232 = ["blue"];
var _c24 = ["toggleFormatButton"];
function ColorInputComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 10)(1, "kendo-textbox", 11, 1);
    ɵɵlistener("blur", function ColorInputComponent_div_3_Template_kendo_textbox_blur_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleHexInputBlur());
    })("input", function ColorInputComponent_div_3_Template_kendo_textbox_input_1_listener() {
      ɵɵrestoreView(_r1);
      const hexInput_r3 = ɵɵreference(2);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleHexValueChange(hexInput_r3.value));
    })("keydown.tab", function ColorInputComponent_div_3_Template_kendo_textbox_keydown_tab_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.focusDragHandle($event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "label", 12);
    ɵɵtext(4, "HEX");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("k-readonly", ctx_r1.readonly);
    ɵɵproperty("focusableId", ctx_r1.focusableId)("size", ctx_r1.size)("disabled", ctx_r1.disabled)("readonly", ctx_r1.readonly)("value", ctx_r1.hex || "")("tabindex", ctx_r1.tabindex);
    ɵɵadvance(2);
    ɵɵproperty("for", ctx_r1.focusableId);
  }
}
function ColorInputComponent_ng_container_4_div_16_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 6)(1, "kendo-numerictextbox", 17, 5);
    ɵɵtwoWayListener("valueChange", function ColorInputComponent_ng_container_4_div_16_Template_kendo_numerictextbox_valueChange_1_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r1.rgba.a, $event) || (ctx_r1.rgba.a = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("blur", function ColorInputComponent_ng_container_4_div_16_Template_kendo_numerictextbox_blur_1_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleRgbaInputBlur());
    })("valueChange", function ColorInputComponent_ng_container_4_div_16_Template_kendo_numerictextbox_valueChange_1_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleRgbaValueChange());
    })("keydown.tab", function ColorInputComponent_ng_container_4_div_16_Template_kendo_numerictextbox_keydown_tab_1_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.focusDragHandle($event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(4, "label", 12);
    ɵɵtext(5, "A");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const alpha_r6 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("localizationService", ctx_r1.localizationService)("disabled", ctx_r1.disabled)("readonly", ctx_r1.readonly)("tabindex", ctx_r1.tabindex)("size", ctx_r1.size)("min", 0)("max", 1);
    ɵɵtwoWayProperty("value", ctx_r1.rgba.a);
    ɵɵproperty("autoCorrect", true)("spinners", false)("step", 0.01)("format", "n2")("decimals", 2);
    ɵɵadvance(3);
    ɵɵproperty("for", alpha_r6.focusableId);
  }
}
function ColorInputComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 6)(2, "kendo-numerictextbox", 13, 2);
    ɵɵtwoWayListener("valueChange", function ColorInputComponent_ng_container_4_Template_kendo_numerictextbox_valueChange_2_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.rgba.r, $event) || (ctx_r1.rgba.r = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("blur", function ColorInputComponent_ng_container_4_Template_kendo_numerictextbox_blur_2_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleRgbaInputBlur());
    })("valueChange", function ColorInputComponent_ng_container_4_Template_kendo_numerictextbox_valueChange_2_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleRgbaValueChange());
    });
    ɵɵelementEnd();
    ɵɵelementStart(4, "label", 12);
    ɵɵtext(5, "R");
    ɵɵelementEnd()();
    ɵɵelementStart(6, "div", 6)(7, "kendo-numerictextbox", 14, 3);
    ɵɵtwoWayListener("valueChange", function ColorInputComponent_ng_container_4_Template_kendo_numerictextbox_valueChange_7_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.rgba.g, $event) || (ctx_r1.rgba.g = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("blur", function ColorInputComponent_ng_container_4_Template_kendo_numerictextbox_blur_7_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleRgbaInputBlur());
    })("valueChange", function ColorInputComponent_ng_container_4_Template_kendo_numerictextbox_valueChange_7_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleRgbaValueChange());
    });
    ɵɵelementEnd();
    ɵɵelementStart(9, "label", 12);
    ɵɵtext(10, "G");
    ɵɵelementEnd()();
    ɵɵelementStart(11, "div", 6)(12, "kendo-numerictextbox", 15, 4);
    ɵɵtwoWayListener("valueChange", function ColorInputComponent_ng_container_4_Template_kendo_numerictextbox_valueChange_12_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.rgba.b, $event) || (ctx_r1.rgba.b = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("blur", function ColorInputComponent_ng_container_4_Template_kendo_numerictextbox_blur_12_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleRgbaInputBlur());
    })("valueChange", function ColorInputComponent_ng_container_4_Template_kendo_numerictextbox_valueChange_12_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleRgbaValueChange());
    })("keydown.tab", function ColorInputComponent_ng_container_4_Template_kendo_numerictextbox_keydown_tab_12_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onTab());
    });
    ɵɵelementEnd();
    ɵɵelementStart(14, "label", 12);
    ɵɵtext(15, "B");
    ɵɵelementEnd()();
    ɵɵtemplate(16, ColorInputComponent_ng_container_4_div_16_Template, 6, 14, "div", 16);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const red_r7 = ɵɵreference(3);
    const green_r8 = ɵɵreference(8);
    const blue_r9 = ɵɵreference(13);
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("localizationService", ctx_r1.localizationService)("disabled", ctx_r1.disabled)("size", ctx_r1.size)("readonly", ctx_r1.readonly)("tabindex", ctx_r1.tabindex)("min", 0)("max", 255);
    ɵɵtwoWayProperty("value", ctx_r1.rgba.r);
    ɵɵproperty("autoCorrect", true)("spinners", false)("format", "n")("decimals", 0);
    ɵɵadvance(2);
    ɵɵproperty("for", red_r7.focusableId);
    ɵɵadvance(3);
    ɵɵproperty("localizationService", ctx_r1.localizationService)("disabled", ctx_r1.disabled)("readonly", ctx_r1.readonly)("tabindex", ctx_r1.tabindex)("size", ctx_r1.size)("min", 0)("max", 255);
    ɵɵtwoWayProperty("value", ctx_r1.rgba.g);
    ɵɵproperty("autoCorrect", true)("spinners", false)("format", "n")("decimals", 0);
    ɵɵadvance(2);
    ɵɵproperty("for", green_r8.focusableId);
    ɵɵadvance(3);
    ɵɵproperty("localizationService", ctx_r1.localizationService)("disabled", ctx_r1.disabled)("readonly", ctx_r1.readonly)("tabindex", ctx_r1.tabindex)("size", ctx_r1.size)("min", 0)("max", 255);
    ɵɵtwoWayProperty("value", ctx_r1.rgba.b);
    ɵɵproperty("autoCorrect", true)("spinners", false)("format", "n")("decimals", 0);
    ɵɵadvance(2);
    ɵɵproperty("for", blue_r9.focusableId);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.opacity);
  }
}
var _c25 = ["kendoContrastValidation", ""];
function ContrastValidationComponent_ng_container_2_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵtext(1);
    ɵɵelement(2, "kendo-icon-wrapper", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.passMessage, " ");
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r0.checkIcon);
  }
}
function ContrastValidationComponent_ng_container_2_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵtext(1);
    ɵɵelement(2, "kendo-icon-wrapper", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.failMessage, " ");
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r0.xCircleIcon);
  }
}
function ContrastValidationComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, ContrastValidationComponent_ng_container_2_span_1_Template, 3, 2, "span", 1)(2, ContrastValidationComponent_ng_container_2_span_2_Template, 3, 2, "span", 2);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.pass);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.pass);
  }
}
var _c26 = ["kendoContrastTool", ""];
function ContrastComponent_ng_container_3_span_1_kendo_icon_wrapper_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("svgIcon", ctx_r0.checkIcon);
  }
}
function ContrastComponent_ng_container_3_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 7);
    ɵɵelement(1, "kendo-icon-wrapper", 8);
    ɵɵtemplate(2, ContrastComponent_ng_container_3_span_1_kendo_icon_wrapper_2_Template, 1, 1, "kendo-icon-wrapper", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r0.checkIcon);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.satisfiesAAACondition);
  }
}
function ContrastComponent_ng_container_3_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 10);
    ɵɵelement(1, "kendo-icon-wrapper", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r0.xCircleIcon);
  }
}
function ContrastComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, ContrastComponent_ng_container_3_span_1_Template, 3, 2, "span", 5)(2, ContrastComponent_ng_container_3_span_2_Template, 2, 1, "span", 6);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.satisfiesAACondition);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.satisfiesAACondition);
  }
}
var _c27 = ["kendoColorContrastSvg", ""];
function ColorContrastSvgComponent__svg_path_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "path", 1);
  }
  if (rf & 2) {
    const path_r1 = ctx.$implicit;
    ɵɵattribute("d", path_r1);
  }
}
var _c28 = ["gradientDragHandle"];
var _c29 = ["inputs"];
var _c30 = ["alphaSlider"];
var _c31 = ["gradientWrapper"];
var _c322 = ["hsvRectangle"];
var _c332 = (a0, a1) => ({
  "k-colorgradient-canvas": true,
  "k-vstack": a0,
  "k-hstack": a1
});
var _c34 = (a0, a1, a2) => ({
  "k-hsv-controls": true,
  "k-sliders-wrap-clearable": a0,
  "k-vstack": a1,
  "k-hstack": a2
});
var _c35 = (a0) => ({
  "k-align-self-end": a0
});
function ColorGradientComponent__svg_svg_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 16);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const gradientWrapper_r4 = ɵɵreference(5);
    ɵɵstyleMap("position: absolute; overflow: visible; pointer-events: none; left: 0px; top: 0px;");
    ɵɵproperty("wrapper", gradientWrapper_r4 ? gradientWrapper_r4 : void 0)("hsva", ctx_r2.hsva)("backgroundColor", ctx_r2.contrastTool);
  }
}
function ColorGradientComponent_button_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 17);
    ɵɵlistener("click", function ColorGradientComponent_button_10_Template_button_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.reset());
    })("keydown.enter", function ColorGradientComponent_button_10_Template_button_keydown_enter_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.reset());
    })("keydown.space", function ColorGradientComponent_button_10_Template_button_keydown_space_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.reset());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵstyleMap("position: absolute; top: 0; left: 50%; transform: translateX(-50%);");
    ɵɵproperty("svgIcon", ctx_r2.dropletSlashIcon)("size", ctx_r2.size)("tabindex", ctx_r2.innerTabIndex.toString());
    ɵɵattribute("aria-label", ctx_r2.clearButtonTitle)("title", ctx_r2.clearButtonTitle);
  }
}
function ColorGradientComponent_kendo_slider_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-slider", 18, 4);
    ɵɵlistener("valueChange", function ColorGradientComponent_kendo_slider_12_Template_kendo_slider_valueChange_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleAlphaSliderChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵstyleProp("height", ctx_r2.clearButton ? "140" : null, "px");
    ɵɵproperty("tabindex", ctx_r2.innerTabIndex)("ngClass", ɵɵpureFunction1(14, _c35, ctx_r2.clearButton))("dragHandleTitle", ctx_r2.opacitySliderTitle)("disabled", ctx_r2.disabled)("readonly", ctx_r2.readonly)("showButtons", false)("vertical", !ctx_r2.adaptiveMode)("min", 0)("max", 100)("smallStep", 1)("largeStep", 10)("value", ctx_r2.alphaSliderValue);
  }
}
function ColorGradientComponent_div_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 19);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("value", ctx_r2.value)("ratio", ctx_r2.contrastTool);
  }
}
var _c36 = (a0, a1, a2, a3) => ({
  backgroundColor: a0,
  width: a1,
  height: a2,
  minWidth: a3
});
function ColorPaletteComponent_tr_3_td_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 5);
    ɵɵlistener("click", function ColorPaletteComponent_tr_3_td_1_Template_td_click_0_listener() {
      const ctx_r1 = ɵɵrestoreView(_r1);
      const color_r3 = ctx_r1.$implicit;
      const colIndex_r4 = ctx_r1.index;
      const rowIndex_r5 = ɵɵnextContext().index;
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5.handleCellSelection(color_r3, {
        row: rowIndex_r5,
        col: colIndex_r4
      }));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const color_r3 = ctx.$implicit;
    const colIndex_r4 = ctx.index;
    const rowIndex_r5 = ɵɵnextContext().index;
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassProp("k-selected", (ctx_r5.selectedCell == null ? null : ctx_r5.selectedCell.row) === rowIndex_r5 && (ctx_r5.selectedCell == null ? null : ctx_r5.selectedCell.col) === colIndex_r4)("k-focus", ctx_r5.focusInComponent && (ctx_r5.focusedCell == null ? null : ctx_r5.focusedCell.row) === rowIndex_r5 && (ctx_r5.focusedCell == null ? null : ctx_r5.focusedCell.col) === colIndex_r4);
    ɵɵproperty("id", "k-" + rowIndex_r5 + "-" + colIndex_r4 + "-" + ctx_r5.uniqueId)("ngStyle", ɵɵpureFunction4(9, _c36, color_r3, (ctx_r5.tileLayout == null ? null : ctx_r5.tileLayout.width) + "px", (ctx_r5.tileLayout == null ? null : ctx_r5.tileLayout.height) + "px", (ctx_r5.tileLayout == null ? null : ctx_r5.tileLayout.width) + "px"));
    ɵɵattribute("aria-selected", (ctx_r5.selectedCell == null ? null : ctx_r5.selectedCell.row) === rowIndex_r5 && (ctx_r5.selectedCell == null ? null : ctx_r5.selectedCell.col) === colIndex_r4 ? "true" : void 0)("aria-label", color_r3)("value", color_r3);
  }
}
function ColorPaletteComponent_tr_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 3);
    ɵɵtemplate(1, ColorPaletteComponent_tr_3_td_1_Template, 1, 14, "td", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r7 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngForOf", row_r7);
  }
}
var _c37 = ["clearButton"];
var _c38 = ["viewButtons"];
var _c39 = ["kendoFlatColorPickerHeader", ""];
function FlatColorPickerHeaderComponent_div_1_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 9, 0);
    ɵɵlistener("click", function FlatColorPickerHeaderComponent_div_1_button_1_Template_button_click_0_listener() {
      const view_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onViewButtonClick(view_r2));
    })("keydown.shift.tab", function FlatColorPickerHeaderComponent_div_1_button_1_Template_button_keydown_shift_tab_0_listener($event) {
      const i_r4 = ɵɵrestoreView(_r1).index;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onHeaderTabOut($event, i_r4));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const view_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("tabindex", ctx_r2.innerTabIndex.toString())("icon", ctx_r2.getViewButtonIcon(view_r2))("svgIcon", ctx_r2.getViewButtonsSVGIcon(view_r2))("size", ctx_r2.size)("ngClass", ctx_r2.activeView === view_r2 ? "k-selected" : "");
    ɵɵattribute("title", ctx_r2.getText(view_r2 === "gradient" ? "gradientView" : "paletteView"))("aria-label", ctx_r2.getText(view_r2 === "gradient" ? "gradientView" : "paletteView"))("aria-pressed", ctx_r2.activeView === view_r2);
  }
}
function FlatColorPickerHeaderComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵtemplate(1, FlatColorPickerHeaderComponent_div_1_button_1_Template, 2, 8, "button", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2.views);
  }
}
function FlatColorPickerHeaderComponent_button_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 10, 1);
    ɵɵlistener("click", function FlatColorPickerHeaderComponent_button_4_Template_button_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.clearButtonClick.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("tabindex", ctx_r2.innerTabIndex.toString())("size", ctx_r2.size)("svgIcon", ctx_r2.dropletSlashIcon);
    ɵɵattribute("aria-label", ctx_r2.getText("clearButton"))("title", ctx_r2.getText("clearButton"));
  }
}
function FlatColorPickerHeaderComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 11);
    ɵɵelement(1, "span", 12);
    ɵɵelementStart(2, "span", 13);
    ɵɵlistener("click", function FlatColorPickerHeaderComponent_div_5_Template_span_click_2_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.valuePaneClick.emit($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵstyleProp("background-color", ctx_r2.selection);
    ɵɵattribute("title", ctx_r2.getText("previewColor"));
    ɵɵadvance();
    ɵɵstyleProp("background-color", ctx_r2.value);
    ɵɵattribute("title", ctx_r2.getText("revertSelection"));
  }
}
var _c40 = ["first"];
var _c41 = ["last"];
var _c422 = ["kendoFlatColorPickerActionButtons", ""];
var _c432 = ["header"];
var _c44 = ["gradient"];
var _c45 = ["palette"];
var _c46 = ["footer"];
function FlatColorPickerComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 10, 0);
    ɵɵlistener("clearButtonClick", function FlatColorPickerComponent_div_1_Template_div_clearButtonClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClearButtonClick());
    })("viewChange", function FlatColorPickerComponent_div_1_Template_div_viewChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onViewChange($event));
    })("valuePaneClick", function FlatColorPickerComponent_div_1_Template_div_valuePaneClick_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.resetSelection($event));
    })("tabOut", function FlatColorPickerComponent_div_1_Template_div_tabOut_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.lastFocusable($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("innerTabIndex", ctx_r1.innerTabIndex)("clearButton", ctx_r1.clearButton)("activeView", ctx_r1.activeView)("views", ctx_r1.views)("size", ctx_r1.size)("value", ctx_r1.value)("selection", ctx_r1.selection)("preview", ctx_r1.preview);
  }
}
function FlatColorPickerComponent_kendo_colorgradient_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-colorgradient", 11, 1);
    ɵɵlistener("keydown.tab", function FlatColorPickerComponent_kendo_colorgradient_3_Template_kendo_colorgradient_keydown_tab_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.focusFirstHeaderButton());
    })("valueChange", function FlatColorPickerComponent_kendo_colorgradient_3_Template_kendo_colorgradient_valueChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleValueChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("tabindex", ctx_r1.innerTabIndex)("value", ctx_r1.selection)("size", ctx_r1.size)("adaptiveMode", ctx_r1.adaptiveMode)("format", ctx_r1.format)("opacity", ctx_r1.gradientSettings.opacity)("delay", ctx_r1.gradientSettings.delay)("contrastTool", ctx_r1.gradientSettings.contrastTool)("gradientSliderSmallStep", ctx_r1.gradientSettings.gradientSliderSmallStep)("gradientSliderStep", ctx_r1.gradientSettings.gradientSliderStep)("readonly", ctx_r1.readonly);
  }
}
function FlatColorPickerComponent_kendo_colorpalette_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-colorpalette", 12, 2);
    ɵɵlistener("valueChange", function FlatColorPickerComponent_kendo_colorpalette_4_Template_kendo_colorpalette_valueChange_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleValueChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("tabindex", ctx_r1.innerTabIndex)("palette", ctx_r1.paletteSettings.palette)("size", ctx_r1.size)("columns", ctx_r1.paletteSettings.columns)("tileSize", ctx_r1.paletteSettings.tileSize)("format", ctx_r1.format)("value", ctx_r1.selection)("readonly", ctx_r1.readonly);
  }
}
function FlatColorPickerComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 13, 3);
    ɵɵlistener("actionButtonClick", function FlatColorPickerComponent_div_5_Template_div_actionButtonClick_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onAction($event));
    })("tabOut", function FlatColorPickerComponent_div_5_Template_div_tabOut_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.firstFocusable.focus());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("innerTabIndex", ctx_r1.innerTabIndex)("size", ctx_r1.size)("ngClass", "k-justify-content-" + ctx_r1.actionsLayout);
  }
}
var _c47 = ["actionSheetSearchBar"];
var _c48 = ["cancel"];
var _c49 = ["apply"];
var _c50 = (a0) => ({
  duration: a0
});
function AdaptiveRendererComponent_ng_template_2_div_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 14)(1, "kendo-adaptive-close-button", 15);
    ɵɵlistener("close", function AdaptiveRendererComponent_ng_template_2_div_6_Template_kendo_adaptive_close_button_close_1_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onApply.emit($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("title", ctx_r2.messageFor("closeButton"))("svgIcon", ctx_r2.checkIcon);
  }
}
function AdaptiveRendererComponent_ng_template_2_div_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 14)(1, "kendo-adaptive-close-button", 16);
    ɵɵlistener("close", function AdaptiveRendererComponent_ng_template_2_div_7_Template_kendo_adaptive_close_button_close_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.actionSheetClose.emit($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("title", ctx_r2.messageFor("closeButton"))("svgIcon", ctx_r2.xIcon);
  }
}
function AdaptiveRendererComponent_ng_template_2_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function AdaptiveRendererComponent_ng_template_2_div_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 17)(1, "button", 18, 1);
    ɵɵlistener("click", function AdaptiveRendererComponent_ng_template_2_div_10_Template_button_click_1_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onCancel.emit($event));
    });
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementStart(4, "button", 19, 2);
    ɵɵlistener("click", function AdaptiveRendererComponent_ng_template_2_div_10_Template_button_click_4_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onApply.emit());
    });
    ɵɵtext(6);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("title", ctx_r2.messageFor("cancelButton"));
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r2.messageFor("cancelButton"), " ");
    ɵɵadvance();
    ɵɵproperty("title", ctx_r2.messageFor("applyButton"));
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r2.messageFor("applyButton"), " ");
  }
}
function AdaptiveRendererComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5)(1, "div", 6)(2, "div", 7)(3, "div", 8);
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵelement(5, "div", 9);
    ɵɵelementEnd();
    ɵɵtemplate(6, AdaptiveRendererComponent_ng_template_2_div_6_Template, 2, 2, "div", 10)(7, AdaptiveRendererComponent_ng_template_2_div_7_Template, 2, 2, "div", 10);
    ɵɵelementEnd()();
    ɵɵelementStart(8, "div", 11);
    ɵɵtemplate(9, AdaptiveRendererComponent_ng_template_2_ng_container_9_Template, 1, 0, "ng-container", 12);
    ɵɵelementEnd();
    ɵɵtemplate(10, AdaptiveRendererComponent_ng_template_2_div_10_Template, 7, 4, "div", 13);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance(4);
    ɵɵtextInterpolate(ctx_r2.messageFor("adaptiveTitle"));
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r2.preview);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.preview);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r2.actionSheetTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.preview);
  }
}
var _c51 = ["container"];
var _c522 = ["activeColor"];
var _c532 = ["popupTemplate"];
var _c54 = ["flatColorPicker"];
var _c55 = (a0, a1) => ({
  "k-icon-color-preview": a0,
  "k-no-color": a1
});
function ColorPickerComponent_kendo_icon_wrapper_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 12);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r1.iconStyles)("customFontClass", ctx_r1.customIconStyles)("svgIcon", ctx_r1.svgIcon);
  }
}
function ColorPickerComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-flatcolorpicker", 13, 3);
    ɵɵlistener("cancel", function ColorPickerComponent_ng_template_7_Template_kendo_flatcolorpicker_cancel_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleCancelEvent($event));
    })("focusout", function ColorPickerComponent_ng_template_7_Template_kendo_flatcolorpicker_focusout_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handlePopupBlur($event));
    })("valueChange", function ColorPickerComponent_ng_template_7_Template_kendo_flatcolorpicker_valueChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleValueChange($event));
    })("keydown", function ColorPickerComponent_ng_template_7_Template_kendo_flatcolorpicker_keydown_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handlePopupKeyDown($event));
    })("activeViewChange", function ColorPickerComponent_ng_template_7_Template_kendo_flatcolorpicker_activeViewChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.activeViewChange.emit($event));
    })("clearButtonClick", function ColorPickerComponent_ng_template_7_Template_kendo_flatcolorpicker_clearButtonClick_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearButtonClick.emit());
    })("actionButtonClick", function ColorPickerComponent_ng_template_7_Template_kendo_flatcolorpicker_actionButtonClick_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.togglePopup());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("value", ctx_r1.value)("format", ctx_r1.format)("size", ctx_r1.isAdaptive ? "large" : ctx_r1.size)("views", ctx_r1.views)("activeView", ctx_r1.activeView)("actionsLayout", ctx_r1.actionsLayout)("adaptiveMode", ctx_r1.isActionSheetExpanded)("preview", ctx_r1.preview)("gradientSettings", ctx_r1.gradientSettings)("paletteSettings", ctx_r1.paletteSettings)("clearButton", ctx_r1.clearButton);
  }
}
function ColorPickerComponent_kendo_resize_sensor_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 14);
    ɵɵlistener("resize", function ColorPickerComponent_kendo_resize_sensor_12_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onResize());
    });
    ɵɵelementEnd();
  }
}
var _c56 = ["*"];
var _c57 = [[["label"], ["kendo-label"]], "*", [["kendo-formhint"]], [["kendo-formerror"]]];
var _c58 = ["label, kendo-label", "*", "kendo-formhint", "kendo-formerror"];
function FormFieldComponent_ng_content_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "hasHints"]);
  }
}
function FormFieldComponent_ng_content_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "hasErrors"]);
  }
}
var _c59 = (a0, a1) => ({
  "k-selected": a0,
  "k-hover": a1
});
var _c60 = (a0) => ({
  index: a0
});
var _c61 = (a0) => ({
  "clipPath": a0
});
function RatingComponent_span_1_ng_container_1_ng_container_1_kendo_icon_wrapper_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 7);
  }
  if (rf & 2) {
    const item_r4 = ɵɵnextContext(3).$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", item_r4.selected || item_r4.hovered ? "star" : "star-outline")("svgIcon", item_r4.selected || item_r4.hovered ? ctx_r1.svgIcon : ctx_r1.svgIconOutline);
  }
}
function RatingComponent_span_1_ng_container_1_ng_container_1_kendo_icon_wrapper_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 8);
  }
  if (rf & 2) {
    const item_r4 = ɵɵnextContext(3).$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", item_r4.selected || item_r4.hovered ? ctx_r1.icon : ctx_r1.icon + "-outline");
  }
}
function RatingComponent_span_1_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, RatingComponent_span_1_ng_container_1_ng_container_1_kendo_icon_wrapper_1_Template, 1, 2, "kendo-icon-wrapper", 5)(2, RatingComponent_span_1_ng_container_1_ng_container_1_kendo_icon_wrapper_2_Template, 1, 1, "kendo-icon-wrapper", 6);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.icon);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.icon);
  }
}
function RatingComponent_span_1_ng_container_1_2_ng_template_0_Template(rf, ctx) {
}
function RatingComponent_span_1_ng_container_1_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, RatingComponent_span_1_ng_container_1_2_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const i_r3 = ɵɵnextContext(2).index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.itemTemplate == null ? null : ctx_r1.itemTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c60, i_r3));
  }
}
function RatingComponent_span_1_ng_container_1_3_ng_template_0_Template(rf, ctx) {
}
function RatingComponent_span_1_ng_container_1_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, RatingComponent_span_1_ng_container_1_3_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const i_r3 = ɵɵnextContext(2).index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.hoveredItemTemplate == null ? null : ctx_r1.hoveredItemTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c60, i_r3));
  }
}
function RatingComponent_span_1_ng_container_1_4_ng_template_0_Template(rf, ctx) {
}
function RatingComponent_span_1_ng_container_1_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, RatingComponent_span_1_ng_container_1_4_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const i_r3 = ɵɵnextContext(2).index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.selectedItemTemplate == null ? null : ctx_r1.selectedItemTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c60, i_r3));
  }
}
function RatingComponent_span_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, RatingComponent_span_1_ng_container_1_ng_container_1_Template, 3, 2, "ng-container", 4)(2, RatingComponent_span_1_ng_container_1_2_Template, 1, 4, null, 4)(3, RatingComponent_span_1_ng_container_1_3_Template, 1, 4, null, 4)(4, RatingComponent_span_1_ng_container_1_4_Template, 1, 4, null, 4);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r4 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.itemTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.itemTemplate && !item_r4.selected && !item_r4.hovered);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hoveredItemTemplate && item_r4.hovered);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.selectedItemTemplate && item_r4.selected && !item_r4.hovered);
  }
}
function RatingComponent_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("name", "star-outline")("svgIcon", ctx_r1.svgIconOutline);
  }
}
function RatingComponent_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 8);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("name", ctx_r1.icon + "-outline");
  }
}
function RatingComponent_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("name", "star")("svgIcon", ctx_r1.svgIcon);
  }
}
function RatingComponent_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 8);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("name", ctx_r1.icon);
  }
}
function RatingComponent_span_1_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "span", 10);
    ɵɵtemplate(2, RatingComponent_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_2_Template, 1, 2, "kendo-icon-wrapper", 5)(3, RatingComponent_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_3_Template, 1, 1, "kendo-icon-wrapper", 6);
    ɵɵelementEnd();
    ɵɵelementStart(4, "span", 12);
    ɵɵtemplate(5, RatingComponent_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_5_Template, 1, 2, "kendo-icon-wrapper", 5)(6, RatingComponent_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_6_Template, 1, 1, "kendo-icon-wrapper", 6);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r1.icon);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.icon);
    ɵɵadvance();
    ɵɵproperty("ngStyle", ɵɵpureFunction1(5, _c61, ctx_r1.direction === "rtl" ? "inset(0 0 0 50%)" : "inset(0 50% 0 0)"));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.icon);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.icon);
  }
}
function RatingComponent_span_1_ng_container_2_ng_template_3_Template(rf, ctx) {
}
function RatingComponent_span_1_ng_container_2_span_4_ng_template_1_Template(rf, ctx) {
}
function RatingComponent_span_1_ng_container_2_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 12);
    ɵɵtemplate(1, RatingComponent_span_1_ng_container_2_span_4_ng_template_1_Template, 0, 0, "ng-template", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const i_r3 = ɵɵnextContext(2).index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngStyle", ɵɵpureFunction1(3, _c61, ctx_r1.direction === "rtl" ? "inset(0 0 0 50%)" : "inset(0 50% 0 0)"));
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.hoveredItemTemplate == null ? null : ctx_r1.hoveredItemTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(5, _c60, i_r3));
  }
}
function RatingComponent_span_1_ng_container_2_span_5_ng_template_1_Template(rf, ctx) {
}
function RatingComponent_span_1_ng_container_2_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 12);
    ɵɵtemplate(1, RatingComponent_span_1_ng_container_2_span_5_ng_template_1_Template, 0, 0, "ng-template", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const i_r3 = ɵɵnextContext(2).index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngStyle", ɵɵpureFunction1(3, _c61, ctx_r1.direction === "rtl" ? "inset(0 0 0 50%)" : "inset(0 50% 0 0)"));
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.selectedItemTemplate == null ? null : ctx_r1.selectedItemTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(5, _c60, i_r3));
  }
}
function RatingComponent_span_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, RatingComponent_span_1_ng_container_2_ng_container_1_Template, 7, 7, "ng-container", 4);
    ɵɵelementStart(2, "span", 10);
    ɵɵtemplate(3, RatingComponent_span_1_ng_container_2_ng_template_3_Template, 0, 0, "ng-template", 9);
    ɵɵelementEnd();
    ɵɵtemplate(4, RatingComponent_span_1_ng_container_2_span_4_Template, 2, 7, "span", 11)(5, RatingComponent_span_1_ng_container_2_span_5_Template, 2, 7, "span", 11);
    ɵɵelement(6, "span");
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    const item_r4 = ctx_r4.$implicit;
    const i_r3 = ctx_r4.index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.itemTemplate);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.itemTemplate == null ? null : ctx_r1.itemTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(11, _c60, i_r3));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hoveredItemTemplate && item_r4.hovered);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.selectedItemTemplate && item_r4.selected && !item_r4.hovered);
    ɵɵadvance();
    ɵɵstyleProp("width", 24, "px")("height", 24, "px")("display", "block");
  }
}
function RatingComponent_span_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 3);
    ɵɵlistener("mouseenter", function RatingComponent_span_1_Template_span_mouseenter_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onMouseEnter($event));
    })("mouseout", function RatingComponent_span_1_Template_span_mouseout_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onMouseOut());
    })("click", function RatingComponent_span_1_Template_span_click_0_listener($event) {
      const i_r3 = ɵɵrestoreView(_r1).index;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.changeValue(i_r3, $event));
    });
    ɵɵtemplate(1, RatingComponent_span_1_ng_container_1_Template, 5, 4, "ng-container", 4)(2, RatingComponent_span_1_ng_container_2_Template, 7, 13, "ng-container", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r4 = ctx.$implicit;
    ɵɵproperty("title", item_r4.title)("ngClass", ɵɵpureFunction2(4, _c59, item_r4.selected || item_r4.selectedIndicator, item_r4.hovered));
    ɵɵadvance();
    ɵɵproperty("ngIf", !item_r4.half);
    ɵɵadvance();
    ɵɵproperty("ngIf", item_r4.half);
  }
}
function RatingComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 13);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.label);
  }
}
var _c622 = ["canvas"];
var _c632 = ["minimize"];
var _c64 = ["maximize"];
function SignatureComponent_button_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 12, 1);
    ɵɵlistener("click", function SignatureComponent_button_4_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onMaximize());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r1.svgIcon("hyperlinkOpenIcon"))("size", ctx_r1.size)("title", ctx_r1.maximizeTitle);
    ɵɵattribute("aria-label", ctx_r1.maximizeTitle);
  }
}
function SignatureComponent_button_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 13, 2);
    ɵɵlistener("click", function SignatureComponent_button_5_Template_button_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onMinimize());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r1.svgIcon("hyperlinkOpenIcon"))("size", ctx_r1.size)("title", ctx_r1.minimizeTitle);
    ɵɵattribute("aria-label", ctx_r1.minimizeTitle);
  }
}
function SignatureComponent_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 14);
  }
}
function SignatureComponent_button_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 15);
    ɵɵlistener("click", function SignatureComponent_button_8_Template_button_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClear());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r1.svgIcon("xIcon"))("size", ctx_r1.size)("title", ctx_r1.clearTitle);
    ɵɵattribute("aria-label", ctx_r1.clearTitle);
  }
}
function SignatureComponent_kendo_dialog_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-dialog", 16);
    ɵɵlistener("click", function SignatureComponent_kendo_dialog_9_Template_kendo_dialog_click_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onDialogClick($event));
    })("keydown", function SignatureComponent_kendo_dialog_9_Template_kendo_dialog_keydown_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onDialogKeydown($event));
    });
    ɵɵelementStart(1, "kendo-signature", 17);
    ɵɵlistener("valueChange", function SignatureComponent_kendo_dialog_9_Template_kendo_signature_valueChange_1_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onDialogValueChange($event));
    })("minimize", function SignatureComponent_kendo_dialog_9_Template_kendo_signature_minimize_1_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onDialogClose());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("k-signature-maximized", true);
    ɵɵproperty("readonly", ctx_r1.readonly)("disabled", ctx_r1.disabled)("size", ctx_r1.size)("rounded", ctx_r1.rounded)("fillMode", ctx_r1.fillMode)("color", ctx_r1.color)("backgroundColor", ctx_r1.backgroundColor)("strokeWidth", ctx_r1.strokeWidth)("smooth", ctx_r1.smooth)("value", ctx_r1.popupValue)("hideLine", ctx_r1.hideLine)("maximized", true)("width", ctx_r1.popupWidth)("height", ctx_r1.popupHeight)("popupScale", ctx_r1.popupScale)("exportScale", 1 / ctx_r1.popupScale * ctx_r1.exportScale)("parentLocalization", ctx_r1.localization);
  }
}
var _c65 = [[["kendo-textarea-prefix"]], [["kendo-textarea-suffix"]]];
var _c66 = ["kendo-textarea-prefix", "kendo-textarea-suffix"];
function TextAreaComponent_kendo_input_separator_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-input-separator", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("orientation", ctx_r1.separatorOrientation);
  }
}
function TextAreaComponent_kendo_input_separator_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-input-separator", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("orientation", ctx_r1.separatorOrientation);
  }
}
function OTPInputSeparatorComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.separator);
  }
}
function OTPInputSeparatorComponent_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.separatorIconString);
  }
}
function OTPInputSeparatorComponent_kendo_icon_wrapper_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.separatorIconString)("svgIcon", ctx_r0.separatorSVGIcon);
  }
}
var _c67 = ["inputGroup"];
var _c68 = () => [];
function OTPInputComponent_ng_container_3_ng_container_1_kendo_otpinput_separator_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-otpinput-separator", 9);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(3);
    ɵɵproperty("separator", ctx_r3.separator);
  }
}
function OTPInputComponent_ng_container_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "kendo-textbox", 7);
    ɵɵlistener("focus", function OTPInputComponent_ng_container_3_ng_container_1_Template_kendo_textbox_focus_1_listener() {
      const i_r3 = ɵɵrestoreView(_r2).index;
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.handleInputFocus(i_r3));
    })("input", function OTPInputComponent_ng_container_3_ng_container_1_Template_kendo_textbox_input_1_listener($event) {
      const i_r3 = ɵɵrestoreView(_r2).index;
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.handleInput($event, i_r3));
    });
    ɵɵelementEnd();
    ɵɵtemplate(2, OTPInputComponent_ng_container_3_ng_container_1_kendo_otpinput_separator_2_Template, 1, 1, "kendo-otpinput-separator", 8);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const i_r3 = ctx.index;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵclassProp("k-invalid", ctx_r3.isControlInvalid);
    ɵɵproperty("selectOnFocus", true)("maxlength", 1)("type", ctx_r3.type !== "number" ? ctx_r3.type : null)("placeholder", ctx_r3.placeholder)("size", ctx_r3.size)("rounded", ctx_r3.rounded)("fillMode", ctx_r3.fillMode)("disabled", ctx_r3.disabled)("readonly", ctx_r3.readonly);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r3.showSeparator(i_r3));
  }
}
function OTPInputComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, OTPInputComponent_ng_container_3_ng_container_1_Template, 3, 12, "ng-container", 6);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r3.inputsArray);
  }
}
function OTPInputComponent_ng_template_4_ng_container_0_kendo_textbox_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-textbox", 7);
    ɵɵlistener("focus", function OTPInputComponent_ng_template_4_ng_container_0_kendo_textbox_3_Template_kendo_textbox_focus_0_listener() {
      const j_r6 = ɵɵrestoreView(_r5).index;
      const i_r7 = ɵɵnextContext().index;
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.handleInputFocus(j_r6, i_r7));
    })("input", function OTPInputComponent_ng_template_4_ng_container_0_kendo_textbox_3_Template_kendo_textbox_input_0_listener($event) {
      const j_r6 = ɵɵrestoreView(_r5).index;
      const i_r7 = ɵɵnextContext().index;
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.handleInput($event, j_r6, i_r7));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(3);
    ɵɵclassProp("k-invalid", ctx_r3.isControlInvalid);
    ɵɵproperty("selectOnFocus", true)("maxlength", 1)("type", ctx_r3.type !== "number" ? ctx_r3.type : null)("placeholder", ctx_r3.placeholder)("size", ctx_r3.size)("rounded", ctx_r3.rounded)("fillMode", ctx_r3.fillMode)("disabled", ctx_r3.disabled)("readonly", ctx_r3.readonly);
  }
}
function OTPInputComponent_ng_template_4_ng_container_0_kendo_otpinput_separator_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-otpinput-separator", 9);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(3);
    ɵɵproperty("separator", ctx_r3.separator);
  }
}
function OTPInputComponent_ng_template_4_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 10, 1);
    ɵɵtemplate(3, OTPInputComponent_ng_template_4_ng_container_0_kendo_textbox_3_Template, 1, 11, "kendo-textbox", 11);
    ɵɵelementEnd();
    ɵɵtemplate(4, OTPInputComponent_ng_template_4_ng_container_0_kendo_otpinput_separator_4_Template, 1, 1, "kendo-otpinput-separator", 8);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const group_r8 = ctx.$implicit;
    const i_r7 = ctx.index;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ɵɵpureFunction0(2, _c68).constructor(group_r8));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r3.showGroupSeparator(i_r7));
  }
}
function OTPInputComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, OTPInputComponent_ng_template_4_ng_container_0_Template, 5, 3, "ng-container", 6);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("ngForOf", ctx_r3.adjacentGroups);
  }
}
var isPresent5 = (value) => value !== null && value !== void 0;
var areSame = (value1, value2) => value1 === value2 || value1 === null && value2 === void 0 || value1 === void 0 && value2 === null;
var requiresZoneOnBlur = (ngControl) => ngControl && (!ngControl.touched || ngControl.control && ngControl.control.updateOn === "blur");
var fitIntoBounds = (contender, min, max) => {
  if (!isPresent5(contender) || isNaN(contender)) {
    return min;
  }
  return contender <= min ? min : contender >= max ? max : contender;
};
var SIZE_MAP = {
  small: "sm",
  medium: "md",
  large: "lg"
};
var ROUNDED_MAP = {
  small: "sm",
  medium: "md",
  large: "lg",
  full: "full"
};
var isNone = (style2) => style2 === "none";
var getStylingClasses2 = (componentType, stylingOption, previousValue, newValue) => {
  switch (stylingOption) {
    case "size":
      return {
        toRemove: `k-${componentType}-${SIZE_MAP[previousValue]}`,
        toAdd: newValue !== "none" ? `k-${componentType}-${SIZE_MAP[newValue]}` : ""
      };
    case "rounded":
      return {
        toRemove: `k-rounded-${ROUNDED_MAP[previousValue]}`,
        toAdd: newValue !== "none" ? `k-rounded-${ROUNDED_MAP[newValue]}` : ""
      };
    case "fillMode":
      return {
        toRemove: `k-${componentType}-${previousValue}`,
        toAdd: newValue !== "none" ? `k-${componentType}-${newValue}` : ""
      };
    default:
      break;
  }
};
var COMPONENT_TYPE = new InjectionToken("TYPE_TOKEN");
var replaceMessagePlaceholder = (message, name2, value) => message.replace(new RegExp(`{\\s*${name2}\\s*}`, "g"), value);
var MAX_PRECISION2 = 20;
var limitPrecision = (precision) => Math.min(precision, MAX_PRECISION2);
var fractionLength = (value) => {
  return (String(value).split(".")[1] || "").length;
};
var maxFractionLength = (value1, value2) => {
  return Math.max(fractionLength(value1), fractionLength(value2));
};
var toFixedPrecision = (value, precision) => {
  const maxPrecision = limitPrecision(precision);
  return parseFloat(value.toFixed(maxPrecision));
};
var add = (value1, value2) => {
  const maxPrecision = maxFractionLength(value1, value2);
  return toFixedPrecision(value1 + value2, maxPrecision);
};
var subtract = (value1, value2) => {
  return add(value1, -value2);
};
var multiply = (value1, value2) => {
  const maxPrecision = fractionLength(value1) + fractionLength(value2);
  return toFixedPrecision(value1 * value2, maxPrecision);
};
var divide = (dividend, divisor) => {
  if (divisor === 0) {
    return NaN;
  }
  const power = maxFractionLength(dividend, divisor);
  const correctionValue = Math.pow(10, power);
  return correctionValue * dividend / (correctionValue * divisor);
};
var remainder = (dividend, divisor) => {
  return Math.abs(subtract(dividend, multiply(divisor, Math.floor(divide(dividend, divisor)))));
};
var calculateFixedTrackSize = ({
  max,
  min,
  smallStep,
  fixedTickWidth
}) => (max - min) / smallStep * fixedTickWidth;
var calculateTicksCount = (min = 0, max = 0, smallStep = 1) => {
  if (smallStep <= 0) {
    throw new Error("Invalid argument: smallStep must be a positive number");
  }
  const adjustedRange = Math.abs(subtract(max, min));
  const adjustedRatio = Math.floor(divide(adjustedRange, smallStep));
  const result = add(adjustedRatio, 1);
  return result;
};
var calculateValueFromTick = (index, {
  max,
  min,
  smallStep,
  reverse,
  vertical
}) => {
  const value = add(min, multiply(index, smallStep));
  return vertical || reverse ? Math.abs(subtract(value, max)) : value;
};
var calculateHandlePosition = ({
  trackWidth,
  min,
  max,
  value
}) => {
  const step = trackWidth / Math.abs(max - min);
  const pos = isPresent5(value) ? step * (value - min) : min;
  return Math.floor(pos);
};
var decreaseValueToStep = (value, {
  max,
  min,
  smallStep,
  largeStep
}, large = false) => {
  const step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;
  const stepValue = subtract(value, min);
  let result;
  const stepRemainder = remainder(stepValue, step);
  if (stepRemainder === 0) {
    result = subtract(stepValue, step);
  } else {
    result = subtract(stepValue, stepRemainder);
  }
  return limitValue3(add(result, min), min, max);
};
var increaseValueToStep = (value, {
  max,
  min,
  smallStep,
  largeStep
}, large = false) => {
  const step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;
  const stepValue = subtract(value, min);
  const stepRemainder = remainder(stepValue, step);
  const result = add(subtract(stepValue, stepRemainder), step);
  return limitValue3(add(result, min), min, max);
};
var isStartHandle = (dragHandle) => dragHandle.id.indexOf("k-start-handle") > -1;
var snapValue = (value, options2) => {
  const {
    smallStep,
    min,
    max
  } = options2;
  const limited = limitValue3(value, min, max);
  if (value !== limited) {
    return limited;
  }
  const left = decreaseValueToStep(value, options2);
  const right = increaseValueToStep(value, options2);
  if ((value - min) % smallStep === 0) {
    return value;
  }
  if (right - value <= (right - left) / 2) {
    return right;
  }
  return left;
};
var trimValue = (max, min, value) => {
  if (value > max) {
    return max;
  }
  if (value < min) {
    return min;
  }
  return value;
};
var trimValueRange = (max, min, value) => {
  return value ? [trimValue(max, min, value[0]), trimValue(max, min, value[1])] : [min, min];
};
var identity = (value) => value;
var isSameRange = (value1, value2) => areSame(value1[0], value2[0]) && areSame(value1[1], value2[1]);
var elementOffset3 = (element) => {
  const box = element.getBoundingClientRect();
  const documentElement = document.documentElement;
  return {
    left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0),
    top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0)
  };
};
var limitValue3 = (value, min, max) => {
  return Math.max(Math.min(value, max), min);
};
var eventValue = (eventArgs, scaleElement, options2) => {
  const {
    min,
    max,
    vertical,
    rtl
  } = options2;
  const trackOffset = elementOffset3(scaleElement);
  const offset = vertical ? eventArgs.pageY - trackOffset.top : eventArgs.pageX - trackOffset.left;
  const scale = (max - min) / (vertical ? scaleElement.clientHeight : scaleElement.clientWidth);
  const offsetValue = offset * scale;
  let value = rtl || vertical ? max - offsetValue : min + offsetValue;
  const stepFractionLength = fractionLength(options2.smallStep);
  value = toFixedPrecision(value, stepFractionLength + 1);
  return snapValue(value, options2);
};
var increment = (options2) => {
  return increaseValueToStep(options2.value, options2);
};
var decrement = (options2) => {
  return decreaseValueToStep(options2.value, options2);
};
var incrementLarge = (options2) => {
  return increaseValueToStep(options2.value, options2, true);
};
var decrementLarge = (options2) => {
  return decreaseValueToStep(options2.value, options2, true);
};
var validateValue = (value) => {
  if (isDevMode && value && value[0] > value[1]) {
    throw new Error("[RangeSlider] The start value should not be greater than the end value.");
  }
};
var SliderModelBase = class {
  props;
  wrapper;
  track;
  renderer;
  button;
  tickSizes;
  constructor(props, wrapper, track, renderer, button) {
    this.props = props;
    this.wrapper = wrapper;
    this.track = track;
    this.renderer = renderer;
    this.button = button;
    this.props = props;
    this.wrapper = wrapper;
    this.track = track;
    this.tickSizes = this.getTickSizes();
  }
  resizeTrack() {
    const orientation = this.props.vertical ? "height" : "width";
    const altOrientation = this.props.vertical ? "width" : "height";
    const trackWidth = this.trackWidth();
    this.track.parentElement.style[orientation] = `${trackWidth}px`;
    this.track.parentElement.style[altOrientation] = "";
  }
  resizeTicks(ticksContainer, ticks) {
    const dimension = this.props.vertical ? "height" : "width";
    [...ticks].map((tick, index) => tick.style[dimension] = `${this.tickSizes[index]}px`);
    if (this.props.vertical) {
      this.adjustPadding(ticksContainer);
    }
  }
  resizeWrapper() {
    const dimension = this.props.vertical ? "height" : "width";
    const fixedTrackWidth = calculateFixedTrackSize(this.props);
    const wrapperParentEl = this.wrapper.parentElement;
    if (fixedTrackWidth) {
      wrapperParentEl.style[dimension] = "auto";
    }
  }
  trackWidth() {
    if (this.props.fixedTickWidth) {
      return calculateFixedTrackSize(this.props);
    }
    const wrapperWidth = this.elementSize(this.wrapper.parentElement);
    const trackOffset = this.getTrackOffset();
    return wrapperWidth - trackOffset;
  }
  getTickSizes() {
    const {
      min,
      max,
      smallStep
    } = this.props;
    const count = calculateTicksCount(min, max, smallStep);
    const trackSize = this.trackWidth();
    const distStep = trackSize / subtract(max, min);
    const result = [];
    let usedSpace = 0;
    let endPoint = 0;
    for (let i = 0; i < count; i++) {
      if (i === 0 || i === count - 1) {
        endPoint += smallStep / 2 * distStep;
      } else {
        endPoint += smallStep * distStep;
      }
      endPoint = +endPoint.toFixed(2) - 0.01;
      const size = Math.round(endPoint - usedSpace);
      result.push(size);
      usedSpace += size;
    }
    if (usedSpace >= trackSize) {
      result[result.length - 1] -= 1;
    }
    return result;
  }
  adjustPadding(ticksContainer) {
    const totalTickSize = this.tickSizes.reduce((prev, curr) => prev + curr, 0);
    const trackWidth = this.trackWidth();
    const reminder = trackWidth - totalTickSize;
    if (reminder !== 0) {
      const padding = reminder + this.elementOffset(this.track);
      ticksContainer.style.paddingTop = `${padding}px`;
    }
  }
  elementOffset(element) {
    const {
      vertical
    } = this.props;
    const style2 = getComputedStyle(element);
    return parseInt(vertical ? style2.bottom : style2.left, 10);
  }
  elementSize(element) {
    const {
      vertical
    } = this.props;
    return vertical ? element.clientHeight : element.clientWidth;
  }
  getTrackOffset() {
    const showButtons = this.props.buttons && isPresent5(this.button);
    if (!showButtons) {
      return 0;
    }
    const BUTTONS_COUNT = 2;
    const buttonStyles = this.button.nativeElement.getBoundingClientRect();
    const wrapperGap = parseInt(window.getComputedStyle(this.wrapper.parentElement).gap);
    const buttonSize = this.props.vertical ? buttonStyles?.height : buttonStyles?.width;
    return (buttonSize + wrapperGap) * BUTTONS_COUNT;
  }
};
var SliderModel = class extends SliderModelBase {
  handlePosition;
  positionHandle(dragHandle) {
    const {
      max,
      min,
      reverse,
      vertical
    } = this.props;
    const position = vertical ? "bottom" : reverse ? "right" : "left";
    const trackWidth = this.trackWidth();
    const value = trimValue(max, min, this.props.value);
    this.handlePosition = calculateHandlePosition({
      min,
      max,
      reverse,
      value,
      trackWidth
    });
    this.renderer.setStyle(dragHandle, position, `${this.handlePosition}px`);
  }
  positionSelection(selection) {
    const {
      vertical
    } = this.props;
    const dimension = vertical ? "height" : "width";
    const size = this.handlePosition;
    this.renderer.setStyle(selection, dimension, `${size}px`);
  }
};
var UNTOUCHED = "ng-untouched";
var toClassList2 = (classNames) => String(classNames).trim().split(" ");
var hasClass = (element, className) => Boolean(toClassList2(element.className).find((name2) => name2 === className));
function invokeElementMethod(element, name2, ...args) {
  if (element && element.nativeElement) {
    return element.nativeElement[name2].apply(element.nativeElement, args);
  }
}
var isUntouched = (element) => element && element.nativeElement && hasClass(element.nativeElement, UNTOUCHED);
var containsFocus = (hostElement, contender) => hostElement && contender && (hostElement === contender || hostElement.contains(contender));
var closest3 = (node, predicate) => {
  while (node && !predicate(node)) {
    node = node.parentNode;
  }
  return node;
};
var packageMetadata5 = {
  name: "@progress/kendo-angular-inputs",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 1745303902,
  version: "18.5.2",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var LabelTemplateDirective = class _LabelTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function LabelTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LabelTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LabelTemplateDirective,
    selectors: [["", "kendoSliderLabelTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LabelTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSliderLabelTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var SliderBase = class _SliderBase {
  localizationService;
  injector;
  renderer;
  ngZone;
  changeDetector;
  hostElement;
  /**
   * Defines the title of the ticks ([see example]({% slug ticks_slider %}#toc-titles)). The default title
   * for each tick is its Slider value. If you use a callback function, the function accepts an argument
   * that holds the value of the component and returns a string with the new title.
   */
  title = identity;
  /**
   * Denotes the location of the tick marks in the Slider ([see example]({% slug ticks_slider %}#toc-placement)).
   *
   * The available options are:
   * * `before`&mdash;The tick marks are located to the top side of the horizontal track or to the left side of a vertical track.
   * * `after`&mdash;The tick marks are located to the bottom side of the horizontal track or to the right side of the vertical track.
   * * `both`&mdash; (Default) The tick marks are located on both sides of the track.
   * * `none`&mdash;The tick marks are not visible. The actual elements are not added to the DOM tree.
   */
  tickPlacement = "both";
  /**
   * If `vertical` is set to `true`, the orientation of the Slider changes from horizontal to vertical
   * ([see example]({% slug orientation_slider %})).
   */
  vertical = false;
  /**
   * The minimum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).
   * The attribute accepts both integers and floating-point numbers.
   */
  min = 0;
  /**
   * The maximum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).
   * The attribute accepts both integers and floating-point numbers.
   */
  max = 10;
  /**
   * The step value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).
   * Accepts positive values only. Can be an integer or a floating-point number.
   */
  smallStep = 1;
  /**
   * Specifies that every n<sup>th</sup> tick will be large and will have a label
   * ([see example]({% slug predefinedsteps_slider %}#toc-large-steps)).
   * Accepts positive integer values only.
   */
  largeStep = null;
  /**
   * Sets the width between each two ticks along the track ([see example]({% slug ticks_slider %}#toc-width)). The value
   * has to be set in pixels. If no `fixedTickWidth` is provided, the Slider automatically adjusts the tick width to
   * accommodate the elements within the size of the component.
   */
  fixedTickWidth;
  /**
   * Determines whether the Slider is disabled ([see example]({% slug disabledstate_slider %})). To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_slider#toc-managing-the-slider-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Determines whether the Slider is in its read-only state ([see example]({% slug readonly_slider %})).
   *
   * @default false
   */
  readonly = false;
  /**
   * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Slider.
   */
  tabindex = 0;
  /**
   * Fires each time the user focuses the component.
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the component is blurred.
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the user selects a new value.
   */
  valueChange = new EventEmitter();
  direction;
  get horizontalClass() {
    return !this.vertical;
  }
  get verticalClass() {
    return this.vertical;
  }
  sliderClass = true;
  get disabledClass() {
    return this.disabled;
  }
  wrapper;
  track;
  sliderSelection;
  ticksContainer;
  ticks;
  labelTemplate;
  subscriptions = new Subscription();
  isFocused;
  isDragged;
  control;
  constructor(localizationService, injector, renderer, ngZone, changeDetector, hostElement) {
    this.localizationService = localizationService;
    this.injector = injector;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.changeDetector = changeDetector;
    this.hostElement = hostElement;
    validatePackage(packageMetadata5);
    this.direction = localizationService.rtl ? "rtl" : "ltr";
  }
  /**
   * @hidden
   * Called when the status of the component changes to or from `disabled`.
   * Depending on the value, it enables or disables the appropriate DOM element.
   *
   * @param isDisabled
   */
  setDisabledState(isDisabled2) {
    this.changeDetector.markForCheck();
    this.disabled = isDisabled2;
  }
  ngOnInit() {
    this.subscriptions.add(this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
      this.sizeComponent();
    }));
    if (this.hostElement) {
      this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
    }
    this.control = this.injector.get(NgControl, null);
  }
  /**
   * @hidden
   */
  get isDisabled() {
    return this.disabled || this.readonly;
  }
  /**
   * @hidden
   */
  ifEnabled = (callback, event) => {
    if (!this.isDisabled) {
      callback.call(this, event);
    }
  };
  /**
   * @hidden
   * Used by the FloatingLabel to determine if the component is empty.
   */
  isEmpty() {
    return false;
  }
  get reverse() {
    return this.localizationService.rtl && !this.vertical;
  }
  get keyBinding() {
    const reverse = this.reverse;
    return {
      [Keys.ArrowLeft]: reverse ? increment : decrement,
      [Keys.ArrowRight]: reverse ? decrement : increment,
      [Keys.ArrowDown]: decrement,
      [Keys.ArrowUp]: increment,
      [Keys.PageUp]: incrementLarge,
      [Keys.PageDown]: decrementLarge,
      [Keys.Home]: ({
        min
      }) => min,
      [Keys.End]: ({
        max
      }) => max
    };
  }
  resetStyles(elements) {
    elements.forEach((el) => {
      if (el) {
        if (this.vertical) {
          this.renderer.removeStyle(el, "width");
          this.renderer.removeStyle(el, "left");
          this.renderer.removeStyle(el, "right");
        } else {
          this.renderer.removeStyle(el, "height");
          this.renderer.removeStyle(el, "bottom");
        }
        this.renderer.removeStyle(el, "padding-top");
      }
    });
  }
  static ɵfac = function SliderBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SliderBase)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SliderBase,
    selectors: [["kendo-slider-base"]],
    contentQueries: function SliderBase_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, LabelTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.labelTemplate = _t.first);
      }
    },
    viewQuery: function SliderBase_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c04, 7);
        ɵɵviewQuery(_c17, 7);
        ɵɵviewQuery(_c23, 7);
        ɵɵviewQuery(_c33, 5, ElementRef);
        ɵɵviewQuery(_c33, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.wrapper = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.track = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.sliderSelection = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.ticksContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.ticks = _t.first);
      }
    },
    hostVars: 11,
    hostBindings: function SliderBase_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-slider-horizontal", ctx.horizontalClass)("k-slider-vertical", ctx.verticalClass)("k-slider", ctx.sliderClass)("k-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      title: "title",
      tickPlacement: "tickPlacement",
      vertical: "vertical",
      min: "min",
      max: "max",
      smallStep: "smallStep",
      largeStep: "largeStep",
      fixedTickWidth: "fixedTickWidth",
      disabled: "disabled",
      readonly: "readonly",
      tabindex: "tabindex"
    },
    outputs: {
      onFocus: "focus",
      onBlur: "blur",
      valueChange: "valueChange"
    },
    standalone: false,
    decls: 0,
    vars: 0,
    template: function SliderBase_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SliderBase, [{
    type: Component,
    args: [{
      selector: "kendo-slider-base",
      template: ``
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: Injector
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }];
  }, {
    title: [{
      type: Input
    }],
    tickPlacement: [{
      type: Input
    }],
    vertical: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    smallStep: [{
      type: Input
    }],
    largeStep: [{
      type: Input
    }],
    fixedTickWidth: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    tabindex: [{
      type: Input
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    valueChange: [{
      type: Output
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    horizontalClass: [{
      type: HostBinding,
      args: ["class.k-slider-horizontal"]
    }],
    verticalClass: [{
      type: HostBinding,
      args: ["class.k-slider-vertical"]
    }],
    sliderClass: [{
      type: HostBinding,
      args: ["class.k-slider"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    wrapper: [{
      type: ViewChild,
      args: ["wrap", {
        static: true
      }]
    }],
    track: [{
      type: ViewChild,
      args: ["track", {
        static: true
      }]
    }],
    sliderSelection: [{
      type: ViewChild,
      args: ["sliderSelection", {
        static: true
      }]
    }],
    ticksContainer: [{
      type: ViewChild,
      args: ["ticks", {
        read: ElementRef,
        static: false
      }]
    }],
    ticks: [{
      type: ViewChild,
      args: ["ticks", {
        static: false
      }]
    }],
    labelTemplate: [{
      type: ContentChild,
      args: [LabelTemplateDirective, {
        static: false
      }]
    }]
  });
})();
var SliderTick = class {
  value;
  classes = {
    "k-tick": true
  };
  large;
  constructor(value) {
    this.value = value;
  }
};
var SliderTicksComponent = class _SliderTicksComponent {
  wrapperClasses = "k-reset k-slider-items";
  tickTitle;
  vertical;
  step;
  largeStep;
  min;
  max;
  labelTemplate;
  tickElements;
  ticks = [];
  ngOnChanges(_2) {
    this.createTicks();
  }
  createTicks() {
    const count = calculateTicksCount(this.min, this.max, this.step);
    const largeStep = this.largeStep;
    const tickValueProps = {
      max: this.max,
      min: this.min,
      smallStep: this.step
    };
    const result = [];
    for (let i = 0; i < count; i++) {
      result.push(new SliderTick(calculateValueFromTick(i, tickValueProps)));
      if (largeStep && i % largeStep === 0) {
        result[i].large = true;
        result[i].classes["k-tick-large"] = true;
      }
    }
    if (result.length > 0) {
      Object.assign(result[0].classes, this.endTickClasses(true));
      Object.assign(result[result.length - 1].classes, this.endTickClasses(false));
    }
    this.ticks = result;
  }
  endTickClasses(first) {
    return {
      "k-first": first && !this.vertical || !first && this.vertical,
      "k-last": !first && !this.vertical || first && this.vertical
    };
  }
  static ɵfac = function SliderTicksComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SliderTicksComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SliderTicksComponent,
    selectors: [["", "kendoSliderTicks", ""]],
    viewQuery: function SliderTicksComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c43, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tickElements = _t);
      }
    },
    hostVars: 2,
    hostBindings: function SliderTicksComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassMap(ctx.wrapperClasses);
      }
    },
    inputs: {
      tickTitle: "tickTitle",
      vertical: "vertical",
      step: "step",
      largeStep: "largeStep",
      min: "min",
      max: "max",
      labelTemplate: "labelTemplate"
    },
    features: [ɵɵNgOnChangesFeature],
    attrs: _c53,
    decls: 3,
    vars: 1,
    consts: [["defaultLabel", ""], ["tickElement", ""], ["role", "presentation", 3, "ngClass", "title", 4, "ngFor", "ngForOf"], ["role", "presentation", 3, "ngClass", "title"], [3, "ngSwitch"], ["class", "k-label", 4, "ngSwitchCase"], [4, "ngSwitchCase"], [1, "k-label"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function SliderTicksComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, SliderTicksComponent_li_0_Template, 5, 5, "li", 2)(1, SliderTicksComponent_ng_template_1_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵproperty("ngForOf", ctx.ticks);
      }
    },
    dependencies: [NgForOf, NgClass, NgSwitch, NgSwitchCase, NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SliderTicksComponent, [{
    type: Component,
    args: [{
      selector: "[kendoSliderTicks]",
      template: `
    <li #tickElement *ngFor="let tick of ticks;"
        [ngClass]="tick.classes"
        title="{{ tickTitle(tick.value) }}"
        role="presentation"
     >
         <ng-container [ngSwitch]="tick.large">
            <span class="k-label" *ngSwitchCase="true">
                <ng-container [ngTemplateOutlet]="labelTemplate || defaultLabel" [ngTemplateOutletContext]="tick">
                </ng-container>
            </span>
            <ng-container *ngSwitchCase="false">&nbsp;</ng-container>
         </ng-container>
     </li>

     <ng-template #defaultLabel let-value="value">
        {{ tickTitle(value) }}
     </ng-template>
  `,
      standalone: true,
      imports: [NgForOf, NgClass, NgSwitch, NgSwitchCase, NgTemplateOutlet]
    }]
  }], null, {
    wrapperClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    tickTitle: [{
      type: Input
    }],
    vertical: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    largeStep: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    labelTemplate: [{
      type: Input
    }],
    tickElements: [{
      type: ViewChildren,
      args: ["tickElement"]
    }]
  });
})();
var SliderMessages = class _SliderMessages extends ComponentMessages {
  /**
   * The title of the **Decrease** button of the Slider.
   */
  decrement;
  /**
   * The title of the **Increase** button of the Slider.
   */
  increment;
  /**
   * The title of the drag handle of the Slider.
   */
  dragHandle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵSliderMessages_BaseFactory;
    return function SliderMessages_Factory(__ngFactoryType__) {
      return (ɵSliderMessages_BaseFactory || (ɵSliderMessages_BaseFactory = ɵɵgetInheritedFactory(_SliderMessages)))(__ngFactoryType__ || _SliderMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _SliderMessages,
    selectors: [["kendo-slider-messages-base"]],
    inputs: {
      decrement: "decrement",
      increment: "increment",
      dragHandle: "dragHandle"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SliderMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-slider-messages-base"
    }]
  }], null, {
    decrement: [{
      type: Input
    }],
    increment: [{
      type: Input
    }],
    dragHandle: [{
      type: Input
    }]
  });
})();
var LocalizedSliderMessagesDirective = class _LocalizedSliderMessagesDirective extends SliderMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedSliderMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedSliderMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedSliderMessagesDirective,
    selectors: [["", "kendoSliderLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: SliderMessages,
      useExisting: forwardRef(() => _LocalizedSliderMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedSliderMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: SliderMessages,
        useExisting: forwardRef(() => LocalizedSliderMessagesDirective)
      }],
      selector: "[kendoSliderLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var PRESSED$1 = "k-pressed";
var SliderComponent = class _SliderComponent extends SliderBase {
  localization;
  injector;
  renderer;
  ngZone;
  changeDetector;
  hostElement;
  /**
   * @hidden
   */
  focusableId = `k-${guid()}`;
  /**
   * Changes the `title` attribute of the drag handle so that it can be localized.
   */
  dragHandleTitle;
  /**
   * Sets the title of the **Increase** button of the Slider ([see example]({% slug sidebuttons_slider %}#toc-titles)).
   */
  incrementTitle;
  /**
   * Determines if the animation will be played on value change.
   * Regardless of this setting, no animation will be played during the initial rendering.
   */
  animate = true;
  /**
   * Sets the title of the **Decrease** button of the Slider ([see example]({% slug sidebuttons_slider %}#toc-titles)).
   */
  decrementTitle;
  /**
   * Renders the arrow side buttons of the Slider ([see example]({% slug sidebuttons_slider %}#toc-hidden-state)).
   * When `showButtons` is set to `false`, the buttons are not displayed.
   */
  showButtons = true;
  /**
   * The current value of the Slider when it is initially displayed.
   * The component can use either NgModel or the `value` binding but not both of them at the same time.
   */
  value = this.min;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * @hidden
   */
  get currentValue() {
    return isPresent5(this.value) ? this.value.toString() : "";
  }
  /**
   * @hidden
   */
  arrowUpIcon = caretAltUpIcon;
  /**
   * @hidden
   */
  arrowDownIcon = caretAltDownIcon;
  /**
   * @hidden
   */
  arrowLeftIcon = caretAltLeftIcon;
  /**
   * @hidden
   */
  arrowRightIcon = caretAltRightIcon;
  draghandle;
  decreaseButton;
  increaseButton;
  focusChangedProgrammatically = false;
  isInvalid;
  constructor(localization, injector, renderer, ngZone, changeDetector, hostElement) {
    super(localization, injector, renderer, ngZone, changeDetector, hostElement);
    this.localization = localization;
    this.injector = injector;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.changeDetector = changeDetector;
    this.hostElement = hostElement;
  }
  /**
   * Focuses the Slider.
   *
   * @example
   * ```ts-no-run
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="slider.focus()">Focus</button>
   *  <kendo-slider #slider></kendo-slider>
   * `
   * })
   * class AppComponent { }
   * ```
   */
  focus() {
    if (!this.disabled) {
      this.focusChangedProgrammatically = true;
      invokeElementMethod(this.draghandle, "focus");
      this.focusChangedProgrammatically = false;
    }
  }
  /**
   * Blurs the Slider.
   */
  blur() {
    this.focusChangedProgrammatically = true;
    invokeElementMethod(this.draghandle, "blur");
    this.handleBlur();
    this.focusChangedProgrammatically = false;
  }
  ngOnChanges(changes) {
    if (anyChanged(["value", "fixedTickWidth", "tickPlacement"], changes, true)) {
      this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
        this.sizeComponent(false);
      });
    }
  }
  ngAfterViewInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (this.showButtons) {
      this.setValueChangeInterval(this.increaseButton.nativeElement, () => this.increaseValue());
      this.setValueChangeInterval(this.decreaseButton.nativeElement, () => this.decreaseValue());
    }
    this.sizeComponent(false);
    if (this.ticks) {
      this.ticks.tickElements.changes.subscribe(() => this.sizeComponent(false));
    }
    this.attachElementEventHandlers();
    this.isSliderInvalid();
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  get incrementMessage() {
    return this.incrementTitle || this.localizationService.get("increment");
  }
  /**
   * @hidden
   */
  get decrementMessage() {
    return this.decrementTitle || this.localizationService.get("decrement");
  }
  /**
   * @hidden
   */
  get dragHandleMessage() {
    return this.dragHandleTitle || this.localizationService.get("dragHandle");
  }
  /**
   * @hidden
   */
  onWrapClick = (args) => {
    const target = args.target;
    if (!this.isDisabled && !target.closest(".k-button")) {
      const value = eventValue(args, this.track.nativeElement, this.getProps());
      this.changeValue(value);
    }
    invokeElementMethod(this.draghandle, "focus");
  };
  /**
   * @hidden
   */
  handleDragPress(args) {
    if (args.originalEvent) {
      args.originalEvent.preventDefault();
    }
    this.renderer.removeClass(this.hostElement.nativeElement, "k-slider-transitions");
  }
  /**
   * @hidden
   */
  onHandleDrag(args) {
    this.dragging = true;
    this.changeValue(eventValue(args, this.track.nativeElement, this.getProps()));
  }
  /**
   * @hidden
   */
  onKeyDown = (e) => {
    const options2 = this.getProps();
    const {
      max,
      min
    } = options2;
    const handler = this.keyBinding[e.keyCode];
    if (this.isDisabled || !handler) {
      return;
    }
    const value = handler(options2);
    this.changeValue(trimValue(max, min, value));
    e.preventDefault();
  };
  /**
   * @hidden
   */
  onHandleRelease() {
    this.dragging = false;
    this.renderer.addClass(this.hostElement.nativeElement, "k-slider-transitions");
  }
  //ngModel binding
  /**
   * @hidden
   */
  writeValue(value) {
    this.changeDetector.markForCheck();
    this.value = value;
    this.sizeComponent(this.animate);
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.ngChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.ngTouched = fn;
  }
  /**
   * @hidden
   */
  changeValue(value) {
    if (!areSame(this.value, value)) {
      this.ngZone.run(() => {
        this.value = value;
        this.ngChange(value);
        this.valueChange.emit(value);
        this.sizeComponent(this.animate);
        this.changeDetector.markForCheck();
      });
    }
    this.isSliderInvalid();
  }
  /**
   * @hidden
   */
  sizeComponent(animate2) {
    if (!isDocumentAvailable()) {
      return;
    }
    const wrapper = this.wrapper.nativeElement;
    const track = this.track.nativeElement;
    const selectionEl = this.sliderSelection.nativeElement;
    const dragHandleEl = this.draghandle.nativeElement;
    const ticks = this.ticks ? this.ticksContainer.nativeElement : null;
    if (!animate2) {
      this.renderer.removeClass(this.hostElement.nativeElement, "k-slider-transitions");
    }
    this.resetStyles([track, selectionEl, dragHandleEl, ticks, this.hostElement.nativeElement]);
    const props = this.getProps();
    const model = new SliderModel(props, wrapper, track, this.renderer, this.increaseButton);
    model.resizeTrack();
    if (this.ticks) {
      model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map((element) => element.nativeElement));
    }
    model.positionHandle(dragHandleEl);
    model.positionSelection(selectionEl);
    if (!animate2) {
      this.hostElement.nativeElement.getBoundingClientRect();
      this.renderer.addClass(this.hostElement.nativeElement, "k-slider-transitions");
    }
    if (this.fixedTickWidth) {
      model.resizeWrapper();
    }
  }
  set focused(value) {
    if (this.isFocused !== value && this.hostElement) {
      this.isFocused = value;
    }
  }
  set dragging(value) {
    if (this.isDragged !== value && this.sliderSelection && this.draghandle) {
      const sliderSelection = this.sliderSelection.nativeElement;
      const draghandle = this.draghandle.nativeElement;
      if (value) {
        this.renderer.addClass(sliderSelection, PRESSED$1);
        this.renderer.addClass(draghandle, PRESSED$1);
      } else {
        this.renderer.removeClass(sliderSelection, PRESSED$1);
        this.renderer.removeClass(draghandle, PRESSED$1);
      }
      this.isDragged = value;
    }
  }
  setValueChangeInterval(element, callback) {
    this.ngZone.runOutsideAngular(() => {
      const pointerdown = fromEvent(element, "pointerdown");
      const pointerup = fromEvent(element, "pointerup");
      const pointerout = fromEvent(element, "pointerout");
      const subscription = pointerdown.pipe(tap((e) => e.preventDefault()), filter((e) => e.button === 0 && !this.isDisabled), concatMap(() => interval(150).pipe(startWith(-1), takeUntil(merge(pointerup, pointerout))))).subscribe(() => {
        if (!this.isFocused) {
          invokeElementMethod(this.draghandle, "focus");
        }
        callback();
      });
      this.subscriptions.add(subscription);
    });
  }
  ngChange = (_2) => {
  };
  ngTouched = () => {
  };
  decreaseValue = () => {
    this.changeValue(decreaseValueToStep(this.value, this.getProps()));
  };
  increaseValue = () => {
    this.changeValue(increaseValueToStep(this.value, this.getProps()));
  };
  getProps() {
    return {
      buttons: this.showButtons,
      disabled: this.disabled,
      fixedTickWidth: this.fixedTickWidth,
      largeStep: this.largeStep,
      max: this.max,
      min: this.min,
      readonly: this.readonly,
      reverse: this.reverse,
      rtl: this.localizationService.rtl,
      smallStep: this.smallStep,
      value: trimValue(this.max, this.min, this.value),
      vertical: this.vertical
    };
  }
  isSliderInvalid() {
    const sliderClasses = this.hostElement.nativeElement.classList;
    this.isInvalid = sliderClasses.contains("ng-invalid") ? true : false;
    this.renderer.setAttribute(this.draghandle.nativeElement, "aria-invalid", `${this.isInvalid}`);
  }
  attachElementEventHandlers() {
    const hostElement = this.hostElement.nativeElement;
    let tabbing = false;
    let cursorInsideWrapper = false;
    this.ngZone.runOutsideAngular(() => {
      this.subscriptions.add(this.renderer.listen(hostElement, "focusin", () => {
        if (!this.isFocused) {
          this.ngZone.run(() => {
            if (!this.focusChangedProgrammatically) {
              this.onFocus.emit();
            }
            this.focused = true;
          });
        }
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "focusout", (args) => {
        if (!this.isFocused) {
          return;
        }
        if (tabbing) {
          if (args.relatedTarget !== this.draghandle.nativeElement) {
            this.handleBlur();
          }
          tabbing = false;
        } else {
          if (!cursorInsideWrapper) {
            this.handleBlur();
          }
        }
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "mouseenter", () => {
        cursorInsideWrapper = true;
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "mouseleave", () => {
        cursorInsideWrapper = false;
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "keydown", (args) => {
        if (args.keyCode === Keys.Tab) {
          tabbing = true;
        } else {
          tabbing = false;
        }
      }));
    });
  }
  handleBlur = () => {
    this.changeDetector.markForCheck();
    this.focused = false;
    if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
      this.ngZone.run(() => {
        this.ngTouched();
        if (!this.focusChangedProgrammatically) {
          this.onBlur.emit();
        }
      });
    }
  };
  get decreaseButtonArrowIcon() {
    const icon = !this.vertical ? this.direction === "ltr" ? "caret-alt-left" : "caret-alt-right" : "caret-alt-down";
    return icon;
  }
  get increaseButtonArrowIcon() {
    const icon = !this.vertical ? this.direction === "ltr" ? "caret-alt-right" : "caret-alt-left" : "caret-alt-up";
    return icon;
  }
  get decreaseButtonArrowSVGIcon() {
    const icon = !this.vertical ? this.direction === "ltr" ? this.arrowLeftIcon : this.arrowRightIcon : this.arrowDownIcon;
    return icon;
  }
  get increaseButtonArrowSVGIcon() {
    const icon = !this.vertical ? this.direction === "ltr" ? this.arrowRightIcon : this.arrowLeftIcon : this.arrowUpIcon;
    return icon;
  }
  static ɵfac = function SliderComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SliderComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SliderComponent,
    selectors: [["kendo-slider"]],
    viewQuery: function SliderComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c63, 7);
        ɵɵviewQuery(_c73, 5, ElementRef);
        ɵɵviewQuery(_c83, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.draghandle = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.decreaseButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.increaseButton = _t.first);
      }
    },
    inputs: {
      focusableId: "focusableId",
      dragHandleTitle: "dragHandleTitle",
      incrementTitle: "incrementTitle",
      animate: "animate",
      decrementTitle: "decrementTitle",
      showButtons: "showButtons",
      value: "value",
      tabIndex: "tabIndex"
    },
    exportAs: ["kendoSlider"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.slider"
    }, {
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _SliderComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _SliderComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 13,
    vars: 23,
    consts: () => {
      let i18n_0;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_0 = goog.getMsg("increment");
        i18n_0 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_0;
      } else {
        i18n_0 = $localize`:kendo.slider.increment|The title of the **Increase** button of the Slider.:increment`;
      }
      let i18n_1;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_1 = goog.getMsg("decrement");
        i18n_1 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_1;
      } else {
        i18n_1 = $localize`:kendo.slider.decrement|The title of the **Decrease** button of the Slider.:decrement`;
      }
      let i18n_2;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_2 = goog.getMsg("Drag");
        i18n_2 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_2;
      } else {
        i18n_2 = $localize`:kendo.slider.dragHandle|The title of the drag handle of the Slider.:Drag`;
      }
      return [["wrap", ""], ["track", ""], ["sliderSelection", ""], ["draghandle", ""], ["decreaseButton", ""], ["ticks", ""], ["increaseButton", ""], ["kendoSliderLocalizedMessages", "", "increment", i18n_0, "decrement", i18n_1, "dragHandle", i18n_2], ["kendoButton", "", "type", "button", "rounded", "full", "class", "k-button-decrease", "aria-hidden", "true", 3, "icon", "svgIcon", "title", 4, "ngIf"], [1, "k-slider-track-wrap", 3, "kendoEventsOutsideAngular"], ["kendoSliderTicks", "", "aria-hidden", "true", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate", 4, "ngIf"], [1, "k-slider-track"], [1, "k-slider-selection"], ["role", "slider", "kendoDraggable", "", 1, "k-draghandle", "k-draghandle-end", 3, "kendoPress", "kendoDrag", "kendoRelease", "title", "id"], ["kendoButton", "", "type", "button", "rounded", "full", "class", "k-button-increase", "aria-hidden", "true", 3, "icon", "svgIcon", "title", 4, "ngIf"], [3, "resize"], ["kendoButton", "", "type", "button", "rounded", "full", "aria-hidden", "true", 1, "k-button-decrease", 3, "icon", "svgIcon", "title"], ["kendoSliderTicks", "", "aria-hidden", "true", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate"], ["kendoButton", "", "type", "button", "rounded", "full", "aria-hidden", "true", 1, "k-button-increase", 3, "icon", "svgIcon", "title"]];
    },
    template: function SliderComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainerStart(0, 7);
        ɵɵtemplate(1, SliderComponent_button_1_Template, 2, 4, "button", 8);
        ɵɵelementStart(2, "div", 9, 0);
        ɵɵtemplate(4, SliderComponent_ul_4_Template, 2, 7, "ul", 10);
        ɵɵelementStart(5, "div", 11, 1);
        ɵɵelement(7, "div", 12, 2);
        ɵɵelementStart(9, "span", 13, 3);
        ɵɵlistener("kendoPress", function SliderComponent_Template_span_kendoPress_9_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.ifEnabled(ctx.handleDragPress, $event));
        })("kendoDrag", function SliderComponent_Template_span_kendoDrag_9_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.ifEnabled(ctx.onHandleDrag, $event));
        })("kendoRelease", function SliderComponent_Template_span_kendoRelease_9_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.ifEnabled(ctx.onHandleRelease, $event));
        });
        ɵɵelementEnd()()();
        ɵɵtemplate(11, SliderComponent_button_11_Template, 2, 4, "button", 14);
        ɵɵelementStart(12, "kendo-resize-sensor", 15);
        ɵɵlistener("resize", function SliderComponent_Template_kendo_resize_sensor_resize_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.sizeComponent(false));
        });
        ɵɵelementEnd();
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showButtons);
        ɵɵadvance();
        ɵɵclassProp("k-slider-topleft", ctx.tickPlacement === "before")("k-slider-bottomright", ctx.tickPlacement === "after");
        ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction2(20, _c93, ctx.onWrapClick, ctx.onKeyDown));
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.tickPlacement !== "none");
        ɵɵadvance(5);
        ɵɵstyleProp("touch-action", ctx.isDisabled ? "" : "none");
        ɵɵproperty("title", ctx.dragHandleMessage)("id", ctx.focusableId);
        ɵɵattribute("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.currentValue)("aria-valuetext", ctx.currentValue)("aria-disabled", ctx.disabled ? true : void 0)("aria-readonly", ctx.readonly ? true : void 0)("aria-orientation", ctx.vertical ? "vertical" : "horizontal")("tabindex", ctx.disabled ? "-1" : ctx.tabIndex);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.showButtons);
      }
    },
    dependencies: [LocalizedSliderMessagesDirective, NgIf, ButtonComponent, EventsOutsideAngularDirective, SliderTicksComponent, DraggableDirective, ResizeSensorComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SliderComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoSlider",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.slider"
      }, {
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => SliderComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => SliderComponent)
      }],
      selector: "kendo-slider",
      template: `
        <ng-container kendoSliderLocalizedMessages
            i18n-increment="kendo.slider.increment|The title of the **Increase** button of the Slider."
            increment="increment"
            i18n-decrement="kendo.slider.decrement|The title of the **Decrease** button of the Slider."
            decrement="decrement"
            i18n-dragHandle="kendo.slider.dragHandle|The title of the drag handle of the Slider."
            dragHandle="Drag"
        >
        <button
            kendoButton
            #decreaseButton
            *ngIf="showButtons"
            type="button"
            rounded="full"
            [icon]="decreaseButtonArrowIcon"
            [svgIcon]="decreaseButtonArrowSVGIcon"
            class="k-button-decrease"
            [title]="decrementMessage"
            aria-hidden="true"
            [attr.tabindex]="-1"
        ></button>
        <div
            #wrap
            class="k-slider-track-wrap"
            [class.k-slider-topleft]="tickPlacement === 'before'"
            [class.k-slider-bottomright]="tickPlacement === 'after'"
            [kendoEventsOutsideAngular]="{ click: onWrapClick, keydown: onKeyDown }"
        >
            <ul kendoSliderTicks
                #ticks
                *ngIf="tickPlacement !== 'none'"
                [tickTitle]="title"
                [vertical]="vertical"
                [step]="smallStep"
                [largeStep]="largeStep"
                [min]="min"
                [max]="max"
                [labelTemplate]="labelTemplate?.templateRef"
                aria-hidden="true"
            >
            </ul>
            <div #track class="k-slider-track">
                <div #sliderSelection class="k-slider-selection">
                </div>
                <span #draghandle
                    role="slider"
                    [attr.aria-valuemin]="min"
                    [attr.aria-valuemax]="max"
                    [attr.aria-valuenow]="currentValue"
                    [attr.aria-valuetext]="currentValue"
                    [attr.aria-disabled]="disabled ? true : undefined"
                    [attr.aria-readonly]="readonly ? true : undefined"
                    [attr.aria-orientation]="vertical ? 'vertical' : 'horizontal'"
                    [style.touch-action]="isDisabled ? '' : 'none'"
                    class="k-draghandle k-draghandle-end"
                    [title]="dragHandleMessage"
                    [attr.tabindex]="disabled ? '-1' : tabIndex"
                    [id]="focusableId"
                    kendoDraggable
                    (kendoPress)="ifEnabled(handleDragPress, $event)"
                    (kendoDrag)="ifEnabled(onHandleDrag, $event)"
                    (kendoRelease)="ifEnabled(onHandleRelease, $event)"
                ></span>
            </div>
        </div>
        <button
            kendoButton
            #increaseButton
            *ngIf="showButtons"
            type="button"
            rounded="full"
            [icon]="increaseButtonArrowIcon"
            [svgIcon]="increaseButtonArrowSVGIcon"
            class="k-button-increase"
            [title]="incrementMessage"
            [attr.tabindex]="-1"
            aria-hidden="true"
        ></button>
        <kendo-resize-sensor (resize)="sizeComponent(false)"></kendo-resize-sensor>
  `,
      standalone: true,
      imports: [LocalizedSliderMessagesDirective, NgIf, ButtonComponent, EventsOutsideAngularDirective, SliderTicksComponent, DraggableDirective, ResizeSensorComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: Injector
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }];
  }, {
    focusableId: [{
      type: Input
    }],
    dragHandleTitle: [{
      type: Input
    }],
    incrementTitle: [{
      type: Input
    }],
    animate: [{
      type: Input
    }],
    decrementTitle: [{
      type: Input
    }],
    showButtons: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    draghandle: [{
      type: ViewChild,
      args: ["draghandle", {
        static: true
      }]
    }],
    decreaseButton: [{
      type: ViewChild,
      args: ["decreaseButton", {
        read: ElementRef
      }]
    }],
    increaseButton: [{
      type: ViewChild,
      args: ["increaseButton", {
        read: ElementRef
      }]
    }]
  });
})();
var RangeSliderModel = class extends SliderModelBase {
  startHandlePosition;
  endHandlePosition;
  positionHandle(dragHandle) {
    if (!dragHandle.id) {
      return;
    }
    const {
      max,
      min,
      reverse,
      vertical
    } = this.props;
    const position = vertical ? "bottom" : reverse ? "right" : "left";
    const trackWidth = this.trackWidth();
    const value = isStartHandle(dragHandle) ? trimValueRange(max, min, this.props.value)[0] : trimValueRange(max, min, this.props.value)[1];
    if (isStartHandle(dragHandle)) {
      this.startHandlePosition = calculateHandlePosition({
        min,
        max,
        reverse,
        value,
        trackWidth
      });
      this.renderer.setStyle(dragHandle, position, `${this.startHandlePosition}px`);
    } else {
      this.endHandlePosition = calculateHandlePosition({
        min,
        max,
        reverse,
        value,
        trackWidth
      });
      this.renderer.setStyle(dragHandle, position, `${this.endHandlePosition}px`);
    }
  }
  positionSelection(dragHandle, selection) {
    const {
      reverse,
      vertical
    } = this.props;
    const dimension = vertical ? "height" : "width";
    const position = vertical ? "bottom" : reverse ? "right" : "left";
    const size = Math.abs(this.endHandlePosition - this.startHandlePosition);
    const currentSelectionPosition = vertical ? dragHandle.style.bottom : reverse ? dragHandle.style.right : dragHandle.style.left;
    this.renderer.setStyle(selection, dimension, `${size}px`);
    this.renderer.setStyle(selection, position, parseFloat(currentSelectionPosition) + "px");
  }
};
var RangeSliderMessages = class _RangeSliderMessages extends ComponentMessages {
  /**
   * The title of the range `start` drag handle.
   */
  dragHandleStart;
  /**
   * The title of the range `end` drag handle.
   */
  dragHandleEnd;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵRangeSliderMessages_BaseFactory;
    return function RangeSliderMessages_Factory(__ngFactoryType__) {
      return (ɵRangeSliderMessages_BaseFactory || (ɵRangeSliderMessages_BaseFactory = ɵɵgetInheritedFactory(_RangeSliderMessages)))(__ngFactoryType__ || _RangeSliderMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _RangeSliderMessages,
    selectors: [["kendo-rangeslider-messages-base"]],
    inputs: {
      dragHandleStart: "dragHandleStart",
      dragHandleEnd: "dragHandleEnd"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeSliderMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-rangeslider-messages-base"
    }]
  }], null, {
    dragHandleStart: [{
      type: Input
    }],
    dragHandleEnd: [{
      type: Input
    }]
  });
})();
var LocalizedRangeSliderMessagesDirective = class _LocalizedRangeSliderMessagesDirective extends RangeSliderMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedRangeSliderMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedRangeSliderMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedRangeSliderMessagesDirective,
    selectors: [["", "kendoSliderLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: RangeSliderMessages,
      useExisting: forwardRef(() => _LocalizedRangeSliderMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedRangeSliderMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: RangeSliderMessages,
        useExisting: forwardRef(() => LocalizedRangeSliderMessagesDirective)
      }],
      selector: "[kendoSliderLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var PRESSED = "k-pressed";
var RangeSliderComponent = class _RangeSliderComponent extends SliderBase {
  localization;
  injector;
  renderer;
  ngZone;
  changeDetector;
  hostElement;
  /**
   * Sets the range value of the RangeSlider.
   * The component can use either NgModel or the `value` binding but not both of them at the same time.
   */
  value;
  draghandleStart;
  draghandleEnd;
  /**
   * @hidden
   */
  startHandleId = `k-start-handle-${guid()}`;
  /**
   * @hidden
   */
  endHandleId = `k-end-handle-${guid()}`;
  /**
   * @hidden
   */
  focusableId = this.startHandleId;
  draggedHandle;
  lastHandlePosition;
  activeHandle = "startHandle";
  focusChangedProgrammatically = false;
  isInvalid;
  constructor(localization, injector, renderer, ngZone, changeDetector, hostElement) {
    super(localization, injector, renderer, ngZone, changeDetector, hostElement);
    this.localization = localization;
    this.injector = injector;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.changeDetector = changeDetector;
    this.hostElement = hostElement;
  }
  /**
   * Focuses the RangeSlider.
   *
   * @example
   * ```ts-no-run
   * _@Component({
   * selector: 'my-app',
   * template: `
   *     <div>
   *         <button class="k-button" (click)="slider.focus()">Focus</button>
   *     </div>
   *     <kendo-rangeslider #slider></kendo-rangeslider>
   * `
   * })
   * class AppComponent { }
   * ```
   */
  focus() {
    this.focusChangedProgrammatically = true;
    invokeElementMethod(this.draghandleStart, "focus");
    this.focusChangedProgrammatically = false;
  }
  /**
   * Blurs the RangeSlider.
   */
  blur() {
    this.focusChangedProgrammatically = true;
    const activeHandle = this.activeHandle === "startHandle" ? this.draghandleStart : this.draghandleEnd;
    invokeElementMethod(activeHandle, "blur");
    this.handleBlur();
    this.focusChangedProgrammatically = false;
  }
  ngOnInit() {
    if (!this.value) {
      this.value = [this.min, this.max];
    }
    super.ngOnInit();
  }
  ngOnChanges(changes) {
    if (anyChanged(["value", "fixedTickWidth", "tickPlacement"], changes, true)) {
      if (changes["value"] && changes["value"].currentValue) {
        validateValue(changes["value"].currentValue);
      }
      this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
        this.sizeComponent();
      });
    }
  }
  ngAfterViewInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.sizeComponent();
    if (this.ticks) {
      this.ticks.tickElements.changes.subscribe(() => this.sizeComponent());
    }
    this.isRangeSliderInvalid();
    this.attachElementEventHandlers();
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  textFor(key) {
    return this.localization.get(key);
  }
  /**
   * @hidden
   */
  get valueText() {
    return this.value ? `${this.value[0]} - ${this.value[1]}` : "";
  }
  /**
   * @hidden
   */
  onWrapClick = (args) => {
    if (!this.isDisabled) {
      this.value = this.value || [this.min, this.min];
      const trackValue = eventValue(args, this.track.nativeElement, this.getProps());
      let newRangeValue;
      const [startValue, endValue] = newRangeValue = this.value;
      if (trackValue <= startValue) {
        newRangeValue = [trackValue, endValue];
        this.activeHandle = "startHandle";
      } else if (startValue < trackValue && trackValue < endValue) {
        if (trackValue < (startValue + endValue) / 2) {
          newRangeValue = [trackValue, endValue];
          this.activeHandle = "startHandle";
        } else {
          newRangeValue = [startValue, trackValue];
          this.activeHandle = "endHandle";
        }
      } else if (trackValue >= endValue) {
        newRangeValue = [startValue, trackValue];
        this.activeHandle = "endHandle";
      }
      const activeHandle = this.activeHandle === "startHandle" ? this.draghandleStart : this.draghandleEnd;
      invokeElementMethod(activeHandle, "focus");
      this.changeValue(newRangeValue);
    }
  };
  /**
   * @hidden
   */
  handleDragPress(args) {
    if (args.originalEvent) {
      args.originalEvent.preventDefault();
    }
    const target = args.originalEvent.target;
    this.draggedHandle = target;
    const nonDraggedHandle = this.draghandleStart.nativeElement === this.draggedHandle ? this.draghandleEnd.nativeElement : this.draghandleStart.nativeElement;
    this.renderer.removeStyle(nonDraggedHandle, "zIndex");
    this.renderer.setStyle(target, "zIndex", 1);
  }
  /**
   * @hidden
   */
  onHandleDrag(args) {
    this.value = this.value || [this.min, this.min];
    const target = args.originalEvent.target;
    const lastCoords = this.draggedHandle.getBoundingClientRect();
    this.lastHandlePosition = {
      x: lastCoords.left,
      y: lastCoords.top
    };
    this.dragging = {
      value: true,
      target
    };
    const mousePos = {
      x: args.pageX - 0.5 - lastCoords.width / 2,
      y: args.pageY - lastCoords.width / 2
    };
    const left = mousePos.x < this.lastHandlePosition.x;
    const right = mousePos.x > this.lastHandlePosition.x;
    const up = mousePos.y > this.lastHandlePosition.y;
    const moveStartHandle = () => this.changeValue([eventValue(args, this.track.nativeElement, this.getProps()), this.value[1]]);
    const moveEndHandle = () => this.changeValue([this.value[0], eventValue(args, this.track.nativeElement, this.getProps())]);
    const moveBothHandles = () => this.changeValue([eventValue(args, this.track.nativeElement, this.getProps()), eventValue(args, this.track.nativeElement, this.getProps())]);
    const activeStartHandle = isStartHandle(this.draggedHandle);
    const vertical = this.vertical;
    const horizontal = !vertical;
    const forward = vertical && up || (this.reverse ? horizontal && right : horizontal && left);
    const incorrectValueState = this.value[0] > this.value[1];
    if (this.value[0] === this.value[1] || incorrectValueState) {
      if (forward) {
        activeStartHandle ? moveStartHandle() : moveBothHandles();
      } else {
        activeStartHandle ? moveBothHandles() : moveEndHandle();
      }
    } else {
      activeStartHandle ? moveStartHandle() : moveEndHandle();
    }
  }
  /**
   * @hidden
   */
  onKeyDown = (e) => {
    this.value = this.value || [this.min, this.min];
    const options2 = this.getProps();
    const {
      max,
      min
    } = options2;
    const handler = this.keyBinding[e.keyCode];
    if (this.isDisabled || !handler) {
      return;
    }
    const startHandleIsActive = isStartHandle(e.target);
    const nonDraggedHandle = startHandleIsActive ? this.draghandleEnd.nativeElement : this.draghandleStart.nativeElement;
    this.renderer.removeStyle(nonDraggedHandle, "zIndex");
    this.renderer.setStyle(e.target, "zIndex", 1);
    const value = handler(__spreadProps(__spreadValues({}, options2), {
      value: startHandleIsActive ? this.value[0] : this.value[1]
    }));
    if (startHandleIsActive) {
      if (value > this.value[1]) {
        this.value[1] = value;
      }
    } else {
      if (value < this.value[0]) {
        this.value[0] = value;
      }
    }
    const trimmedValue = trimValue(max, min, value);
    const newValue = startHandleIsActive ? [trimmedValue, this.value[1]] : [this.value[0], trimmedValue];
    this.changeValue(newValue);
    e.preventDefault();
  };
  /**
   * @hidden
   */
  onHandleRelease(args) {
    this.dragging = {
      value: false,
      target: args.originalEvent.target
    };
    this.draggedHandle = void 0;
  }
  //ngModel binding
  /**
   * @hidden
   */
  writeValue(value) {
    validateValue(value);
    this.value = value;
    this.sizeComponent();
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.ngChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.ngTouched = fn;
  }
  /**
   * @hidden
   */
  changeValue(value) {
    if (!this.value || !isSameRange(this.value, value)) {
      this.ngZone.run(() => {
        this.value = value;
        this.ngChange(value);
        if (this.value) {
          this.valueChange.emit(value);
        }
        this.sizeComponent();
      });
    }
    this.isRangeSliderInvalid();
  }
  /**
   * @hidden
   */
  sizeComponent() {
    if (!isDocumentAvailable()) {
      return;
    }
    const wrapper = this.wrapper.nativeElement;
    const track = this.track.nativeElement;
    const selectionEl = this.sliderSelection.nativeElement;
    const dragHandleStartEl = this.draghandleStart.nativeElement;
    const dragHandleEndEl = this.draghandleEnd.nativeElement;
    const ticks = this.ticks ? this.ticksContainer.nativeElement : null;
    this.resetStyles([track, selectionEl, dragHandleStartEl, dragHandleEndEl, ticks, this.hostElement.nativeElement]);
    const props = this.getProps();
    const model = new RangeSliderModel(props, wrapper, track, this.renderer);
    model.resizeTrack();
    if (this.ticks) {
      model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map((element) => element.nativeElement));
    }
    model.positionHandle(dragHandleStartEl);
    model.positionHandle(dragHandleEndEl);
    model.positionSelection(dragHandleStartEl, selectionEl);
    if (this.fixedTickWidth) {
      model.resizeWrapper();
    }
  }
  /**
   * @hidden
   */
  get isDisabled() {
    return this.disabled || this.readonly;
  }
  /**
   * @hidden
   * Used by the FloatingLabel to determine if the component is empty.
   */
  isEmpty() {
    return false;
  }
  set focused(value) {
    if (this.isFocused !== value && this.hostElement) {
      this.isFocused = value;
    }
  }
  set dragging(data) {
    if (this.isDragged !== data.value && this.sliderSelection && this.draghandleStart && this.draghandleEnd) {
      const sliderSelection = this.sliderSelection.nativeElement;
      const draghandle = data.target;
      if (data.value) {
        this.renderer.addClass(sliderSelection, PRESSED);
        this.renderer.addClass(draghandle, PRESSED);
      } else {
        this.renderer.removeClass(sliderSelection, PRESSED);
        this.renderer.removeClass(draghandle, PRESSED);
      }
      this.isDragged = data.value;
    }
  }
  ngChange = (_2) => {
  };
  ngTouched = () => {
  };
  getProps() {
    return {
      disabled: this.disabled,
      fixedTickWidth: this.fixedTickWidth,
      largeStep: this.largeStep,
      max: this.max,
      min: this.min,
      readonly: this.readonly,
      reverse: this.reverse,
      rtl: this.localizationService.rtl,
      smallStep: this.smallStep,
      value: trimValueRange(this.max, this.min, this.value),
      vertical: this.vertical,
      buttons: false
    };
  }
  isRangeSliderInvalid() {
    const rangeSliderClasses = this.hostElement.nativeElement.classList;
    this.isInvalid = rangeSliderClasses.contains("ng-invalid") ? true : false;
    this.renderer.setAttribute(this.draghandleStart.nativeElement, "aria-invalid", `${this.isInvalid}`);
    this.renderer.setAttribute(this.draghandleEnd.nativeElement, "aria-invalid", `${this.isInvalid}`);
  }
  attachElementEventHandlers() {
    const hostElement = this.hostElement.nativeElement;
    let tabbing = false;
    let cursorInsideWrapper = false;
    this.ngZone.runOutsideAngular(() => {
      this.subscriptions.add(this.renderer.listen(hostElement, "focusin", () => {
        if (!this.isFocused) {
          this.ngZone.run(() => {
            if (!this.focusChangedProgrammatically) {
              this.onFocus.emit();
            }
            this.focused = true;
          });
        }
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "focusout", (args) => {
        if (!this.isFocused) {
          return;
        }
        if (tabbing) {
          if (args.relatedTarget !== this.draghandleStart.nativeElement && args.relatedTarget !== this.draghandleEnd.nativeElement) {
            this.handleBlur();
          }
          tabbing = false;
        } else {
          if (!cursorInsideWrapper) {
            this.handleBlur();
          }
        }
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "mouseenter", () => {
        cursorInsideWrapper = true;
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "mouseleave", () => {
        cursorInsideWrapper = false;
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "keydown", (args) => {
        if (args.keyCode === Keys.Tab) {
          tabbing = true;
        } else {
          tabbing = false;
        }
      }));
    });
  }
  handleBlur = () => {
    this.changeDetector.markForCheck();
    this.focused = false;
    if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
      this.ngZone.run(() => {
        this.ngTouched();
        if (!this.focusChangedProgrammatically) {
          this.onBlur.emit();
        }
      });
    }
  };
  static ɵfac = function RangeSliderComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RangeSliderComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _RangeSliderComponent,
    selectors: [["kendo-rangeslider"]],
    viewQuery: function RangeSliderComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c103, 7);
        ɵɵviewQuery(_c112, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.draghandleStart = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.draghandleEnd = _t.first);
      }
    },
    inputs: {
      value: "value"
    },
    exportAs: ["kendoRangeSlider"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.rangeslider"
    }, {
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _RangeSliderComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _RangeSliderComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 13,
    vars: 33,
    consts: () => {
      let i18n_3;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_3 = goog.getMsg("Drag");
        i18n_3 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_3;
      } else {
        i18n_3 = $localize`:kendo.rangeslider.dragHandleStart|The title of the **Start** drag handle of the Slider.:Drag`;
      }
      let i18n_4;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_4 = goog.getMsg("Drag");
        i18n_4 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_4;
      } else {
        i18n_4 = $localize`:kendo.rangeslider.dragHandleEnd|The title of the **End** drag handle of the Slider.:Drag`;
      }
      return [["wrap", ""], ["track", ""], ["sliderSelection", ""], ["draghandleStart", ""], ["draghandleEnd", ""], ["ticks", ""], ["kendoSliderLocalizedMessages", "", "dragHandleStart", i18n_3, "dragHandleEnd", i18n_4], [1, "k-slider-track-wrap", 3, "kendoEventsOutsideAngular"], ["kendoSliderTicks", "", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate", 4, "ngIf"], [1, "k-slider-track"], [1, "k-slider-selection"], ["role", "slider", "kendoDraggable", "", 1, "k-draghandle", 3, "kendoPress", "kendoDrag", "kendoRelease", "id", "title"], [3, "resize"], ["kendoSliderTicks", "", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate"]];
    },
    template: function RangeSliderComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainerStart(0, 6);
        ɵɵelementStart(1, "div", 7, 0);
        ɵɵtemplate(3, RangeSliderComponent_ul_3_Template, 2, 8, "ul", 8);
        ɵɵelementStart(4, "div", 9, 1);
        ɵɵelement(6, "div", 10, 2);
        ɵɵelementStart(8, "span", 11, 3);
        ɵɵlistener("kendoPress", function RangeSliderComponent_Template_span_kendoPress_8_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.ifEnabled(ctx.handleDragPress, $event));
        })("kendoDrag", function RangeSliderComponent_Template_span_kendoDrag_8_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.ifEnabled(ctx.onHandleDrag, $event));
        })("kendoRelease", function RangeSliderComponent_Template_span_kendoRelease_8_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.ifEnabled(ctx.onHandleRelease, $event));
        });
        ɵɵelementEnd();
        ɵɵelementStart(10, "span", 11, 4);
        ɵɵlistener("kendoPress", function RangeSliderComponent_Template_span_kendoPress_10_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.ifEnabled(ctx.handleDragPress, $event));
        })("kendoDrag", function RangeSliderComponent_Template_span_kendoDrag_10_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.ifEnabled(ctx.onHandleDrag, $event));
        })("kendoRelease", function RangeSliderComponent_Template_span_kendoRelease_10_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.ifEnabled(ctx.onHandleRelease, $event));
        });
        ɵɵelementEnd()()();
        ɵɵelementStart(12, "kendo-resize-sensor", 12);
        ɵɵlistener("resize", function RangeSliderComponent_Template_kendo_resize_sensor_resize_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.sizeComponent());
        });
        ɵɵelementEnd();
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵclassProp("k-slider-topleft", ctx.tickPlacement === "before")("k-slider-bottomright", ctx.tickPlacement === "after");
        ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction2(30, _c93, ctx.onWrapClick, ctx.onKeyDown));
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.tickPlacement !== "none");
        ɵɵadvance(5);
        ɵɵstyleProp("touch-action", ctx.isDisabled ? "" : "none");
        ɵɵproperty("id", ctx.startHandleId)("title", ctx.textFor("dragHandleStart"));
        ɵɵattribute("tabindex", ctx.disabled ? void 0 : ctx.tabindex)("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.value ? ctx.value[0] : null)("aria-valuetext", ctx.valueText)("aria-disabled", ctx.disabled ? true : void 0)("aria-readonly", ctx.readonly ? true : void 0)("aria-orientation", ctx.vertical ? "vertical" : "horizontal");
        ɵɵadvance(2);
        ɵɵstyleProp("touch-action", ctx.isDisabled ? "" : "none");
        ɵɵproperty("id", ctx.endHandleId)("title", ctx.textFor("dragHandleEnd"));
        ɵɵattribute("tabindex", ctx.disabled ? void 0 : ctx.tabindex)("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.value ? ctx.value[1] : null)("aria-valuetext", ctx.valueText)("aria-disabled", ctx.disabled ? true : void 0)("aria-readonly", ctx.readonly ? true : void 0)("aria-orientation", ctx.vertical ? "vertical" : "horizontal");
      }
    },
    dependencies: [LocalizedRangeSliderMessagesDirective, EventsOutsideAngularDirective, NgIf, SliderTicksComponent, DraggableDirective, ResizeSensorComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeSliderComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoRangeSlider",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.rangeslider"
      }, {
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => RangeSliderComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => RangeSliderComponent)
      }],
      selector: "kendo-rangeslider",
      template: `
        <ng-container kendoSliderLocalizedMessages
            i18n-dragHandleStart="kendo.rangeslider.dragHandleStart|The title of the **Start** drag handle of the Slider."
            dragHandleStart="Drag"
            i18n-dragHandleEnd="kendo.rangeslider.dragHandleEnd|The title of the **End** drag handle of the Slider."
            dragHandleEnd="Drag"
        >

        <div
            #wrap
            class="k-slider-track-wrap"
            [class.k-slider-topleft]="tickPlacement === 'before'"
            [class.k-slider-bottomright]="tickPlacement === 'after'"
            [kendoEventsOutsideAngular]="{ click: onWrapClick, keydown: onKeyDown }"
        >
            <ul kendoSliderTicks
                #ticks
                *ngIf="tickPlacement !== 'none'"
                [tickTitle]="title"
                [vertical]="vertical"
                [step]="smallStep"
                [largeStep]="largeStep"
                [min]="min"
                [max]="max"
                [labelTemplate]="labelTemplate?.templateRef"
                [attr.aria-hidden]="true"
            >
            </ul>
            <div #track class="k-slider-track">
                <div #sliderSelection class="k-slider-selection">
                </div>
                <span #draghandleStart
                    role="slider"
                    [id]="startHandleId"
                    [attr.tabindex]="disabled ? undefined : tabindex"
                    [attr.aria-valuemin]="min"
                    [attr.aria-valuemax]="max"
                    [attr.aria-valuenow]="value ? value[0] : null"
                    [attr.aria-valuetext]="valueText"
                    [attr.aria-disabled]="disabled ? true : undefined"
                    [attr.aria-readonly]="readonly ? true : undefined"
                    [attr.aria-orientation]="vertical ? 'vertical' : 'horizontal'"
                    [style.touch-action]="isDisabled ? '' : 'none'"
                    class="k-draghandle"
                    [title]="textFor('dragHandleStart')"
                    kendoDraggable
                    (kendoPress)="ifEnabled(handleDragPress ,$event)"
                    (kendoDrag)="ifEnabled(onHandleDrag ,$event)"
                    (kendoRelease)="ifEnabled(onHandleRelease, $event)"
                ></span>
                <span #draghandleEnd
                    role="slider"
                    [id]="endHandleId"
                    [attr.tabindex]="disabled ? undefined : tabindex"
                    [attr.aria-valuemin]="min"
                    [attr.aria-valuemax]="max"
                    [attr.aria-valuenow]="value ? value[1] : null"
                    [attr.aria-valuetext]="valueText"
                    [attr.aria-disabled]="disabled ? true : undefined"
                    [attr.aria-readonly]="readonly ? true : undefined"
                    [attr.aria-orientation]="vertical ? 'vertical' : 'horizontal'"
                    [style.touch-action]="isDisabled ? '' : 'none'"
                    class="k-draghandle"
                    [title]="textFor('dragHandleEnd')"
                    kendoDraggable
                    (kendoPress)="ifEnabled(handleDragPress ,$event)"
                    (kendoDrag)="ifEnabled(onHandleDrag ,$event)"
                    (kendoRelease)="ifEnabled(onHandleRelease, $event)"
                ></span>
            </div>
        </div>
        <kendo-resize-sensor (resize)="sizeComponent()"></kendo-resize-sensor>
  `,
      standalone: true,
      imports: [LocalizedRangeSliderMessagesDirective, EventsOutsideAngularDirective, NgIf, SliderTicksComponent, DraggableDirective, ResizeSensorComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: Injector
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }];
  }, {
    value: [{
      type: Input
    }],
    draghandleStart: [{
      type: ViewChild,
      args: ["draghandleStart", {
        static: true
      }]
    }],
    draghandleEnd: [{
      type: ViewChild,
      args: ["draghandleEnd", {
        static: true
      }]
    }]
  });
})();
var Messages2 = class _Messages extends ComponentMessages {
  /**
   * The title of the **On** button of the Switch.
   */
  on;
  /**
   * The title of the **Off** button of the Switch.
   */
  off;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMessages_BaseFactory;
    return function Messages_Factory(__ngFactoryType__) {
      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵɵgetInheritedFactory(_Messages)))(__ngFactoryType__ || _Messages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _Messages,
    selectors: [["kendo-switch-messages-base"]],
    inputs: {
      on: "on",
      off: "off"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Messages2, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-switch-messages-base"
    }]
  }], null, {
    on: [{
      type: Input
    }],
    off: [{
      type: Input
    }]
  });
})();
var LocalizedSwitchMessagesDirective = class _LocalizedSwitchMessagesDirective extends Messages2 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedSwitchMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedSwitchMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedSwitchMessagesDirective,
    selectors: [["", "kendoSwitchLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: Messages2,
      useExisting: forwardRef(() => _LocalizedSwitchMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedSwitchMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: Messages2,
        useExisting: forwardRef(() => LocalizedSwitchMessagesDirective)
      }],
      selector: "[kendoSwitchLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var FOCUSED$5 = "k-focus";
var DEFAULT_SIZE$e = "medium";
var DEFAULT_THUMB_ROUNDED = "full";
var DEFAULT_TRACK_ROUNDED = "full";
var SwitchComponent = class _SwitchComponent {
  renderer;
  hostElement;
  localizationService;
  injector;
  changeDetector;
  ngZone;
  /**
   * @hidden
   */
  get focusableId() {
    if (this.hostElement.nativeElement.hasAttribute("id")) {
      return this.hostElement.nativeElement.getAttribute("id");
    }
    return `k-${guid()}`;
  }
  /**
   * Sets the **On** label ([see example]({% slug labels_switch %})).
   * Takes precedence over the [custom messages component]({% slug api_inputs_switchcustommessagescomponent %}).
   */
  onLabel;
  /**
   * Sets the **Off** label ([see example]({% slug labels_switch %})).
   * Takes precedence over the [custom messages component]({% slug api_inputs_switchcustommessagescomponent %}).
   */
  offLabel;
  /**
   * Sets the value of the Switch when it is initially displayed.
   */
  set checked(value) {
    this.setHostClasses(value);
    this._checked = value;
  }
  get checked() {
    return this._checked;
  }
  /**
   * Determines whether the Switch is disabled ([see example]({% slug disabled_switch %})). To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_switch#toc-managing-the-switch-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Determines whether the Switch is in its read-only state ([see example]({% slug readonly_switch %})).
   *
   * @default false
   */
  readonly = false;
  /**
   * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Switch.
   */
  tabindex = 0;
  /**
   * Specifies the width and height of the Switch.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$e;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Specifies the border radius of the Switch thumb.
   *
   * The possible values are:
   * * `full` (default)
   * * `small`
   * * `medium`
   * * `large`
   * * `none`
   */
  set thumbRounded(thumbRounded) {
    const newThumbRounded = thumbRounded ? thumbRounded : DEFAULT_THUMB_ROUNDED;
    this.handleThumbClasses(newThumbRounded);
    this._thumbRounded = newThumbRounded;
  }
  get thumbRounded() {
    return this._thumbRounded;
  }
  /**
   * Specifies the border radius of the Switch track.
   *
   * The possible values are:
   * * `full` (default)
   * * `small`
   * * `medium`
   * * `large`
   * * `none`
   */
  set trackRounded(trackRounded) {
    const newTrackRounded = trackRounded ? trackRounded : DEFAULT_TRACK_ROUNDED;
    this.handleTrackClasses(newTrackRounded);
    this._trackRounded = newTrackRounded;
  }
  get trackRounded() {
    return this._trackRounded;
  }
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Fires each time the Switch component is focused as a result of user interaction.
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the Switch component is blurred as a result of user interaction.
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the user selects a new value.
   */
  valueChange = new EventEmitter();
  direction;
  get ieClass() {
    return browser && browser.msie;
  }
  hostRole = "switch";
  get hostId() {
    return this.focusableId;
  }
  get ariaChecked() {
    return this.checked;
  }
  get ariaInvalid() {
    return this.isControlInvalid ? true : void 0;
  }
  get hostTabIndex() {
    return this.disabled ? void 0 : this.tabIndex;
  }
  get ariaDisabled() {
    return this.disabled ? true : void 0;
  }
  get ariaReadonly() {
    return this.readonly;
  }
  hostClasses = true;
  get disabledClass() {
    return this.disabled;
  }
  track;
  thumb;
  /**
   * @hidden
   */
  initialized = false;
  localizationChangeSubscription;
  isFocused;
  control;
  domSubscriptions = [];
  _checked = false;
  _size = "medium";
  _trackRounded = "full";
  _thumbRounded = "full";
  constructor(renderer, hostElement, localizationService, injector, changeDetector, ngZone) {
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.localizationService = localizationService;
    this.injector = injector;
    this.changeDetector = changeDetector;
    this.ngZone = ngZone;
    validatePackage(packageMetadata5);
    this.direction = localizationService.rtl ? "rtl" : "ltr";
    this.keyDownHandler = this.keyDownHandler.bind(this);
    this.clickHandler = this.clickHandler.bind(this);
  }
  /**
   * @hidden
   */
  get onLabelMessage() {
    return this.onLabel !== void 0 ? this.onLabel : this.localizationService.get("on");
  }
  /**
   * @hidden
   */
  get offLabelMessage() {
    return this.offLabel !== void 0 ? this.offLabel : this.localizationService.get("off");
  }
  ngChange = (_2) => {
  };
  ngTouched = () => {
  };
  get isEnabled() {
    return !this.disabled && !this.readonly;
  }
  ngOnInit() {
    if (this.hostElement) {
      const wrapper = this.hostElement.nativeElement;
      this.renderer.removeAttribute(wrapper, "tabindex");
    }
    this.localizationChangeSubscription = this.localizationService.changes.pipe(skip(1)).subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
    this.control = this.injector.get(NgControl, null);
    this.ngZone.onStable.pipe(take(1)).subscribe(() => this.initialized = true);
  }
  ngAfterViewInit() {
    const wrapper = this.hostElement.nativeElement;
    if (!this.checked && !wrapper.classList.contains("k-switch-off")) {
      this.renderer.addClass(wrapper, "k-switch-off");
    }
    this.handleClasses(this.size, "size");
    this.handleTrackClasses(this.trackRounded);
    this.handleThumbClasses(this.thumbRounded);
    this.attachHostHandlers();
  }
  ngOnDestroy() {
    if (this.localizationChangeSubscription) {
      this.localizationChangeSubscription.unsubscribe();
    }
    this.domSubscriptions.forEach((subscription) => subscription());
    const wrapper = this.hostElement.nativeElement;
    wrapper.removeEventListener("focus", this.handleFocus, true);
    wrapper.removeEventListener("blur", this.handleBlur, true);
  }
  /**
   * Focuses the Switch.
   *
   * @example
   * ```ts-no-run
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="switch.focus()">Focus</button>
   *  <kendo-switch #switch></kendo-switch>
   * `
   * })
   * class AppComponent { }
   * ```
   */
  focus() {
    if (!this.hostElement) {
      return;
    }
    this.hostElement.nativeElement.focus();
  }
  /**
   * Blurs the Switch.
   */
  blur() {
    if (!this.hostElement) {
      return;
    }
    this.hostElement.nativeElement.blur();
  }
  /**
   * @hidden
   * Called when the status of the component changes to or from `disabled`.
   * Depending on the value, it enables or disables the appropriate DOM element.
   */
  setDisabledState(isDisabled2) {
    this.disabled = isDisabled2;
    this.changeDetector.markForCheck();
  }
  /**
   * @hidden
   */
  handleFocus = (event) => {
    if (this.isFocused) {
      return;
    }
    event.stopImmediatePropagation();
    this.focused = true;
    if (hasObservers(this.onFocus)) {
      this.ngZone.run(() => {
        const eventArgs = {
          originalEvent: event
        };
        this.onFocus.emit(eventArgs);
      });
    }
  };
  /**
   * @hidden
   */
  handleBlur = (event) => {
    const relatedTarget = event && event.relatedTarget;
    if (this.hostElement.nativeElement.contains(relatedTarget)) {
      return;
    }
    event.stopImmediatePropagation();
    this.changeDetector.markForCheck();
    this.focused = false;
    if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
      this.ngZone.run(() => {
        this.ngTouched();
        const eventArgs = {
          originalEvent: event
        };
        this.onBlur.emit(eventArgs);
      });
    }
  };
  /**
   * @hidden
   */
  get isControlInvalid() {
    return this.control && this.control.touched && !this.control.valid;
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.checked = value === null ? false : value;
    this.changeDetector.markForCheck();
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.ngChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.ngTouched = fn;
  }
  /**
   * @hidden
   */
  keyDownHandler(e) {
    const keyCode = e.keyCode;
    if (this.isEnabled && (keyCode === Keys.Space || keyCode === Keys.Enter)) {
      this.changeValue(!this.checked);
      e.preventDefault();
    }
  }
  /**
   * @hidden
   */
  clickHandler() {
    if (this.isEnabled) {
      this.changeValue(!this.checked);
    }
  }
  /**
   * @hidden
   * Used by the FloatingLabel to determine if the component is empty.
   */
  isEmpty() {
    return false;
  }
  changeValue(value) {
    if (this.checked !== value) {
      this.ngZone.run(() => {
        this.checked = value;
        this.ngChange(value);
        this.valueChange.emit(value);
        this.changeDetector.markForCheck();
      });
    }
  }
  set focused(value) {
    if (this.isFocused !== value && this.hostElement) {
      const wrapper = this.hostElement.nativeElement;
      if (value) {
        this.renderer.addClass(wrapper, FOCUSED$5);
      } else {
        this.renderer.removeClass(wrapper, FOCUSED$5);
      }
      this.isFocused = value;
    }
  }
  attachHostHandlers() {
    this.ngZone.runOutsideAngular(() => {
      const wrapper = this.hostElement.nativeElement;
      this.domSubscriptions.push(this.renderer.listen(wrapper, "click", this.clickHandler), this.renderer.listen(wrapper, "keydown", this.keyDownHandler));
      wrapper.addEventListener("focus", this.handleFocus, true);
      wrapper.addEventListener("blur", this.handleBlur, true);
    });
  }
  setHostClasses(value) {
    const wrapper = this.hostElement.nativeElement;
    if (value) {
      this.renderer.removeClass(wrapper, "k-switch-off");
      this.renderer.addClass(wrapper, "k-switch-on");
    } else {
      this.renderer.removeClass(wrapper, "k-switch-on");
      this.renderer.addClass(wrapper, "k-switch-off");
    }
  }
  handleClasses(value, input) {
    const elem = this.hostElement.nativeElement;
    const classes = getStylingClasses2("switch", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  handleTrackClasses(value) {
    const track = this.track?.nativeElement;
    if (!track) {
      return;
    }
    const classes = getStylingClasses2("switch", "rounded", this.trackRounded, value);
    if (classes.toRemove) {
      this.renderer.removeClass(track, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(track, classes.toAdd);
    }
  }
  handleThumbClasses(value) {
    const thumb = this.thumb?.nativeElement;
    if (!thumb) {
      return;
    }
    const classes = getStylingClasses2("switch", "rounded", this.thumbRounded, value);
    if (classes.toRemove) {
      this.renderer.removeClass(thumb, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(thumb, classes.toAdd);
    }
  }
  static ɵfac = function SwitchComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SwitchComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SwitchComponent,
    selectors: [["kendo-switch"]],
    viewQuery: function SwitchComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c17, 7);
        ɵɵviewQuery(_c122, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.track = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.thumb = _t.first);
      }
    },
    hostVars: 16,
    hostBindings: function SwitchComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction)("role", ctx.hostRole)("id", ctx.hostId)("aria-checked", ctx.ariaChecked)("aria-invalid", ctx.ariaInvalid)("tabindex", ctx.hostTabIndex)("aria-disabled", ctx.ariaDisabled)("aria-readonly", ctx.ariaReadonly);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-ie", ctx.ieClass)("k-switch", ctx.hostClasses)("k-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      focusableId: "focusableId",
      onLabel: "onLabel",
      offLabel: "offLabel",
      checked: "checked",
      disabled: "disabled",
      readonly: "readonly",
      tabindex: "tabindex",
      size: "size",
      thumbRounded: "thumbRounded",
      trackRounded: "trackRounded",
      tabIndex: "tabIndex"
    },
    outputs: {
      onFocus: "focus",
      onBlur: "blur",
      valueChange: "valueChange"
    },
    exportAs: ["kendoSwitch"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.switch"
    }, {
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _SwitchComponent)
      /* eslint-disable-line*/
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _SwitchComponent)
    }])],
    decls: 10,
    vars: 8,
    consts: () => {
      let i18n_5;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_5 = goog.getMsg("ON");
        i18n_5 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_5;
      } else {
        i18n_5 = $localize`:kendo.switch.on|The **On** label of the Switch.:ON`;
      }
      let i18n_6;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_6 = goog.getMsg("OFF");
        i18n_6 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_6;
      } else {
        i18n_6 = $localize`:kendo.switch.off|The **Off** label of the Switch.:OFF`;
      }
      return [["track", ""], ["thumb", ""], ["kendoSwitchLocalizedMessages", "", "on", i18n_5, "off", i18n_6], [1, "k-switch-track"], [1, "k-switch-label-on"], [1, "k-switch-label-off"], [1, "k-switch-thumb-wrap"], [1, "k-switch-thumb"]];
    },
    template: function SwitchComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainerStart(0, 2);
        ɵɵelementStart(1, "span", 3, 0)(3, "span", 4);
        ɵɵtext(4);
        ɵɵelementEnd();
        ɵɵelementStart(5, "span", 5);
        ɵɵtext(6);
        ɵɵelementEnd()();
        ɵɵelementStart(7, "span", 6);
        ɵɵelement(8, "span", 7, 1);
        ɵɵelementEnd();
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵstyleProp("transition-duration", ctx.initialized ? "200ms" : "0ms");
        ɵɵadvance(2);
        ɵɵattribute("aria-hidden", true);
        ɵɵadvance();
        ɵɵtextInterpolate(ctx.onLabelMessage);
        ɵɵadvance();
        ɵɵattribute("aria-hidden", true);
        ɵɵadvance();
        ɵɵtextInterpolate(ctx.offLabelMessage);
        ɵɵadvance();
        ɵɵstyleProp("transition-duration", ctx.initialized ? "200ms" : "0ms");
      }
    },
    dependencies: [LocalizedSwitchMessagesDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SwitchComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoSwitch",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.switch"
      }, {
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => SwitchComponent)
        /* eslint-disable-line*/
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => SwitchComponent)
      }],
      selector: "kendo-switch",
      template: `
        <ng-container kendoSwitchLocalizedMessages
            i18n-on="kendo.switch.on|The **On** label of the Switch."
            on="ON"
            i18n-off="kendo.switch.off|The **Off** label of the Switch."
            off="OFF"
        >

        <span
            #track
            class="k-switch-track"
            [style.transitionDuration]="initialized ? '200ms' : '0ms'"
        >
            <span class="k-switch-label-on" [attr.aria-hidden]="true" >{{onLabelMessage}}</span>
            <span class="k-switch-label-off" [attr.aria-hidden]="true">{{offLabelMessage}}</span>
        </span>
        <span
            class="k-switch-thumb-wrap"
            [style.transitionDuration]="initialized ? '200ms' : '0ms'">
            <span #thumb class="k-switch-thumb"></span>
        </span>
  `,
      standalone: true,
      imports: [LocalizedSwitchMessagesDirective]
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: LocalizationService
    }, {
      type: Injector
    }, {
      type: ChangeDetectorRef
    }, {
      type: NgZone
    }];
  }, {
    focusableId: [{
      type: Input
    }],
    onLabel: [{
      type: Input
    }],
    offLabel: [{
      type: Input
    }],
    checked: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    tabindex: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    thumbRounded: [{
      type: Input
    }],
    trackRounded: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    valueChange: [{
      type: Output
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    ieClass: [{
      type: HostBinding,
      args: ["class.k-ie"]
    }],
    hostRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    hostId: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    ariaChecked: [{
      type: HostBinding,
      args: ["attr.aria-checked"]
    }],
    ariaInvalid: [{
      type: HostBinding,
      args: ["attr.aria-invalid"]
    }],
    hostTabIndex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    ariaDisabled: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    ariaReadonly: [{
      type: HostBinding,
      args: ["attr.aria-readonly"]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-switch"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    track: [{
      type: ViewChild,
      args: ["track", {
        static: true
      }]
    }],
    thumb: [{
      type: ViewChild,
      args: ["thumb", {
        static: true
      }]
    }]
  });
})();
var TextBoxDirective = class _TextBoxDirective {
  renderer;
  inputElement;
  ngZone;
  hostClasses = true;
  /**
   * @hidden
   */
  onFocus = new EventEmitter();
  /**
   * @hidden
   */
  onBlur = new EventEmitter();
  /**
   * @hidden
   */
  onValueChange = new EventEmitter();
  /**
   * @hidden
   */
  autoFillStart = new EventEmitter();
  /**
   * @hidden
   */
  autoFillEnd = new EventEmitter();
  /**
   * @hidden
   */
  set value(text) {
    if (!this.inputElement) {
      return;
    }
    this.inputElement.nativeElement.value = text === void 0 || text === null ? "" : text;
    this.onValueChange.emit();
  }
  /**
   * @hidden
   */
  get value() {
    return this.inputElement.nativeElement.value;
  }
  get id() {
    return this.inputElement.nativeElement.id;
  }
  set id(id2) {
    this.renderer.setAttribute(this.inputElement.nativeElement, "id", id2);
  }
  listeners = [];
  constructor(renderer, inputElement, ngZone) {
    this.renderer = renderer;
    this.inputElement = inputElement;
    this.ngZone = ngZone;
  }
  ngAfterViewInit() {
    const input = this.inputElement.nativeElement;
    this.listeners = [this.renderer.listen(input, "focus", () => this.onFocus.emit()), this.renderer.listen(input, "blur", () => this.onBlur.emit())];
    this.ngZone.runOutsideAngular(() => {
      this.renderer.listen(input, "animationstart", (e) => {
        if (e.animationName === "autoFillStart") {
          this.autoFillStart.emit();
        } else if (e.animationName === "autoFillEnd") {
          this.autoFillEnd.emit();
        }
      });
    });
  }
  ngOnDestroy() {
    this.listeners.forEach((listener) => listener());
  }
  static ɵfac = function TextBoxDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextBoxDirective)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TextBoxDirective,
    selectors: [["input", "kendoTextBox", ""]],
    hostVars: 10,
    hostBindings: function TextBoxDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-textbox", ctx.hostClasses)("k-input", ctx.hostClasses)("k-input-md", ctx.hostClasses)("k-rounded-md", ctx.hostClasses)("k-input-solid", ctx.hostClasses);
      }
    },
    inputs: {
      value: "value"
    },
    features: [ɵɵProvidersFeature([{
      provide: KendoInput,
      useExisting: forwardRef(() => _TextBoxDirective)
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextBoxDirective, [{
    type: Directive,
    args: [{
      selector: "input[kendoTextBox]",
      providers: [{
        provide: KendoInput,
        useExisting: forwardRef(() => TextBoxDirective)
      }],
      standalone: true
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-textbox"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }, {
      type: HostBinding,
      args: ["class.k-input-md"]
    }, {
      type: HostBinding,
      args: ["class.k-rounded-md"]
    }, {
      type: HostBinding,
      args: ["class.k-input-solid"]
    }],
    value: [{
      type: Input
    }]
  });
})();
var TextAreaDirective = class _TextAreaDirective {
  renderer;
  element;
  zone;
  changeDetector;
  injector;
  elementClasses = true;
  autofillClass = true;
  direction;
  /**
   * Fires each time the textarea value is changed.
   */
  valueChange = new EventEmitter();
  /**
   * Specifies if the `textarea` element will resize its height automatically
   * ([see example](slug:textarea_sizing#toc-auto-resizing)).
   *
   * @default false
   */
  autoSize = false;
  /**
   * Specifies the textarea value.
   */
  value;
  /**
   * @hidden
   */
  onFocus = new EventEmitter();
  /**
   * @hidden
   */
  onBlur = new EventEmitter();
  /**
   * @hidden
   */
  onValueChange = new EventEmitter();
  /**
   * @hidden
   */
  autoFillStart = new EventEmitter();
  /**
   * @hidden
   */
  autoFillEnd = new EventEmitter();
  get id() {
    return this.element.nativeElement.id;
  }
  set id(id2) {
    this.renderer.setAttribute(this.element.nativeElement, "id", id2);
  }
  listeners = [];
  inputSubscription;
  initialHeight;
  control;
  resizeSubscription;
  constructor(renderer, element, zone, changeDetector, injector, rtl) {
    this.renderer = renderer;
    this.element = element;
    this.zone = zone;
    this.changeDetector = changeDetector;
    this.injector = injector;
    this.direction = rtl ? "rtl" : "ltr";
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.elementValue = value;
    this.resize();
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.ngChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.ngTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.setElementProperty("disabled", isDisabled2);
  }
  ngOnInit() {
    const element = this.element.nativeElement;
    this.zone.runOutsideAngular(() => {
      this.listeners = [this.renderer.listen(element, "focus", this.handleFocus.bind(this)), this.renderer.listen(element, "blur", this.handleBlur.bind(this)), this.renderer.listen(element, "animationstart", (e) => {
        if (e.animationName === "autoFillStart") {
          this.autoFillStart.emit();
        } else if (e.animationName === "autoFillEnd") {
          this.autoFillEnd.emit();
        }
      })];
      if (isDocumentAvailable() && this.autoSize) {
        this.resizeSubscription = fromEvent(window, "resize").pipe(debounceTime(50)).subscribe(() => this.resize());
      }
      this.inputSubscription = fromEvent(element, "input").subscribe(this.handleInput.bind(this));
    });
    this.control = this.injector.get(NgControl, null);
  }
  ngOnChanges(changes) {
    const element = this.element.nativeElement;
    if (changes.value) {
      this.elementValue = this.value;
    }
    if (changes.autoSize) {
      if (this.autoSize) {
        this.initialHeight = element.offsetHeight;
        this.renderer.setStyle(element, "resize", "none");
      } else {
        this.renderer.setStyle(element, "overflow-y", "auto");
        this.renderer.setStyle(element, "resize", "both");
        element.style.height = `${this.initialHeight}px`;
      }
    }
    this.zone.onStable.pipe(take(1)).subscribe(() => this.resize());
  }
  ngOnDestroy() {
    this.listeners.forEach((listener) => listener());
    if (this.inputSubscription) {
      this.inputSubscription.unsubscribe();
    }
    if (this.resizeSubscription) {
      this.resizeSubscription.unsubscribe();
    }
  }
  ngChange = (_2) => {
  };
  ngTouched = () => {
  };
  get elementValue() {
    if (this.element) {
      return this.element.nativeElement.value;
    }
    return "";
  }
  set elementValue(value) {
    this.setElementProperty("value", value === void 0 || value === null ? "" : value);
  }
  setElementProperty(name2, value) {
    if (this.element) {
      this.renderer.setProperty(this.element.nativeElement, name2, value);
    }
  }
  resize() {
    if (!this.autoSize) {
      return;
    }
    const element = this.element.nativeElement;
    this.renderer.setStyle(element, "overflow-y", "hidden");
    element.style.height = `${this.initialHeight}px`;
    const scrollHeight = element.scrollHeight;
    if (scrollHeight > this.initialHeight) {
      element.style.height = `${scrollHeight}px`;
    }
  }
  handleInput() {
    const value = this.elementValue;
    this.value = value;
    if (this.control || hasObservers(this.onValueChange) || hasObservers(this.valueChange)) {
      this.zone.run(() => {
        this.ngChange(value);
        this.onValueChange.emit(value);
        this.valueChange.emit(value);
        this.changeDetector.markForCheck();
      });
    }
    this.resize();
  }
  handleFocus() {
    if (hasObservers(this.onFocus)) {
      this.zone.run(() => {
        this.onFocus.emit();
      });
    }
  }
  handleBlur() {
    if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
      this.zone.run(() => {
        this.ngTouched();
        this.onBlur.emit();
        this.changeDetector.markForCheck();
      });
    }
  }
  static ɵfac = function TextAreaDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextAreaDirective)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(RTL, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TextAreaDirective,
    selectors: [["textarea", "kendoTextArea", ""]],
    hostVars: 13,
    hostBindings: function TextAreaDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-textarea", ctx.elementClasses)("k-input", ctx.elementClasses)("k-input-md", ctx.elementClasses)("k-rounded-md", ctx.elementClasses)("k-input-solid", ctx.elementClasses)("k-autofill", ctx.autofillClass);
      }
    },
    inputs: {
      autoSize: "autoSize",
      value: "value"
    },
    outputs: {
      valueChange: "valueChange"
    },
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _TextAreaDirective),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _TextAreaDirective)
    }]), ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextAreaDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => TextAreaDirective),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => TextAreaDirective)
      }],
      selector: "textarea[kendoTextArea]",
      standalone: true
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: Injector
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [RTL]
      }]
    }];
  }, {
    elementClasses: [{
      type: HostBinding,
      args: ["class.k-textarea"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }, {
      type: HostBinding,
      args: ["class.k-input-md"]
    }, {
      type: HostBinding,
      args: ["class.k-rounded-md"]
    }, {
      type: HostBinding,
      args: ["class.k-input-solid"]
    }],
    autofillClass: [{
      type: HostBinding,
      args: ["class.k-autofill"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    valueChange: [{
      type: Output
    }],
    autoSize: [{
      type: Input
    }],
    value: [{
      type: Input
    }]
  });
})();
var createMaxValidator = (maxValue) => {
  return (c) => {
    if (!isPresent5(maxValue) || !isPresent5(c.value) || c.value <= maxValue) {
      return null;
    }
    return {
      maxError: {
        maxValue,
        value: c.value
      }
    };
  };
};
var createMinValidator = (minValue) => {
  return (c) => {
    if (!isPresent5(minValue) || !isPresent5(c.value) || c.value >= minValue) {
      return null;
    }
    return {
      minError: {
        minValue,
        value: c.value
      }
    };
  };
};
var MIN_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-min";
var MAX_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-max";
var POINT2 = ".";
var INITIAL_SPIN_DELAY = 500;
var SPIN_DELAY = 50;
var EXPONENT_REGEX = /[eE][\-+]?([0-9]+)/;
var numericRegex = (options2) => {
  const {
    autoCorrect,
    decimals,
    min
  } = options2;
  let separator = options2.separator;
  if (separator === POINT2) {
    separator = "\\" + separator;
  }
  const signPattern = autoCorrect && min !== null && min >= 0 ? "" : "-?";
  let numberPattern;
  if (decimals === 0) {
    numberPattern = "\\d*";
  } else {
    numberPattern = `(?:(?:\\d+(${separator}\\d*)?)|(?:${separator}\\d*))?`;
  }
  return new RegExp(`^${signPattern}${numberPattern}$`);
};
var decimalPart = (value) => {
  return value >= 0 ? Math.floor(value) : Math.ceil(value);
};
var noop$1 = (_2) => {
};
var defined2 = (value) => {
  return typeof value !== "undefined";
};
var isNumber3 = (value) => {
  return !isNaN(value) && value !== null;
};
function pad3(value, digits) {
  const count = digits - String(value).length;
  let result = value;
  if (count > 0) {
    const padString = new Array(count + 1).join("0");
    result = parseFloat(value + padString);
  }
  return result;
}
var getDeltaFromMouseWheel = (e) => {
  let delta = 0;
  if (e.wheelDelta) {
    delta = e.wheelDelta / 120;
    delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
  } else if (e.detail) {
    delta = Math.round(-e.detail / 3);
  }
  return delta;
};
var getCaretPosition = (element) => element.selectionStart;
var extractSignificantNumericChars = (formattedString, separator) => {
  const significantCharacters = `${separator}0123456789-`;
  return formattedString.split("").reduce((acc, curr) => significantCharacters.includes(curr) ? ++acc : acc, 0);
};
var isRightClick = (event) => {
  const isRightClickIE = event.button && event.button === 2;
  const isRightClickOther = event.which && event.which === 3;
  return isRightClickIE || isRightClickOther;
};
var ArrowDirection;
(function(ArrowDirection2) {
  ArrowDirection2[ArrowDirection2["Down"] = -1] = "Down";
  ArrowDirection2[ArrowDirection2["None"] = 0] = "None";
  ArrowDirection2[ArrowDirection2["Up"] = 1] = "Up";
})(ArrowDirection || (ArrowDirection = {}));
var InputSeparatorComponent = class _InputSeparatorComponent {
  /**
   * Specifies the orientation of the separator. Applicable for the adornments of the [`TextAreaComponent`](slug:api_inputs_textareacomponent).
   *
   * @default 'vertical'
   */
  orientation = "vertical";
  get vertical() {
    return this.orientation === "vertical";
  }
  get horizontal() {
    return this.orientation === "horizontal";
  }
  hostClass = true;
  static ɵfac = function InputSeparatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InputSeparatorComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _InputSeparatorComponent,
    selectors: [["kendo-input-separator"], ["kendo-textbox-separator"]],
    hostVars: 6,
    hostBindings: function InputSeparatorComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-input-separator-vertical", ctx.vertical)("k-input-separator-horizontal", ctx.horizontal)("k-input-separator", ctx.hostClass);
      }
    },
    inputs: {
      orientation: "orientation"
    },
    decls: 0,
    vars: 0,
    template: function InputSeparatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InputSeparatorComponent, [{
    type: Component,
    args: [{
      selector: "kendo-input-separator, kendo-textbox-separator",
      template: ``,
      standalone: true
    }]
  }], null, {
    orientation: [{
      type: Input
    }],
    vertical: [{
      type: HostBinding,
      args: ["class.k-input-separator-vertical"]
    }],
    horizontal: [{
      type: HostBinding,
      args: ["class.k-input-separator-horizontal"]
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-input-separator"]
    }]
  });
})();
var SharedInputEventsDirective = class _SharedInputEventsDirective {
  ngZone;
  renderer;
  cdr;
  hostElement;
  clearButtonClicked;
  isFocused;
  isFocusedChange = new EventEmitter();
  onFocus = new EventEmitter();
  handleBlur = new EventEmitter();
  subscriptions = new Subscription();
  constructor(ngZone, renderer, cdr) {
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.cdr = cdr;
  }
  ngAfterViewInit() {
    const hostElement = this.hostElement.nativeElement;
    let cursorInsideWrapper = false;
    let tabbing = false;
    this.ngZone.runOutsideAngular(() => {
      this.subscriptions.add(this.renderer.listen(hostElement, "focusin", () => {
        this.cdr.detectChanges();
        if (!this.isFocused) {
          this.ngZone.run(() => {
            this.onFocus.emit();
            this.isFocused = true;
            this.isFocusedChange.emit(this.isFocused);
          });
        }
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "focusout", (args) => {
        if (!this.isFocused) {
          return;
        }
        if (tabbing) {
          const closestTextbox = closest3(args.relatedTarget, (element) => element === hostElement);
          if (!closestTextbox) {
            this.handleBlur.emit();
          }
          tabbing = false;
        } else {
          if (!cursorInsideWrapper && !this?.clearButtonClicked) {
            this.handleBlur.emit();
          }
        }
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "mouseenter", () => {
        cursorInsideWrapper = true;
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "mouseleave", () => {
        cursorInsideWrapper = false;
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "keydown", (args) => {
        if (args.keyCode === Keys.Tab) {
          tabbing = true;
        } else {
          tabbing = false;
        }
      }));
    });
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  static ɵfac = function SharedInputEventsDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SharedInputEventsDirective)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SharedInputEventsDirective,
    selectors: [["", "kendoInputSharedEvents", ""]],
    inputs: {
      hostElement: "hostElement",
      clearButtonClicked: "clearButtonClicked",
      isFocused: "isFocused"
    },
    outputs: {
      isFocusedChange: "isFocusedChange",
      onFocus: "onFocus",
      handleBlur: "handleBlur"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SharedInputEventsDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoInputSharedEvents]",
      standalone: true
    }]
  }], function() {
    return [{
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    hostElement: [{
      type: Input
    }],
    clearButtonClicked: [{
      type: Input
    }],
    isFocused: [{
      type: Input
    }],
    isFocusedChange: [{
      type: Output
    }],
    onFocus: [{
      type: Output
    }],
    handleBlur: [{
      type: Output
    }]
  });
})();
var NumericTextBoxMessages = class _NumericTextBoxMessages extends ComponentMessages {
  /**
   * The title of the **Decrement** button of the NumericTextBox.
   */
  decrement;
  /**
   * The title of the **Increment** button of the NumericTextBox.
   */
  increment;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵNumericTextBoxMessages_BaseFactory;
    return function NumericTextBoxMessages_Factory(__ngFactoryType__) {
      return (ɵNumericTextBoxMessages_BaseFactory || (ɵNumericTextBoxMessages_BaseFactory = ɵɵgetInheritedFactory(_NumericTextBoxMessages)))(__ngFactoryType__ || _NumericTextBoxMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _NumericTextBoxMessages,
    selectors: [["kendo-numerictextbox-messages-base"]],
    inputs: {
      decrement: "decrement",
      increment: "increment"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericTextBoxMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-numerictextbox-messages-base"
    }]
  }], null, {
    decrement: [{
      type: Input
    }],
    increment: [{
      type: Input
    }]
  });
})();
var LocalizedNumericTextBoxMessagesDirective = class _LocalizedNumericTextBoxMessagesDirective extends NumericTextBoxMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedNumericTextBoxMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedNumericTextBoxMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedNumericTextBoxMessagesDirective,
    selectors: [["", "kendoNumericTextBoxLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: NumericTextBoxMessages,
      useExisting: forwardRef(() => _LocalizedNumericTextBoxMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedNumericTextBoxMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: NumericTextBoxMessages,
        useExisting: forwardRef(() => LocalizedNumericTextBoxMessagesDirective)
      }],
      selector: "[kendoNumericTextBoxLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var PARSABLE_OPTIONS = ["min", "max", "step", "decimals"];
var PARSABLE_DEFAULTS = {
  decimals: null,
  max: null,
  min: null,
  step: 1
};
var FOCUSED$4 = "k-focus";
var DEFAULT_SIZE$d = "medium";
var DEFAULT_ROUNDED$8 = "medium";
var DEFAULT_FILL_MODE$6 = "solid";
var NumericTextBoxComponent = class _NumericTextBoxComponent {
  intl;
  renderer;
  localizationService;
  injector;
  ngZone;
  changeDetector;
  hostElement;
  /**
   * @hidden
   */
  focusableId = `k-${guid()}`;
  /**
   * Determines whether the NumericTextBox is disabled ([see example]({% slug disabled_numerictextbox %})). To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_numerictextbox#toc-managing-the-numerictextbox-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Determines whether the NumericTextBox is in its read-only state ([see example]({% slug readonly_numerictextbox %})).
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the title of the `input` element of the NumericTextBox.
   */
  title = "";
  /**
   * Specifies whether the value will be auto-corrected based on the minimum and maximum values
   * ([see example]({% slug precision_numerictextbox %})).
   */
  autoCorrect = false;
  /**
   * Specifies the number format which is used when the NumericTextBox is not focused
   * ([see example]({% slug formats_numerictextbox %})).
   * If `format` is set to `null` or `undefined`, the default format will be used.
   */
  get format() {
    const format3 = this._format;
    return format3 !== null && format3 !== void 0 ? format3 : "n2";
  }
  set format(value) {
    this._format = value;
  }
  /**
   * Specifies the greatest value that is valid
   * ([see example]({% slug precision_numerictextbox %}#toc-value-ranges)).
   */
  max;
  /**
   * Specifies the smallest value that is valid
   * ([see example]({% slug precision_numerictextbox %}#toc-value-ranges)).
   */
  min;
  /**
   * Specifies the number of decimals that the user can enter when the input is focused
   * ([see example]({% slug precision_numerictextbox %})).
   */
  decimals = null;
  /**
   * Specifies the input placeholder.
   */
  placeholder;
  /**
   * Specifies the value that is used to increment or decrement the component value
   * ([see example]({% slug predefinedsteps_numerictextbox %})).
   */
  step = 1;
  /**
   * Specifies whether the **Up** and **Down** spin buttons will be rendered
   * ([see example]({% slug spinbuttons_numerictextbox %})).
   */
  spinners = true;
  /**
   * Determines whether the built-in minimum or maximum validators are enforced when a form is validated.
   *
   * > The 4.2.0 Angular version introduces the `min` and `max` validation directives. As a result, even if you set `rangeValidation`
   * > to `false`, the built-in Angular validators will be executed.
   */
  rangeValidation = true;
  /**
   * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Determines whether the value of the NumericTextBox will be changed via scrolling. Defaults to `true`.
   *
   * @default true
   */
  changeValueOnScroll = true;
  /**
   * Determines whether the whole value will be selected when the NumericTextBox is clicked. Defaults to `true`.
   */
  selectOnFocus = true;
  /**
   * Specifies the value of the NumericTextBox
   * ([see example]({% slug formats_numerictextbox %})).
   */
  value = null;
  /**
   * Specifies the maximum number of characters the end user can type or paste in the input.
   * The locale-specific decimal separator and negative sign (`-`) are included in the length of the value when present.
   * The `maxlength` restriction is not applied to the length of the formatted value when the component is not focused.
   */
  maxlength;
  /**
   * The size property specifies padding of the NumericTextBox internal input element
   * ([see example]({% slug appearance_numerictextbox %}#toc-size)).
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$d;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * The `rounded` property specifies the border radius of the NumericTextBox
   * ([see example](slug:appearance_numerictextbox#toc-roundness)).
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED$8;
    this.handleClasses(newRounded, "rounded");
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * The `fillMode` property specifies the background and border styles of the NumericTextBox
   * ([see example](slug:appearance_numerictextbox#toc-fill-mode)).
   * The possible values are:
   * * `flat`
   * * `solid` (default)
   * * `outline`
   * * `none`
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$6;
    this.handleClasses(newFillMode, "fillMode");
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
   */
  set inputAttributes(attributes) {
    if (isObjectPresent(this.parsedAttributes)) {
      removeHTMLAttributes(this.parsedAttributes, this.renderer, this.numericInput.nativeElement);
    }
    this._inputAttributes = attributes;
    this.parsedAttributes = this.inputAttributes ? parseAttributes(this.inputAttributes, this.defaultAttributes) : this.inputAttributes;
    this.setInputAttributes();
  }
  get inputAttributes() {
    return this._inputAttributes;
  }
  /**
   * Fires each time the user selects a new value ([see example](slug:events_numerictextbox)).
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the user focuses the NumericTextBox element ([see example](slug:events_numerictextbox)).
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the NumericTextBox component gets blurred ([see example](slug:events_numerictextbox)).
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the user focuses the `input` element.
   */
  inputFocus = new EventEmitter();
  /**
   * Fires each time the `input` element gets blurred.
   */
  inputBlur = new EventEmitter();
  /**
   * @hidden
   */
  numericInput;
  /**
   * @hidden
   */
  suffixTemplate;
  /**
   * @hidden
   */
  prefixTemplate;
  direction;
  /**
   * @hidden
   */
  ArrowDirection = ArrowDirection;
  /**
   * @hidden
   */
  arrowDirection = ArrowDirection.None;
  get disableClass() {
    return this.disabled;
  }
  hostClasses = true;
  /**
   * @hidden
   */
  arrowUpIcon = caretAltUpIcon;
  /**
   * @hidden
   */
  arrowDownIcon = caretAltDownIcon;
  subscriptions;
  inputValue = "";
  spinTimeout;
  isFocused;
  minValidateFn = noop$1;
  maxValidateFn = noop$1;
  numericRegex;
  _format = "n2";
  previousSelection;
  pressedKey;
  control;
  isPasted = false;
  mouseDown = false;
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  ngChange = noop$1;
  ngTouched = noop$1;
  ngValidatorChange = noop$1;
  domEvents = [];
  _inputAttributes;
  parsedAttributes = {};
  get defaultAttributes() {
    return {
      id: this.focusableId,
      disabled: this.disabled ? "" : null,
      readonly: this.readonly ? "" : null,
      tabindex: this.tabIndex,
      placeholder: this.placeholder,
      title: this.title,
      maxlength: this.maxlength,
      "aria-valuemin": this.min,
      "aria-valuemax": this.max,
      "aria-valuenow": this.value,
      required: this.isControlRequired ? "" : null,
      "aria-invalid": this.isControlInvalid
    };
  }
  get mutableAttributes() {
    return {
      autocomplete: "off",
      autocorrect: "off",
      role: "spinbutton"
    };
  }
  constructor(intl, renderer, localizationService, injector, ngZone, changeDetector, hostElement) {
    this.intl = intl;
    this.renderer = renderer;
    this.localizationService = localizationService;
    this.injector = injector;
    this.ngZone = ngZone;
    this.changeDetector = changeDetector;
    this.hostElement = hostElement;
    validatePackage(packageMetadata5);
    this.direction = localizationService.rtl ? "rtl" : "ltr";
  }
  ngOnInit() {
    this.subscriptions = this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
    this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));
    if (this.hostElement) {
      this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
    }
    this.control = this.injector.get(NgControl, null);
    this.ngZone.runOutsideAngular(() => {
      this.domEvents.push(this.renderer.listen(this.hostElement.nativeElement, "mousewheel", this.handleWheel.bind(this)));
      this.domEvents.push(this.renderer.listen(this.hostElement.nativeElement, "DOMMouseScroll", this.handleWheel.bind(this)));
    });
  }
  ngAfterViewInit() {
    const stylingInputs = ["size", "rounded", "fillMode"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
  }
  /**
   * @hidden
   */
  increasePress = (e) => {
    this.arrowPress(ArrowDirection.Up, e);
  };
  /**
   * @hidden
   */
  decreasePress = (e) => {
    this.arrowPress(ArrowDirection.Down, e);
  };
  /**
   * @hidden
   */
  releaseArrow = () => {
    clearTimeout(this.spinTimeout);
    if (this.arrowDirection !== ArrowDirection.None) {
      this.arrowDirection = ArrowDirection.None;
      this.changeDetector.detectChanges();
    }
  };
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    if (anyChanged(PARSABLE_OPTIONS, changes, false)) {
      this.parseOptions(PARSABLE_OPTIONS.filter((option) => changes[option]));
    }
    this.verifySettings();
    if (anyChanged(["min", "max", "rangeValidation"], changes, false)) {
      this.minValidateFn = this.rangeValidation ? createMinValidator(this.min) : noop$1;
      this.maxValidateFn = this.rangeValidation ? createMaxValidator(this.max) : noop$1;
      this.ngValidatorChange();
    }
    if (anyChanged(["autoCorrect", "decimals", "min"], changes)) {
      delete this.numericRegex;
    }
    if (anyChanged(["value", "format"], changes, false)) {
      this.verifyValue(this.value);
      this.value = this.restrictModelValue(this.value);
      if (!this.focused || this.intl.parseNumber(this.elementValue) !== this.value) {
        this.setInputValue();
      }
    }
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
    clearTimeout(this.spinTimeout);
    this.domEvents.forEach((unbindHandler) => unbindHandler());
  }
  /**
   * @hidden
   */
  validate(control) {
    return this.minValidateFn(control) || this.maxValidateFn(control);
  }
  /**
   * @hidden
   */
  registerOnValidatorChange(fn) {
    this.ngValidatorChange = fn;
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.verifyValue(value);
    const restrictedValue = this.restrictModelValue(value);
    this.value = restrictedValue;
    this.setInputValue();
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.ngChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.ngTouched = fn;
  }
  /**
   * @hidden
   * Called when the status of the component changes to or from `disabled`.
   * Depending on the value, it enables or disables the appropriate DOM element.
   *
   * @param isDisabled
   */
  setDisabledState(isDisabled2) {
    this.changeDetector.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * Focuses the NumericTextBox.
   *
   * @example
   * ```ts-no-run
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="numerictextbox.focus()">Focus NumericTextBox</button>
   *  <kendo-numerictextbox #numerictextbox></kendo-numerictextbox>
   * `
   * })
   * class AppComponent { }
   * ```
   */
  focus() {
    invokeElementMethod(this.numericInput, "focus");
  }
  /**
   * Blurs the NumericTextBox.
   */
  blur() {
    invokeElementMethod(this.numericInput, "blur");
  }
  /**
   * Notifies the `NumericTextBoxComponent` that the input value should be changed.
   * Can be used to update the input after setting the component properties directly.
   */
  notifyValueChange() {
    this.setInputValue();
  }
  /**
   * @hidden
   */
  handlePaste = () => {
    this.isPasted = true;
  };
  /**
   * @hidden
   */
  handleInput = () => {
    const input = this.numericInput.nativeElement;
    let {
      selectionStart,
      selectionEnd,
      value: inputValue
    } = input;
    if (this.pressedKey === Keys.NumpadDecimal) {
      inputValue = this.replaceNumpadDotValue();
    }
    if (this.isPasted) {
      inputValue = this.formatInputValue(this.intl.parseNumber(inputValue));
    }
    if (!this.isValid(inputValue)) {
      input.value = this.inputValue;
      this.setSelection(selectionStart - 1, selectionEnd - 1);
      return;
    }
    const parsedValue = this.intl.parseNumber(inputValue);
    let value = this.restrictDecimals(parsedValue);
    if (this.autoCorrect) {
      const limited = this.limitInputValue(value);
      value = limited.value;
      selectionStart = limited.selectionStart;
      selectionEnd = limited.selectionEnd;
    }
    if (parsedValue !== value || this.hasTrailingZeros(inputValue) || !this.focused) {
      this.setInputValue(value);
      this.setSelection(selectionStart, selectionEnd);
    } else {
      this.inputValue = inputValue;
    }
    if (this.isPasted) {
      input.value = this.inputValue;
    }
    this.updateValue(value);
    this.previousSelection = null;
    this.isPasted = false;
  };
  /**
   * @hidden
   */
  handleDragEnter = () => {
    if (!this.focused && !this.isDisabled) {
      this.setInputValue(this.value, true);
    }
  };
  /**
   * @hidden
   */
  handleMouseDown = () => {
    this.mouseDown = true;
  };
  /**
   * @hidden
   */
  handleInputFocus = () => {
    if (!this.focused) {
      this.focused = true;
      if (!this.isDisabled) {
        const shouldSelectAll = this.selectOnFocus || !this.mouseDown;
        this.ngZone.runOutsideAngular(() => {
          setTimeout(() => {
            if (shouldSelectAll) {
              this.selectAll();
            } else {
              this.selectCaret();
            }
          }, 0);
        });
      }
      if (hasObservers(this.onFocus)) {
        this.ngZone.run(() => {
          this.onFocus.emit();
        });
      }
    }
    this.mouseDown = false;
    if (hasObservers(this.inputFocus)) {
      this.ngZone.run(() => {
        this.inputFocus.emit();
      });
    }
  };
  /**
   * @hidden
   */
  handleFocus() {
    this.ngZone.run(() => {
      if (!this.focused && hasObservers(this.onFocus)) {
        this.onFocus.emit();
      }
      this.focused = true;
    });
  }
  /**
   * @hidden
   */
  handleBlur = () => {
    this.changeDetector.markForCheck();
    this.focused = false;
    if (this.inputValue !== this.elementValue) {
      this.handleInput();
    }
    this.setInputValue();
    if (hasObservers(this.onBlur)) {
      this.ngZone.run(() => {
        this.ngTouched();
        this.onBlur.emit();
      });
    }
  };
  /**
   * @hidden
   */
  handleInputBlur = () => {
    this.changeDetector.markForCheck();
    if (this.inputValue !== this.elementValue) {
      this.handleInput();
    }
    this.setInputValue();
    if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {
      this.ngZone.run(() => {
        this.ngTouched();
        this.inputBlur.emit();
      });
    }
  };
  /**
   * @hidden
   */
  handleKeyDown = (e) => {
    if (this.isDisabled) {
      return;
    }
    let step;
    if (e.keyCode === Keys.ArrowDown) {
      step = -1;
    } else if (e.keyCode === Keys.ArrowUp) {
      step = 1;
    }
    if (step && this.step) {
      e.preventDefault();
      this.addStep(step);
    }
    const input = this.numericInput.nativeElement;
    this.previousSelection = {
      end: input.selectionEnd,
      start: input.selectionStart
    };
    this.pressedKey = e.keyCode;
  };
  /**
   * @hidden
   */
  handleWheel = (e) => {
    if (this.focused && !this.isDisabled && this.changeValueOnScroll) {
      e.preventDefault();
      const delta = getDeltaFromMouseWheel(e);
      this.addStep(delta);
    }
  };
  /**
   * @hidden
   */
  get incrementTitle() {
    return this.localizationService.get("increment");
  }
  /**
   * @hidden
   */
  get decrementTitle() {
    return this.localizationService.get("decrement");
  }
  /**
   * @hidden
   */
  get isControlInvalid() {
    return this.control && this.control.touched && !this.control.valid;
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.control?.control);
  }
  /**
   * @hidden
   */
  get focused() {
    return this.isFocused;
  }
  /**
   * @hidden
   */
  set focused(value) {
    if (this.isFocused !== value && this.hostElement) {
      const wrap2 = this.hostElement.nativeElement;
      if (value) {
        this.renderer.addClass(wrap2, FOCUSED$4);
      } else {
        this.renderer.removeClass(wrap2, FOCUSED$4);
      }
      this.isFocused = value;
    }
  }
  get decimalSeparator() {
    const numberSymbols3 = this.intl.numberSymbols();
    return numberSymbols3.decimal;
  }
  get elementValue() {
    return this.numericInput.nativeElement.value;
  }
  set elementValue(value) {
    this.renderer.setProperty(this.numericInput.nativeElement, "value", value);
  }
  get hasDecimals() {
    return this.decimals !== null && this.decimals >= 0;
  }
  get isDisabled() {
    return this.disabled || this.readonly;
  }
  arrowPress(direction, e) {
    e.preventDefault();
    if (this.isDisabled || isRightClick(e)) {
      return;
    }
    if (!mobileOS) {
      this.focus();
      this.focused = true;
    }
    if (this.arrowDirection !== direction) {
      this.arrowDirection = direction;
      this.changeDetector.detectChanges();
    }
    if (this.step) {
      this.spin(direction, INITIAL_SPIN_DELAY);
    } else {
      this.setInputValue();
    }
  }
  updateValue(value) {
    if (!areSame(this.value, value)) {
      this.ngZone.run(() => {
        this.value = value;
        this.ngChange(value);
        this.valueChange.emit(value);
        this.changeDetector.markForCheck();
      });
    }
  }
  replaceNumpadDotValue() {
    let value = this.inputValue || "";
    if (this.previousSelection) {
      const input = this.numericInput.nativeElement;
      const {
        selectionStart,
        selectionEnd
      } = input;
      const {
        start,
        end
      } = this.previousSelection;
      input.value = value = value.substring(0, start) + this.decimalSeparator + value.substring(end);
      this.setSelection(selectionStart, selectionEnd);
    }
    return value;
  }
  isValid(value) {
    if (!this.numericRegex) {
      this.numericRegex = numericRegex({
        autoCorrect: this.autoCorrect,
        decimals: this.decimals,
        min: this.min,
        separator: this.decimalSeparator
      });
    }
    return this.numericRegex.test(value);
  }
  spin(step, timeout) {
    clearTimeout(this.spinTimeout);
    this.spinTimeout = window.setTimeout(() => {
      this.spin(step, SPIN_DELAY);
    }, timeout);
    this.addStep(step);
  }
  addStep(step) {
    let value = add(this.value || 0, this.step * step);
    value = this.limitValue(value);
    value = this.restrictDecimals(value);
    this.setInputValue(value);
    this.updateValue(value);
  }
  setSelection(start, end) {
    if (this.focused) {
      invokeElementMethod(this.numericInput, "setSelectionRange", start, end);
    }
  }
  limitValue(value) {
    let result = value;
    if (!this.isInRange(value)) {
      if (isNumber3(this.max) && value > this.max) {
        result = this.max;
      }
      if (isNumber3(this.min) && value < this.min) {
        result = this.min;
      }
    }
    return result;
  }
  limitInputValue(value) {
    const {
      selectionStart,
      selectionEnd,
      value: enteredValue
    } = this.numericInput.nativeElement;
    let limitedValue = value;
    let selectToEnd = false;
    if (!this.isInRange(value)) {
      const lengthChange = enteredValue.length - String(this.inputValue).length;
      const {
        min,
        max
      } = this;
      const hasMax = isNumber3(max);
      const hasMin = isNumber3(min);
      let padLimit, replaceNext;
      let correctedValue = value;
      if (selectionStart === 0 && this.inputValue.substr(1) === enteredValue) {
        return {
          selectionEnd,
          selectionStart,
          value: null
        };
      }
      if (hasMax && value > max) {
        if (value > 0) {
          replaceNext = true;
        } else {
          padLimit = max;
        }
      } else if (hasMin && value < min) {
        if (value > 0) {
          padLimit = min;
        } else {
          replaceNext = true;
        }
      }
      if (padLimit) {
        const paddedValue = this.tryPadValue(value, padLimit);
        if (paddedValue && decimalPart(value) !== decimalPart(padLimit)) {
          correctedValue = paddedValue;
          selectToEnd = true;
        }
      } else if (replaceNext) {
        if (this.inputValue && selectionStart !== enteredValue.length) {
          correctedValue = parseFloat(enteredValue.substr(0, selectionStart) + enteredValue.substr(selectionStart + lengthChange));
        }
      }
      limitedValue = this.limitValue(correctedValue);
      selectToEnd = (selectToEnd || limitedValue !== correctedValue) && this.previousSelection && this.previousSelection.end - this.previousSelection.start + lengthChange > 0;
    }
    return {
      selectionEnd: selectToEnd ? String(limitedValue).length : selectionEnd,
      selectionStart,
      value: limitedValue
    };
  }
  tryPadValue(value, limit) {
    const limitLength = String(Math.floor(limit)).length;
    const zeroPadded = pad3(value, limitLength);
    const zeroPaddedNext = pad3(value, limitLength + 1);
    let result;
    if (this.isInRange(zeroPadded)) {
      result = zeroPadded;
    } else if (this.isInRange(zeroPaddedNext)) {
      result = zeroPaddedNext;
    }
    return result;
  }
  isInRange(value) {
    return !isNumber3(value) || (!isNumber3(this.min) || this.min <= value) && (!isNumber3(this.max) || value <= this.max);
  }
  restrictModelValue(value) {
    let result = this.restrictDecimals(value, true);
    if (this.autoCorrect && this.limitValue(result) !== result) {
      result = null;
    }
    return result;
  }
  restrictDecimals(value, round3) {
    let result = value;
    if (value && this.hasDecimals) {
      const decimals = this.decimals;
      const stringValue = String(value);
      if (round3 || EXPONENT_REGEX.test(stringValue)) {
        result = toFixedPrecision(value, decimals);
      } else {
        const parts = stringValue.split(POINT2);
        let fraction = parts[1];
        if (fraction && fraction.length > decimals) {
          fraction = fraction.substr(0, decimals);
          result = parseFloat(`${parts[0]}${POINT2}${fraction}`);
        }
      }
    }
    return result;
  }
  formatInputValue(value) {
    let stringValue = Object.is(value, -0) ? "-0" : String(value);
    const exponentMatch = EXPONENT_REGEX.exec(stringValue);
    if (exponentMatch) {
      stringValue = value.toFixed(limitPrecision(parseInt(exponentMatch[1], 10)));
    }
    return stringValue.replace(POINT2, this.decimalSeparator);
  }
  formatValue(value, focused) {
    let formattedValue;
    if (value === null || !defined2(value) || value === "") {
      formattedValue = "";
    } else if (focused && !this.readonly) {
      formattedValue = this.formatInputValue(value);
    } else {
      formattedValue = this.intl.formatNumber(value, this.format);
    }
    return formattedValue;
  }
  setInputValue(value = this.value, focused = this.focused) {
    const formattedValue = this.formatValue(value, focused);
    this.elementValue = formattedValue;
    this.inputValue = formattedValue;
  }
  verifySettings() {
    if (!isDevMode()) {
      return;
    }
    if (this.min !== null && this.max !== null && this.min > this.max) {
      throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK} and ${MAX_DOC_LINK}.`);
    }
  }
  verifyValue(value) {
    if (isDevMode() && value && typeof value !== "number") {
      throw new Error(`The NumericTextBox component requires value of type Number and ${JSON.stringify(value)} was set.`);
    }
  }
  parseOptions(options2) {
    for (let idx2 = 0; idx2 < options2.length; idx2++) {
      const name2 = options2[idx2];
      const value = this[name2];
      if (typeof value === "string") {
        const parsed = parseFloat(value);
        const valid = !isNaN(parsed);
        if (isDevMode() && !valid && value !== "") {
          throw new Error(`The NumericTextBox component requires value of type Number or a String representing a number for the ${name2} property and ${JSON.stringify(value)} was set.`);
        }
        this[name2] = valid ? parsed : PARSABLE_DEFAULTS[name2];
      }
    }
  }
  intlChange() {
    delete this.numericRegex;
    if (this.numericInput && (!this.focused || !this.isValid(this.elementValue))) {
      this.setInputValue();
    }
  }
  hasTrailingZeros(inputValue) {
    if (this.hasDecimals && this.focused) {
      const fraction = inputValue.split(this.decimalSeparator)[1];
      return fraction && fraction.length > this.decimals && fraction.lastIndexOf("0") === fraction.length - 1;
    }
  }
  selectAll() {
    this.setInputValue();
    this.setSelection(0, this.inputValue.length);
  }
  selectCaret() {
    const caretPosition = getCaretPosition(this.numericInput.nativeElement);
    const formattedValue = this.elementValue;
    const partialValue = formattedValue.substring(0, caretPosition);
    this.setInputValue();
    if (partialValue.length) {
      const significantCharsInFormattedValue = extractSignificantNumericChars(partialValue, this.decimalSeparator);
      const adjustedSignificantChars = this.adjustSignificantChars(formattedValue, significantCharsInFormattedValue);
      this.setSelection(adjustedSignificantChars, adjustedSignificantChars);
    } else {
      this.setSelection(0, 0);
    }
  }
  numberOfLeadingZeroes(formattedValue) {
    const separatorIndex = formattedValue.indexOf(this.decimalSeparator);
    const matchedLeadingZeroes = formattedValue.match(/^[^1-9]*?(0+)/);
    if (matchedLeadingZeroes) {
      const lengthOfMatch = matchedLeadingZeroes[0].length;
      const lengthOfLeadingZeroesMatch = matchedLeadingZeroes[1].length;
      return lengthOfMatch === separatorIndex ? lengthOfLeadingZeroesMatch - 1 : lengthOfLeadingZeroesMatch;
    }
    return 0;
  }
  adjustSignificantChars(formattedValue, significantChars) {
    const leadingZeroes = this.numberOfLeadingZeroes(formattedValue);
    if (leadingZeroes > 0) {
      return Math.max(0, significantChars - leadingZeroes);
    }
    return significantChars;
  }
  handleClasses(value, input) {
    const elem = this.hostElement.nativeElement;
    const classes = getStylingClasses2("input", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  setInputAttributes() {
    const attributesToRender = Object.assign({}, this.mutableAttributes, this.parsedAttributes);
    setHTMLAttributes(attributesToRender, this.renderer, this.numericInput.nativeElement, this.ngZone);
  }
  static ɵfac = function NumericTextBoxComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NumericTextBoxComponent)(ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _NumericTextBoxComponent,
    selectors: [["kendo-numerictextbox"]],
    contentQueries: function NumericTextBoxComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, SuffixTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, PrefixTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.suffixTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.prefixTemplate = _t.first);
      }
    },
    viewQuery: function NumericTextBoxComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c132, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.numericInput = _t.first);
      }
    },
    hostVars: 9,
    hostBindings: function NumericTextBoxComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-disabled", ctx.disableClass)("k-input", ctx.hostClasses)("k-numerictextbox", ctx.hostClasses);
      }
    },
    inputs: {
      focusableId: "focusableId",
      disabled: "disabled",
      readonly: "readonly",
      title: "title",
      autoCorrect: "autoCorrect",
      format: "format",
      max: "max",
      min: "min",
      decimals: "decimals",
      placeholder: "placeholder",
      step: "step",
      spinners: "spinners",
      rangeValidation: "rangeValidation",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      changeValueOnScroll: "changeValueOnScroll",
      selectOnFocus: "selectOnFocus",
      value: "value",
      maxlength: "maxlength",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      inputAttributes: "inputAttributes"
    },
    outputs: {
      valueChange: "valueChange",
      onFocus: "focus",
      onBlur: "blur",
      inputFocus: "inputFocus",
      inputBlur: "inputBlur"
    },
    exportAs: ["kendoNumericTextBox"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.numerictextbox"
    }, {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _NumericTextBoxComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _NumericTextBoxComponent),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _NumericTextBoxComponent)
    }]), ɵɵNgOnChangesFeature],
    decls: 9,
    vars: 28,
    consts: () => {
      let i18n_7;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_7 = goog.getMsg("Increase value");
        i18n_7 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_7;
      } else {
        i18n_7 = $localize`:kendo.numerictextbox.increment|The title for the **Increment** button in the NumericTextBox:Increase value`;
      }
      let i18n_8;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_8 = goog.getMsg("Decrease value");
        i18n_8 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_8;
      } else {
        i18n_8 = $localize`:kendo.numerictextbox.decrement|The title for the **Decrement** button in the NumericTextBox:Decrease value`;
      }
      return [["numericInput", ""], ["kendoNumericTextBoxLocalizedMessages", "", "increment", i18n_7, "decrement", i18n_8], ["kendoInputSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused"], ["class", "k-input-prefix k-input-prefix-horizontal", 4, "ngIf"], [4, "ngIf"], ["role", "spinbutton", "autocomplete", "off", "autocorrect", "off", 1, "k-input-inner", 3, "id", "tabindex", "disabled", "readonly", "kendoEventsOutsideAngular"], ["class", "k-input-suffix k-input-suffix-horizontal", 4, "ngIf"], ["class", "k-input-spinner k-spin-button", 3, "kendoEventsOutsideAngular", 4, "ngIf"], [1, "k-input-prefix", "k-input-prefix-horizontal"], [3, "ngTemplateOutlet"], [1, "k-input-suffix", "k-input-suffix-horizontal"], [1, "k-input-spinner", "k-spin-button", 3, "kendoEventsOutsideAngular"], ["type", "button", "tabindex", "-1", 1, "k-spinner-increase", "k-button", "k-button-md", "k-icon-button", "k-button-solid", "k-button-solid-base", 3, "kendoEventsOutsideAngular", "title"], ["name", "caret-alt-up", "innerCssClass", "k-button-icon", 3, "svgIcon"], ["type", "button", "tabindex", "-1", 1, "k-spinner-decrease", "k-button", "k-button-md", "k-icon-button", "k-button-solid", "k-button-solid-base", 3, "kendoEventsOutsideAngular", "title"], ["name", "caret-alt-down", "innerCssClass", "k-button-icon", 3, "svgIcon"]];
    },
    template: function NumericTextBoxComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 1);
        ɵɵelementContainerStart(1, 2);
        ɵɵtwoWayListener("isFocusedChange", function NumericTextBoxComponent_Template_ng_container_isFocusedChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.focused, $event) || (ctx.focused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function NumericTextBoxComponent_Template_ng_container_handleBlur_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function NumericTextBoxComponent_Template_ng_container_onFocus_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵtemplate(2, NumericTextBoxComponent_span_2_Template, 2, 1, "span", 3)(3, NumericTextBoxComponent_kendo_input_separator_3_Template, 1, 0, "kendo-input-separator", 4);
        ɵɵelement(4, "input", 5, 0);
        ɵɵtemplate(6, NumericTextBoxComponent_kendo_input_separator_6_Template, 1, 0, "kendo-input-separator", 4)(7, NumericTextBoxComponent_span_7_Template, 2, 1, "span", 6)(8, NumericTextBoxComponent_span_8_Template, 5, 22, "span", 7);
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.focused);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate && ctx.prefixTemplate.showSeparator);
        ɵɵadvance();
        ɵɵproperty("id", ctx.focusableId)("tabindex", ctx.tabIndex)("disabled", ctx.disabled)("readonly", ctx.readonly)("kendoEventsOutsideAngular", ɵɵpureFunction7(20, _c142, ctx.handleMouseDown, ctx.handleDragEnter, ctx.handleKeyDown, ctx.handleInput, ctx.handleInputFocus, ctx.handleInputBlur, ctx.handlePaste));
        ɵɵattribute("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.value)("title", ctx.title)("placeholder", ctx.placeholder)("maxLength", ctx.maxlength)("aria-invalid", ctx.isControlInvalid)("required", ctx.isControlRequired ? "" : null);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.suffixTemplate && (ctx.suffixTemplate == null ? null : ctx.suffixTemplate.showSeparator));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffixTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.spinners);
      }
    },
    dependencies: [LocalizedNumericTextBoxMessagesDirective, SharedInputEventsDirective, NgIf, NgTemplateOutlet, InputSeparatorComponent, EventsOutsideAngularDirective, IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericTextBoxComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoNumericTextBox",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.numerictextbox"
      }, {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NumericTextBoxComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => NumericTextBoxComponent),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => NumericTextBoxComponent)
      }],
      selector: "kendo-numerictextbox",
      template: `
        <ng-container kendoNumericTextBoxLocalizedMessages
            i18n-increment="kendo.numerictextbox.increment|The title for the **Increment** button in the NumericTextBox"
            increment="Increase value"
            i18n-decrement="kendo.numerictextbox.decrement|The title for the **Decrement** button in the NumericTextBox"
            decrement="Decrease value"
        >
        </ng-container>
        <ng-container
            kendoInputSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="focused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
        >
            <span *ngIf="prefixTemplate" class="k-input-prefix k-input-prefix-horizontal">
                <ng-template [ngTemplateOutlet]="prefixTemplate?.templateRef">
                </ng-template>
            </span>
            <kendo-input-separator *ngIf="prefixTemplate && prefixTemplate.showSeparator"></kendo-input-separator>
            <input #numericInput
                class="k-input-inner"
                role="spinbutton"
                autocomplete="off"
                autocorrect="off"
                [id]="focusableId"
                [attr.aria-valuemin]="min"
                [attr.aria-valuemax]="max"
                [attr.aria-valuenow]="value"
                [attr.title]="title"
                [attr.placeholder]="placeholder"
                [attr.maxLength]="maxlength"
                [tabindex]="tabIndex"
                [disabled]="disabled"
                [readonly]="readonly"
                [attr.aria-invalid]="isControlInvalid"
                [attr.required]="isControlRequired ? '' : null"
                [kendoEventsOutsideAngular]="{
                    mousedown: handleMouseDown,
                    dragenter: handleDragEnter,
                    keydown: handleKeyDown,
                    input: handleInput,
                    focus: handleInputFocus,
                    blur: handleInputBlur,
                    paste: handlePaste
                }"/>
            <kendo-input-separator *ngIf="suffixTemplate && suffixTemplate?.showSeparator"></kendo-input-separator>
            <span *ngIf="suffixTemplate" class="k-input-suffix k-input-suffix-horizontal">
                <ng-template [ngTemplateOutlet]="suffixTemplate?.templateRef">
                </ng-template>
            </span>
            <span
                class="k-input-spinner k-spin-button" *ngIf="spinners"
                [kendoEventsOutsideAngular]="{ mouseup: releaseArrow, mouseleave: releaseArrow }"
            >
            <button
                type="button"
                [kendoEventsOutsideAngular]="{ mousedown: increasePress }"
                [attr.aria-hidden]="true"
                [attr.aria-label]="incrementTitle"
                [title]="incrementTitle"
                class="k-spinner-increase k-button k-button-md k-icon-button k-button-solid k-button-solid-base"
                [class.k-active]="arrowDirection === ArrowDirection.Up"
                tabindex="-1"
            >
                <kendo-icon-wrapper
                    name="caret-alt-up"
                    innerCssClass="k-button-icon"
                    [svgIcon]="arrowUpIcon"
                >
                </kendo-icon-wrapper>
            </button>
            <button
                type="button"
                [kendoEventsOutsideAngular]="{ mousedown: decreasePress }"
                [attr.aria-hidden]="true"
                [attr.aria-label]="decrementTitle"
                [title]="decrementTitle"
                [class.k-active]="arrowDirection === ArrowDirection.Down"
                class="k-spinner-decrease k-button k-button-md k-icon-button k-button-solid k-button-solid-base"
                tabindex="-1"
            >
                <kendo-icon-wrapper
                    name="caret-alt-down"
                    innerCssClass="k-button-icon"
                    [svgIcon]="arrowDownIcon"
                >
                    </kendo-icon-wrapper>
                </button>
            </span>
        </ng-container>
    `,
      standalone: true,
      imports: [LocalizedNumericTextBoxMessagesDirective, SharedInputEventsDirective, NgIf, NgTemplateOutlet, InputSeparatorComponent, EventsOutsideAngularDirective, IconWrapperComponent]
    }]
  }], function() {
    return [{
      type: IntlService
    }, {
      type: Renderer2
    }, {
      type: LocalizationService
    }, {
      type: Injector
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }];
  }, {
    focusableId: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    title: [{
      type: Input
    }],
    autoCorrect: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    decimals: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    spinners: [{
      type: Input
    }],
    rangeValidation: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    changeValueOnScroll: [{
      type: Input
    }],
    selectOnFocus: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    maxlength: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    inputFocus: [{
      type: Output
    }],
    inputBlur: [{
      type: Output
    }],
    numericInput: [{
      type: ViewChild,
      args: ["numericInput", {
        static: true
      }]
    }],
    suffixTemplate: [{
      type: ContentChild,
      args: [SuffixTemplateDirective]
    }],
    prefixTemplate: [{
      type: ContentChild,
      args: [PrefixTemplateDirective]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    disableClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-input"]
    }, {
      type: HostBinding,
      args: ["class.k-numerictextbox"]
    }]
  });
})();
var NumericTextBoxCustomMessagesComponent = class _NumericTextBoxCustomMessagesComponent extends NumericTextBoxMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function NumericTextBoxCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NumericTextBoxCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _NumericTextBoxCustomMessagesComponent,
    selectors: [["kendo-numerictextbox-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: NumericTextBoxMessages,
      useExisting: forwardRef(() => _NumericTextBoxCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function NumericTextBoxCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericTextBoxCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: NumericTextBoxMessages,
        useExisting: forwardRef(() => NumericTextBoxCustomMessagesComponent)
      }],
      selector: "kendo-numerictextbox-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var ResultType2;
(function(ResultType3) {
  ResultType3[ResultType3["Literal"] = 0] = "Literal";
  ResultType3[ResultType3["Mask"] = 1] = "Mask";
  ResultType3[ResultType3["Undefined"] = 2] = "Undefined";
})(ResultType2 || (ResultType2 = {}));
var Result2 = class _Result {
  value;
  rest;
  type;
  constructor(value, rest, type = ResultType2.Undefined) {
    this.value = value;
    this.rest = rest;
    this.type = type;
  }
  //map :: Functor f => f a ~> (a -> b) -> f b
  map(fn) {
    return new _Result(fn(this.value), this.rest);
  }
  //chain :: Chain m => m a ~> (a -> m b) -> m b
  chain(fn) {
    return fn(this.value, this.rest);
  }
  fold(s, _2) {
    return s(this.value, this.rest);
  }
  concat(r) {
    return this.map((vs, _2) => r.chain((v, __) => vs.concat([v])));
  }
  toString() {
    return `Result({ value: '${this.value}', rest: ${this.rest} })`;
  }
};
var Stream2 = class {
  input;
  control;
  inputCursor = 0;
  controlCursor = 0;
  constructor(input = [], control = []) {
    this.input = input;
    this.control = control;
  }
  eof() {
    return this.inputCursor >= this.input.length;
  }
  // Get the first value from the input.
  next() {
    return {
      char: this.input[this.inputCursor++],
      control: this.control[this.controlCursor++]
    };
  }
  peek() {
    return {
      char: this.input[this.inputCursor],
      control: this.control[this.controlCursor]
    };
  }
  eat_input() {
    this.inputCursor++;
  }
  eat_control() {
    this.controlCursor++;
  }
  eat() {
    this.inputCursor++;
    this.controlCursor++;
  }
};
var toArray3 = (value) => (value || "").split("");
var ESCAPE_CHARACTER2 = "\\";
var Parser2 = class _Parser {
  parse;
  constructor(parse3) {
    this.parse = parse3;
  }
  run(input, control = "") {
    if (input instanceof Stream2) {
      return this.parse(input);
    } else {
      return this.parse(new Stream2(toArray3(input), toArray3(control)));
    }
  }
  //map :: Functor f => f a ~> (a -> b) -> f b
  map(f) {
    return new _Parser((stream2) => this.parse(stream2).map(f));
  }
  //chain :: Chain m => m a ~> (a -> m b) -> m b
  chain(f) {
    return new _Parser((stream2) => this.parse(stream2).chain((v, s) => f(v).run(s)));
  }
  isLiteral(c) {
    return this.run(c).type === ResultType2.Literal;
  }
};
var mask2 = ({
  prompt,
  promptPlaceholder
}) => (rule) => new Parser2((stream2) => {
  while (!stream2.eof()) {
    const {
      char,
      control
    } = stream2.peek();
    if (char === control && control === prompt) {
      stream2.eat();
      return new Result2(prompt, stream2, ResultType2.Mask);
    }
    if (rule.test(char)) {
      stream2.eat();
      return new Result2(char, stream2, ResultType2.Mask);
    }
    if (char === promptPlaceholder) {
      stream2.eat();
      return new Result2(prompt, stream2, ResultType2.Mask);
    }
    stream2.eat_input();
  }
  stream2.eat();
  return new Result2(prompt, stream2, ResultType2.Mask);
});
var literal2 = (_token) => new Parser2((stream2) => {
  const char = stream2.peek().char;
  if (char === _token) {
    stream2.eat();
    return new Result2(_token, stream2, ResultType2.Literal);
  }
  return new Result2(_token, stream2, ResultType2.Literal);
});
var unmask2 = (prompt) => (rule) => new Parser2((stream2) => {
  while (!stream2.eof()) {
    const {
      char,
      control
    } = stream2.peek();
    if (char === prompt && control === prompt) {
      stream2.eat();
      return new Result2(char, stream2);
    }
    if (rule.test(char)) {
      stream2.eat();
      return new Result2(char, stream2);
    }
    stream2.eat_input();
  }
  stream2.eat();
  return new Result2("", stream2);
});
var unliteral2 = (_token) => new Parser2((stream2) => {
  if (stream2.eof()) {
    return new Result2("", stream2);
  }
  const {
    char
  } = stream2.peek();
  if (char === _token) {
    stream2.eat();
  }
  return new Result2(_token, stream2);
});
var token2 = (rules, creator) => new Parser2((stream2) => {
  let {
    char
  } = stream2.next();
  const rule = rules[char];
  if (char === ESCAPE_CHARACTER2) {
    char = stream2.next().char;
    return new Result2(creator.literal(char), stream2);
  }
  if (!rule) {
    return new Result2(creator.literal(char), stream2);
  }
  return new Result2(creator.mask(rule), stream2);
});
var rawMask2 = ({
  prompt,
  promptPlaceholder
}) => new Parser2((stream2) => {
  const {
    char
  } = stream2.next();
  if (char === prompt) {
    return new Result2(promptPlaceholder, stream2);
  }
  return new Result2(char, stream2);
});
var rawLiteral2 = (includeLiterals) => new Parser2((stream2) => {
  const {
    char
  } = stream2.next();
  if (includeLiterals) {
    return new Result2(char, stream2);
  }
  return new Result2("", stream2);
});
var always2 = (value) => new Parser2((stream2) => new Result2(value, stream2));
var append3 = (p1, p2) => p1.chain((vs) => p2.map((v) => vs.concat([v])));
var sequence2 = (list) => list.reduce((acc, parser) => append3(acc, parser), always2([]));
var greedy2 = (parser) => new Parser2((stream2) => {
  let result = new Result2([], stream2);
  while (!stream2.eof()) {
    result = result.concat(parser.run(stream2));
  }
  return result;
});
var MaskingService2 = class _MaskingService {
  rules = {};
  prompt = "_";
  mask = "";
  promptPlaceholder = " ";
  includeLiterals = false;
  maskTokens = [];
  unmaskTokens = [];
  rawTokens = [];
  validationTokens = [];
  update({
    mask: mask3 = "",
    prompt = "",
    promptPlaceholder = " ",
    rules = {},
    includeLiterals = false
  }) {
    this.mask = mask3;
    this.prompt = prompt;
    this.promptPlaceholder = promptPlaceholder;
    this.rules = rules;
    this.includeLiterals = includeLiterals;
    this.tokenize();
  }
  validationValue(maskedValue = "") {
    let value = maskedValue;
    sequence2(this.validationTokens).run(maskedValue).fold((unmasked) => {
      value = unmasked.join("");
    });
    return value;
  }
  rawValue(maskedValue = "") {
    let value = maskedValue;
    if (!this.rawTokens.length) {
      return value;
    }
    sequence2(this.rawTokens).run(maskedValue).fold((unmasked) => {
      value = unmasked.join("");
    });
    return value;
  }
  /**
   * @hidden
   */
  maskRaw(rawValue = "") {
    let value = rawValue;
    if (!this.maskTokens.length) {
      return value;
    }
    sequence2(this.maskTokens).run(rawValue).fold((masked) => {
      value = masked.join("");
    });
    return value;
  }
  maskInput(input, control, splitPoint) {
    if (input.length < control.length) {
      return this.maskRemoved(input, control, splitPoint);
    }
    return this.maskInserted(input, control, splitPoint);
  }
  maskInRange(pasted, oldValue, start, end) {
    let value = "";
    const selection = end;
    const beforeChange = oldValue.split("").slice(0, start);
    const afterChange = oldValue.split("").slice(end);
    sequence2(this.maskTokens.slice(start, end)).run(pasted).fold((masked) => {
      value = beforeChange.concat(masked).concat(afterChange).join("");
    });
    return {
      selection,
      value
    };
  }
  maskRemoved(input, control, splitPoint) {
    let value = "";
    let selection = splitPoint;
    const unchanged = input.split("").slice(splitPoint);
    const changed = input.split("").slice(0, splitPoint).join("");
    const take2 = this.maskTokens.length - (input.length - splitPoint);
    sequence2(this.maskTokens.slice(0, take2)).run(changed, control).fold((masked) => {
      selection = this.adjustPosition(masked, selection);
      value = masked.concat(unchanged).join("");
    });
    return {
      selection,
      value
    };
  }
  adjustPosition(input, selection) {
    const caretChar = input[selection];
    const isLiteral = this.maskTokens[selection].isLiteral(caretChar);
    if (!isLiteral && caretChar !== this.prompt) {
      return selection + 1;
    }
    return selection;
  }
  maskInserted(input, control, splitPoint) {
    let value = "";
    let selection = splitPoint;
    const changed = input.slice(0, splitPoint);
    sequence2(this.unmaskTokens).run(changed, control).chain((unmasked) => {
      selection = unmasked.join("").length;
      const unchanged = control.slice(selection);
      return sequence2(this.maskTokens).run(unmasked.join("") + unchanged, control);
    }).fold((masked) => {
      value = masked.join("");
    });
    return {
      selection,
      value
    };
  }
  get maskTokenCreator() {
    const {
      prompt,
      promptPlaceholder
    } = this;
    return {
      literal: (rule) => literal2(rule),
      mask: (rule) => mask2({
        prompt,
        promptPlaceholder
      })(rule)
    };
  }
  get unmaskTokenCreator() {
    return {
      literal: (rule) => unliteral2(rule),
      mask: (rule) => unmask2(this.prompt)(rule)
    };
  }
  get rawTokenCreator() {
    const {
      prompt,
      promptPlaceholder,
      includeLiterals
    } = this;
    return {
      literal: (_2) => rawLiteral2(includeLiterals),
      mask: (_2) => rawMask2({
        prompt,
        promptPlaceholder
      })
    };
  }
  get validationTokenCreator() {
    const {
      prompt
    } = this;
    return {
      literal: (_2) => rawLiteral2(false),
      mask: (_2) => rawMask2({
        prompt,
        promptPlaceholder: ""
      })
    };
  }
  tokenize() {
    greedy2(token2(this.rules, this.maskTokenCreator)).run(this.mask).fold((tokens, _2) => {
      this.maskTokens = tokens;
    });
    greedy2(token2(this.rules, this.unmaskTokenCreator)).run(this.mask).fold((tokens, _2) => {
      this.unmaskTokens = tokens;
    });
    greedy2(token2(this.rules, this.rawTokenCreator)).run(this.mask).fold((tokens, _2) => {
      this.rawTokens = tokens;
    });
    greedy2(token2(this.rules, this.validationTokenCreator)).run(this.mask).fold((tokens, _2) => {
      this.validationTokens = tokens;
    });
  }
  static ɵfac = function MaskingService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MaskingService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _MaskingService,
    factory: _MaskingService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaskingService2, [{
    type: Injectable
  }], null, null);
})();
var resolvedPromise = Promise.resolve(null);
var FOCUSED$3 = "k-focus";
var DEFAULT_SIZE$c = "medium";
var DEFAULT_ROUNDED$7 = "medium";
var DEFAULT_FILL_MODE$5 = "solid";
var MaskedTextBoxComponent = class _MaskedTextBoxComponent {
  service;
  renderer;
  hostElement;
  ngZone;
  injector;
  changeDetector;
  /**
   * @hidden
   */
  focusableId = `k-${guid()}`;
  /**
   * Determines whether the MaskedTextBox is disabled ([see example]({% slug disabled_maskedtextbox %})). To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_maskedtextbox#toc-managing-the-maskedtextbox-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Determines whether the MaskedTextBox is in its read-only state ([see example]({% slug readonly_maskedtextbox %})).
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the title of the `input` element.
   */
  title;
  /**
   * The size property specifies the padding of the MaskedTextBox internal input element
   * ([see example]({% slug appearance_maskedtextbox %}#toc-size)).
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$c;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * The rounded property specifies the border radius of the MaskedTextBox
   * ([see example](slug:appearance_maskedtextbox#toc-roundness)).
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED$7;
    this.handleClasses(newRounded, "rounded");
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * The `fillMode` property specifies the background and border styles of the MaskedTexBox
   * ([see example]({% slug appearance_maskedtextbox %}#toc-fill-mode)).
   * The possible values are:
   * * `flat`
   * * `solid` (default)
   * * `outline`
   * * `none`
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$5;
    this.handleClasses(newFillMode, "fillMode");
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Represents the current mask ([see example]({% slug value_maskedtextbox %})).
   * If no mask is set, the component behaves as a standard `type="text"` input.
   *
   * > If the mask allows for spaces, set the [promptPlaceholder]({% slug api_inputs_maskedtextboxcomponent %}#toc-promptplaceholder)
   * to a character that is not accepted by the mask.
   */
  mask;
  /**
   * Provides a value for the MaskedTextBox.
   */
  value;
  /**
   * Exposes the RegExp-based mask validation array ([see example]({% slug masks_maskedtextbox %})).
   */
  set rules(value) {
    this._rules = Object.assign({}, this.defaultRules, value);
  }
  get rules() {
    return this._rules || this.defaultRules;
  }
  /**
   * Represents a prompt character for the masked value.
   * @default `_`
   */
  prompt = "_";
  /**
   * Indicates a character which represents an empty position in the raw value.
   * @default ' '
   */
  promptPlaceholder = " ";
  /**
   * Indicates whether to include literals in the raw value  ([see example]({% slug value_maskedtextbox %})).
   * @default false
   */
  includeLiterals = false;
  /**
   * Specifies if the mask should be shown on focus for empty value.
   */
  maskOnFocus = false;
  /**
   * Determines whether the built-in mask validator is enforced when a form is validated
   * ([see example]({% slug validation_maskedtextbox %})).
   * @default true
   */
  maskValidation = true;
  /**
   * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
   */
  set inputAttributes(attributes) {
    if (isObjectPresent(this.parsedAttributes)) {
      removeHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement);
    }
    this._inputAttributes = attributes;
    this.parsedAttributes = this.inputAttributes ? parseAttributes(this.inputAttributes, this.defaultAttributes) : this.inputAttributes;
    this.setInputAttributes();
  }
  get inputAttributes() {
    return this._inputAttributes;
  }
  get defaultAttributes() {
    return {
      id: this.focusableId,
      disabled: this.disabled ? "" : null,
      readonly: this.readonly ? "" : null,
      tabindex: this.tabIndex,
      "aria-invalid": this.isControlInvalid,
      title: this.title,
      required: this.isControlRequired ? "" : null
    };
  }
  get mutableAttributes() {
    return {
      "aria-placeholder": this.mask,
      autocomplete: "off",
      autocorrect: "off",
      autocapitalize: "off",
      spellcheck: "false"
    };
  }
  /**
   * Fires each time the user focuses the MaskedTextBox component.
   *
   * > To wire the event programmatically, use the `onFocus` property.
   *
   * @example
   * ```ts-no-run
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <kendo-maskedtextbox (focus)="handleFocus()"></kendo-maskedtextbox>
   * `
   * })
   * class AppComponent {
   *   public handleFocus(): void {
   *      console.log("Component is focused");
   *   }
   * }
   * ```
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the MaskedTextBox component gets blurred.
   *
   * > To wire the event programmatically, use the `onBlur` property.
   *
   * @example
   * ```ts-no-run
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <kendo-maskedtextbox (blur)="handleBlur()"></kendo-maskedtextbox>
   * `
   * })
   * class AppComponent {
   *   public handleBlur(): void {
   *      console.log("Component is blurred");
   *   }
   * }
   * ```
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the user focuses the `input` element.
   */
  inputFocus = new EventEmitter();
  /**
   * Fires each time the `input` element gets blurred.
   */
  inputBlur = new EventEmitter();
  /**
   * Fires each time the value changes.
   */
  valueChange = new EventEmitter();
  direction;
  hostClasses = true;
  get hostDisabledClass() {
    return this.disabled;
  }
  /**
   * Represents the `ElementRef` of the visible `input` element.
   */
  input;
  /**
   * @hidden
   */
  suffixTemplate;
  /**
   * @hidden
   */
  prefixTemplate;
  isFocused;
  maskedValue;
  focusClick = false;
  defaultRules = {
    "#": /[\d\s\+\-]/,
    "&": /[\S]/,
    "0": /[\d]/,
    "9": /[\d\s]/,
    "?": /[a-zA-Z\s]/,
    "A": /[a-zA-Z0-9]/,
    "C": /./,
    "L": /[a-zA-Z]/,
    "a": /[a-zA-Z0-9\s]/
  };
  _rules;
  isPasted = false;
  selection = [0, 0];
  control;
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  _inputAttributes;
  parsedAttributes = {};
  constructor(service, renderer, hostElement, ngZone, injector, changeDetector, rtl) {
    this.service = service;
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.ngZone = ngZone;
    this.injector = injector;
    this.changeDetector = changeDetector;
    validatePackage(packageMetadata5);
    this.direction = rtl ? "rtl" : "ltr";
    this.updateService();
  }
  ngOnInit() {
    if (this.hostElement) {
      this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
    }
    this.control = this.injector.get(NgControl, null);
  }
  ngAfterViewInit() {
    const stylingInputs = ["size", "rounded", "fillMode"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
  }
  /**
   * @hidden
   * Used by the FloatingLabel to determine if the MaskedTextBox is empty.
   */
  isEmpty() {
    if (this.input) {
      return !this.input.nativeElement.value;
    }
  }
  /**
   * @hidden
   */
  handleFocus = () => {
    this.ngZone.run(() => {
      if (!this.focused && hasObservers(this.onFocus)) {
        this.onFocus.emit();
      }
      this.focused = true;
    });
    if (this.maskOnFocus && this.emptyMask) {
      this.updateInput(this.service.maskRaw(this.value));
      this.ngZone.runOutsideAngular(() => {
        setTimeout(() => {
          this.setSelection(0, 0);
        }, 0);
      });
    }
  };
  /**
   * @hidden
   */
  handleInputFocus = () => {
    this.handleFocus();
    if (hasObservers(this.inputFocus)) {
      this.ngZone.run(() => {
        this.inputFocus.emit();
      });
    }
  };
  /**
   * @hidden
   */
  handleClick = () => {
    if (this.focused && !this.focusClick) {
      this.focusClick = true;
    }
    if (this.promptPlaceholder === null || this.promptPlaceholder === "") {
      const {
        selectionStart,
        selectionEnd
      } = this.input.nativeElement;
      if (selectionStart === selectionEnd) {
        this.setFocusSelection();
      }
    }
  };
  /**
   * @hidden
   */
  handleBlur = () => {
    this.changeDetector.markForCheck();
    this.focused = false;
    this.focusClick = false;
    if (this.maskOnFocus && this.emptyMask) {
      this.updateInput(this.maskedValue);
    }
    if (hasObservers(this.onBlur)) {
      this.ngZone.run(() => {
        this.onBlur.emit();
      });
    }
    this.ngZone.run(() => {
      if (this.control) {
        this.control && !this.control.touched && this.onTouched();
      }
    });
  };
  /**
   * @hidden
   */
  handleInputBlur = () => {
    this.changeDetector.markForCheck();
    if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {
      this.ngZone.run(() => {
        this.inputBlur.emit();
      });
    }
  };
  /**
   * @hidden
   */
  handleDragDrop() {
    return false;
  }
  /**
   * Focuses the MaskedTextBox.
   *
   * @example
   * ```ts-no-run
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="maskedinput.focus()">Focus the input</button>
   *  <kendo-maskedtextbox #maskedinput></kendo-maskedtextbox>
   * `
   * })
   * class AppComponent { }
   * ```
   */
  focus() {
    if (!this.input) {
      return;
    }
    this.input.nativeElement.focus();
    this.focused = true;
    this.setFocusSelection();
  }
  /**
   * Blurs the MaskedTextBox.
   */
  blur() {
    if (!this.input) {
      return;
    }
    this.input.nativeElement.blur();
    this.focused = false;
  }
  /**
   * @hidden
   */
  pasteHandler(e) {
    const {
      selectionStart,
      selectionEnd
    } = e.target;
    if (selectionEnd === selectionStart) {
      return;
    }
    this.isPasted = true;
    this.selection = [selectionStart, selectionEnd];
  }
  /**
   * @hidden
   */
  inputHandler(e) {
    const value = e.target.value;
    const [start, end] = this.selection;
    if (!this.mask) {
      this.updateValueWithEvents(value);
      this.isPasted = false;
      return;
    }
    let result;
    if (this.isPasted) {
      this.isPasted = false;
      const rightPart = this.maskedValue.length - end;
      const to = value.length - rightPart;
      result = this.service.maskInRange(value.slice(start, to), this.maskedValue, start, end);
    } else {
      result = this.service.maskInput(value, this.maskedValue || "", e.target.selectionStart);
    }
    this.updateInput(result.value, result.selection);
    this.updateValueWithEvents(result.value);
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    if (changes["value"]) {
      this.value = this.normalizeValue(this.value);
    }
    const next = this.extractChanges(changes);
    this.updateService(next);
    if (!this.mask) {
      this.updateInput(this.value);
      return;
    }
    const maskedValue = this.service.maskRaw(this.value);
    this.updateInput(maskedValue, null, true);
    if (changes["includeLiterals"] || isChanged("promptPlaceholder", changes)) {
      resolvedPromise.then(() => {
        this.updateValueWithEvents(this.maskedValue, false);
      });
    }
  }
  /**
   * @hidden
   * Writes a new value to the element.
   */
  writeValue(value) {
    this.value = this.normalizeValue(value);
    this.updateInput(this.service.maskRaw(this.value));
    if (this.includeLiterals) {
      this.updateValue(this.maskedValue, false);
    }
  }
  /**
   * @hidden
   * Sets the function that will be called when a `change` event is triggered.
   */
  registerOnChange(fn) {
    this.onChange = fn;
  }
  /**
   * @hidden
   * Sets the function that will be called when a `touch` event is triggered.
   */
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  /**
   * @hidden
   * Called when the status of the component changes to or from `disabled`.
   * Depending on the value, it enables or disables the appropriate DOM element.
   *
   * @param isDisabled
   */
  setDisabledState(isDisabled2) {
    this.changeDetector.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * @hidden
   */
  validate(_2) {
    if (this.maskValidation === false || !this.mask) {
      return null;
    }
    if (!this.service.validationValue(this.maskedValue)) {
      return null;
    }
    if (this.maskedValue.indexOf(this.prompt) !== -1) {
      return {
        patternError: {
          mask: this.mask,
          maskedValue: this.maskedValue,
          value: this.value
        }
      };
    }
    return null;
  }
  /**
   * @hidden
   */
  get isControlInvalid() {
    return this.control && this.control.touched && this.control.invalid;
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.control?.control);
  }
  /**
   * @hidden
   */
  updateValueWithEvents(maskedValue, callOnChange = true) {
    const previousValue = this.value;
    this.updateValue(maskedValue, callOnChange);
    const valueChanged = this.value !== previousValue;
    if (valueChanged && hasObservers(this.valueChange)) {
      this.valueChange.emit(this.value);
    }
  }
  onChange = (_2) => {
  };
  onTouched = () => {
  };
  updateValue(value, callOnChange = true) {
    if (this.mask && !this.service.validationValue(value) && !this.includeLiterals) {
      this.value = "";
    } else {
      this.value = this.service.rawValue(value);
    }
    callOnChange && this.onChange(this.value);
  }
  updateInput(maskedValue = "", selection, isFromOnChanges) {
    if (isFromOnChanges && maskedValue === this.maskedValue) {
      return;
    }
    this.maskedValue = maskedValue;
    const value = this.maskOnFocus && !this.focused && this.emptyMask ? "" : maskedValue;
    this.renderer.setProperty(this.input.nativeElement, "value", value);
    if (selection !== void 0) {
      this.setSelection(selection, selection);
    }
  }
  extractChanges(changes) {
    return Object.keys(changes).filter((key) => key !== "rules").reduce((obj, key) => {
      obj[key] = changes[key].currentValue;
      return obj;
    }, {});
  }
  updateService(extra) {
    const config = Object.assign({
      includeLiterals: this.includeLiterals,
      mask: this.mask,
      prompt: this.prompt,
      promptPlaceholder: this.promptPlaceholder,
      rules: this.rules
    }, extra);
    this.service.update(config);
  }
  setSelection(start = this.selection[0], end = this.selection[1]) {
    if (this.focused) {
      invokeElementMethod(this.input, "setSelectionRange", start, end);
    }
  }
  get emptyMask() {
    return this.service.maskRaw() === this.maskedValue;
  }
  setFocusSelection() {
    const selectionStart = this.input.nativeElement.selectionStart;
    const index = this.maskedValue ? this.maskedValue.indexOf(this.prompt) : 0;
    if (index >= 0 && index < selectionStart) {
      this.selection = [index, index];
      this.setSelection();
    }
  }
  /**
   * @hidden
   */
  get focused() {
    return this.isFocused;
  }
  /**
   * @hidden
   */
  set focused(value) {
    if (this.isFocused !== value && this.hostElement) {
      const element = this.hostElement.nativeElement;
      if (value) {
        this.renderer.addClass(element, FOCUSED$3);
      } else {
        this.renderer.removeClass(element, FOCUSED$3);
      }
      this.isFocused = value;
    }
  }
  normalizeValue(value) {
    const present = isPresent5(value);
    if (present && typeof value !== "string") {
      if (isDevMode()) {
        throw new Error("The MaskedTextBox component supports only string values.");
      }
      return String(value);
    }
    return present ? value : "";
  }
  handleClasses(value, input) {
    const elem = this.hostElement.nativeElement;
    const classes = getStylingClasses2("input", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  setInputAttributes() {
    const attributesToRender = Object.assign({}, this.mutableAttributes, this.parsedAttributes);
    setHTMLAttributes(attributesToRender, this.renderer, this.input.nativeElement, this.ngZone);
  }
  static ɵfac = function MaskedTextBoxComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MaskedTextBoxComponent)(ɵɵdirectiveInject(MaskingService2), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(RTL, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MaskedTextBoxComponent,
    selectors: [["kendo-maskedtextbox"]],
    contentQueries: function MaskedTextBoxComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, SuffixTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, PrefixTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.suffixTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.prefixTemplate = _t.first);
      }
    },
    viewQuery: function MaskedTextBoxComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c172, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
      }
    },
    hostVars: 9,
    hostBindings: function MaskedTextBoxComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("paste", function MaskedTextBoxComponent_paste_HostBindingHandler($event) {
          return ctx.pasteHandler($event);
        })("input", function MaskedTextBoxComponent_input_HostBindingHandler($event) {
          return ctx.inputHandler($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-input", ctx.hostClasses)("k-maskedtextbox", ctx.hostClasses)("k-disabled", ctx.hostDisabledClass);
      }
    },
    inputs: {
      focusableId: "focusableId",
      disabled: "disabled",
      readonly: "readonly",
      title: "title",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      mask: "mask",
      value: "value",
      rules: "rules",
      prompt: "prompt",
      promptPlaceholder: "promptPlaceholder",
      includeLiterals: "includeLiterals",
      maskOnFocus: "maskOnFocus",
      maskValidation: "maskValidation",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      inputAttributes: "inputAttributes"
    },
    outputs: {
      onFocus: "focus",
      onBlur: "blur",
      inputFocus: "inputFocus",
      inputBlur: "inputBlur",
      valueChange: "valueChange"
    },
    exportAs: ["kendoMaskedTextBox"],
    features: [ɵɵProvidersFeature([MaskingService2, {
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _MaskedTextBoxComponent)
      /* eslint-disable-line*/
    }, {
      multi: true,
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _MaskedTextBoxComponent)
      /* eslint-disable-line*/
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _MaskedTextBoxComponent)
    }]), ɵɵNgOnChangesFeature],
    decls: 7,
    vars: 21,
    consts: [["input", ""], ["kendoInputSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused"], ["class", "k-input-prefix k-input-prefix-horizontal", 4, "ngIf"], [4, "ngIf"], ["autocomplete", "off", "autocorrect", "off", "autocapitalize", "off", "spellcheck", "false", 1, "k-input-inner", 3, "id", "tabindex", "disabled", "readonly", "kendoEventsOutsideAngular"], ["class", "k-input-suffix k-input-suffix-horizontal", 4, "ngIf"], [1, "k-input-prefix", "k-input-prefix-horizontal"], [3, "ngTemplateOutlet"], [1, "k-input-suffix", "k-input-suffix-horizontal"]],
    template: function MaskedTextBoxComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainerStart(0, 1);
        ɵɵtwoWayListener("isFocusedChange", function MaskedTextBoxComponent_Template_ng_container_isFocusedChange_0_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.focused, $event) || (ctx.focused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function MaskedTextBoxComponent_Template_ng_container_handleBlur_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function MaskedTextBoxComponent_Template_ng_container_onFocus_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵtemplate(1, MaskedTextBoxComponent_span_1_Template, 2, 1, "span", 2)(2, MaskedTextBoxComponent_kendo_input_separator_2_Template, 1, 0, "kendo-input-separator", 3);
        ɵɵelement(3, "input", 4, 0);
        ɵɵtemplate(5, MaskedTextBoxComponent_kendo_input_separator_5_Template, 1, 0, "kendo-input-separator", 3)(6, MaskedTextBoxComponent_span_6_Template, 2, 1, "span", 5);
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.focused);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate && ctx.prefixTemplate.showSeparator);
        ɵɵadvance();
        ɵɵproperty("id", ctx.focusableId)("tabindex", ctx.tabIndex)("disabled", ctx.disabled)("readonly", ctx.readonly)("kendoEventsOutsideAngular", ɵɵpureFunction5(15, _c18, ctx.handleInputFocus, ctx.handleInputBlur, ctx.handleClick, ctx.handleDragDrop, ctx.handleDragDrop));
        ɵɵattribute("title", ctx.title)("aria-placeholder", ctx.mask)("aria-invalid", ctx.isControlInvalid)("required", ctx.isControlRequired ? "" : null);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.suffixTemplate && ctx.suffixTemplate.showSeparator);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffixTemplate);
      }
    },
    dependencies: [SharedInputEventsDirective, NgIf, NgTemplateOutlet, InputSeparatorComponent, EventsOutsideAngularDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaskedTextBoxComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoMaskedTextBox",
      providers: [MaskingService2, {
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => MaskedTextBoxComponent)
        /* eslint-disable-line*/
      }, {
        multi: true,
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => MaskedTextBoxComponent)
        /* eslint-disable-line*/
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => MaskedTextBoxComponent)
      }],
      selector: "kendo-maskedtextbox",
      template: `
        <ng-container
            kendoInputSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="focused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
        >
            <span *ngIf="prefixTemplate" class="k-input-prefix k-input-prefix-horizontal">
                <ng-template [ngTemplateOutlet]="prefixTemplate?.templateRef">
                </ng-template>
            </span>
            <kendo-input-separator *ngIf="prefixTemplate && prefixTemplate.showSeparator"></kendo-input-separator>
            <input #input
                class="k-input-inner"
                autocomplete="off"
                autocorrect="off"
                autocapitalize="off"
                spellcheck="false"
                [id]="focusableId"
                [tabindex]="tabIndex"
                [attr.title]="title"
                [attr.aria-placeholder]="mask"
                [attr.aria-invalid]="isControlInvalid"
                [attr.required]="isControlRequired ? '' : null"
                [disabled]="disabled"
                [readonly]="readonly"
                [kendoEventsOutsideAngular]="{
                    focus: handleInputFocus,
                    blur: handleInputBlur,
                    click: handleClick,
                    dragstart: handleDragDrop,
                    drop: handleDragDrop
                }"
            />
            <kendo-input-separator *ngIf="suffixTemplate && suffixTemplate.showSeparator"></kendo-input-separator>
            <span *ngIf="suffixTemplate" class="k-input-suffix k-input-suffix-horizontal">
                <ng-template [ngTemplateOutlet]="suffixTemplate?.templateRef">
                </ng-template>
            </span>
        </ng-container>
    `,
      standalone: true,
      imports: [SharedInputEventsDirective, NgIf, NgTemplateOutlet, InputSeparatorComponent, EventsOutsideAngularDirective]
    }]
  }], function() {
    return [{
      type: MaskingService2
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Injector
    }, {
      type: ChangeDetectorRef
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [RTL]
      }]
    }];
  }, {
    focusableId: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    title: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    mask: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    rules: [{
      type: Input
    }],
    prompt: [{
      type: Input
    }],
    promptPlaceholder: [{
      type: Input
    }],
    includeLiterals: [{
      type: Input
    }],
    maskOnFocus: [{
      type: Input
    }],
    maskValidation: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    inputFocus: [{
      type: Output
    }],
    inputBlur: [{
      type: Output
    }],
    valueChange: [{
      type: Output
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-input"]
    }, {
      type: HostBinding,
      args: ["class.k-maskedtextbox"]
    }],
    hostDisabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    input: [{
      type: ViewChild,
      args: ["input", {
        static: true
      }]
    }],
    suffixTemplate: [{
      type: ContentChild,
      args: [SuffixTemplateDirective]
    }],
    prefixTemplate: [{
      type: ContentChild,
      args: [PrefixTemplateDirective]
    }],
    pasteHandler: [{
      type: HostListener,
      args: ["paste", ["$event"]]
    }],
    inputHandler: [{
      type: HostListener,
      args: ["input", ["$event"]]
    }]
  });
})();
var FOCUSED$2 = "k-focus";
var DEFAULT_SIZE$b = "medium";
var RadioCheckBoxBase = class _RadioCheckBoxBase {
  componentType;
  hostElement;
  renderer;
  cdr;
  ngZone;
  injector;
  /**
   * @hidden
   */
  focusableId = `k-${guid()}`;
  /**
   * Sets the `title` attribute of the `input` element of the component.
   */
  title;
  /**
   * Sets the `name` attribute for the component.
   */
  name;
  /**
   * Sets the disabled state of the component.
   *
   * @default false
   */
  disabled = false;
  /**
   * Specifies the `tabindex` of the component.
   *
   * @default 0
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Provides a value for the component.
   */
  value;
  /**
   * The size property specifies the width and height of the component.
   *
   * @default 'medium'
   *
   * The possible values are:
   * * `small`
   * * `medium`
   * * `large`
   * * `none`
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$b;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
   */
  set inputAttributes(attributes) {
    if (isObjectPresent(this.parsedAttributes)) {
      removeHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement);
    }
    this._inputAttributes = attributes;
    this.parsedAttributes = this.inputAttributes ? parseAttributes(this.inputAttributes, this.defaultAttributes) : this.inputAttributes;
    this.setInputAttributes();
  }
  get inputAttributes() {
    return this._inputAttributes;
  }
  ngOnInit() {
    this.control = this.injector.get(NgControl, null);
  }
  /**
   * Fires each time the user focuses the component.
   *
   * > To wire the event programmatically, use the `onFocus` property.
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the component gets blurred.
   *
   * > To wire the event programmatically, use the `onBlur` property.
   */
  onBlur = new EventEmitter();
  /**
   * Focuses the component.
   */
  focus() {
    if (!this.input) {
      return;
    }
    this.focusChangedProgrammatically = true;
    this.isFocused = true;
    this.input.nativeElement.focus();
    this.focusChangedProgrammatically = false;
  }
  /**
   * Blurs the component.
   */
  blur() {
    this.focusChangedProgrammatically = true;
    const isFocusedElement = this.hostElement.nativeElement.querySelector(":focus");
    if (isFocusedElement) {
      isFocusedElement.blur();
    }
    this.isFocused = false;
    this.focusChangedProgrammatically = false;
  }
  /**
   * @hidden
   */
  handleInputBlur = () => {
    this.cdr.markForCheck();
    if (requiresZoneOnBlur(this.control)) {
      this.ngZone.run(() => {
        this.ngTouched();
      });
    }
  };
  /**
   * @hidden
   */
  handleFocus() {
    this.ngZone.run(() => {
      if (!this.focusChangedProgrammatically && hasObservers(this.onFocus)) {
        this.onFocus.emit();
      }
      this.isFocused = true;
    });
  }
  /**
   * @hidden
   */
  handleBlur() {
    this.ngZone.run(() => {
      if (!this.focusChangedProgrammatically) {
        this.ngTouched();
        this.onBlur.emit();
      }
      this.isFocused = false;
    });
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.ngChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.ngTouched = fn;
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.control?.control);
  }
  /**
   * @hidden
   */
  get isControlInvalid() {
    return this.control && this.control.touched && !this.control.valid;
  }
  /**
   * Represents the visible `input` element.
   */
  input;
  /**
   * @hidden
   */
  get isFocused() {
    return this._isFocused;
  }
  /**
   * @hidden
   */
  set isFocused(value) {
    if (this._isFocused !== value && this.input) {
      const element = this.input.nativeElement;
      if (value && !this.disabled) {
        this.renderer.addClass(element, FOCUSED$2);
      } else {
        this.renderer.removeClass(element, FOCUSED$2);
      }
      this._isFocused = value;
    }
  }
  /**
   * @hidden
   * Called when the status of the component changes to or from `disabled`.
   * Depending on the value, it enables or disables the appropriate DOM element.
   *
   * @param isDisabled
   */
  setDisabledState(isDisabled2) {
    this.cdr.markForCheck();
    this.disabled = isDisabled2;
  }
  control;
  focusChangedProgrammatically = false;
  get defaultAttributes() {
    return null;
  }
  parsedAttributes = {};
  _inputAttributes;
  ngChange = (_2) => {
  };
  ngTouched = () => {
  };
  _isFocused = false;
  _size = DEFAULT_SIZE$b;
  constructor(componentType, hostElement, renderer, cdr, ngZone, injector) {
    this.componentType = componentType;
    this.hostElement = hostElement;
    this.renderer = renderer;
    this.cdr = cdr;
    this.ngZone = ngZone;
    this.injector = injector;
  }
  /**
   * @hidden
   */
  writeValue(_value) {
  }
  handleClasses(value, input) {
    if (!isPresent(this.input)) {
      return;
    }
    const inputElem = this.input.nativeElement;
    const classes = getStylingClasses2(this.componentType, input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(inputElem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(inputElem, classes.toAdd);
    }
  }
  setInputAttributes() {
    setHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement, this.ngZone);
  }
  static ɵfac = function RadioCheckBoxBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RadioCheckBoxBase)(ɵɵdirectiveInject(COMPONENT_TYPE), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Injector));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _RadioCheckBoxBase,
    selectors: [["ng-component"]],
    viewQuery: function RadioCheckBoxBase_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c172, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
      }
    },
    inputs: {
      focusableId: "focusableId",
      title: "title",
      name: "name",
      disabled: "disabled",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      value: "value",
      size: "size",
      inputAttributes: "inputAttributes"
    },
    outputs: {
      onFocus: "focus",
      onBlur: "blur"
    },
    standalone: false,
    decls: 0,
    vars: 0,
    template: function RadioCheckBoxBase_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioCheckBoxBase, [{
    type: Component,
    args: [{
      template: ""
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [COMPONENT_TYPE]
      }]
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }, {
      type: NgZone
    }, {
      type: Injector
    }];
  }, {
    focusableId: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    input: [{
      type: ViewChild,
      args: ["input", {
        static: true
      }]
    }]
  });
})();
var DEFAULT_ROUNDED$6 = "medium";
var CheckBoxComponent = class _CheckBoxComponent extends RadioCheckBoxBase {
  renderer;
  hostElement;
  cdr;
  ngZone;
  injector;
  hostClass = true;
  /**
   * Sets the checked state of the component.
   *
   * @default false
   */
  set checkedState(value) {
    this._checkedState = value;
    if (!isPresent(this.input)) {
      return;
    }
    this.input.nativeElement.indeterminate = value === "indeterminate";
  }
  get checkedState() {
    return this._checkedState;
  }
  /**
   * The rounded property specifies the border radius of the CheckBox
   * ([see example](slug:appearance_checkboxdirective#toc-roundness)).
   *
   * @default 'medium'
   *
   * The possible values are:
   * * `small`
   * * `medium`
   * * `large`
   * * `none`
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED$6;
    this.handleClasses(newRounded, "rounded");
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Fires each time the inner input's checked state is changed.
   * When the state of the component is programmatically changed to `ngModel` or `formControl`
   * through its API or form binding, the `checkedStateChange` event is not triggered because it
   * might cause a mix-up with the built-in mechanisms of the `ngModel` or `formControl` bindings.
   *
   * Used to provide a two-way binding for the `checkedState` property.
   */
  checkedStateChange = new EventEmitter();
  /**
   * @hidden
   */
  get isChecked() {
    return typeof this.checkedState === "boolean" && this.checkedState;
  }
  /**
   * @hidden
   */
  get isIndeterminate() {
    return typeof this.checkedState === "string" && this.checkedState === "indeterminate";
  }
  get defaultAttributes() {
    return {
      type: "checkbox",
      id: this.focusableId,
      title: this.title,
      tabindex: this.tabindex,
      tabIndex: this.tabindex,
      disabled: this.disabled ? "" : null,
      value: this.value,
      checked: this.isChecked,
      "aria-invalid": this.isControlInvalid
    };
  }
  _rounded = DEFAULT_ROUNDED$6;
  _checkedState = false;
  constructor(renderer, hostElement, cdr, ngZone, injector) {
    super("checkbox", hostElement, renderer, cdr, ngZone, injector);
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.cdr = cdr;
    this.ngZone = ngZone;
    this.injector = injector;
    validatePackage(packageMetadata5);
  }
  ngAfterViewInit() {
    const stylingInputs = ["size", "rounded"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
    this.input.nativeElement.indeterminate = this.checkedState === "indeterminate";
  }
  /**
   * @hidden
   */
  handleChange = ($event) => {
    this.ngZone.run(() => {
      this.checkedState = $event && $event.target && $event.target.checked;
      this.checkedStateChange.emit(this.checkedState);
      this.ngChange(this.checkedState);
    });
  };
  /**
   * @hidden
   */
  writeValue(value) {
    this.checkedState = value;
  }
  static ɵfac = function CheckBoxComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CheckBoxComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Injector));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CheckBoxComponent,
    selectors: [["kendo-checkbox"]],
    hostVars: 2,
    hostBindings: function CheckBoxComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-checkbox-wrap", ctx.hostClass);
      }
    },
    inputs: {
      checkedState: "checkedState",
      rounded: "rounded"
    },
    outputs: {
      checkedStateChange: "checkedStateChange"
    },
    exportAs: ["kendoCheckBox"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.checkbox"
    }, {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _CheckBoxComponent),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _CheckBoxComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 3,
    vars: 22,
    consts: [["input", ""], ["kendoInputSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused"], ["type", "checkbox", 1, "k-checkbox", 3, "id", "disabled", "value", "checked", "kendoEventsOutsideAngular"]],
    template: function CheckBoxComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainerStart(0, 1);
        ɵɵtwoWayListener("isFocusedChange", function CheckBoxComponent_Template_ng_container_isFocusedChange_0_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.isFocused, $event) || (ctx.isFocused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function CheckBoxComponent_Template_ng_container_handleBlur_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function CheckBoxComponent_Template_ng_container_onFocus_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵelement(1, "input", 2, 0);
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.isFocused);
        ɵɵadvance();
        ɵɵclassProp("k-disabled", ctx.disabled)("k-checked", ctx.isChecked)("k-indeterminate", ctx.isIndeterminate)("k-invalid", ctx.isControlInvalid);
        ɵɵproperty("id", ctx.focusableId)("disabled", ctx.disabled)("value", ctx.value)("checked", ctx.isChecked)("kendoEventsOutsideAngular", ɵɵpureFunction2(19, _c19, ctx.handleInputBlur, ctx.handleChange));
        ɵɵattribute("title", ctx.title)("tabindex", ctx.disabled ? void 0 : ctx.tabindex)("aria-invalid", ctx.isControlInvalid)("required", ctx.isControlRequired ? "" : null);
      }
    },
    dependencies: [SharedInputEventsDirective, EventsOutsideAngularDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckBoxComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoCheckBox",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.checkbox"
      }, {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => CheckBoxComponent),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => CheckBoxComponent)
      }],
      selector: "kendo-checkbox",
      template: `
        <ng-container
            kendoInputSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="isFocused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
        >
            <input #input
                type="checkbox"
                class="k-checkbox"
                [id]="focusableId"
                [attr.title]="title"
                [disabled]="disabled"
                [class.k-disabled]="disabled"
                [attr.tabindex]="disabled ? undefined : tabindex"
                [value]="value"
                [checked]="isChecked"
                [class.k-checked]="isChecked"
                [class.k-indeterminate]="isIndeterminate"
                [class.k-invalid]="isControlInvalid"
                [attr.aria-invalid]="isControlInvalid"
                [attr.required]="isControlRequired ? '' : null"
                [kendoEventsOutsideAngular]="{
                    blur: handleInputBlur,
                    change: handleChange
                }"
            />
        </ng-container>
    `,
      standalone: true,
      imports: [SharedInputEventsDirective, EventsOutsideAngularDirective]
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: NgZone
    }, {
      type: Injector
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-checkbox-wrap"]
    }],
    checkedState: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    checkedStateChange: [{
      type: Output
    }]
  });
})();
var DEFAULT_SIZE$a = "medium";
var DEFAULT_ROUNDED$5 = "medium";
var CheckBoxDirective = class _CheckBoxDirective {
  renderer;
  hostElement;
  kendoClass = true;
  /**
   * The size property specifies the width and height of the CheckBox
   * ([see example]({% slug appearance_checkboxdirective %}#toc-size)).
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$a;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * The rounded property specifies the border radius of the CheckBox
   * ([see example](slug:appearance_checkboxdirective#toc-roundness)).
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED$5;
    this.handleClasses(newRounded, "rounded");
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  _size = "medium";
  _rounded = "medium";
  constructor(renderer, hostElement) {
    this.renderer = renderer;
    this.hostElement = hostElement;
  }
  ngAfterViewInit() {
    const stylingInputs = ["size", "rounded"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
  }
  handleClasses(value, input) {
    const elem = this.hostElement.nativeElement;
    const classes = getStylingClasses2("checkbox", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  static ɵfac = function CheckBoxDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CheckBoxDirective)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CheckBoxDirective,
    selectors: [["input", "kendoCheckBox", ""]],
    hostVars: 2,
    hostBindings: function CheckBoxDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-checkbox", ctx.kendoClass);
      }
    },
    inputs: {
      size: "size",
      rounded: "rounded"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckBoxDirective, [{
    type: Directive,
    args: [{
      selector: "input[kendoCheckBox]",
      standalone: true
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, {
    kendoClass: [{
      type: HostBinding,
      args: ["class.k-checkbox"]
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }]
  });
})();
var parseColor4 = (value, format3, opacityEnabled = false, safe2 = true) => {
  const allowedFormats = ["hex", "rgba", "name"];
  if (allowedFormats.indexOf(format3) === -1) {
    throw new Error(`Unsupported color output format '${format3}'. The available options are 'hex', 'rgba' or 'name'.`);
  }
  if (!isPresent5(value)) {
    return;
  }
  if (format3 === "name") {
    return nameFormat(value, safe2);
  }
  const parsedColor = parseColor(value.trim(), safe2);
  if (!isPresent5(parsedColor)) {
    return;
  }
  const parsedColorResult = format3 === "hex" ? getHexValue(parsedColor, opacityEnabled) : parsedColor.toCssRgba();
  return parsedColorResult;
};
var getHSV = (value, safe2 = true) => {
  const parsed = parseColor(value, safe2);
  if (!isPresent5(parsed)) {
    return {};
  }
  return parsed.toHSV();
};
var getRGBA = (value, safe2 = true) => {
  const parsed = parseColor(value, safe2);
  if (!isPresent5(parsed)) {
    return {};
  }
  return parsed.toBytes();
};
var getColorFromHSV = (hsva, format3 = "rgba", opacityEnabled = false) => {
  const hue = fitIntoBounds(hsva.h, 0, 359.9);
  const saturation = fitIntoBounds(hsva.s, 0, 1);
  const value = fitIntoBounds(hsva.v, 0, 1);
  const alpha = fitIntoBounds(hsva.a, 0, 1);
  const color = color_default.fromHSV(hue, saturation, value, alpha);
  return format3 === "hex" ? getHexValue(color, opacityEnabled) : color.toCssRgba();
};
var getHexValue = (color, opacity) => {
  return opacity && color.a < 1 ? color.toCss({
    alpha: true
  }) : color.toCss();
};
var getColorFromHue = (hue) => {
  return getColorFromHSV({
    h: hue,
    s: 1,
    v: 1,
    a: 1
  });
};
var getColorFromRGBA = (rgba) => {
  const red = fitIntoBounds(rgba.r, 0, 255);
  const green = fitIntoBounds(rgba.g, 0, 255);
  const blue = fitIntoBounds(rgba.b, 0, 255);
  const alpha = fitIntoBounds(rgba.a, 0, 1);
  return color_default.fromBytes(red, green, blue, alpha).toCssRgba();
};
function nameFormat(value, safe2) {
  value = value.toLowerCase().trim();
  if (isPresent5(named_colors_default[value])) {
    return value;
  }
  if (parseColor(value, safe2)) {
    value = parseColor(value, safe2).toHex();
  }
  const key = Object.keys(named_colors_default).find((key2) => named_colors_default[key2] === value);
  if (!key && !safe2) {
    throw new Error(`The provided color ${value} is not supported for 'format="name"' property.To display ${value} color, the component 'format' property should be set to 'hex' or 'rgba' `);
  }
  return key;
}
var getRGBFromRGBA = (foregroundColor, backgroundColor) => {
  const r1 = fitIntoBounds(foregroundColor.r, 0, 255);
  const g1 = fitIntoBounds(foregroundColor.g, 0, 255);
  const b1 = fitIntoBounds(foregroundColor.b, 0, 255);
  const a1 = fitIntoBounds(foregroundColor.a, 0, 1);
  const r2 = fitIntoBounds(backgroundColor.r, 0, 255);
  const g2 = fitIntoBounds(backgroundColor.g, 0, 255);
  const b2 = fitIntoBounds(backgroundColor.b, 0, 255);
  return {
    r: Math.round((1 - a1) * r2 + a1 * r1),
    g: Math.round((1 - a1) * g2 + a1 * g1),
    b: Math.round((1 - a1) * b2 + a1 * b1)
  };
};
var getLuminance = (rgb) => {
  const a = [rgb.r, rgb.g, rgb.b].map(function(v) {
    v /= 255;
    return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
  });
  return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;
};
var getContrast = (luminance1, luminance2) => {
  const brightest = Math.max(luminance1, luminance2);
  const darkest = Math.min(luminance1, luminance2);
  return (brightest + 0.05) / (darkest + 0.05);
};
var getContrastFromTwoRGBAs = (a, b) => {
  return getContrast(getLuminance(getRGBFromRGBA(a, b)), getLuminance(getRGBFromRGBA(b, {
    r: 0,
    g: 0,
    b: 0,
    a: 1
  })));
};
var bezierCommand = (controlPointCalc) => (point2, i, a) => {
  const [cpsX, cpsY] = controlPointCalc(a[i - 1], a[i - 2], point2);
  const [cpeX, cpeY] = controlPointCalc(point2, a[i - 1], a[i + 1], true);
  return `C ${cpsX},${cpsY} ${cpeX},${cpeY} ${point2[0]},${point2[1]}`;
};
var controlPoint = (lineCalc) => (current, previous, next, reverse) => {
  const p = previous || current;
  const n = next || current;
  const smooth = 0.1;
  const l = lineCalc(p, n);
  const angle = l.angle + (reverse ? Math.PI : 0);
  const length = l.length * smooth;
  const x = current[0] + Math.cos(angle) * length;
  const y = current[1] + Math.sin(angle) * length;
  return [x, y];
};
var line = (pointA, pointB) => {
  const lengthX = pointB[0] - pointA[0];
  const lengthY = pointB[1] - pointA[1];
  return {
    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),
    angle: Math.atan2(lengthY, lengthX)
  };
};
var svgPath = (points3, command) => {
  if (points3.length === 0) {
    return "";
  }
  const d = points3.reduce((acc, point2, i, a) => i === 0 ? (
    // if first point
    `M ${point2[0]},${point2[1]}`
  ) : (
    // else
    `${acc} ${command(point2, i, a)}`
  ), "");
  return d;
};
var ColorPickerLocalizationService = class _ColorPickerLocalizationService extends LocalizationService {
  constructor(prefix, messageService, _rtl) {
    super(prefix, messageService, _rtl);
  }
  static ɵfac = function ColorPickerLocalizationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorPickerLocalizationService)(ɵɵinject(L10N_PREFIX), ɵɵinject(MessageService, 8), ɵɵinject(RTL, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ColorPickerLocalizationService,
    factory: _ColorPickerLocalizationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorPickerLocalizationService, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [L10N_PREFIX]
      }]
    }, {
      type: MessageService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [RTL]
      }]
    }];
  }, null);
})();
var FlatColorPickerLocalizationService = class _FlatColorPickerLocalizationService extends LocalizationService {
  colorPickerLocalization;
  constructor(prefix, messageService, _rtl, colorPickerLocalization) {
    super(prefix, messageService, _rtl);
    this.colorPickerLocalization = colorPickerLocalization;
  }
  get(shortKey) {
    if (this.colorPickerLocalization) {
      return this.colorPickerLocalization.get(shortKey);
    }
    return super.get(shortKey);
  }
  static ɵfac = function FlatColorPickerLocalizationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FlatColorPickerLocalizationService)(ɵɵinject(L10N_PREFIX), ɵɵinject(MessageService, 8), ɵɵinject(RTL, 8), ɵɵinject(ColorPickerLocalizationService, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FlatColorPickerLocalizationService,
    factory: _FlatColorPickerLocalizationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FlatColorPickerLocalizationService, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [L10N_PREFIX]
      }]
    }, {
      type: MessageService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [RTL]
      }]
    }, {
      type: ColorPickerLocalizationService,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [ColorPickerLocalizationService]
      }]
    }];
  }, null);
})();
var ColorGradientLocalizationService = class _ColorGradientLocalizationService extends LocalizationService {
  flatColorPickerLocalization;
  constructor(prefix, messageService, _rtl, flatColorPickerLocalization) {
    super(prefix, messageService, _rtl);
    this.flatColorPickerLocalization = flatColorPickerLocalization;
  }
  get(shortKey) {
    if (this.flatColorPickerLocalization) {
      return this.flatColorPickerLocalization.get(shortKey);
    }
    return super.get(shortKey);
  }
  static ɵfac = function ColorGradientLocalizationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorGradientLocalizationService)(ɵɵinject(L10N_PREFIX), ɵɵinject(MessageService, 8), ɵɵinject(RTL, 8), ɵɵinject(FlatColorPickerLocalizationService, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ColorGradientLocalizationService,
    factory: _ColorGradientLocalizationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorGradientLocalizationService, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [L10N_PREFIX]
      }]
    }, {
      type: MessageService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [RTL]
      }]
    }, {
      type: FlatColorPickerLocalizationService,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [FlatColorPickerLocalizationService]
      }]
    }];
  }, null);
})();
var NumericLabelDirective = class _NumericLabelDirective {
  host;
  kendoAdditionalNumericLabel;
  localizationService;
  constructor(host) {
    this.host = host;
  }
  ngOnInit() {
    const localizationToken = `${this.kendoAdditionalNumericLabel}ChannelLabel`;
    this.host.numericInput.nativeElement.setAttribute("aria-label", this.localizationService.get(localizationToken));
  }
  static ɵfac = function NumericLabelDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NumericLabelDirective)(ɵɵdirectiveInject(NumericTextBoxComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NumericLabelDirective,
    selectors: [["", "kendoAdditionalNumericLabel", ""]],
    inputs: {
      kendoAdditionalNumericLabel: "kendoAdditionalNumericLabel",
      localizationService: "localizationService"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericLabelDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoAdditionalNumericLabel]",
      standalone: true
    }]
  }], function() {
    return [{
      type: NumericTextBoxComponent
    }];
  }, {
    kendoAdditionalNumericLabel: [{
      type: Input
    }],
    localizationService: [{
      type: Input
    }]
  });
})();
var isJapanese = (input) => {
  const japaneseRegex = /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g;
  return japaneseRegex.test(input);
};
var TextBoxSuffixTemplateDirective = class _TextBoxSuffixTemplateDirective {
  templateRef;
  /**
   * Sets the `showSeparator` attribute of the `kendoTextBoxSuffixTemplate`.
   *
   * @default false
   */
  set showSeparator(value) {
    this._showSeparator = value;
  }
  get showSeparator() {
    return this._showSeparator;
  }
  _showSeparator = false;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function TextBoxSuffixTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextBoxSuffixTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TextBoxSuffixTemplateDirective,
    selectors: [["", "kendoTextBoxSuffixTemplate", ""]],
    inputs: {
      showSeparator: "showSeparator"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextBoxSuffixTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTextBoxSuffixTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    showSeparator: [{
      type: Input
    }]
  });
})();
var TextBoxPrefixTemplateDirective = class _TextBoxPrefixTemplateDirective {
  templateRef;
  /**
   * Sets the `showSeparator` attribute of the `kendoTextBoxPrefixTemplate`.
   *
   * @default false
   */
  set showSeparator(value) {
    this._showSeparator = value;
  }
  get showSeparator() {
    return this._showSeparator;
  }
  _showSeparator = false;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function TextBoxPrefixTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextBoxPrefixTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TextBoxPrefixTemplateDirective,
    selectors: [["", "kendoTextBoxPrefixTemplate", ""]],
    inputs: {
      showSeparator: "showSeparator"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextBoxPrefixTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTextBoxPrefixTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    showSeparator: [{
      type: Input
    }]
  });
})();
var TextBoxMessages = class _TextBoxMessages extends ComponentMessages {
  /**
   * The title of the **Clear** button of the TextBox.
   */
  clear;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵTextBoxMessages_BaseFactory;
    return function TextBoxMessages_Factory(__ngFactoryType__) {
      return (ɵTextBoxMessages_BaseFactory || (ɵTextBoxMessages_BaseFactory = ɵɵgetInheritedFactory(_TextBoxMessages)))(__ngFactoryType__ || _TextBoxMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _TextBoxMessages,
    selectors: [["kendo-textbox-messages-base"]],
    inputs: {
      clear: "clear"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextBoxMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-textbox-messages-base"
    }]
  }], null, {
    clear: [{
      type: Input
    }]
  });
})();
var LocalizedTextBoxMessagesDirective = class _LocalizedTextBoxMessagesDirective extends TextBoxMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedTextBoxMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedTextBoxMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedTextBoxMessagesDirective,
    selectors: [["", "kendoTextBoxLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: TextBoxMessages,
      useExisting: forwardRef(() => _LocalizedTextBoxMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedTextBoxMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: TextBoxMessages,
        useExisting: forwardRef(() => LocalizedTextBoxMessagesDirective)
      }],
      selector: "[kendoTextBoxLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var FOCUSED$1 = "k-focus";
var DEFAULT_SIZE$9 = "medium";
var DEFAULT_ROUNDED$4 = "medium";
var DEFAULT_FILL_MODE$4 = "solid";
var iconsMap$1 = {
  checkIcon,
  exclamationCircleIcon,
  xIcon
};
var TextBoxComponent = class _TextBoxComponent {
  localizationService;
  ngZone;
  changeDetector;
  renderer;
  injector;
  hostElement;
  /**
   * @hidden
   */
  focusableId = `k-${guid()}`;
  /**
   * Sets the `title` attribute of the `input` element of the TextBox.
   */
  title;
  /**
   * Sets the `type` attribute of the `input` element of the TextBox.
   */
  type = "text";
  /**
   * Sets the disabled state of the TextBox. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_textbox#toc-managing-the-textbox-disabled-state-in-reactive-forms).
   *
   * @default false
   */
  disabled = false;
  /**
   * Sets the read-only state of the component.
   *
   * @default false
   */
  readonly = false;
  /**
   * Specifies the `tabindex` of the TextBox.
   *
   * @default 0
   */
  tabindex = 0;
  /**
   * Provides a value for the TextBox.
   */
  value = null;
  /**
   * Determines whether the whole value will be selected when the TextBox is clicked. Defaults to `false`.
   *
   * @default false
   */
  selectOnFocus = false;
  /**
   * Specifies when the Success icon will be shown ([see example]({% slug validation_textbox %})).
   *
   * The possible values are:
   *
   * `boolean`&mdash;The Success icon is displayed, if the condition given by the developer is met.
   *
   * `initial`&mdash;The Success icon will be displayed when the component state is neither `invalid` nor `touched` or `dirty`.
   *
   * @default false
   */
  showSuccessIcon = false;
  /**
   * Specifies when the Error icon will be shown ([see example]({% slug validation_textbox %})).
   *
   * The possible values are:
   *
   * * `initial`&mdash;The Error icon will be displayed when the component state is
   * `invalid` and `touched` or `dirty`.
   * * `boolean`&mdash;The Error icon is displayed, if the condition given by the developer is met.
   *
   * @default false
   */
  showErrorIcon = false;
  /**
   * Specifies whether a Clear button will be rendered.
   *
   * @default false
   */
  clearButton = false;
  /**
   * Sets a custom icon that will be rendered instead of the default one for a valid user input.
   */
  successIcon;
  /**
   * Sets a custom SVG icon that will be rendered instead of the default one for a valid user input.
   */
  successSvgIcon;
  /**
   * Sets a custom icon that will be rendered instead of the default one for invalid user input.
   */
  errorIcon;
  /**
   * Sets a custom SVG icon that will be rendered instead of the default one for invalid user input.
   */
  errorSvgIcon;
  /**
   * Sets a custom icon that will be rendered instead of the default one.
   */
  clearButtonIcon;
  /**
   * Sets a custom SVG icon that will be rendered instead of the default one.
   */
  clearButtonSvgIcon;
  /**
   * The size property specifies the padding of the TextBox internal input element
   * ([see example]({% slug appearance_textbox %}#toc-size)).
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$9;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * The `rounded` property specifies the border radius of the TextBox
   * ([see example](slug:appearance_textbox#toc-roundness)).
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `full`
   * * `none`
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED$4;
    this.handleClasses(newRounded, "rounded");
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * The `fillMode` property specifies the background and border styles of the TextBox
   * ([see example]({% slug appearance_textbox %}#toc-fill-mode)).
   *
   * The possible values are:
   * * `flat`
   * * `solid` (default)
   * * `outline`
   * * `none`
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$4;
    this.handleClasses(newFillMode, "fillMode");
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * The hint, which is displayed when the component is empty.
   */
  placeholder;
  /**
   * Specifies the maximum length of the TextBox value.
   */
  maxlength;
  /**
   * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
   */
  set inputAttributes(attributes) {
    if (isObjectPresent(this.parsedAttributes)) {
      removeHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement);
    }
    this._inputAttributes = attributes;
    this.parsedAttributes = this.inputAttributes ? parseAttributes(this.inputAttributes, this.defaultAttributes) : this.inputAttributes;
    this.setInputAttributes();
  }
  get inputAttributes() {
    return this._inputAttributes;
  }
  /**
   * Fires each time the value is changed&mdash;
   * when the component is blurred or the value is cleared through the **Clear** button
   * ([see example](slug:events_textbox)).
   * When the value of the component is programmatically changed to `ngModel` or `formControl`
   * through its API or form binding, the `valueChange` event is not triggered because it
   * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the user focuses the `input` element.
   */
  inputFocus = new EventEmitter();
  /**
   * Fires each time the `input` element gets blurred.
   */
  inputBlur = new EventEmitter();
  /**
   * Fires each time the user focuses the TextBox component.
   *
   * > To wire the event programmatically, use the `onFocus` property.
   *
   * @example
   * ```ts-no-run
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <kendo-textbox (focus)="handleFocus()"></kendo-textbox>
   * `
   * })
   * class AppComponent {
   *   public handleFocus(): void {
   *      console.log('Component is focused.');
   *   }
   * }
   * ```
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the TextBox component gets blurred.
   *
   * > To wire the event programmatically, use the `onBlur` property.
   *
   * @example
   * ```ts-no-run
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <kendo-textbox (blur)="handleBlur()"></kendo-textbox>
   * `
   * })
   * class AppComponent {
   *   public handleBlur(): void {
   *      console.log('Component is blurred');
   *   }
   * }
   * ```
   */
  onBlur = new EventEmitter();
  /**
   * Represents the visible `input` element of the TextBox.
   */
  input;
  /**
   * @hidden
   */
  textBoxSuffixTemplate;
  /**
   * @hidden
   */
  textBoxPrefixTemplate;
  /**
   * @hidden
   */
  suffixTemplate;
  /**
   * @hidden
   */
  prefixTemplate;
  get disabledClass() {
    return this.disabled;
  }
  hostClasses = true;
  direction;
  /**
   * @hidden
   */
  showClearButton;
  /**
   * @hidden
   */
  clearButtonClicked;
  /**
   * @hidden
   */
  suffix;
  /**
   * @hidden
   */
  prefix;
  control;
  subscriptions;
  _isFocused = false;
  focusChangedProgrammatically = false;
  _inputAttributes;
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  parsedAttributes = {};
  get defaultAttributes() {
    return {
      id: this.focusableId,
      disabled: this.disabled ? "" : null,
      readonly: this.readonly ? "" : null,
      tabindex: this.disabled ? void 0 : this.tabindex,
      type: this.type,
      placeholder: this.placeholder,
      title: this.title,
      maxlength: this.maxlength,
      "aria-invalid": this.isControlInvalid,
      required: this.isControlRequired ? "" : null
    };
  }
  constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {
    this.localizationService = localizationService;
    this.ngZone = ngZone;
    this.changeDetector = changeDetector;
    this.renderer = renderer;
    this.injector = injector;
    this.hostElement = hostElement;
    validatePackage(packageMetadata5);
    this.direction = localizationService.rtl ? "rtl" : "ltr";
  }
  ngOnInit() {
    this.control = this.injector.get(NgControl, null);
    this.checkClearButton();
    this.subscriptions = this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
  }
  ngAfterViewInit() {
    const stylingInputs = ["size", "rounded", "fillMode"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
  }
  ngAfterContentInit() {
    this.configureAdornments();
    this.subscriptions.add(this.textBoxPrefixTemplate.changes.subscribe(this.configureAdornments.bind(this)));
    this.subscriptions.add(this.textBoxSuffixTemplate.changes.subscribe(this.configureAdornments.bind(this)));
  }
  ngOnChanges(changes) {
    if (changes["disabled"] || changes["readonly"] || changes["value"]) {
      this.checkClearButton();
    }
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  svgIcon(name2) {
    return iconsMap$1[name2];
  }
  /**
   * Focuses the TextBox.
   *
   * @example
   * ```ts-no-run
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="input.focus()">Focus the input</button>
   *  <kendo-textbox #input></kendo-textbox>
   * `
   * })
   * class AppComponent { }
   * ```
   */
  focus() {
    if (!this.input) {
      return;
    }
    this.focusChangedProgrammatically = true;
    this.isFocused = true;
    this.input.nativeElement.focus();
    this.focusChangedProgrammatically = false;
  }
  /**
   * Blurs the TextBox.
   */
  blur() {
    this.focusChangedProgrammatically = true;
    const isFocusedElement = this.hostElement.nativeElement.querySelector(":focus");
    if (isFocusedElement) {
      isFocusedElement.blur();
    }
    this.isFocused = false;
    this.focusChangedProgrammatically = false;
  }
  /**
   * @hidden
   */
  handleInputFocus = () => {
    if (!this.disabled) {
      if (this.selectOnFocus && this.value) {
        this.ngZone.run(() => {
          setTimeout(() => {
            this.selectAll();
          });
        });
      }
      if (!this.isFocused) {
        this.handleFocus();
      }
      if (hasObservers(this.inputFocus)) {
        if (!this.focusChangedProgrammatically || this.focusChangedProgrammatically && this.clearButtonClicked) {
          this.ngZone.run(() => {
            this.inputFocus.emit();
          });
        }
      }
    }
  };
  /**
   * @hidden
   */
  handleInputBlur = () => {
    this.changeDetector.markForCheck();
    if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {
      this.ngZone.run(() => {
        this.ngTouched();
        this.inputBlur.emit();
      });
    }
  };
  /**
   * @hidden
   */
  handleInput = (ev) => {
    const target = ev.target;
    const isBrowserSafari = isSafari(navigator.userAgent);
    const incomingValue = isBrowserSafari && isJapanese(target.value) ? ev.data : target.value;
    const [caretStart, caretEnd] = [target.selectionStart, target.selectionEnd];
    this.updateValue(incomingValue);
    if (isBrowserSafari) {
      target.setSelectionRange(caretStart, caretEnd);
    }
  };
  /**
   * @hidden
   */
  clearTitle() {
    return this.localizationService.get("clear");
  }
  /**
   * @hidden
   */
  checkClearButton() {
    this.showClearButton = !this.disabled && !this.readonly && this.clearButton && !!this.value;
  }
  /**
   * @hidden
   */
  clearValue(ev) {
    if (ev) {
      ev.preventDefault();
    }
    this.clearButtonClicked = true;
    this.input.nativeElement.value = "";
    this.input.nativeElement.focus();
    this.updateValue("");
    this.checkClearButton();
    this.clearButtonClicked = false;
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value;
    this.checkClearButton();
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.ngChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.ngTouched = fn;
  }
  /**
   * @hidden
   * Called when the status of the component changes to or from `disabled`.
   * Depending on the value, it enables or disables the appropriate DOM element.
   *
   * @param isDisabled
   */
  setDisabledState(isDisabled2) {
    this.changeDetector.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * @hidden
   */
  showErrorsInitial() {
    if (!this.control) {
      return false;
    }
    const {
      invalid,
      dirty,
      touched
    } = this.control;
    return invalid && (dirty || touched);
  }
  /**
   * @hidden
   */
  showSuccessInitial() {
    if (!this.control) {
      return false;
    }
    const {
      valid,
      dirty,
      touched
    } = this.control;
    return valid && (dirty || touched);
  }
  /**
   * @hidden
   */
  get isControlInvalid() {
    return this.control && this.control.touched && !this.control.valid;
  }
  /**
   * @hidden
   */
  get successIconClasses() {
    if (!this.successIcon) {
      return `check`;
    }
  }
  /**
   * @hidden
   */
  get customSuccessIconClasses() {
    if (this.successIcon) {
      return this.successIcon;
    }
  }
  /**
   * @hidden
   */
  get errorIconClasses() {
    if (!this.errorIcon) {
      return `exclamation-circle`;
    }
  }
  /**
   * @hidden
   */
  get customIconClasses() {
    if (this.errorIcon) {
      return this.errorIcon;
    }
  }
  /**
   * @hidden
   */
  get customClearButtonClasses() {
    if (this.clearButtonIcon) {
      return this.clearButtonIcon;
    }
  }
  /**
   * @hidden
   */
  get clearButtonClass() {
    if (!this.clearButtonIcon) {
      return "x";
    }
  }
  /**
   * @hidden
   */
  get hasErrors() {
    return this.showErrorIcon === "initial" ? this.showErrorsInitial() : this.showErrorIcon;
  }
  /**
   * @hidden
   */
  get isSuccessful() {
    return this.showSuccessIcon === "initial" ? this.showSuccessInitial() : this.showSuccessIcon;
  }
  /**
   * @hidden
   */
  get isFocused() {
    return this._isFocused;
  }
  /**
   * @hidden
   */
  set isFocused(value) {
    if (this._isFocused !== value && this.hostElement) {
      const element = this.hostElement.nativeElement;
      if (value && !this.disabled) {
        this.renderer.addClass(element, FOCUSED$1);
      } else {
        this.renderer.removeClass(element, FOCUSED$1);
      }
      this._isFocused = value;
    }
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.control?.control);
  }
  ngChange = (_2) => {
  };
  ngTouched = () => {
  };
  setSelection(start, end) {
    if (this.isFocused) {
      invokeElementMethod(this.input, "setSelectionRange", start, end);
    }
  }
  selectAll() {
    if (this.value) {
      this.setSelection(0, this.value.length);
    }
  }
  updateValue(value) {
    if (!areSame(this.value, value)) {
      this.ngZone.run(() => {
        this.value = value;
        this.ngChange(value);
        this.valueChange.emit(value);
        this.checkClearButton();
        this.changeDetector.markForCheck();
      });
    }
  }
  /**
   * @hidden
   */
  handleFocus() {
    this.ngZone.run(() => {
      if (!this.focusChangedProgrammatically && hasObservers(this.onFocus)) {
        this.onFocus.emit();
      }
      this.isFocused = true;
    });
  }
  /**
   * @hidden
   */
  handleBlur() {
    this.ngZone.run(() => {
      if (!this.focusChangedProgrammatically) {
        this.onBlur.emit();
      }
      this.isFocused = false;
    });
  }
  handleClasses(value, input) {
    const elem = this.hostElement.nativeElement;
    const classes = getStylingClasses2("input", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  configureAdornments() {
    this.prefix = this.textBoxPrefixTemplate.first || this.prefixTemplate;
    this.suffix = this.textBoxSuffixTemplate.first || this.suffixTemplate;
  }
  setInputAttributes() {
    setHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement, this.ngZone);
  }
  static ɵfac = function TextBoxComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextBoxComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TextBoxComponent,
    selectors: [["kendo-textbox"]],
    contentQueries: function TextBoxComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, SuffixTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, PrefixTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, TextBoxSuffixTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, TextBoxPrefixTemplateDirective, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.suffixTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.prefixTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.textBoxSuffixTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.textBoxPrefixTemplate = _t);
      }
    },
    viewQuery: function TextBoxComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c172, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
      }
    },
    hostVars: 9,
    hostBindings: function TextBoxComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-disabled", ctx.disabledClass)("k-textbox", ctx.hostClasses)("k-input", ctx.hostClasses);
      }
    },
    inputs: {
      focusableId: "focusableId",
      title: "title",
      type: "type",
      disabled: "disabled",
      readonly: "readonly",
      tabindex: "tabindex",
      value: "value",
      selectOnFocus: "selectOnFocus",
      showSuccessIcon: "showSuccessIcon",
      showErrorIcon: "showErrorIcon",
      clearButton: "clearButton",
      successIcon: "successIcon",
      successSvgIcon: "successSvgIcon",
      errorIcon: "errorIcon",
      errorSvgIcon: "errorSvgIcon",
      clearButtonIcon: "clearButtonIcon",
      clearButtonSvgIcon: "clearButtonSvgIcon",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      tabIndex: "tabIndex",
      placeholder: "placeholder",
      maxlength: "maxlength",
      inputAttributes: "inputAttributes"
    },
    outputs: {
      valueChange: "valueChange",
      inputFocus: "inputFocus",
      inputBlur: "inputBlur",
      onFocus: "focus",
      onBlur: "blur"
    },
    exportAs: ["kendoTextBox"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.textbox"
    }, {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _TextBoxComponent),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _TextBoxComponent)
    }]), ɵɵNgOnChangesFeature],
    decls: 12,
    vars: 26,
    consts: () => {
      let i18n_9;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_9 = goog.getMsg("Clear");
        i18n_9 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_9;
      } else {
        i18n_9 = $localize`:kendo.textbox.clear|The title for the **Clear** button in the TextBox.:Clear`;
      }
      return [["input", ""], ["kendoTextBoxLocalizedMessages", "", "clear", i18n_9], ["kendoInputSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused", "clearButtonClicked"], ["class", "k-input-prefix k-input-prefix-horizontal", 4, "ngIf"], [4, "ngIf"], [1, "k-input-inner", 3, "id", "disabled", "readonly", "value", "kendoEventsOutsideAngular"], ["role", "button", "class", "k-clear-value", 3, "tabindex", "title", "click", "mousedown", "keydown.enter", "keydown.space", 4, "ngIf"], ["innerCssClass", "k-input-validation-icon", 3, "name", "customFontClass", "svgIcon", 4, "ngIf"], ["class", "k-input-suffix k-input-suffix-horizontal", 4, "ngIf"], [1, "k-input-prefix", "k-input-prefix-horizontal"], [3, "ngTemplateOutlet"], ["role", "button", 1, "k-clear-value", 3, "click", "mousedown", "keydown.enter", "keydown.space", "tabindex", "title"], [3, "name", "customFontClass", "svgIcon"], ["innerCssClass", "k-input-validation-icon", 3, "name", "customFontClass", "svgIcon"], [1, "k-input-suffix", "k-input-suffix-horizontal"]];
    },
    template: function TextBoxComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 1);
        ɵɵelementContainerStart(1, 2);
        ɵɵtwoWayListener("isFocusedChange", function TextBoxComponent_Template_ng_container_isFocusedChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.isFocused, $event) || (ctx.isFocused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function TextBoxComponent_Template_ng_container_handleBlur_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function TextBoxComponent_Template_ng_container_onFocus_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵtemplate(2, TextBoxComponent_span_2_Template, 2, 1, "span", 3)(3, TextBoxComponent_kendo_input_separator_3_Template, 1, 0, "kendo-input-separator", 4);
        ɵɵelement(4, "input", 5, 0);
        ɵɵtemplate(6, TextBoxComponent_span_6_Template, 2, 6, "span", 6)(7, TextBoxComponent_kendo_icon_wrapper_7_Template, 1, 3, "kendo-icon-wrapper", 7)(8, TextBoxComponent_kendo_icon_wrapper_8_Template, 1, 3, "kendo-icon-wrapper", 7)(9, TextBoxComponent_kendo_input_separator_9_Template, 1, 0, "kendo-input-separator", 4)(10, TextBoxComponent_span_10_Template, 2, 1, "span", 8);
        ɵɵelementContainer(11);
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.isFocused);
        ɵɵproperty("clearButtonClicked", ctx.clearButtonClicked);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefix);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefix && ctx.prefix.showSeparator);
        ɵɵadvance();
        ɵɵproperty("id", ctx.focusableId)("disabled", ctx.disabled)("readonly", ctx.readonly)("value", ctx.value)("kendoEventsOutsideAngular", ɵɵpureFunction3(22, _c20, ctx.handleInputFocus, ctx.handleInputBlur, ctx.handleInput));
        ɵɵattribute("tabindex", ctx.disabled ? void 0 : ctx.tabindex)("type", ctx.type)("placeholder", ctx.placeholder)("title", ctx.title)("maxlength", ctx.maxlength)("aria-invalid", ctx.isControlInvalid)("required", ctx.isControlRequired ? "" : null);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.showClearButton);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hasErrors);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isSuccessful);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffix && ctx.suffix.showSeparator);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffix);
      }
    },
    dependencies: [LocalizedTextBoxMessagesDirective, SharedInputEventsDirective, NgIf, NgTemplateOutlet, InputSeparatorComponent, EventsOutsideAngularDirective, IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextBoxComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoTextBox",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.textbox"
      }, {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => TextBoxComponent),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => TextBoxComponent)
      }],
      selector: "kendo-textbox",
      template: `
        <ng-container kendoTextBoxLocalizedMessages
            i18n-clear="kendo.textbox.clear|The title for the **Clear** button in the TextBox."
            clear="Clear">
        </ng-container>
        <ng-container
            kendoInputSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="isFocused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
            [clearButtonClicked]="clearButtonClicked"
        >
            <span *ngIf="prefix" class="k-input-prefix k-input-prefix-horizontal">
                <ng-template [ngTemplateOutlet]="prefix?.templateRef">
                </ng-template>
            </span>
            <kendo-input-separator *ngIf="prefix && prefix.showSeparator"></kendo-input-separator>
            <input #input
                class="k-input-inner"
                [id]="focusableId"
                [disabled]="disabled"
                [readonly]="readonly"
                [attr.tabindex]="disabled ? undefined : tabindex"
                [value]="value"
                [attr.type]="type"
                [attr.placeholder]="placeholder"
                [attr.title]="title"
                [attr.maxlength]="maxlength"
                [attr.aria-invalid]="isControlInvalid"
                [attr.required]="isControlRequired ? '' : null"
                [kendoEventsOutsideAngular]="{
                    focus: handleInputFocus,
                    blur: handleInputBlur,
                    input: handleInput}"
            />
            <span
                role="button"
                class="k-clear-value"
                *ngIf="showClearButton"
                (click)="clearValue()"
                (mousedown)="$event.preventDefault()"
                [tabindex]="tabIndex"
                [attr.aria-label]="clearTitle()"
                [title]="clearTitle()"
                (keydown.enter)="clearValue($event)"
                (keydown.space)="clearValue($event)">
                    <kendo-icon-wrapper
                        [name]="clearButtonClass"
                        [customFontClass]="customClearButtonClasses"
                        [svgIcon]="clearButtonSvgIcon || svgIcon('xIcon')"
                    >
                    </kendo-icon-wrapper>
            </span>
            <kendo-icon-wrapper
                *ngIf="hasErrors"
                innerCssClass="k-input-validation-icon"
                [name]="errorIconClasses"
                [customFontClass]="customIconClasses"
                [svgIcon]="errorSvgIcon || svgIcon('exclamationCircleIcon')"
            >
            </kendo-icon-wrapper>
            <kendo-icon-wrapper
                *ngIf="isSuccessful"
                innerCssClass="k-input-validation-icon"
                [name]="successIconClasses"
                [customFontClass]="customSuccessIconClasses"
                [svgIcon]="successSvgIcon || svgIcon('checkIcon')"
            >
            </kendo-icon-wrapper>
            <kendo-input-separator *ngIf="suffix && suffix.showSeparator"></kendo-input-separator>
            <span *ngIf="suffix" class="k-input-suffix k-input-suffix-horizontal">
                <ng-template [ngTemplateOutlet]="suffix?.templateRef">
                </ng-template>
            </span>
        <ng-container>
    `,
      standalone: true,
      imports: [LocalizedTextBoxMessagesDirective, SharedInputEventsDirective, NgIf, NgTemplateOutlet, InputSeparatorComponent, EventsOutsideAngularDirective, IconWrapperComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }, {
      type: Injector
    }, {
      type: ElementRef
    }];
  }, {
    focusableId: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    tabindex: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    selectOnFocus: [{
      type: Input
    }],
    showSuccessIcon: [{
      type: Input
    }],
    showErrorIcon: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    successIcon: [{
      type: Input
    }],
    successSvgIcon: [{
      type: Input
    }],
    errorIcon: [{
      type: Input
    }],
    errorSvgIcon: [{
      type: Input
    }],
    clearButtonIcon: [{
      type: Input
    }],
    clearButtonSvgIcon: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    maxlength: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    inputFocus: [{
      type: Output
    }],
    inputBlur: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    input: [{
      type: ViewChild,
      args: ["input", {
        static: true
      }]
    }],
    textBoxSuffixTemplate: [{
      type: ContentChildren,
      args: [TextBoxSuffixTemplateDirective, {
        descendants: false
      }]
    }],
    textBoxPrefixTemplate: [{
      type: ContentChildren,
      args: [TextBoxPrefixTemplateDirective, {
        descendants: false
      }]
    }],
    suffixTemplate: [{
      type: ContentChild,
      args: [SuffixTemplateDirective]
    }],
    prefixTemplate: [{
      type: ContentChild,
      args: [PrefixTemplateDirective]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-textbox"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }]
  });
})();
var TextLabelDirective = class _TextLabelDirective {
  textBox;
  renderer;
  focusableId;
  constructor(textBox, renderer) {
    this.textBox = textBox;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.renderer.setAttribute(this.textBox.input.nativeElement, "id", this.focusableId);
  }
  static ɵfac = function TextLabelDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextLabelDirective)(ɵɵdirectiveInject(TextBoxComponent), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TextLabelDirective,
    selectors: [["", "kendoTextLabel", ""]],
    inputs: {
      focusableId: "focusableId"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextLabelDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTextLabel]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TextBoxComponent
    }, {
      type: Renderer2
    }];
  }, {
    focusableId: [{
      type: Input
    }]
  });
})();
var DEFAULT_SIZE$8 = "medium";
var ColorInputComponent = class _ColorInputComponent {
  host;
  renderer;
  cdr;
  localizationService;
  /**
   * The id of the hex input.
   */
  focusableId = `k-${guid()}`;
  /**
   * The color format view.
   */
  formatView;
  /**
   * The size property specifies the padding of the ColorInput.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  size = DEFAULT_SIZE$8;
  /**
   * The inputs tabindex.
   */
  tabindex = -1;
  /**
   * The color value that will be parsed and populate the hex & rgba inputs.
   * Required input property.
   */
  value;
  /**
   * Sets whether the alpha slider will be shown.
   */
  opacity = true;
  /**
   * Sets the disabled state of the ColorInput.
   */
  disabled = false;
  /**
   * Sets the read-only state of the ColorInput.
   *
   * @default false
   */
  readonly = false;
  /**
   * Emits a parsed rgba string color.
   */
  valueChange = new EventEmitter();
  /**
   * Emits when the user tabs out of the last focusable input.
   */
  tabOut = new EventEmitter();
  colorInputClass = true;
  opacityInput;
  hexInput;
  blueInput;
  toggleFormatButton;
  /**
   * The rgba inputs values.
   */
  rgba = {};
  /*
   * The hex input value.
   */
  hex;
  /**
   * Indicates whether any of the inputs are focused.
   */
  get isFocused() {
    if (!(isDocumentAvailable() && isPresent5(this.host))) {
      return false;
    }
    const activeElement = document.activeElement;
    return this.host.nativeElement.contains(activeElement);
  }
  /**
   * Indicates whether any of the rgba inputs have value.
   */
  get rgbaInputValid() {
    return Object.keys(this.rgba).every((key) => isPresent5(this.rgba[key]));
  }
  /**
   * @hidden
   */
  caretAltExpandIcon = caretAltExpandIcon;
  subscriptions = new Subscription();
  constructor(host, renderer, cdr, localizationService) {
    this.host = host;
    this.renderer = renderer;
    this.cdr = cdr;
    this.localizationService = localizationService;
  }
  ngAfterViewInit() {
    this.initDomEvents();
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  ngOnChanges(changes) {
    if (isPresent5(changes["value"]) && !this.isFocused) {
      this.hex = parseColor4(this.value, "hex", this.opacity);
      this.rgba = getRGBA(this.value);
      this.rgba.a = parseColor4(this.value, "rgba", this.opacity) ? this.rgba.a : 1;
    }
  }
  get formatButtonTitle() {
    return this.localizationService.get("formatButton");
  }
  handleRgbaValueChange() {
    const color = getColorFromRGBA(this.rgba);
    if (!this.rgbaInputValid || color === this.value) {
      return;
    }
    this.value = color;
    this.rgba = getRGBA(this.value);
    this.hex = parseColor4(color, "hex", this.opacity);
    this.valueChange.emit(color);
  }
  focusDragHandle(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    this.tabOut.emit();
  }
  handleHexValueChange(hex2) {
    this.hex = hex2;
    const color = parseColor4(hex2, "rgba", this.opacity);
    if (!isPresent5(color) || color === this.value) {
      return;
    }
    this.value = color;
    this.rgba = getRGBA(color);
    this.valueChange.emit(color);
  }
  handleRgbaInputBlur() {
    if (!this.rgbaInputValid) {
      this.rgba = getRGBA(this.value);
    }
  }
  handleHexInputBlur() {
    this.hex = parseColor4(this.value, "hex", this.opacity);
  }
  focusLast() {
    this.lastInput().focus();
  }
  onTab() {
    if (this.opacity) {
      return;
    }
  }
  toggleFormatView() {
    this.formatView = this.formatView === "hex" ? "rgba" : "hex";
    this.cdr.markForCheck();
  }
  initDomEvents() {
    if (!this.host) {
      return;
    }
    this.subscriptions.add(this.renderer.listen(this.toggleFormatButton.nativeElement, "click", () => this.toggleFormatView()));
  }
  lastInput() {
    return this.hexInput?.nativeElement || this.opacityInput || this.blueInput;
  }
  static ɵfac = function ColorInputComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorInputComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColorInputComponent,
    selectors: [["kendo-colorinput"]],
    viewQuery: function ColorInputComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c21, 5);
        ɵɵviewQuery(_c222, 5);
        ɵɵviewQuery(_c232, 5);
        ɵɵviewQuery(_c24, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.opacityInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.hexInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.blueInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toggleFormatButton = _t.first);
      }
    },
    hostVars: 4,
    hostBindings: function ColorInputComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-colorgradient-inputs", ctx.colorInputClass)("k-hstack", ctx.colorInputClass);
      }
    },
    inputs: {
      focusableId: "focusableId",
      formatView: "formatView",
      size: "size",
      tabindex: "tabindex",
      value: "value",
      opacity: "opacity",
      disabled: "disabled",
      readonly: "readonly"
    },
    outputs: {
      valueChange: "valueChange",
      tabOut: "tabOut"
    },
    features: [ɵɵNgOnChangesFeature],
    decls: 5,
    vars: 8,
    consts: [["toggleFormatButton", ""], ["hexInput", ""], ["red", ""], ["green", ""], ["blue", ""], ["opacityInput", "", "alpha", ""], [1, "k-vstack"], ["kendoButton", "", "type", "button", "fillMode", "flat", "icon", "caret-alt-expand", 1, "k-colorgradient-toggle-mode", 3, "svgIcon", "size", "disabled", "tabindex"], ["class", "k-vstack k-flex-1", 4, "ngIf"], [4, "ngIf"], [1, "k-vstack", "k-flex-1"], ["kendoTextLabel", "", 1, "k-hex-value", 3, "blur", "input", "keydown.tab", "focusableId", "size", "disabled", "readonly", "value", "tabindex"], [1, "k-colorgradient-input-label", 3, "for"], ["kendoAdditionalNumericLabel", "red", 3, "valueChange", "blur", "localizationService", "disabled", "size", "readonly", "tabindex", "min", "max", "value", "autoCorrect", "spinners", "format", "decimals"], ["kendoAdditionalNumericLabel", "green", 3, "valueChange", "blur", "localizationService", "disabled", "readonly", "tabindex", "size", "min", "max", "value", "autoCorrect", "spinners", "format", "decimals"], ["kendoAdditionalNumericLabel", "blue", 3, "valueChange", "blur", "keydown.tab", "localizationService", "disabled", "readonly", "tabindex", "size", "min", "max", "value", "autoCorrect", "spinners", "format", "decimals"], ["class", "k-vstack", 4, "ngIf"], ["kendoAdditionalNumericLabel", "alpha", 3, "valueChange", "blur", "keydown.tab", "localizationService", "disabled", "readonly", "tabindex", "size", "min", "max", "value", "autoCorrect", "spinners", "step", "format", "decimals"]],
    template: function ColorInputComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 6);
        ɵɵelement(1, "button", 7, 0);
        ɵɵelementEnd();
        ɵɵtemplate(3, ColorInputComponent_div_3_Template, 5, 9, "div", 8)(4, ColorInputComponent_ng_container_4_Template, 17, 40, "ng-container", 9);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("svgIcon", ctx.caretAltExpandIcon)("size", ctx.size)("disabled", ctx.disabled)("tabindex", ctx.tabindex.toString());
        ɵɵattribute("aria-label", ctx.formatButtonTitle)("title", ctx.formatButtonTitle);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.formatView === "hex");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.formatView === "rgba");
      }
    },
    dependencies: [ButtonComponent, NgIf, NumericTextBoxComponent, NumericLabelDirective, TextBoxComponent, TextLabelDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorInputComponent, [{
    type: Component,
    args: [{
      selector: "kendo-colorinput",
      template: `
        <div class="k-vstack">
            <button 
                kendoButton
                type="button"
                fillMode="flat"
                #toggleFormatButton
                icon="caret-alt-expand"
                [svgIcon]="caretAltExpandIcon"
                [size]="size"
                class="k-colorgradient-toggle-mode"
                [attr.aria-label]="formatButtonTitle"
                [attr.title]="formatButtonTitle"
                [disabled]="disabled"
                [tabindex]="tabindex.toString()"
            >
            </button>
        </div>
        <div *ngIf="formatView === 'hex'" class="k-vstack k-flex-1">
            <kendo-textbox
                #hexInput
                kendoTextLabel
                [focusableId]="focusableId"
                class="k-hex-value"
                [size]="size"
                [class.k-readonly]="readonly"
                [disabled]="disabled"
                [readonly]="readonly"
                [value]="hex || ''"
                (blur)="handleHexInputBlur()"
                (input)="handleHexValueChange(hexInput.value)"
                [tabindex]="tabindex"
                (keydown.tab)="focusDragHandle($event)">
            </kendo-textbox>
            <label [for]="focusableId" class="k-colorgradient-input-label">HEX</label>
        </div>
        <ng-container *ngIf="formatView === 'rgba'">
            <div class="k-vstack">
                <kendo-numerictextbox
                    #red
                    kendoAdditionalNumericLabel="red"
                    [localizationService]="localizationService"
                    [disabled]="disabled"
                    [size]="size"
                    [readonly]="readonly"
                    [tabindex]="tabindex"
                    [min]="0"
                    [max]="255"
                    [(value)]="rgba.r"
                    [autoCorrect]="true"
                    [spinners]="false"
                    [format]="'n'"
                    [decimals]="0"
                    (blur)="handleRgbaInputBlur()"
                    (valueChange)="handleRgbaValueChange()">
                </kendo-numerictextbox>
                <label [for]="red.focusableId" class="k-colorgradient-input-label">R</label>
            </div>
            <div class="k-vstack">
                <kendo-numerictextbox
                    #green
                    kendoAdditionalNumericLabel="green"
                    [localizationService]="localizationService"
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [tabindex]="tabindex"
                    [size]="size"
                    [min]="0"
                    [max]="255"
                    [(value)]="rgba.g"
                    [autoCorrect]="true"
                    [spinners]="false"
                    [format]="'n'"
                    [decimals]="0"
                    (blur)="handleRgbaInputBlur()"
                    (valueChange)="handleRgbaValueChange()">
                </kendo-numerictextbox>
                <label [for]="green.focusableId" class="k-colorgradient-input-label">G</label>
            </div>
            <div class="k-vstack">
                <kendo-numerictextbox
                    #blue
                    kendoAdditionalNumericLabel="blue"
                    [localizationService]="localizationService"
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [tabindex]="tabindex"
                    [size]="size"
                    [min]="0"
                    [max]="255"
                    [(value)]="rgba.b"
                    [autoCorrect]="true"
                    [spinners]="false"
                    [format]="'n'"
                    [decimals]="0"
                    (blur)="handleRgbaInputBlur()"
                    (valueChange)="handleRgbaValueChange()"
                    (keydown.tab)="onTab()">
                </kendo-numerictextbox>
                <label [for]="blue.focusableId" class="k-colorgradient-input-label">B</label>
            </div>
            <div class="k-vstack" *ngIf="opacity">
                <kendo-numerictextbox #opacityInput
                    #alpha
                    kendoAdditionalNumericLabel="alpha"
                    [localizationService]="localizationService"
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [tabindex]="tabindex"
                    [size]="size"
                    [min]="0"
                    [max]="1"
                    [(value)]="rgba.a"
                    [autoCorrect]="true"
                    [spinners]="false"
                    [step]="0.01"
                    [format]="'n2'"
                    [decimals]="2"
                    (blur)="handleRgbaInputBlur()"
                    (valueChange)="handleRgbaValueChange()"
                    (keydown.tab)="focusDragHandle($event)">
                </kendo-numerictextbox>
                <label [for]="alpha.focusableId" class="k-colorgradient-input-label">A</label>
            </div>
        </ng-container>
    `,
      standalone: true,
      imports: [ButtonComponent, NgIf, NumericTextBoxComponent, NumericLabelDirective, TextBoxComponent, TextLabelDirective]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }, {
      type: LocalizationService
    }];
  }, {
    focusableId: [{
      type: Input
    }],
    formatView: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    opacity: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    tabOut: [{
      type: Output
    }],
    colorInputClass: [{
      type: HostBinding,
      args: ["class.k-colorgradient-inputs"]
    }, {
      type: HostBinding,
      args: ["class.k-hstack"]
    }],
    opacityInput: [{
      type: ViewChild,
      args: ["opacityInput"]
    }],
    hexInput: [{
      type: ViewChild,
      args: ["hexInput"]
    }],
    blueInput: [{
      type: ViewChild,
      args: ["blue"]
    }],
    toggleFormatButton: [{
      type: ViewChild,
      args: ["toggleFormatButton", {
        static: false,
        read: ElementRef
      }]
    }]
  });
})();
var DEFAULT_OUTPUT_FORMAT = "rgba";
var DEFAULT_GRADIENT_BACKGROUND_COLOR = "rgba(255, 0, 0, 1)";
var DRAGHANDLE_MOVE_SPEED = 5;
var DRAGHANDLE_MOVE_SPEED_SMALL_STEP = 2;
var AAA_RATIO = 7;
var AA_RATIO = 4.5;
var DEFAULT_PRESET$1 = "office";
var DEFAULT_ACCESSIBLE_PRESET$1 = "accessible";
var STEP_COUNT = 16;
var ContrastValidationComponent = class _ContrastValidationComponent {
  localization;
  type;
  pass;
  value;
  checkIcon = checkIcon;
  xCircleIcon = xCircleIcon;
  constructor(localization) {
    this.localization = localization;
  }
  get passMessage() {
    return this.localization.get("passContrast");
  }
  get failMessage() {
    return this.localization.get("failContrast");
  }
  get contrastText() {
    const ratio = this.type === "AA" ? AA_RATIO : AAA_RATIO;
    return `${this.type}: ${ratio.toFixed(1)}`;
  }
  static ɵfac = function ContrastValidationComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ContrastValidationComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ContrastValidationComponent,
    selectors: [["", "kendoContrastValidation", ""]],
    inputs: {
      type: "type",
      pass: "pass",
      value: "value"
    },
    attrs: _c25,
    decls: 3,
    vars: 2,
    consts: [[4, "ngIf"], ["class", "k-contrast-validation k-text-success", 4, "ngIf"], ["class", "k-contrast-validation k-text-error", 4, "ngIf"], [1, "k-contrast-validation", "k-text-success"], ["name", "check", 3, "svgIcon"], [1, "k-contrast-validation", "k-text-error"], ["name", "x", 3, "svgIcon"]],
    template: function ContrastValidationComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "span");
        ɵɵtext(1);
        ɵɵelementEnd();
        ɵɵtemplate(2, ContrastValidationComponent_ng_container_2_Template, 3, 2, "ng-container", 0);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵtextInterpolate(ctx.contrastText);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.value);
      }
    },
    dependencies: [NgIf, IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContrastValidationComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoContrastValidation]",
      template: `
        <span>{{contrastText}}</span>
        <ng-container *ngIf="value">
            <span class="k-contrast-validation k-text-success" *ngIf="pass">
                {{passMessage}}
                <kendo-icon-wrapper name="check" [svgIcon]="checkIcon"></kendo-icon-wrapper>
            </span>
            <span class="k-contrast-validation k-text-error" *ngIf="!pass">
                {{failMessage}}
                <kendo-icon-wrapper name="x" [svgIcon]="xCircleIcon"></kendo-icon-wrapper>
            </span>
        </ng-container>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, {
    type: [{
      type: Input
    }],
    pass: [{
      type: Input
    }],
    value: [{
      type: Input
    }]
  });
})();
var ContrastComponent = class _ContrastComponent {
  localization;
  value;
  ratio;
  checkIcon = checkIcon;
  xCircleIcon = xCircleIcon;
  constructor(localization) {
    this.localization = localization;
  }
  get formatedRatio() {
    return this.contrastRatio.toFixed(2);
  }
  get contrastRatioText() {
    return `${this.localization.get("contrastRatio")}: ${this.value ? this.formatedRatio : "n/a"}`;
  }
  get satisfiesAACondition() {
    return this.contrastRatio >= AA_RATIO;
  }
  get satisfiesAAACondition() {
    return this.contrastRatio >= AAA_RATIO;
  }
  get contrastRatio() {
    const contrast = getContrastFromTwoRGBAs(getRGBA(this.value), getRGBA(this.ratio));
    return contrast;
  }
  static ɵfac = function ContrastComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ContrastComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ContrastComponent,
    selectors: [["", "kendoContrastTool", ""]],
    inputs: {
      value: "value",
      ratio: "ratio"
    },
    attrs: _c26,
    decls: 6,
    vars: 6,
    consts: [[1, "k-contrast-ratio"], [1, "k-contrast-ratio-text"], [4, "ngIf"], ["kendoContrastValidation", "", "type", "AA", 3, "value", "pass"], ["kendoContrastValidation", "", "type", "AAA", 3, "value", "pass"], ["class", "k-contrast-validation k-text-success", 4, "ngIf"], ["class", "k-contrast-validation k-text-error", 4, "ngIf"], [1, "k-contrast-validation", "k-text-success"], ["name", "check", 3, "svgIcon"], ["name", "check", 3, "svgIcon", 4, "ngIf"], [1, "k-contrast-validation", "k-text-error"], ["name", "x", 3, "svgIcon"]],
    template: function ContrastComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0)(1, "span", 1);
        ɵɵtext(2);
        ɵɵelementEnd();
        ɵɵtemplate(3, ContrastComponent_ng_container_3_Template, 3, 2, "ng-container", 2);
        ɵɵelementEnd();
        ɵɵelement(4, "div", 3)(5, "div", 4);
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵtextInterpolate(ctx.contrastRatioText);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.value);
        ɵɵadvance();
        ɵɵproperty("value", ctx.value)("pass", ctx.satisfiesAACondition);
        ɵɵadvance();
        ɵɵproperty("value", ctx.value)("pass", ctx.satisfiesAAACondition);
      }
    },
    dependencies: [NgIf, IconWrapperComponent, ContrastValidationComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContrastComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoContrastTool]",
      template: `
        <div class="k-contrast-ratio">
            <span class="k-contrast-ratio-text">{{contrastRatioText}}</span>
            <ng-container *ngIf="value">
                <span class="k-contrast-validation k-text-success" *ngIf="satisfiesAACondition">
                    <kendo-icon-wrapper name="check" [svgIcon]="checkIcon"></kendo-icon-wrapper>
                    <kendo-icon-wrapper *ngIf="satisfiesAAACondition" name="check" [svgIcon]="checkIcon"></kendo-icon-wrapper>
                </span>
                <span class="k-contrast-validation k-text-error" *ngIf="!satisfiesAACondition">
                    <kendo-icon-wrapper name="x" [svgIcon]="xCircleIcon"></kendo-icon-wrapper>
                </span>
            </ng-container>
        </div>
        <div kendoContrastValidation
            type="AA"
            [value]="value"
            [pass]="satisfiesAACondition">
        </div>
        <div kendoContrastValidation
            type="AAA"
            [value]="value"
            [pass]="satisfiesAAACondition">
        </div>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent, ContrastValidationComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, {
    value: [{
      type: Input
    }],
    ratio: [{
      type: Input
    }]
  });
})();
var ColorContrastSvgComponent = class _ColorContrastSvgComponent {
  hostClass = true;
  wrapper;
  hsva;
  backgroundColor;
  paths;
  oldHsva;
  oldH;
  oldA;
  metrics;
  ngAfterViewInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.metrics = this.wrapper.getBoundingClientRect();
    this.oldA = this.hsva.value.a;
    this.oldH = this.hsva.value.h;
    this.hsva.subscribe((value) => {
      if (value.h !== this.oldH || value.a !== this.oldA) {
        this.oldH = value.h;
        this.oldA = value.a;
        this.setPaths();
      }
    });
  }
  ngOnChanges(changes) {
    if (isPresent5(changes["backgroundColor"]) && this.metrics) {
      this.setPaths();
    }
  }
  setPaths() {
    const bezierCommandCalc = bezierCommand(controlPoint(line));
    this.paths = [svgPath(this.getPaths(AA_RATIO, STEP_COUNT), bezierCommandCalc), svgPath(this.getPaths(AA_RATIO, STEP_COUNT, true), bezierCommandCalc), svgPath(this.getPaths(AAA_RATIO, STEP_COUNT), bezierCommandCalc), svgPath(this.getPaths(AAA_RATIO, STEP_COUNT, true), bezierCommandCalc)];
  }
  findValue(contrast, saturation, low, high, comparer) {
    const mid = (low + high) / 2;
    const hsva = __spreadProps(__spreadValues({}, this.hsva.value), {
      s: saturation / this.metrics.width,
      v: 1 - mid / this.metrics.height
    });
    const currentContrast = getContrastFromTwoRGBAs(getRGBA(getColorFromHSV(hsva)), getRGBA(this.backgroundColor || ""));
    if (low + 0.5 > high) {
      if (currentContrast < contrast + 1 && currentContrast > contrast - 1) {
        return mid;
      } else {
        return null;
      }
    }
    if (comparer(currentContrast, contrast)) {
      return this.findValue(contrast, saturation, low, high - (high - low) / 2, comparer);
    }
    return this.findValue(contrast, saturation, low + (high - low) / 2, high, comparer);
  }
  getPaths(contrast, stepCount, reversed = false) {
    const points3 = [];
    for (let i = 0; i <= this.metrics.width; i += this.metrics.width / stepCount) {
      const value = this.findValue(contrast, i, 0, this.metrics.height, reversed ? (a, b) => a < b : (a, b) => a > b);
      if (value !== null) {
        points3.push([i, value]);
      }
    }
    return points3;
  }
  static ɵfac = function ColorContrastSvgComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorContrastSvgComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColorContrastSvgComponent,
    selectors: [["", "kendoColorContrastSvg", ""]],
    hostVars: 2,
    hostBindings: function ColorContrastSvgComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-color-contrast-svg", ctx.hostClass);
      }
    },
    inputs: {
      wrapper: "wrapper",
      hsva: "hsva",
      backgroundColor: "backgroundColor"
    },
    features: [ɵɵNgOnChangesFeature],
    attrs: _c27,
    decls: 1,
    vars: 1,
    consts: [["fill", "none", "stroke", "white", "stroke-width", "1", 4, "ngFor", "ngForOf"], ["fill", "none", "stroke", "white", "stroke-width", "1"]],
    template: function ColorContrastSvgComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, ColorContrastSvgComponent__svg_path_0_Template, 1, 1, "path", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngForOf", ctx.paths);
      }
    },
    dependencies: [NgForOf],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorContrastSvgComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoColorContrastSvg]",
      template: `
        <svg:path *ngFor="let path of paths" [attr.d]="path" fill="none" stroke="white" stroke-width="1"></svg:path>
    `,
      standalone: true,
      imports: [NgForOf]
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-color-contrast-svg"]
    }],
    wrapper: [{
      type: Input
    }],
    hsva: [{
      type: Input
    }],
    backgroundColor: [{
      type: Input
    }]
  });
})();
var ColorPickerMessages = class _ColorPickerMessages extends ComponentMessages {
  /**
   * The aria-label applied to the ColorPalette component when the value is empty.
   */
  colorPaletteNoColor;
  /**
   * The aria-label applied to the ColorGradient component when the value is empty.
   */
  colorGradientNoColor;
  /**
   * The aria-label applied to the FlatColorPicker component when the value is empty.
   */
  flatColorPickerNoColor;
  /**
   * The aria-label applied to the ColorPicker component when the value is empty.
   */
  colorPickerNoColor;
  /**
   * The title for the gradient color drag handle chooser.
   */
  colorGradientHandle;
  /**
   * The title for the clear button.
   */
  clearButton;
  /**
   * The title for the hue slider handle.
   */
  hueSliderHandle;
  /**
   * The title for the opacity slider handle.
   */
  opacitySliderHandle;
  /**
   * The placeholder for the HEX color input.
   */
  hexInputPlaceholder;
  /**
   * The placeholder for the red color input.
   */
  redInputPlaceholder;
  /**
   * The placeholder for the green color input.
   */
  greenInputPlaceholder;
  /**
   * The placeholder for the blue color input.
   */
  blueInputPlaceholder;
  /**
   * The placeholder for the alpha input.
   */
  alphaInputPlaceholder;
  /**
   * The aria-label attribute of the red color input.
   */
  redChannelLabel;
  /**
   * The aria-label attribute of the green color input.
   */
  greenChannelLabel;
  /**
   * The aria-label attribute of the blue color input.
   */
  blueChannelLabel;
  /**
   * The aria-label attribute of the alpha color input.
   */
  alphaChannelLabel;
  /**
   * The "Pass" message for the contrast tool.
   */
  passContrast;
  /**
   * The "Fail" message for the contrast tool.
   */
  failContrast;
  /**
   * The "Contrast ratio" message for the contrast tool.
   */
  contrastRatio;
  /**
   * The message for the color preview pane.
   */
  previewColor;
  /**
   * The message for the selected color pane.
   */
  revertSelection;
  /**
   * The message for the gradient view button.
   */
  gradientView;
  /**
   * The message for the palette view button.
   */
  paletteView;
  /**
   * The message for the input format toggle button.
   */
  formatButton;
  /**
   * The message for the Apply action button.
   */
  applyButton;
  /**
   * The message for the Cancel action button.
   */
  cancelButton;
  /**
   * The title for the Close button in adaptive mode.
   */
  closeButton;
  /**
   * The title for the ActionSheet when in adaptive mode.
   */
  adaptiveTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵColorPickerMessages_BaseFactory;
    return function ColorPickerMessages_Factory(__ngFactoryType__) {
      return (ɵColorPickerMessages_BaseFactory || (ɵColorPickerMessages_BaseFactory = ɵɵgetInheritedFactory(_ColorPickerMessages)))(__ngFactoryType__ || _ColorPickerMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _ColorPickerMessages,
    selectors: [["kendo-colorpicker-messages-base"]],
    inputs: {
      colorPaletteNoColor: "colorPaletteNoColor",
      colorGradientNoColor: "colorGradientNoColor",
      flatColorPickerNoColor: "flatColorPickerNoColor",
      colorPickerNoColor: "colorPickerNoColor",
      colorGradientHandle: "colorGradientHandle",
      clearButton: "clearButton",
      hueSliderHandle: "hueSliderHandle",
      opacitySliderHandle: "opacitySliderHandle",
      hexInputPlaceholder: "hexInputPlaceholder",
      redInputPlaceholder: "redInputPlaceholder",
      greenInputPlaceholder: "greenInputPlaceholder",
      blueInputPlaceholder: "blueInputPlaceholder",
      alphaInputPlaceholder: "alphaInputPlaceholder",
      redChannelLabel: "redChannelLabel",
      greenChannelLabel: "greenChannelLabel",
      blueChannelLabel: "blueChannelLabel",
      alphaChannelLabel: "alphaChannelLabel",
      passContrast: "passContrast",
      failContrast: "failContrast",
      contrastRatio: "contrastRatio",
      previewColor: "previewColor",
      revertSelection: "revertSelection",
      gradientView: "gradientView",
      paletteView: "paletteView",
      formatButton: "formatButton",
      applyButton: "applyButton",
      cancelButton: "cancelButton",
      closeButton: "closeButton",
      adaptiveTitle: "adaptiveTitle"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorPickerMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-colorpicker-messages-base"
    }]
  }], null, {
    colorPaletteNoColor: [{
      type: Input
    }],
    colorGradientNoColor: [{
      type: Input
    }],
    flatColorPickerNoColor: [{
      type: Input
    }],
    colorPickerNoColor: [{
      type: Input
    }],
    colorGradientHandle: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    hueSliderHandle: [{
      type: Input
    }],
    opacitySliderHandle: [{
      type: Input
    }],
    hexInputPlaceholder: [{
      type: Input
    }],
    redInputPlaceholder: [{
      type: Input
    }],
    greenInputPlaceholder: [{
      type: Input
    }],
    blueInputPlaceholder: [{
      type: Input
    }],
    alphaInputPlaceholder: [{
      type: Input
    }],
    redChannelLabel: [{
      type: Input
    }],
    greenChannelLabel: [{
      type: Input
    }],
    blueChannelLabel: [{
      type: Input
    }],
    alphaChannelLabel: [{
      type: Input
    }],
    passContrast: [{
      type: Input
    }],
    failContrast: [{
      type: Input
    }],
    contrastRatio: [{
      type: Input
    }],
    previewColor: [{
      type: Input
    }],
    revertSelection: [{
      type: Input
    }],
    gradientView: [{
      type: Input
    }],
    paletteView: [{
      type: Input
    }],
    formatButton: [{
      type: Input
    }],
    applyButton: [{
      type: Input
    }],
    cancelButton: [{
      type: Input
    }],
    closeButton: [{
      type: Input
    }],
    adaptiveTitle: [{
      type: Input
    }]
  });
})();
var LocalizedColorPickerMessagesDirective = class _LocalizedColorPickerMessagesDirective extends ColorPickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedColorPickerMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedColorPickerMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedColorPickerMessagesDirective,
    selectors: [["", "kendoColorPickerLocalizedMessages", ""], ["", "kendoFlatColorPickerLocalizedMessages", ""], ["", "kendoColorGradientLocalizedMessages", ""], ["", "kendoColorPaletteLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: ColorPickerMessages,
      useExisting: forwardRef(() => _LocalizedColorPickerMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedColorPickerMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: ColorPickerMessages,
        useExisting: forwardRef(() => LocalizedColorPickerMessagesDirective)
      }],
      selector: "[kendoColorPickerLocalizedMessages], [kendoFlatColorPickerLocalizedMessages], [kendoColorGradientLocalizedMessages], [kendoColorPaletteLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var serial$3 = 0;
var DEFAULT_SIZE$7 = "medium";
var ColorGradientComponent = class _ColorGradientComponent {
  host;
  ngZone;
  renderer;
  cdr;
  localizationService;
  injector;
  hostClasses = true;
  get readonlyAttribute() {
    return this.readonly;
  }
  get disabledClass() {
    return this.disabled;
  }
  get gradientId() {
    return this.id;
  }
  direction;
  get hostTabindex() {
    return this.tabindex?.toString() || "0";
  }
  ariaRole = "textbox";
  get isControlInvalid() {
    return this.control?.invalid?.toString();
  }
  get isDisabled() {
    return this.disabled?.toString() || void 0;
  }
  /**
   * @hidden
   */
  enterHandler(event) {
    if (event.target !== this.host.nativeElement) {
      return;
    }
    this.internalNavigation = true;
    this.gradientDragHandle.nativeElement.focus();
  }
  /**
   * @hidden
   */
  escapeHandler(event) {
    if (!this.host.nativeElement.matches(":focus")) {
      event.stopImmediatePropagation();
    }
    this.internalNavigation = false;
    this.host.nativeElement.focus();
  }
  /**
   * @hidden
   */
  focusHandler(ev) {
    this.internalNavigation = ev.target !== this.host.nativeElement;
  }
  /**
   * @hidden
   */
  adaptiveMode = false;
  /**
   * @hidden
   */
  id = `k-colorgradient-${serial$3++}`;
  /**
   * Defines whether the alpha slider will be displayed.
   *
   * @default true
   */
  opacity = true;
  /**
   * The size property specifies the padding of the ColorGradient internal elements.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set size(size) {
    const newSize = size || DEFAULT_SIZE$7;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the disabled state of the ColorGradient. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_colorgradient#toc-managing-the-colorgradient-disabled-state-in-reactive-forms).
   *
   * @default false
   */
  disabled = false;
  /**
   * Sets the read-only state of the ColorGradient.
   *
   * @default false
   */
  readonly = false;
  /**
   * Specifies whether the ColorGradient should display a 'Clear color' button.
   *
   * @default false
   */
  clearButton = false;
  /**
   * Determines the delay time (in milliseconds) before the value is changed on handle drag. A value of 0 indicates no delay.
   *
   * @default 0
   */
  delay = 0;
  /**
   * Specifies the value of the initially selected color.
   */
  set value(value) {
    this._value = parseColor4(value, this.format, this.opacity);
  }
  get value() {
    return this._value;
  }
  /**
   * Enables the color contrast tool. Accepts the background color that will be compared to the selected value.
   * The tool will calculate the contrast ratio between the two colors.
   */
  set contrastTool(value) {
    this._contrastTool = parseColor4(value, this.format, this.opacity);
  }
  get contrastTool() {
    return this._contrastTool;
  }
  /**
   * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   *
   * @default 0
   */
  set tabindex(value) {
    if (isPresent5(value)) {
      const tabindex = Number(value);
      this._tabindex = !isNaN(tabindex) ? tabindex : 0;
    } else {
      this._tabindex = value;
    }
  }
  get tabindex() {
    return !this.disabled ? this._tabindex : void 0;
  }
  /**
   * Specifies the output format of the ColorGradientComponent.
   * The input value may be in a different format, but it will be parsed into the output `format`
   * after the component processes it.
   *
   * The supported values are:
   * * (Default) `rgba`
   * * `hex`
   */
  format = DEFAULT_OUTPUT_FORMAT;
  /**
   * Fires each time the user selects a new color.
   */
  valueChange = new EventEmitter();
  /**
   * @hidden
   */
  backgroundColor = DEFAULT_GRADIENT_BACKGROUND_COLOR;
  /**
   * @hidden
   *
   * Represents the currently selected `hue`, `saturation`, `value`, and `alpha` values.
   * The values are initially set in `ngOnInit` or in `ngOnChanges` and are
   * updated on moving the drag handle or the sliders.
   */
  hsva = new BehaviorSubject({});
  /**
   * Indicates whether the ColorGradient or any of its content is focused.
   */
  get isFocused() {
    if (!(isDocumentAvailable() && isPresent5(this.host))) {
      return false;
    }
    return this.host.nativeElement === document.activeElement || this.host.nativeElement.contains(document.activeElement);
  }
  /**
   * @hidden
   */
  get alphaSliderValue() {
    if (!(isPresent5(this.hsva.value) && isPresent5(this.hsva.value.a))) {
      return;
    }
    return this.hsva.value.a * 100;
  }
  /**
   * Determines the step (in pixels) when moving the gradient drag handle using the keyboard arrow keys.
   *
   * @default 5
   */
  gradientSliderStep = DRAGHANDLE_MOVE_SPEED;
  /**
   * Determines the step (in pixels) when moving the gradient drag handle using the keyboard arrow keys while holding the shift key.
   *
   * @default 2
   */
  gradientSliderSmallStep = DRAGHANDLE_MOVE_SPEED_SMALL_STEP;
  gradientDragHandle;
  inputs;
  alphaSlider;
  gradientWrapper;
  hsvRectangle;
  /**
   * @hidden
   */
  internalNavigation = false;
  /**
   * @hidden
   */
  dropletSlashIcon = dropletSlashIcon;
  _value;
  _tabindex = 0;
  _contrastTool;
  listeners = [];
  hueSliderTouched = false;
  alphaSliderTouched = false;
  _size = "medium";
  updateValues = new Subject();
  changeRequestsSubscription;
  dynamicRTLSubscription;
  hsvHandleCoordinates = {
    x: 0,
    y: 0
  };
  get gradientRect() {
    return this.gradientWrapper.nativeElement.getBoundingClientRect();
  }
  /**
   * @hidden
   */
  get hsvSliderValueText() {
    return `X: ${this.hsvHandleCoordinates.x} Y: ${this.hsvHandleCoordinates.y}`;
  }
  /**
   * @hidden
   */
  get contrastToolVisible() {
    return this.contrastTool && this.contrastTool.length > 0;
  }
  /**
   * @hidden
   */
  get innerTabIndex() {
    return this.internalNavigation ? 0 : -1;
  }
  control;
  constructor(host, ngZone, renderer, cdr, localizationService, injector) {
    this.host = host;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.cdr = cdr;
    this.localizationService = localizationService;
    this.injector = injector;
    validatePackage(packageMetadata5);
    this.dynamicRTLSubscription = localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
  }
  ngOnInit() {
    this.control = this.injector.get(NgControl, null);
  }
  ngAfterViewInit() {
    const stylingInputs = ["size"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      this.updateUI();
      this.cdr.detectChanges();
    });
    this.addEventListeners();
    this.subscribeChanges();
  }
  ngOnChanges(changes) {
    if (isChanged("value", changes) && !this.isFocused) {
      this.updateUI();
    }
    if (isChanged("delay", changes)) {
      this.unsubscribeChanges();
      this.subscribeChanges();
    }
  }
  ngOnDestroy() {
    this.listeners.forEach((removeListener) => removeListener());
    if (this.dynamicRTLSubscription) {
      this.dynamicRTLSubscription.unsubscribe();
    }
    this.unsubscribeChanges();
  }
  /**
   * Focuses the component.
   */
  focus() {
    if (this.disabled) {
      return;
    }
    this.gradientDragHandle.nativeElement.focus();
  }
  /**
   * @hidden
   */
  reset() {
    this.handleValueChange(void 0);
    this.updateUI();
  }
  /**
   * @hidden
   */
  handleDragPress(args) {
    if (this.disabled || this.readonly || !isPresent5(args.originalEvent)) {
      return;
    }
    this.focus();
    args.originalEvent.preventDefault();
  }
  /**
   * @hidden
   */
  onHandleDrag(args) {
    if (this.disabled || this.readonly) {
      return;
    }
    this.renderer.addClass(this.gradientWrapper.nativeElement, "k-dragging");
    this.changePosition(args);
  }
  /**
   * @hidden
   */
  onHandleRelease() {
    if (this.disabled || this.readonly) {
      return;
    }
    this.renderer.removeClass(this.gradientWrapper.nativeElement, "k-dragging");
    this.handleValueChange(getColorFromHSV(this.hsva.value, this.format, this.opacity));
  }
  /**
   * @hidden
   */
  onKeyboardAction(args) {
    if (this.disabled || this.readonly) {
      return;
    }
    if (args.key && args.key.indexOf("Arrow") !== -1) {
      args.preventDefault();
      const dragHandleElement = this.gradientDragHandle.nativeElement;
      this.renderer.addClass(this.gradientWrapper.nativeElement, "k-dragging");
      let keyboardMoveX = 0;
      let keyboardMoveY = 0;
      const shiftKey = args.shiftKey;
      switch (args.key) {
        case "ArrowRight":
          keyboardMoveX = shiftKey ? this.gradientSliderSmallStep : this.gradientSliderStep;
          break;
        case "ArrowLeft":
          keyboardMoveX = shiftKey ? -this.gradientSliderSmallStep : -this.gradientSliderStep;
          break;
        case "ArrowUp":
          keyboardMoveY = shiftKey ? -this.gradientSliderSmallStep : -this.gradientSliderStep;
          break;
        case "ArrowDown":
          keyboardMoveY = shiftKey ? this.gradientSliderSmallStep : this.gradientSliderStep;
          break;
        default:
          break;
      }
      const newY = parseInt(dragHandleElement.style.top, 10) + keyboardMoveY;
      const newX = parseInt(dragHandleElement.style.left, 10) + keyboardMoveX;
      this.renderer.setStyle(dragHandleElement, "top", `${newY}px`);
      this.renderer.setStyle(dragHandleElement, "left", `${newX}px`);
      this.ngZone.run(() => this.moveDragHandle(newX, newY));
    }
  }
  /**
   * @hidden
   */
  changePosition(position) {
    if (this.disabled || this.readonly) {
      return;
    }
    this.gradientDragHandle.nativeElement.focus();
    const gradientRect = this.gradientRect;
    const newX = position.clientX - gradientRect.left;
    const newY = position.clientY - gradientRect.top;
    this.ngZone.run(() => this.moveDragHandle(newX, newY));
  }
  /**
   * @hidden
   */
  handleHueSliderChange(hue) {
    const hsva = this.hsva.value;
    hsva.h = hue;
    this.hsva.next(hsva);
    this.handleValueChange(getColorFromHSV(this.hsva.value, this.format, this.opacity));
    this.backgroundColor = getColorFromHue(hue);
    this.setBackgroundColor(this.backgroundColor);
    this.setAlphaSliderBackground(this.backgroundColor);
    this.hueSliderTouched = true;
  }
  /**
   * @hidden
   */
  handleAlphaSliderChange(alpha) {
    const hsva = this.hsva.value;
    hsva.a = alpha / 100;
    this.hsva.next(hsva);
    this.handleValueChange(getColorFromHSV(this.hsva.value, this.format, this.opacity));
    this.alphaSliderTouched = true;
  }
  /**
   * @hidden
   */
  handleInputsValueChange(color) {
    const parsed = parseColor4(color, this.format, this.opacity);
    if (this.value !== parsed) {
      this.handleValueChange(parsed);
      this.updateUI();
    }
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value;
    if (isPresent5(this.gradientWrapper)) {
      this.updateUI();
    }
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.notifyNgChanged = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.notifyNgTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.cdr.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * @hidden
   */
  get colorGradientHandleTitle() {
    return this.localizationService.get("colorGradientHandle");
  }
  /**
   * @hidden
   */
  get colorGradientHandleAriaLabel() {
    const parsed = parseColor4(this.value, this.format, this.opacity);
    return `${this.value ? parsed : this.localizationService.get("colorGradientNoColor")}`;
  }
  /**
   * @hidden
   */
  get hueSliderTitle() {
    return this.localizationService.get("hueSliderHandle");
  }
  /**
   * @hidden
   */
  get opacitySliderTitle() {
    return this.localizationService.get("opacitySliderHandle");
  }
  /**
   * @hidden
   */
  get clearButtonTitle() {
    return this.localizationService.get("clearButton");
  }
  /**
   * @hidden
   * Used by the FloatingLabel to determine if the component is empty.
   */
  isEmpty() {
    return false;
  }
  notifyNgChanged = () => {
  };
  notifyNgTouched = () => {
  };
  moveDragHandle(positionX, positionY) {
    const gradientRect = this.gradientRect;
    const gradientRectWidth = gradientRect.width;
    const gradientRectHeight = gradientRect.height;
    const top = fitIntoBounds(positionY, 0, gradientRectHeight);
    const left = fitIntoBounds(positionX, 0, gradientRectWidth);
    this.setDragHandleElementPosition(top, left);
    const hsva = this.hsva.value;
    hsva.s = left / gradientRectWidth;
    hsva.v = 1 - top / gradientRectHeight;
    this.hsva.next(hsva);
    this.updateValues.next(getColorFromHSV(this.hsva.value, this.format, this.opacity));
    this.setAlphaSliderBackground(getColorFromHSV(__spreadProps(__spreadValues({}, this.hsva.value), {
      a: 1
    }), this.format, this.opacity));
  }
  handleValueChange(color) {
    if (this.value === color) {
      return;
    }
    this.value = color;
    this.valueChange.emit(color);
    this.notifyNgChanged(color);
    this.setHostElementAriaLabel();
  }
  setDragHandleElementPosition(top, left) {
    const dragHandle = this.gradientDragHandle.nativeElement;
    this.hsvHandleCoordinates = {
      x: left,
      y: top
    };
    this.renderer.setStyle(dragHandle, "top", `${top}px`);
    this.renderer.setStyle(dragHandle, "left", `${left}px`);
  }
  setAlphaSliderBackground(backgroundColor) {
    if (!isPresent5(this.alphaSlider)) {
      return;
    }
    const sliderTrack = this.alphaSlider.track.nativeElement;
    this.renderer.setStyle(sliderTrack, "background", `linear-gradient(to ${this.adaptiveMode ? "right" : "top"}, transparent, ${backgroundColor})`);
  }
  setHostElementAriaLabel() {
    const parsed = parseColor4(this.value, this.format, this.opacity);
    this.renderer.setAttribute(this.host.nativeElement, "aria-label", `${this.value ? parsed : this.localizationService.get("colorGradientNoColor")}`);
  }
  setBackgroundColor(color) {
    this.renderer.setStyle(this.hsvRectangle.nativeElement, "background", color);
  }
  updateUI() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (this.hueSliderTouched || this.alphaSliderTouched) {
      this.hueSliderTouched = false;
      this.alphaSliderTouched = false;
      return;
    }
    this.hsva.next(this.value ? getHSV(this.value) : {
      h: 0,
      s: 0,
      v: 1,
      a: 1
    });
    const gradientRect = this.gradientRect;
    const top = (1 - this.hsva.value.v) * gradientRect.height;
    const left = this.hsva.value.s * gradientRect.width;
    this.setDragHandleElementPosition(top, left);
    this.backgroundColor = getColorFromHue(this.hsva.value.h);
    this.setBackgroundColor(this.backgroundColor);
    this.setAlphaSliderBackground(this.backgroundColor);
    this.setHostElementAriaLabel();
  }
  addEventListeners() {
    this.ngZone.runOutsideAngular(() => {
      const focusOutListener = this.renderer.listen(this.host.nativeElement, "focusout", (event) => {
        if (!containsFocus(this.host.nativeElement, event.relatedTarget) && isUntouched(this.host)) {
          this.ngZone.run(() => this.notifyNgTouched());
        }
      });
      const keydownListener = this.renderer.listen(this.gradientDragHandle.nativeElement, "keydown", (event) => {
        this.onKeyboardAction(event);
      });
      const keyupListener = this.renderer.listen(this.gradientDragHandle.nativeElement, "keyup", () => {
        this.renderer.removeClass(this.gradientWrapper.nativeElement, "k-dragging");
        if (!this.readonly && !this.disabled) {
          this.ngZone.run(() => this.handleValueChange(getColorFromHSV(this.hsva.value, this.format, this.opacity)));
        }
      });
      const dragHandleFocusInListener = this.renderer.listen(this.gradientDragHandle.nativeElement, "focusin", () => {
        this.renderer.addClass(this.gradientDragHandle.nativeElement, "k-focus");
      });
      const dragHandleFocusOutListener = this.renderer.listen(this.gradientDragHandle.nativeElement, "focusout", () => {
        this.renderer.removeClass(this.gradientDragHandle.nativeElement, "k-focus");
      });
      this.listeners.push(focusOutListener, keydownListener, keyupListener, dragHandleFocusInListener, dragHandleFocusOutListener);
    });
  }
  subscribeChanges() {
    this.changeRequestsSubscription = this.updateValues.pipe(throttleTime(this.delay)).subscribe((value) => {
      this.handleValueChange(value);
    });
  }
  unsubscribeChanges() {
    if (this.changeRequestsSubscription) {
      this.changeRequestsSubscription.unsubscribe();
    }
  }
  handleClasses(value, input) {
    const elem = this.host.nativeElement;
    const classes = getStylingClasses2("colorgradient", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  static ɵfac = function ColorGradientComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorGradientComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Injector));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColorGradientComponent,
    selectors: [["kendo-colorgradient"]],
    viewQuery: function ColorGradientComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c28, 5);
        ɵɵviewQuery(_c29, 5);
        ɵɵviewQuery(_c30, 5);
        ɵɵviewQuery(_c31, 5);
        ɵɵviewQuery(_c322, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.gradientDragHandle = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputs = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.alphaSlider = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.gradientWrapper = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.hsvRectangle = _t.first);
      }
    },
    hostVars: 13,
    hostBindings: function ColorGradientComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown.enter", function ColorGradientComponent_keydown_enter_HostBindingHandler($event) {
          return ctx.enterHandler($event);
        })("keydown.escape", function ColorGradientComponent_keydown_escape_HostBindingHandler($event) {
          return ctx.escapeHandler($event);
        })("focusin", function ColorGradientComponent_focusin_HostBindingHandler($event) {
          return ctx.focusHandler($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("aria-readonly", ctx.readonlyAttribute)("id", ctx.gradientId)("dir", ctx.direction)("tabindex", ctx.hostTabindex)("role", ctx.ariaRole)("aria-invalid", ctx.isControlInvalid)("aria-disabled", ctx.isDisabled);
        ɵɵclassProp("k-colorgradient", ctx.hostClasses)("k-disabled", ctx.disabledClass)("k-readonly", ctx.readonly);
      }
    },
    inputs: {
      adaptiveMode: "adaptiveMode",
      id: "id",
      opacity: "opacity",
      size: "size",
      disabled: "disabled",
      readonly: "readonly",
      clearButton: "clearButton",
      delay: "delay",
      value: "value",
      contrastTool: "contrastTool",
      tabindex: "tabindex",
      format: "format",
      gradientSliderStep: "gradientSliderStep",
      gradientSliderSmallStep: "gradientSliderSmallStep"
    },
    outputs: {
      valueChange: "valueChange"
    },
    exportAs: ["kendoColorGradient"],
    features: [ɵɵProvidersFeature([{
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _ColorGradientComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _ColorGradientComponent)
    }, ColorGradientLocalizationService, {
      provide: LocalizationService,
      useExisting: ColorGradientLocalizationService
    }, {
      provide: L10N_PREFIX,
      useValue: "kendo.colorgradient"
    }]), ɵɵNgOnChangesFeature],
    decls: 16,
    vars: 46,
    consts: () => {
      let i18n_10;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_10 = goog.getMsg("Colorgradient no color chosen");
        i18n_10 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_10;
      } else {
        i18n_10 = $localize`:kendo.colorgradient.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty.:Colorgradient no color chosen`;
      }
      let i18n_11;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_11 = goog.getMsg("Choose color");
        i18n_11 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_11;
      } else {
        i18n_11 = $localize`:kendo.colorgradient.colorGradientHandle|The title for the gradient color drag handle chooser.:Choose color`;
      }
      let i18n_12;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_12 = goog.getMsg("Clear value");
        i18n_12 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_12;
      } else {
        i18n_12 = $localize`:kendo.colorgradient.clearButton|The title for the clear button.:Clear value`;
      }
      let i18n_13;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_13 = goog.getMsg("Set hue");
        i18n_13 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_13;
      } else {
        i18n_13 = $localize`:kendo.colorgradient.hueSliderHandle|The title for the hue slider handle.:Set hue`;
      }
      let i18n_14;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_14 = goog.getMsg("Set opacity");
        i18n_14 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_14;
      } else {
        i18n_14 = $localize`:kendo.colorgradient.opacitySliderHandle|The title for the opacity slider handle.:Set opacity`;
      }
      let i18n_15;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_15 = goog.getMsg("Pass");
        i18n_15 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_15;
      } else {
        i18n_15 = $localize`:kendo.colorgradient.passContrast|The pass message for the contrast tool.:Pass`;
      }
      let i18n_16;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_16 = goog.getMsg("Fail");
        i18n_16 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_16;
      } else {
        i18n_16 = $localize`:kendo.colorgradient.failContrast|The fail message for the contrast tool.:Fail`;
      }
      let i18n_17;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_17 = goog.getMsg("Contrast ratio");
        i18n_17 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_17;
      } else {
        i18n_17 = $localize`:kendo.colorgradient.contrastRatio|The contrast ratio message for the contrast tool.:Contrast ratio`;
      }
      let i18n_18;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_18 = goog.getMsg("Change color format");
        i18n_18 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_18;
      } else {
        i18n_18 = $localize`:kendo.colorgradient.formatButton|The message for the input format toggle button.:Change color format`;
      }
      let i18n_19;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_19 = goog.getMsg("Red channel");
        i18n_19 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_19;
      } else {
        i18n_19 = $localize`:kendo.colorgradient.redChannelLabel|The label of the NumericTextBox representing the red color channel.:Red channel`;
      }
      let i18n_20;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_20 = goog.getMsg("Green channel");
        i18n_20 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_20;
      } else {
        i18n_20 = $localize`:kendo.colorgradient.greenChannelLabel|The label of the NumericTextBox representing the green color channel.:Green channel`;
      }
      let i18n_21;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_21 = goog.getMsg("Blue channel");
        i18n_21 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_21;
      } else {
        i18n_21 = $localize`:kendo.colorgradient.blueChannelLabel|The label of the NumericTextBox representing the blue color channel.:Blue channel`;
      }
      let i18n_22;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_22 = goog.getMsg("Alpha channel");
        i18n_22 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_22;
      } else {
        i18n_22 = $localize`:kendo.colorgradient.alphaChannelLabel|The label of the NumericTextBox representing the alpha color channel.:Alpha channel`;
      }
      let i18n_23;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_23 = goog.getMsg("R");
        i18n_23 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_23;
      } else {
        i18n_23 = $localize`:kendo.colorgradient.redChannelLabel|The label of the NumericTextBox representing the red color channel.:R`;
      }
      let i18n_24;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_24 = goog.getMsg("G");
        i18n_24 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_24;
      } else {
        i18n_24 = $localize`:kendo.colorgradient.greenInputPlaceholder|The placeholder for the green color input.:G`;
      }
      let i18n_25;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_25 = goog.getMsg("B");
        i18n_25 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_25;
      } else {
        i18n_25 = $localize`:kendo.colorgradient.blueInputPlaceholder|The placeholder for the blue color input.:B`;
      }
      let i18n_26;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_26 = goog.getMsg("HEX");
        i18n_26 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_26;
      } else {
        i18n_26 = $localize`:kendo.colorgradient.hexInputPlaceholder|The placeholder for the HEX color input.:HEX`;
      }
      return [["hsvRectangle", ""], ["gradientWrapper", ""], ["gradientDragHandle", ""], ["inputs", ""], ["alphaSlider", ""], ["kendoColorGradientLocalizedMessages", "", "colorGradientNoColor", i18n_10, "colorGradientHandle", i18n_11, "clearButton", i18n_12, "hueSliderHandle", i18n_13, "opacitySliderHandle", i18n_14, "passContrast", i18n_15, "failContrast", i18n_16, "contrastRatio", i18n_17, "formatButton", i18n_18, "redChannelLabel", i18n_19, "greenChannelLabel", i18n_20, "blueChannelLabel", i18n_21, "alphaChannelLabel", i18n_22, "redChannelLabel", i18n_23, "greenInputPlaceholder", i18n_24, "blueInputPlaceholder", i18n_25, "hexInputPlaceholder", i18n_26], [3, "ngClass"], [1, "k-hsv-rectangle"], ["kendoDraggable", "", 1, "k-hsv-gradient", 3, "click", "kendoPress", "kendoDrag", "kendoRelease"], ["role", "slider", 1, "k-hsv-draghandle", "k-draghandle", 3, "keydown.shift.tab", "tabindex"], ["kendoColorContrastSvg", "", "class", "k-color-contrast-svg", "xmlns", "http://www.w3.org/2000/svg", 3, "wrapper", "hsva", "backgroundColor", "style", 4, "ngIf"], ["kendoButton", "", "class", "k-clear-color", "fillMode", "flat", "icon", "droplet-slash", 3, "svgIcon", "size", "tabindex", "style", "click", "keydown.enter", "keydown.space", 4, "ngIf"], ["tickPlacement", "none", 1, "k-hue-slider", "k-colorgradient-slider", 3, "valueChange", "ngClass", "dragHandleTitle", "tabindex", "disabled", "readonly", "showButtons", "vertical", "min", "max", "value", "smallStep", "largeStep"], ["class", "k-alpha-slider k-colorgradient-slider", "tickPlacement", "none", 3, "tabindex", "ngClass", "height", "dragHandleTitle", "disabled", "readonly", "showButtons", "vertical", "min", "max", "smallStep", "largeStep", "value", "valueChange", 4, "ngIf"], [3, "valueChange", "tabOut", "tabindex", "opacity", "size", "formatView", "value", "disabled", "readonly"], ["class", "k-colorgradient-color-contrast k-vbox", "kendoContrastTool", "", 3, "value", "ratio", 4, "ngIf"], ["kendoColorContrastSvg", "", "xmlns", "http://www.w3.org/2000/svg", 1, "k-color-contrast-svg", 3, "wrapper", "hsva", "backgroundColor"], ["kendoButton", "", "fillMode", "flat", "icon", "droplet-slash", 1, "k-clear-color", 3, "click", "keydown.enter", "keydown.space", "svgIcon", "size", "tabindex"], ["tickPlacement", "none", 1, "k-alpha-slider", "k-colorgradient-slider", 3, "valueChange", "tabindex", "ngClass", "dragHandleTitle", "disabled", "readonly", "showButtons", "vertical", "min", "max", "smallStep", "largeStep", "value"], ["kendoContrastTool", "", 1, "k-colorgradient-color-contrast", "k-vbox", 3, "value", "ratio"]];
    },
    template: function ColorGradientComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 5);
        ɵɵelementStart(1, "div", 6)(2, "div", 7, 0)(4, "div", 8, 1);
        ɵɵlistener("click", function ColorGradientComponent_Template_div_click_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.changePosition($event));
        })("kendoPress", function ColorGradientComponent_Template_div_kendoPress_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleDragPress($event));
        })("kendoDrag", function ColorGradientComponent_Template_div_kendoDrag_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onHandleDrag($event));
        })("kendoRelease", function ColorGradientComponent_Template_div_kendoRelease_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onHandleRelease());
        });
        ɵɵelementStart(6, "div", 9, 2);
        ɵɵlistener("keydown.shift.tab", function ColorGradientComponent_Template_div_keydown_shift_tab_6_listener($event) {
          ɵɵrestoreView(_r1);
          const inputs_r2 = ɵɵreference(14);
          $event.preventDefault();
          return ɵɵresetView(inputs_r2.focusLast());
        });
        ɵɵelementEnd()();
        ɵɵtemplate(8, ColorGradientComponent__svg_svg_8_Template, 1, 5, "svg", 10);
        ɵɵelementEnd();
        ɵɵelementStart(9, "div", 6);
        ɵɵtemplate(10, ColorGradientComponent_button_10_Template, 1, 7, "button", 11);
        ɵɵelementStart(11, "kendo-slider", 12);
        ɵɵlistener("valueChange", function ColorGradientComponent_Template_kendo_slider_valueChange_11_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleHueSliderChange($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(12, ColorGradientComponent_kendo_slider_12_Template, 2, 16, "kendo-slider", 13);
        ɵɵelementEnd()();
        ɵɵelementStart(13, "kendo-colorinput", 14, 3);
        ɵɵlistener("valueChange", function ColorGradientComponent_Template_kendo_colorinput_valueChange_13_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputsValueChange($event));
        })("tabOut", function ColorGradientComponent_Template_kendo_colorinput_tabOut_13_listener() {
          ɵɵrestoreView(_r1);
          const gradientDragHandle_r7 = ɵɵreference(7);
          return ɵɵresetView(gradientDragHandle_r7.focus());
        });
        ɵɵelementEnd();
        ɵɵtemplate(15, ColorGradientComponent_div_15_Template, 1, 2, "div", 15);
      }
      if (rf & 2) {
        const gradientWrapper_r4 = ɵɵreference(5);
        ɵɵadvance();
        ɵɵproperty("ngClass", ɵɵpureFunction2(37, _c332, ctx.adaptiveMode, !ctx.adaptiveMode));
        ɵɵadvance(3);
        ɵɵstyleProp("touch-action", "none");
        ɵɵadvance(2);
        ɵɵproperty("tabindex", ctx.innerTabIndex.toString());
        ɵɵattribute("title", ctx.colorGradientHandleTitle)("aria-label", ctx.colorGradientHandleTitle + " " + ctx.colorGradientHandleAriaLabel)("aria-valuetext", ctx.hsvSliderValueText)("aria-readonly", ctx.readonly ? ctx.readonly : void 0)("aria-disabled", ctx.disabled ? ctx.disabled : void 0)("aria-orientation", "undefined")("aria-valuenow", "0");
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.contrastToolVisible && gradientWrapper_r4);
        ɵɵadvance();
        ɵɵproperty("ngClass", ɵɵpureFunction3(40, _c34, ctx.clearButton, ctx.adaptiveMode, !ctx.adaptiveMode));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.clearButton);
        ɵɵadvance();
        ɵɵstyleProp("height", ctx.clearButton ? "140" : null, "px");
        ɵɵproperty("ngClass", ɵɵpureFunction1(44, _c35, ctx.clearButton))("dragHandleTitle", ctx.hueSliderTitle)("tabindex", ctx.innerTabIndex)("disabled", ctx.disabled)("readonly", ctx.readonly)("showButtons", false)("vertical", !ctx.adaptiveMode)("min", 0)("max", 360)("value", ctx.hsva.value.h)("smallStep", 5)("largeStep", 10);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.opacity);
        ɵɵadvance();
        ɵɵproperty("tabindex", ctx.innerTabIndex)("opacity", ctx.opacity)("size", ctx.size)("formatView", ctx.format)("value", ctx.value)("disabled", ctx.disabled)("readonly", ctx.readonly);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.contrastToolVisible);
      }
    },
    dependencies: [LocalizedColorPickerMessagesDirective, DraggableDirective, NgIf, ColorContrastSvgComponent, ButtonComponent, SliderComponent, NgClass, ColorInputComponent, ContrastComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorGradientComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoColorGradient",
      selector: "kendo-colorgradient",
      providers: [{
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => ColorGradientComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => ColorGradientComponent)
      }, ColorGradientLocalizationService, {
        provide: LocalizationService,
        useExisting: ColorGradientLocalizationService
      }, {
        provide: L10N_PREFIX,
        useValue: "kendo.colorgradient"
      }],
      template: `
        <ng-container kendoColorGradientLocalizedMessages
            i18n-colorGradientNoColor="kendo.colorgradient.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty."
            colorGradientNoColor="Colorgradient no color chosen"
            i18n-colorGradientHandle="kendo.colorgradient.colorGradientHandle|The title for the gradient color drag handle chooser."
            colorGradientHandle="Choose color"
            i18n-clearButton="kendo.colorgradient.clearButton|The title for the clear button."
            clearButton="Clear value"
            i18n-hueSliderHandle="kendo.colorgradient.hueSliderHandle|The title for the hue slider handle."
            hueSliderHandle="Set hue"
            i18n-opacitySliderHandle="kendo.colorgradient.opacitySliderHandle|The title for the opacity slider handle."
            opacitySliderHandle="Set opacity"
            i18n-passContrast="kendo.colorgradient.passContrast|The pass message for the contrast tool."
            passContrast="Pass"
            i18n-failContrast="kendo.colorgradient.failContrast|The fail message for the contrast tool."
            failContrast="Fail"
            i18n-contrastRatio="kendo.colorgradient.contrastRatio|The contrast ratio message for the contrast tool."
            contrastRatio="Contrast ratio"
            i18n-formatButton="kendo.colorgradient.formatButton|The message for the input format toggle button."
            formatButton="Change color format"
            i18n-redChannelLabel="kendo.colorgradient.redChannelLabel|The label of the NumericTextBox representing the red color channel."
            redChannelLabel="Red channel"
            i18n-greenChannelLabel="kendo.colorgradient.greenChannelLabel|The label of the NumericTextBox representing the green color channel."
            greenChannelLabel="Green channel"
            i18n-blueChannelLabel="kendo.colorgradient.blueChannelLabel|The label of the NumericTextBox representing the blue color channel."
            blueChannelLabel="Blue channel"
            i18n-alphaChannelLabel="kendo.colorgradient.alphaChannelLabel|The label of the NumericTextBox representing the alpha color channel."
            alphaChannelLabel="Alpha channel"
            i18n-redInputPlaceholder="kendo.colorgradient.redInputPlaceholder|The placeholder for the red color input."
            redChannelLabel="R"
            i18n-greenInputPlaceholder="kendo.colorgradient.greenInputPlaceholder|The placeholder for the green color input."
            greenInputPlaceholder="G"
            i18n-blueInputPlaceholder="kendo.colorgradient.blueInputPlaceholder|The placeholder for the blue color input."
            blueInputPlaceholder="B"
            i18n-hexInputPlaceholder="kendo.colorgradient.hexInputPlaceholder|The placeholder for the HEX color input."
            hexInputPlaceholder="HEX">
        </ng-container>
        <div [ngClass]="{
                'k-colorgradient-canvas': true,
                'k-vstack': adaptiveMode,
                'k-hstack': !adaptiveMode
            }">
            <div class="k-hsv-rectangle" #hsvRectangle>
                <div
                    #gradientWrapper
                    kendoDraggable
                    class="k-hsv-gradient"
                    (click)="changePosition($event)"
                    (kendoPress)="handleDragPress($event)"
                    (kendoDrag)="onHandleDrag($event)"
                    (kendoRelease)="onHandleRelease()"
                    [style.touch-action]="'none'">
                    <div
                        #gradientDragHandle
                        class="k-hsv-draghandle k-draghandle"
                        [tabindex]="innerTabIndex.toString()"
                        [attr.title]="colorGradientHandleTitle"
                        [attr.aria-label]="colorGradientHandleTitle + ' ' + colorGradientHandleAriaLabel"
                        role="slider"
                        [attr.aria-valuetext]="hsvSliderValueText"
                        [attr.aria-readonly]="readonly ? readonly : undefined"
                        [attr.aria-disabled]="disabled ? disabled : undefined"
                        [attr.aria-orientation]="'undefined'"
                        [attr.aria-valuenow]="'0'"
                        (keydown.shift.tab)="$event.preventDefault(); inputs.focusLast();">
                    </div>
                </div>
                <svg kendoColorContrastSvg
                    *ngIf="contrastToolVisible && gradientWrapper"
                    class="k-color-contrast-svg"
                    xmlns="http://www.w3.org/2000/svg"
                    [wrapper]="gradientWrapper ? gradientWrapper : undefined"
                    [hsva]="hsva"
                    [backgroundColor]="contrastTool"
                    [style]="'position: absolute; overflow: visible; pointer-events: none; left: 0px; top: 0px;'">
                </svg>
            </div>
            <div [ngClass]="{
                    'k-hsv-controls': true,
                    'k-sliders-wrap-clearable': clearButton,
                    'k-vstack': adaptiveMode,
                    'k-hstack': !adaptiveMode
                }">
                <button
                    kendoButton
                    *ngIf="clearButton"
                    class="k-clear-color"
                    fillMode="flat"
                    icon="droplet-slash"
                    [svgIcon]="dropletSlashIcon"
                    [size]="size"
                    (click)="reset()"
                    (keydown.enter)="reset()"
                    (keydown.space)="reset()"
                    [attr.aria-label]="clearButtonTitle"
                    [attr.title]="clearButtonTitle"
                    [tabindex]="innerTabIndex.toString()"
                    [style]="'position: absolute; top: 0; left: 50%; transform: translateX(-50%);'"
                >
                </button>
                <kendo-slider
                    [ngClass]="{'k-align-self-end': clearButton}"
                    [style.height.px]="clearButton ? '140' : null"
                    class="k-hue-slider k-colorgradient-slider"
                    [dragHandleTitle]="hueSliderTitle"
                    [tabindex]="innerTabIndex"
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [showButtons]="false"
                    tickPlacement="none"
                    [vertical]="!adaptiveMode"
                    [min]="0"
                    [max]="360"
                    [value]="hsva.value.h"
                    [smallStep]="5"
                    [largeStep]="10"
                    (valueChange)="handleHueSliderChange($event)"
                >
                </kendo-slider>
                <kendo-slider
                    *ngIf="opacity"
                    #alphaSlider
                    [tabindex]="innerTabIndex"
                    [ngClass]="{'k-align-self-end': clearButton}"
                    [style.height.px]="clearButton ? '140' : null"
                    class="k-alpha-slider k-colorgradient-slider"
                    [dragHandleTitle]="opacitySliderTitle"
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [showButtons]="false"
                    tickPlacement="none"
                    [vertical]="!adaptiveMode"
                    [min]="0"
                    [max]="100"
                    [smallStep]="1"
                    [largeStep]="10"
                    [value]="alphaSliderValue"
                    (valueChange)="handleAlphaSliderChange($event)"
                >
                </kendo-slider>
            </div>
        </div>
        <kendo-colorinput  #inputs
            [tabindex]="innerTabIndex"
            [opacity]="opacity"
            [size]="size"
            [formatView]="format"
            [value]="value"
            [disabled]="disabled"
            [readonly]="readonly"
            (valueChange)="handleInputsValueChange($event)"
            (tabOut)="gradientDragHandle.focus()"
        >
        </kendo-colorinput>
        <div class="k-colorgradient-color-contrast k-vbox"
            *ngIf="contrastToolVisible"
            kendoContrastTool
            [value]="value"
            [ratio]="contrastTool">
        </div>
    `,
      standalone: true,
      imports: [LocalizedColorPickerMessagesDirective, DraggableDirective, NgIf, ColorContrastSvgComponent, ButtonComponent, SliderComponent, NgClass, ColorInputComponent, ContrastComponent]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }, {
      type: LocalizationService
    }, {
      type: Injector
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-colorgradient"]
    }],
    readonlyAttribute: [{
      type: HostBinding,
      args: ["attr.aria-readonly"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    gradientId: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    hostTabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    ariaRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    isControlInvalid: [{
      type: HostBinding,
      args: ["attr.aria-invalid"]
    }],
    isDisabled: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    enterHandler: [{
      type: HostListener,
      args: ["keydown.enter", ["$event"]]
    }],
    escapeHandler: [{
      type: HostListener,
      args: ["keydown.escape", ["$event"]]
    }],
    focusHandler: [{
      type: HostListener,
      args: ["focusin", ["$event"]]
    }],
    adaptiveMode: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    opacity: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    clearButton: [{
      type: Input
    }],
    delay: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    contrastTool: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    gradientSliderStep: [{
      type: Input
    }],
    gradientSliderSmallStep: [{
      type: Input
    }],
    gradientDragHandle: [{
      type: ViewChild,
      args: ["gradientDragHandle"]
    }],
    inputs: [{
      type: ViewChild,
      args: ["inputs"]
    }],
    alphaSlider: [{
      type: ViewChild,
      args: ["alphaSlider"]
    }],
    gradientWrapper: [{
      type: ViewChild,
      args: ["gradientWrapper"]
    }],
    hsvRectangle: [{
      type: ViewChild,
      args: ["hsvRectangle"]
    }]
  });
})();
var ColorPaletteLocalizationService = class _ColorPaletteLocalizationService extends LocalizationService {
  flatColorPickerLocalization;
  constructor(prefix, messageService, _rtl, flatColorPickerLocalization) {
    super(prefix, messageService, _rtl);
    this.flatColorPickerLocalization = flatColorPickerLocalization;
  }
  get(shortKey) {
    if (this.flatColorPickerLocalization) {
      return this.flatColorPickerLocalization.get(shortKey);
    }
    return super.get(shortKey);
  }
  static ɵfac = function ColorPaletteLocalizationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorPaletteLocalizationService)(ɵɵinject(L10N_PREFIX), ɵɵinject(MessageService, 8), ɵɵinject(RTL, 8), ɵɵinject(FlatColorPickerLocalizationService, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ColorPaletteLocalizationService,
    factory: _ColorPaletteLocalizationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorPaletteLocalizationService, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [L10N_PREFIX]
      }]
    }, {
      type: MessageService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [RTL]
      }]
    }, {
      type: FlatColorPickerLocalizationService,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [FlatColorPickerLocalizationService]
      }]
    }];
  }, null);
})();
var PALETTEPRESETS = {
  basic: {
    colors: "000000,7f7f7f,880015,ed1c24,ff7f27,fff200,22b14c,00a2e8,3f48cc,a349a4,ffffff,c3c3c3,b97a57,ffaec9,ffc90e,efe4b0,b5e61d,99d9ea,7092be,c8bfe7",
    columns: 10
  },
  office: {
    colors: "ffffff, 000000, e6e6e6, 435569, 4371c4, ed7e32, a5a4a5, febf04, 5a9bd5, 71ae48, f2f2f3, 7f7f7f, d1cece, d5dde3, dae1f4, fce5d4, deeded, fff2cc, deeaf6, e1efd9, d7d8d8, 585959, aeabab, adbaca, b4c5e7, f6caac, dbdbdb, ffe498, bcd6ee, c5e0b2, bfbfc0, 3f3f3f, 767070, 8595b1, 8fabdb, f5b183, c9c8c9, fed965, 9bc4e5, a8d08d, a5a5a6, 262625, 393939, 334050, 2e5496, c45a11, 7b7b7a, bf9000, 2f75b5, 548235, 7f7f7f, 0b0c0c, 161616, 222a34, 203764, 843d0b, 525252, 7f6000, 1d4d79, 375623",
    columns: 10
  },
  apex: {
    colors: "ffffff, 000000, c9c2d1, 69676d, ceb966, 9cb084, 6bb1c9, 6585cf, 7e6bc9, a379bb, f2f2f2, 7f7f7f, f4f2f5, e0e0e2, f5f1e0, ebefe6, e1eff4, e0e6f5, e5e1f4, ece4f1, d8d8d8, 595959, e9e6ec, c2c1c5, ebe3c1, d7dfcd, c3dfe9, c1ceeb, cbc3e9, dac9e3, bfbfbf, 3f3f3f, dedae3, a4a3a8, e1d5a3, c3cfb5, a6d0de, a2b5e2, b1a6de, c7aed6, a5a5a5, 262626, 9688a5, 4e4d51, ae9638, 758c5a, 3d8da9, 365bb0, 533da9, 7d4d99, 7f7f7f, 0c0c0c, 635672, 343336, 746425, 4e5d3c, 295e70, 243c75, 372970, 533366",
    columns: 10
  },
  austin: {
    colors: "ffffff, 000000, caf278, 3e3d2d, 94c600, 71685a, ff6700, 909465, 956b43, fea022, f2f2f2, 7f7f7f, f4fce4, dddcd0, efffc0, e3e1dc, ffe0cb, e8e9df, ece1d6, feecd2, d8d8d8, 595959, e9f9c9, bbb9a1, dfff82, c8c3ba, ffc299, d2d4c0, dac3ad, fed9a6, bfbfbf, 3f3f3f, dff7ae, ada598, cfff43, ada598, ffa365, bcbfa1, c8a585, fec67a, a5a5a5, 262626, a9ea25, 2e2d21, 6f9400, 544e43, bf4d00, 6c6f4b, 6f5032, d77b00, 7f7f7f, 0c0c0c, 74a50f, 1f1e16, 4a6300, 38342d, 7f3300, 484a32, 4a3521, 8f5200",
    columns: 10
  },
  clarity: {
    colors: "ffffff, 292934, f3f2dc, d2533c, 93a299, ad8f67, 726056, 4c5a6a, 808da0, 79463d, f2f2f2, e7e7ec, e7e5b9, f6dcd8, e9ecea, eee8e0, e4dedb, d8dde3, e5e8ec, e9d6d3, d8d8d8, c4c4d1, d5d185, edbab1, d3d9d6, ded2c2, c9beb8, b2bcc8, ccd1d9, d3aea7, bfbfbf, 8a8aa3, aca73b, e4978a, bec7c1, cdbba3, af9e94, 8c9bac, b2bac6, bd857c, a5a5a5, 56566e, 56531d, a43925, 6b7c72, 866b48, 554840, 39434f, 5c697b, 5a342d, 7f7f7f, 3b3b4b, 22210b, 6d2619, 47534c, 594730, 39302b, 262d35, 3d4652, 3c231e",
    columns: 10
  },
  slipstream: {
    colors: "ffffff, 000000, b4dcfa, 212745, 4e67c8, 5eccf3, a7ea52, 5dceaf, ff8021, f14124, f2f2f2, 7f7f7f, 8bc9f7, c7cce4, dbe0f4, def4fc, edfadc, def5ef, ffe5d2, fcd9d3, d8d8d8, 595959, 4facf3, 909aca, b8c2e9, beeafa, dbf6b9, beebdf, ffcca6, f9b3a7, bfbfbf, 3f3f3f, 0d78c9, 5967af, 94a3de, 9ee0f7, caf297, 9de1cf, ffb279, f68d7b, a5a5a5, 262626, 063c64, 181d33, 31479f, 11b2eb, 81d319, 34ac8b, d85c00, c3260c, 7f7f7f, 0c0c0c, 021828, 101322, 202f6a, 0b769c, 568c11, 22725c, 903d00, 821908",
    columns: 10
  },
  metro: {
    colors: "ffffff, 000000, d6ecff, 4e5b6f, 7fd13b, ea157a, feb80a, 00addc, 738ac8, 1ab39f, f2f2f2, 7f7f7f, a7d6ff, d9dde4, e5f5d7, fad0e4, fef0cd, c5f2ff, e2e7f4, c9f7f1, d8d8d8, 595959, 60b5ff, b3bcca, cbecb0, f6a1c9, fee29c, 8be6ff, c7d0e9, 94efe3, bfbfbf, 3f3f3f, 007dea, 8d9baf, b2e389, f272af, fed46b, 51d9ff, aab8de, 5fe7d5, a5a5a5, 262626, 003e75, 3a4453, 5ea226, af0f5b, c58c00, 0081a5, 425ea9, 138677, 7f7f7f, 0c0c0c, 00192e, 272d37, 3f6c19, 750a3d, 835d00, 00566e, 2c3f71, 0c594f",
    columns: 10
  },
  flow: {
    colors: "ffffff, 000000, dbf5f9, 04617b, 0f6fc6, 009dd9, 0bd0d9, 10cf9b, 7cca62, a5c249, f2f2f2, 7f7f7f, b2e9f2, b4ecfc, c7e2fa, c4eeff, c9fafc, c9faed, e4f4df, edf2da, d8d8d8, 595959, 76d9e8, 6adafa, 90c6f6, 89deff, 93f5f9, 94f6db, cae9c0, dbe6b6, bfbfbf, 3f3f3f, 21b2c8, 20c8f7, 59a9f2, 4fceff, 5df0f6, 5ff2ca, b0dfa0, c9da91, a5a5a5, 262626, 105964, 02485c, 0b5394, 0075a2, 089ca2, 0b9b74, 54a838, 7e9532, 7f7f7f, 0c0c0c, 062328, 01303d, 073763, 004e6c, 05686c, 07674d, 387025, 546321",
    columns: 10
  },
  hardcover: {
    colors: "ffffff, 000000, ece9c6, 895d1d, 873624, d6862d, d0be40, 877f6c, 972109, aeb795, f2f2f2, 7f7f7f, e1dca5, f2e0c6, f0d0c9, f6e6d5, f5f2d8, e7e5e1, fbc7bc, eef0e9, d8d8d8, 595959, d0c974, e6c28d, e2a293, eeceaa, ece5b2, cfccc3, f78f7a, dee2d4, bfbfbf, 3f3f3f, a29a36, daa454, d4735e, e6b681, e2d88c, b7b2a5, f35838, ced3bf, a5a5a5, 262626, 514d1b, 664515, 65281a, a2641f, a39428, 655f50, 711806, 879464, 7f7f7f, 0c0c0c, 201e0a, 442e0e, 431b11, 6c4315, 6d621a, 433f35, 4b1004, 5a6243",
    columns: 10
  },
  trek: {
    colors: "ffffff, 000000, fbeec9, 4e3b30, f0a22e, a5644e, b58b80, c3986d, a19574, c17529, f2f2f2, 7f7f7f, f7e09e, e1d6cf, fcecd5, eddfda, f0e7e5, f3eae1, ece9e3, f5e3d1, d8d8d8, 595959, f3cc5f, c4ad9f, f9d9ab, dcc0b6, e1d0cc, e7d5c4, d9d4c7, ebc7a3, bfbfbf, 3f3f3f, d29f0f, a78470, f6c781, cba092, d2b9b2, dbc1a7, c6bfab, e1ac76, a5a5a5, 262626, 694f07, 3a2c24, c87d0e, 7b4b3a, 926255, a17242, 7b7153, 90571e, 7f7f7f, 0c0c0c, 2a1f03, 271d18, 855309, 523226, 614138, 6b4c2c, 524b37, 603a14",
    columns: 10
  },
  verve: {
    colors: "ffffff, 000000, d2d2d2, 666666, ff388c, e40059, 9c007f, 68007f, 005bd3, 00349e, f2f2f2, 7f7f7f, bdbdbd, e0e0e0, ffd7e8, ffc6dc, ffb8f1, f1b2ff, c3dcff, b8cfff, d8d8d8, 595959, 9d9d9d, c1c1c1, ffafd1, ff8eba, ff71e4, e365ff, 87baff, 72a0ff, bfbfbf, 3f3f3f, 696969, a3a3a3, ff87ba, ff5597, ff2ad7, d519ff, 4b98ff, 2b71ff, a5a5a5, 262626, 343434, 4c4c4c, e90062, ab0042, 75005f, 4e005f, 00449e, 002676, 7f7f7f, 0c0c0c, 151515, 333333, 9b0041, 72002c, 4e003f, 34003f, 002d69, 00194f",
    columns: 10
  },
  monochrome: {
    colors: "000000, 1a1a1a, 333333, 4d4d4d, 666666, 808080, 999999, b3b3b3, cccccc, e6e6e6, f2f2f2, ffffff",
    columns: 12
  },
  accessible: {
    colors: "black, grey, darkred, red, darkorange, gold, green, blue, darkblue, purple, white, darkgrey, saddlebrown, pink, orange, yellow, lightgreen, lightskyblue, lightblue, mediumpurple",
    columns: 10
  }
};
var ColorPaletteService = class _ColorPaletteService {
  colorRows = [];
  setColorMatrix(palette, columns) {
    this.colorRows = [];
    if (!(isPresent5(palette) && palette.length)) {
      return;
    }
    columns = columns || palette.length;
    for (let start = 0; start < palette.length; start += columns) {
      const row = palette.slice(start, columns + start);
      this.colorRows.push(row);
    }
  }
  getCellCoordsFor(color) {
    if (!isPresent5(color)) {
      return;
    }
    for (let row = 0; row < this.colorRows.length; row++) {
      for (let col = 0; col < this.colorRows[row].length; col++) {
        if (this.colorRows[row][col] === color) {
          return {
            row,
            col
          };
        }
      }
    }
  }
  getColorAt(cellCoords) {
    if (!(isPresent5(cellCoords) && isPresent5(this.colorRows[cellCoords.row]))) {
      return;
    }
    return this.colorRows[cellCoords.row][cellCoords.col];
  }
  getNextCell(current, horizontalStep, verticalStep) {
    if (!(isPresent5(current) && isPresent5(current.row) && isPresent5(current.col))) {
      return {
        row: 0,
        col: 0
      };
    }
    const row = this.clampIndex(current.row + verticalStep, this.colorRows.length - 1);
    const col = this.clampIndex(current.col + horizontalStep, this.colorRows[row].length - 1);
    return {
      row,
      col
    };
  }
  clampIndex(index, max) {
    const minArrayIndex = 0;
    if (index < minArrayIndex) {
      return minArrayIndex;
    }
    if (index > max) {
      return max;
    }
    return index;
  }
  static ɵfac = function ColorPaletteService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorPaletteService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ColorPaletteService,
    factory: _ColorPaletteService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorPaletteService, [{
    type: Injectable
  }], null, null);
})();
var DEFAULT_COLUMNS_COUNT = 10;
var DEFAULT_PRESET = "office";
var DEFAULT_ACCESSIBLE_PRESET = "accessible";
var DEFAULT_SIZE$6 = "medium";
var serial$2 = 0;
var ColorPaletteComponent = class _ColorPaletteComponent {
  host;
  service;
  cdr;
  renderer;
  localizationService;
  ngZone;
  /**
   * @hidden
   */
  direction;
  /**
   * @hidden
   */
  role = "grid";
  /**
   * @hidden
   */
  get activeDescendant() {
    return this.activeCellId;
  }
  /**
   * @hidden
   */
  get paletteId() {
    return this.id;
  }
  /**
   * @hidden
   */
  id = `k-colorpalette-${serial$2++}`;
  /**
   * Specifies the output format of the ColorPaletteComponent.
   * The input value may be in a different format. However, it will be parsed into the output `format`
   * after the component processes it.
   *
   * The supported values are:
   * * (Default) `hex`
   * * `rgba`
   * * `name`
   */
  format = "hex";
  /**
   * Specifies the value of the initially selected color.
   */
  set value(value) {
    this._value = parseColor4(value, this.format);
  }
  get value() {
    return this._value;
  }
  /**
   * Specifies the number of columns that will be displayed.
   * Defaults to `10`.
   */
  set columns(value) {
    const minColumnsCount = 1;
    this._columns = value > minColumnsCount ? value : minColumnsCount;
  }
  get columns() {
    return this._columns;
  }
  /**
   * The color palette that will be displayed.
   *
   * The supported values are:
   * * The name of the predefined palette preset (for example, `office`, `basic`, and `apex`).
   * * A string with comma-separated colors.
   * * A string array.
   */
  set palette(value) {
    if (!isPresent5(value)) {
      value = DEFAULT_PRESET;
    }
    if (typeof value === "string" && isPresent5(PALETTEPRESETS[value])) {
      this.columns = this.columns || PALETTEPRESETS[value].columns;
      value = PALETTEPRESETS[value].colors;
    }
    const colors2 = typeof value === "string" ? value.split(",") : value;
    this._palette = colors2.map((color) => parseColor4(color, this.format, false, false));
  }
  get palette() {
    return this._palette;
  }
  /**
   * The size property specifies the padding of the ColorPalette internal elements.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set size(size) {
    const newSize = size || DEFAULT_SIZE$6;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   */
  set tabindex(value) {
    const tabindex = Number(value);
    const defaultValue = 0;
    this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
  }
  get tabindex() {
    return !this.disabled ? this._tabindex : void 0;
  }
  /**
   * Sets the disabled state of the ColorPalette. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_colorpalette#toc-managing-the-colorpalette-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Sets the read-only state of the ColorPalette.
   *
   * @default false
   */
  readonly = false;
  /**
   * Specifies the size of a color cell. The default tile size depends on the `size` of the component.
   */
  tileSize;
  /**
   * @hidden
   */
  get tileLayout() {
    if (typeof this.tileSize !== "number") {
      return this.tileSize;
    }
    return {
      width: this.tileSize,
      height: this.tileSize
    };
  }
  /**
   * Fires each time the color selection is changed.
   */
  selectionChange = new EventEmitter();
  /**
   * Fires each time the value is changed.
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the user selects a cell with the mouse or presses `Enter`.
   *
   * @hidden
   */
  cellSelection = new EventEmitter();
  /**
   * @hidden
   */
  get colorRows() {
    return this.service.colorRows;
  }
  /**
   * @hidden
   */
  get hostTabindex() {
    return this.tabindex;
  }
  /**
   * @hidden
   */
  hostClasses = true;
  /**
   * @hidden
   */
  get disabledClass() {
    return this.disabled;
  }
  /**
   * @hidden
   */
  get readonlyAttribute() {
    return this.readonly;
  }
  /**
   * @hidden
   */
  activeCellId;
  /**
   * @hidden
   */
  focusedCell;
  /**
   * @hidden
   */
  selectedCell;
  /**
   * @hidden
   */
  focusInComponent;
  /**
   * @hidden
   */
  uniqueId = guid();
  selection;
  _size = "medium";
  _value;
  _columns;
  _palette;
  _tabindex = 0;
  subs = new Subscription();
  dynamicRTLSubscription;
  constructor(host, service, cdr, renderer, localizationService, ngZone) {
    this.host = host;
    this.service = service;
    this.cdr = cdr;
    this.renderer = renderer;
    this.localizationService = localizationService;
    this.ngZone = ngZone;
    validatePackage(packageMetadata5);
    this.dynamicRTLSubscription = localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
  }
  ngOnInit() {
    if (this.colorRows.length === 0) {
      const defaultPreset = this.format !== "name" ? DEFAULT_PRESET : DEFAULT_ACCESSIBLE_PRESET;
      this.palette = this.palette || defaultPreset;
      this.setRows();
    }
    const elem = this.host.nativeElement;
    this.subs.add(this.renderer.listen(elem, "keydown", (event) => this.handleKeydown(event)));
    this.subs.add(this.renderer.listen(elem, "focus", () => this.handleFocus()));
    this.subs.add(this.renderer.listen(elem, "blur", () => this.handleHostBlur()));
  }
  ngAfterViewInit() {
    const stylingInputs = ["size"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
    this.setHostElementAriaLabel();
    if (this.value) {
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        this.selectCell(this.value);
      });
    }
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
    if (this.dynamicRTLSubscription) {
      this.dynamicRTLSubscription.unsubscribe();
    }
  }
  ngOnChanges(changes) {
    if (changes["palette"] || changes["columns"]) {
      this.setRows();
    }
    if (changes["palette"] || changes["value"] || changes["columns"]) {
      this.selectCell(this.value);
      this.setHostElementAriaLabel();
    }
  }
  /**
   * @hidden
   */
  handleKeydown(event) {
    const isRTL = this.direction === "rtl";
    switch (event.keyCode) {
      case Keys.ArrowDown:
        this.handleCellNavigation(0, 1);
        break;
      case Keys.ArrowUp:
        this.handleCellNavigation(0, -1);
        break;
      case Keys.ArrowRight:
        this.handleCellNavigation(isRTL ? -1 : 1, 0);
        break;
      case Keys.ArrowLeft:
        this.handleCellNavigation(isRTL ? 1 : -1, 0);
        break;
      case Keys.Enter:
        this.handleEnter();
        break;
      default:
        return;
    }
    event.preventDefault();
  }
  /**
   * @hidden
   */
  handleFocus() {
    if (!this.focusInComponent) {
      this.focus();
    }
  }
  /**
   * @hidden
   */
  handleHostBlur() {
    this.notifyNgTouched();
    this.handleCellFocusOnBlur();
  }
  /**
   * @hidden
   */
  handleCellSelection(value, focusedCell) {
    if (this.readonly) {
      return;
    }
    this.selectedCell = focusedCell;
    this.focusedCell = this.selectedCell;
    this.focusInComponent = true;
    const parsedColor = parseColor4(value, this.format, false, false);
    this.cellSelection.emit(parsedColor);
    this.handleValueChange(parsedColor);
    if (this.selection !== parsedColor) {
      this.selection = parsedColor;
      this.selectionChange.emit(parsedColor);
    }
    if (focusedCell) {
      this.activeCellId = `k-${this.selectedCell.row}-${this.selectedCell.col}-${this.uniqueId}`;
    }
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value;
    this.selectCell(value);
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.notifyNgChanged = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.notifyNgTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.cdr.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * @hidden
   */
  focus() {
    this.host.nativeElement.focus();
    if (!this.focusedCell && !this.readonly && !this.disabled) {
      this.focusedCell = {
        row: 0,
        col: 0
      };
      this.activeCellId = `k-${this.focusedCell.row}-${this.focusedCell.col}-${this.uniqueId}`;
    }
  }
  /**
   * @hidden
   * Used by the FloatingLabel to determine if the component is empty.
   */
  isEmpty() {
    return false;
  }
  /**
   * Clears the color value of the ColorPalette.
   */
  reset() {
    this.focusedCell = null;
    if (isPresent5(this.value)) {
      this.handleValueChange(void 0);
    }
    this.selectedCell = void 0;
  }
  handleValueChange(color) {
    if (this.value === color) {
      return;
    }
    this.value = color;
    this.valueChange.emit(color);
    this.notifyNgChanged(color);
    this.setHostElementAriaLabel();
  }
  handleCellFocusOnBlur() {
    this.focusInComponent = false;
    this.focusedCell = this.selectedCell;
  }
  selectCell(value) {
    const parsedColor = parseColor4(value, "hex");
    this.selectedCell = this.service.getCellCoordsFor(parsedColor);
    this.focusedCell = this.selectedCell;
  }
  setRows() {
    if (!isPresent5(this.palette)) {
      return;
    }
    this.columns = this.columns || DEFAULT_COLUMNS_COUNT;
    this.service.setColorMatrix(this.palette, this.columns);
  }
  handleCellNavigation(horizontalStep, verticalStep) {
    if (this.readonly) {
      return;
    }
    this.focusedCell = this.service.getNextCell(this.focusedCell, horizontalStep, verticalStep);
    this.focusInComponent = true;
    if (this.focusedCell) {
      this.activeCellId = `k-${this.focusedCell.row}-${this.focusedCell.col}-${this.uniqueId}`;
    }
  }
  setHostElementAriaLabel() {
    const parsed = parseColor4(this.value, this.format);
    this.renderer.setAttribute(this.host.nativeElement, "aria-label", `${this.value ? parsed : this.localizationService.get("colorPaletteNoColor")}`);
  }
  handleEnter() {
    if (!isPresent5(this.focusedCell)) {
      return;
    }
    const selectedColor = this.service.getColorAt(this.focusedCell);
    this.handleCellSelection(selectedColor, this.focusedCell);
  }
  handleClasses(value, input) {
    const elem = this.host.nativeElement;
    const classes = getStylingClasses2("colorpalette", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  notifyNgTouched = () => {
  };
  notifyNgChanged = () => {
  };
  static ɵfac = function ColorPaletteComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorPaletteComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ColorPaletteService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColorPaletteComponent,
    selectors: [["kendo-colorpalette"]],
    hostVars: 13,
    hostBindings: function ColorPaletteComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction)("role", ctx.role)("aria-activedescendant", ctx.activeDescendant)("id", ctx.paletteId)("tabindex", ctx.hostTabindex)("aria-disabled", ctx.disabledClass)("aria-readonly", ctx.readonlyAttribute);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-colorpalette", ctx.hostClasses)("k-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      id: "id",
      format: "format",
      value: "value",
      columns: "columns",
      palette: "palette",
      size: "size",
      tabindex: "tabindex",
      disabled: "disabled",
      readonly: "readonly",
      tileSize: "tileSize"
    },
    outputs: {
      selectionChange: "selectionChange",
      valueChange: "valueChange",
      cellSelection: "cellSelection"
    },
    exportAs: ["kendoColorPalette"],
    features: [ɵɵProvidersFeature([{
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _ColorPaletteComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _ColorPaletteComponent)
    }, ColorPaletteService, ColorPaletteLocalizationService, {
      provide: LocalizationService,
      useExisting: ColorPaletteLocalizationService
    }, {
      provide: L10N_PREFIX,
      useValue: "kendo.colorpalette"
    }]), ɵɵNgOnChangesFeature],
    decls: 4,
    vars: 1,
    consts: () => {
      let i18n_27;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_27 = goog.getMsg("Colorpalette no color chosen");
        i18n_27 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_27;
      } else {
        i18n_27 = $localize`:kendo.colorpalette.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty.:Colorpalette no color chosen`;
      }
      return [["kendoColorPaletteLocalizedMessages", "", "colorPaletteNoColor", i18n_27], ["role", "presentation", 1, "k-colorpalette-table"], ["role", "row", 4, "ngFor", "ngForOf"], ["role", "row"], ["role", "gridcell", "class", "k-colorpalette-tile", 3, "k-selected", "k-focus", "id", "ngStyle", "click", 4, "ngFor", "ngForOf"], ["role", "gridcell", 1, "k-colorpalette-tile", 3, "click", "id", "ngStyle"]];
    },
    template: function ColorPaletteComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
        ɵɵelementStart(1, "table", 1)(2, "tbody");
        ɵɵtemplate(3, ColorPaletteComponent_tr_3_Template, 2, 1, "tr", 2);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵproperty("ngForOf", ctx.colorRows);
      }
    },
    dependencies: [LocalizedColorPickerMessagesDirective, NgForOf, NgStyle],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorPaletteComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoColorPalette",
      selector: "kendo-colorpalette",
      providers: [{
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => ColorPaletteComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => ColorPaletteComponent)
      }, ColorPaletteService, ColorPaletteLocalizationService, {
        provide: LocalizationService,
        useExisting: ColorPaletteLocalizationService
      }, {
        provide: L10N_PREFIX,
        useValue: "kendo.colorpalette"
      }],
      template: `
        <ng-container kendoColorPaletteLocalizedMessages
            i18n-colorPaletteNoColor="kendo.colorpalette.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty."
            colorPaletteNoColor="Colorpalette no color chosen">
        </ng-container>
        <table role="presentation" class="k-colorpalette-table">
            <tbody>
                <tr *ngFor="let row of colorRows; let rowIndex = index" role="row">
                    <td *ngFor="let color of row; let colIndex = index"
                        role="gridcell"
                        [class.k-selected]="selectedCell?.row === rowIndex && selectedCell?.col === colIndex"
                        [class.k-focus]="focusInComponent && focusedCell?.row === rowIndex && focusedCell?.col === colIndex"
                        [attr.aria-selected]="selectedCell?.row === rowIndex && selectedCell?.col === colIndex ? 'true' : undefined"
                        [attr.aria-label]="color"
                        class="k-colorpalette-tile"
                        [id]="'k-' + rowIndex + '-' + colIndex + '-' + uniqueId"
                        [attr.value]="color"
                        (click)="handleCellSelection(color, { row: rowIndex, col: colIndex })"
                        [ngStyle]="{
                            backgroundColor: color,
                            width: tileLayout?.width + 'px',
                            height: tileLayout?.height + 'px',
                            minWidth: tileLayout?.width + 'px'
                        }">
                    </td>
                </tr>
            </tbody>
        </table>
    `,
      standalone: true,
      imports: [LocalizedColorPickerMessagesDirective, NgForOf, NgStyle]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ColorPaletteService
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }, {
      type: LocalizationService
    }, {
      type: NgZone
    }];
  }, {
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    activeDescendant: [{
      type: HostBinding,
      args: ["attr.aria-activedescendant"]
    }],
    paletteId: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    id: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    palette: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    tileSize: [{
      type: Input
    }],
    selectionChange: [{
      type: Output
    }],
    valueChange: [{
      type: Output
    }],
    cellSelection: [{
      type: Output
    }],
    hostTabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-colorpalette"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }, {
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    readonlyAttribute: [{
      type: HostBinding,
      args: ["attr.aria-readonly"]
    }]
  });
})();
var FlatColorPickerService = class _FlatColorPickerService {
  getPaletteSettings(settings, format3) {
    const defaultPreset = format3 !== "name" ? DEFAULT_PRESET$1 : DEFAULT_ACCESSIBLE_PRESET$1;
    const settingsPalette = settings.palette;
    const presetColumns = typeof settingsPalette === "string" && PALETTEPRESETS[settingsPalette] ? PALETTEPRESETS[settingsPalette].columns : void 0;
    return {
      palette: settingsPalette || defaultPreset,
      tileSize: settings.tileSize,
      columns: settings.columns || presetColumns || 10
    };
  }
  paletteTileLayout(tileSize) {
    if (typeof tileSize === "number") {
      return {
        width: tileSize,
        height: tileSize
      };
    }
    return {
      width: tileSize?.width ? tileSize?.width : tileSize?.height,
      height: tileSize?.height ? tileSize?.height : tileSize?.width
    };
  }
  static ɵfac = function FlatColorPickerService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FlatColorPickerService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FlatColorPickerService,
    factory: _FlatColorPickerService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FlatColorPickerService, [{
    type: Injectable
  }], null, null);
})();
var ColorPickerCancelEvent = class extends PreventableEvent {
  /**
   * The DOM event that triggered the `cancel` event.
   */
  originalEvent;
  constructor(originalEvent) {
    super();
    this.originalEvent = originalEvent;
  }
};
var ColorPickerCloseEvent = class extends PreventableEvent {
};
var ColorPickerOpenEvent = class extends PreventableEvent {
};
var ActiveColorClickEvent = class {
  color;
  openPrevented = false;
  /**
   * @hidden
   * @param color Represents the current value of the ColorPicker.
   */
  constructor(color) {
    this.color = color;
  }
  /**
   * Prevents the opening of the popup.
   */
  preventOpen() {
    this.openPrevented = true;
  }
  /**
   * Returns `true` if the popup opening is prevented by any of its subscribers.
   *
   * @returns - Returns `true` if the open action was prevented. Otherwise, returns `false`.
   */
  isOpenPrevented() {
    return this.openPrevented;
  }
};
var FlatColorPickerHeaderComponent = class _FlatColorPickerHeaderComponent {
  localizationService;
  renderer;
  hostClasses = true;
  clearButton;
  activeView;
  views;
  preview;
  innerTabIndex = -1;
  value;
  selection;
  size;
  viewChange = new EventEmitter();
  valuePaneClick = new EventEmitter();
  clearButtonClick = new EventEmitter();
  tabOut = new EventEmitter();
  viewButtonsCollection;
  clearButtonElement;
  dropletSliderIcon = dropletSliderIcon;
  paletteIcon = paletteIcon;
  dropletSlashIcon = dropletSlashIcon;
  constructor(localizationService, renderer) {
    this.localizationService = localizationService;
    this.renderer = renderer;
  }
  ngAfterViewInit() {
    if (this.viewButtonsCollection.length > 0) {
      this.viewButtonsCollection.forEach((button) => {
        const buttonElem = button.nativeElement;
        const isViewActive = buttonElem.getAttribute("aria-pressed") === "true";
        if (isViewActive) {
          this.renderer.addClass(buttonElem, "k-selected");
        }
      });
    }
  }
  onViewButtonClick(view) {
    this.activeView = view;
    this.viewChange.emit(view);
  }
  get viewButtons() {
    return this.views && this.views.indexOf("gradient") >= 0 && this.views.indexOf("palette") >= 0;
  }
  getViewButtonIcon(view) {
    return view === "gradient" ? "color-canvas" : "palette";
  }
  getViewButtonsSVGIcon(view) {
    return view === "gradient" ? this.dropletSliderIcon : this.paletteIcon;
  }
  getText(text) {
    return this.localizationService.get(text);
  }
  onHeaderTabOut(ev, index) {
    if (index === 0) {
      ev.preventDefault();
      this.tabOut.emit(ev);
    }
  }
  static ɵfac = function FlatColorPickerHeaderComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FlatColorPickerHeaderComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FlatColorPickerHeaderComponent,
    selectors: [["", "kendoFlatColorPickerHeader", ""]],
    viewQuery: function FlatColorPickerHeaderComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c37, 5, ElementRef);
        ɵɵviewQuery(_c38, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.clearButtonElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.viewButtonsCollection = _t);
      }
    },
    hostVars: 4,
    hostBindings: function FlatColorPickerHeaderComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-coloreditor-header", ctx.hostClasses)("k-hstack", ctx.hostClasses);
      }
    },
    inputs: {
      clearButton: "clearButton",
      activeView: "activeView",
      views: "views",
      preview: "preview",
      innerTabIndex: "innerTabIndex",
      value: "value",
      selection: "selection",
      size: "size"
    },
    outputs: {
      viewChange: "viewChange",
      valuePaneClick: "valuePaneClick",
      clearButtonClick: "clearButtonClick",
      tabOut: "tabOut"
    },
    attrs: _c39,
    decls: 6,
    vars: 3,
    consts: [["viewButtons", ""], ["clearButton", ""], [1, "k-coloreditor-header-actions", "k-hstack"], ["class", "k-button-group k-button-group-flat", "role", "group", 4, "ngIf"], [1, "k-spacer"], ["kendoButton", "", "type", "button", "fillMode", "flat", "icon", "reset-color", "class", "k-coloreditor-reset", 3, "tabindex", "size", "svgIcon", "click", 4, "ngIf"], ["class", "k-coloreditor-preview k-vstack", "aria-hidden", "true", 4, "ngIf"], ["role", "group", 1, "k-button-group", "k-button-group-flat"], ["kendoButton", "", "type", "button", "fillMode", "flat", 3, "tabindex", "icon", "svgIcon", "size", "ngClass", "click", "keydown.shift.tab", 4, "ngFor", "ngForOf"], ["kendoButton", "", "type", "button", "fillMode", "flat", 3, "click", "keydown.shift.tab", "tabindex", "icon", "svgIcon", "size", "ngClass"], ["kendoButton", "", "type", "button", "fillMode", "flat", "icon", "reset-color", 1, "k-coloreditor-reset", 3, "click", "tabindex", "size", "svgIcon"], ["aria-hidden", "true", 1, "k-coloreditor-preview", "k-vstack"], [1, "k-coloreditor-preview-color", "k-color-preview"], [1, "k-coloreditor-current-color", "k-color-preview", 3, "click"]],
    template: function FlatColorPickerHeaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 2);
        ɵɵtemplate(1, FlatColorPickerHeaderComponent_div_1_Template, 2, 1, "div", 3);
        ɵɵelementEnd();
        ɵɵelement(2, "div", 4);
        ɵɵelementStart(3, "div", 2);
        ɵɵtemplate(4, FlatColorPickerHeaderComponent_button_4_Template, 2, 5, "button", 5)(5, FlatColorPickerHeaderComponent_div_5_Template, 3, 6, "div", 6);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.viewButtons);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.clearButton);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.preview);
      }
    },
    dependencies: [NgIf, NgForOf, ButtonComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FlatColorPickerHeaderComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoFlatColorPickerHeader]",
      template: `
        <div class="k-coloreditor-header-actions k-hstack">
            <div 
                *ngIf="viewButtons" 
                class="k-button-group k-button-group-flat"
                role="group"
            >
                <button 
                    *ngFor="let view of views; let i = index;"
                    kendoButton
                    type="button"
                    #viewButtons
                    fillMode="flat"
                    [tabindex]="innerTabIndex.toString()"
                    (click)="onViewButtonClick(view)"
                    [icon]="getViewButtonIcon(view)"
                    [svgIcon]="getViewButtonsSVGIcon(view)"
                    (keydown.shift.tab)="onHeaderTabOut($event, i)"
                    [size]="size"
                    [attr.title]="getText(view === 'gradient' ? 'gradientView' : 'paletteView')"
                    [attr.aria-label]="getText(view === 'gradient' ? 'gradientView' : 'paletteView')"
                    [attr.aria-pressed]="activeView === view"
                    [ngClass]="activeView === view ? 'k-selected' : ''">
                </button>
            </div>
        </div>
        <div class="k-spacer"></div>
        <div class="k-coloreditor-header-actions k-hstack">
            <button
                kendoButton
                type="button"
                [tabindex]="innerTabIndex.toString()"
                *ngIf="clearButton"
                #clearButton
                [size]="size"
                fillMode="flat"
                icon="reset-color"
                [svgIcon]="dropletSlashIcon"
                class="k-coloreditor-reset"
                [attr.aria-label]="getText('clearButton')"
                [attr.title]="getText('clearButton')"
                (click)="clearButtonClick.emit()">
            </button>
            <div class="k-coloreditor-preview k-vstack" *ngIf="preview" aria-hidden="true">
                <span
                    class="k-coloreditor-preview-color k-color-preview"
                    [attr.title]="getText('previewColor')"
                    [style.background-color]="selection">
                </span>
                <span class="k-coloreditor-current-color k-color-preview"
                    [style.background-color]="value"
                    [attr.title]="getText('revertSelection')"
                    (click)="valuePaneClick.emit($event)">
                </span>
            </div>
        </div>
    `,
      standalone: true,
      imports: [NgIf, NgForOf, ButtonComponent, NgClass]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: Renderer2
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-coloreditor-header"]
    }, {
      type: HostBinding,
      args: ["class.k-hstack"]
    }],
    clearButton: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    views: [{
      type: Input
    }],
    preview: [{
      type: Input
    }],
    innerTabIndex: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    selection: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    viewChange: [{
      type: Output
    }],
    valuePaneClick: [{
      type: Output
    }],
    clearButtonClick: [{
      type: Output
    }],
    tabOut: [{
      type: Output
    }],
    viewButtonsCollection: [{
      type: ViewChildren,
      args: ["viewButtons", {
        read: ElementRef
      }]
    }],
    clearButtonElement: [{
      type: ViewChild,
      args: ["clearButton", {
        read: ElementRef
      }]
    }]
  });
})();
var FlatColorPickerActionButtonsComponent = class _FlatColorPickerActionButtonsComponent {
  localizationService;
  hostClasses = true;
  innerTabIndex = -1;
  size;
  actionButtonClick = new EventEmitter();
  tabOut = new EventEmitter();
  firstButton;
  lastButton;
  constructor(localizationService) {
    this.localizationService = localizationService;
  }
  getText(text) {
    return this.localizationService.get(text);
  }
  onActionButtonClick(type, ev) {
    const args = {
      target: type,
      originalEvent: ev
    };
    this.actionButtonClick.emit(args);
  }
  static ɵfac = function FlatColorPickerActionButtonsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FlatColorPickerActionButtonsComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FlatColorPickerActionButtonsComponent,
    selectors: [["", "kendoFlatColorPickerActionButtons", ""]],
    viewQuery: function FlatColorPickerActionButtonsComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c40, 5, ElementRef);
        ɵɵviewQuery(_c41, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.firstButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.lastButton = _t.first);
      }
    },
    hostVars: 6,
    hostBindings: function FlatColorPickerActionButtonsComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-coloreditor-footer", ctx.hostClasses)("k-actions", ctx.hostClasses)("k-actions-horizontal", ctx.hostClasses);
      }
    },
    inputs: {
      innerTabIndex: "innerTabIndex",
      size: "size"
    },
    outputs: {
      actionButtonClick: "actionButtonClick",
      tabOut: "tabOut"
    },
    attrs: _c422,
    decls: 6,
    vars: 8,
    consts: [["first", ""], ["last", ""], ["kendoButton", "", "type", "button", 1, "k-coloreditor-cancel", 3, "click", "size", "tabindex"], ["kendoButton", "", "themeColor", "primary", "type", "button", 1, "k-coloreditor-apply", 3, "click", "keydown.tab", "size", "tabindex"]],
    template: function FlatColorPickerActionButtonsComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "button", 2, 0);
        ɵɵlistener("click", function FlatColorPickerActionButtonsComponent_Template_button_click_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onActionButtonClick("cancel", $event));
        });
        ɵɵtext(2);
        ɵɵelementEnd();
        ɵɵelementStart(3, "button", 3, 1);
        ɵɵlistener("click", function FlatColorPickerActionButtonsComponent_Template_button_click_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onActionButtonClick("apply", $event));
        })("keydown.tab", function FlatColorPickerActionButtonsComponent_Template_button_keydown_tab_3_listener($event) {
          ɵɵrestoreView(_r1);
          $event.preventDefault();
          return ɵɵresetView(ctx.tabOut.emit());
        });
        ɵɵtext(5);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("size", ctx.size)("tabindex", ctx.innerTabIndex.toString());
        ɵɵattribute("title", ctx.getText("cancelButton"));
        ɵɵadvance(2);
        ɵɵtextInterpolate(ctx.getText("cancelButton"));
        ɵɵadvance();
        ɵɵproperty("size", ctx.size)("tabindex", ctx.innerTabIndex.toString());
        ɵɵattribute("title", ctx.getText("applyButton"));
        ɵɵadvance(2);
        ɵɵtextInterpolate(ctx.getText("applyButton"));
      }
    },
    dependencies: [ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FlatColorPickerActionButtonsComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoFlatColorPickerActionButtons]",
      template: `
        <button #first
            kendoButton
            class="k-coloreditor-cancel"
            [size]="size"
            [attr.title]="getText('cancelButton')"
            (click)="onActionButtonClick('cancel', $event)"
            type="button"
            [tabindex]="innerTabIndex.toString()"
        >{{getText('cancelButton')}}</button>
        <button #last
            kendoButton
            themeColor="primary"
            [size]="size"
            class="k-coloreditor-apply"
            [attr.title]="getText('applyButton')"
            (click)="onActionButtonClick('apply', $event)"
            type="button"
            [tabindex]="innerTabIndex.toString()"
            (keydown.tab)="$event.preventDefault(); tabOut.emit();"
        >{{getText('applyButton')}}</button>
    `,
      standalone: true,
      imports: [ButtonComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-coloreditor-footer"]
    }, {
      type: HostBinding,
      args: ["class.k-actions"]
    }, {
      type: HostBinding,
      args: ["class.k-actions-horizontal"]
    }],
    innerTabIndex: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    actionButtonClick: [{
      type: Output
    }],
    tabOut: [{
      type: Output
    }],
    firstButton: [{
      type: ViewChild,
      args: ["first", {
        read: ElementRef
      }]
    }],
    lastButton: [{
      type: ViewChild,
      args: ["last", {
        read: ElementRef
      }]
    }]
  });
})();
var DEFAULT_SIZE$5 = "medium";
var FlatColorPickerComponent = class _FlatColorPickerComponent {
  host;
  service;
  localizationService;
  cdr;
  renderer;
  ngZone;
  injector;
  hostClasses = true;
  get disabledClass() {
    return this.disabled;
  }
  get ariaReadonly() {
    return this.readonly;
  }
  direction;
  get hostTabindex() {
    return this.tabindex?.toString() || "0";
  }
  ariaRole = "textbox";
  get isControlInvalid() {
    return this.control?.invalid?.toString();
  }
  get isDisabled() {
    return this.disabled?.toString() || void 0;
  }
  /**
   * @hidden
   */
  enterHandler(event) {
    if (event.target !== this.host.nativeElement) {
      return;
    }
    event.preventDefault();
    this.internalNavigation = true;
    this.ngZone.onStable.pipe(take(1)).subscribe(() => this.firstFocusable?.focus());
  }
  /**
   * @hidden
   */
  escapeHandler() {
    this.internalNavigation = false;
    this.host.nativeElement.focus();
  }
  /**
   * @hidden
   */
  focusHandler(ev) {
    this.internalNavigation = ev.target !== this.host.nativeElement;
  }
  /**
   * Sets the read-only state of the FlatColorPicker.
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the disabled state of the FlatColorPicker. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_flatcolorpicker#toc-managing-the-flatcolorpicker-disabled-state-in-reactive-forms).
   *
   * @default false
   */
  disabled = false;
  /**
   * Specifies the output format of the FlatColorPicker.
   *
   * If the input value is in a different format, it will be parsed into the specified output `format`.
   *
   * The supported values are:
   * * `rgba` (default)
   * * `hex`
   */
  format = "rgba";
  /**
   * Specifies the initially selected color.
   */
  set value(value) {
    this._value = parseColor4(value, this.format, this.gradientSettings.opacity);
  }
  get value() {
    return this._value;
  }
  /**
   * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   *
   * @default 0
   */
  set tabindex(value) {
    if (isPresent5(value)) {
      const tabindex = Number(value);
      this._tabindex = !isNaN(tabindex) ? tabindex : 0;
    } else {
      this._tabindex = value;
    }
  }
  get tabindex() {
    return !this.disabled ? this._tabindex : void 0;
  }
  /**
   * Specifies whether the FlatColorPicker should display a 'Clear color' button.
   *
   * @default true
   */
  clearButton = true;
  /**
   * Displays `Apply` and `Cancel` action buttons and a color preview pane.
   *
   * When enabled, the component value will not change immediately upon
   * color selection, but only after the `Apply` button is clicked.
   *
   * The `Cancel` button reverts the current selection to its
   * initial state i.e. to the current value.
   *
   * @default true
   */
  preview = true;
  /**
   * Configures the layout of the `Apply` and `Cancel` action buttons.
   * * `start`
   * * `center`
   * * `end` (default)
   * * `stretch`
   */
  actionsLayout = "end";
  /**
   * Sets the initially active view in the FlatColorPicker. The property supports two-way binding.
   * * `gradient` (default)
   * * `palette`
   */
  activeView;
  /**
   * Specifies the views that will be rendered. Default value is gradient and palette.
   */
  views = ["gradient", "palette"];
  /**
   * Configures the gradient view.
   */
  set gradientSettings(value) {
    Object.assign(this._gradientSettings, value);
  }
  get gradientSettings() {
    return this._gradientSettings;
  }
  /**
   * @hidden
   */
  adaptiveMode = false;
  /**
   * Configures the palette view.
   */
  set paletteSettings(value) {
    Object.assign(this._paletteSettings, value);
  }
  get paletteSettings() {
    return this._paletteSettings;
  }
  /**
   * The size property specifies the padding of the FlatColorPicker internal elements.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set size(size) {
    const newSize = size || DEFAULT_SIZE$5;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Fires each time the component value is changed.
   */
  valueChange = new EventEmitter();
  /**
   * Fires when the user cancels the current color selection.
   *
   * The event is emitted on preview pane or on 'Cancel' button click.
   */
  cancel = new EventEmitter();
  /**
   * Fires each time the view is about to change.
   * Used to provide a two-way binding for the `activeView` property.
   */
  activeViewChange = new EventEmitter();
  /**
   * @hidden
   * Fires each time the clear button is clicked.
   */
  clearButtonClick = new EventEmitter();
  /**
   * @hidden
   */
  actionButtonClick = new EventEmitter();
  header;
  headerElement;
  gradient;
  gradientElement;
  palette;
  footer;
  /**
   * @hidden
   */
  selection;
  focused;
  _value;
  _tabindex = 0;
  _gradientSettings = {
    opacity: true,
    delay: 0,
    gradientSliderStep: DRAGHANDLE_MOVE_SPEED,
    gradientSliderSmallStep: DRAGHANDLE_MOVE_SPEED_SMALL_STEP
  };
  _paletteSettings = {};
  dynamicRTLSubscription;
  subscriptions = new Subscription();
  internalNavigation = false;
  _size = "medium";
  control;
  /**
   * @hidden
   */
  get innerTabIndex() {
    return this.internalNavigation ? 0 : -1;
  }
  /**
   * @hidden
   */
  get firstFocusable() {
    if (this.headerHasContent) {
      return this.headerElement.nativeElement.querySelector(".k-button");
    }
    return this.activeView === "gradient" ? this.gradient : this.palette;
  }
  constructor(host, service, localizationService, cdr, renderer, ngZone, injector) {
    this.host = host;
    this.service = service;
    this.localizationService = localizationService;
    this.cdr = cdr;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.injector = injector;
    validatePackage(packageMetadata5);
    this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
  }
  ngOnInit() {
    this.selection = this.value;
    this.control = this.injector.get(NgControl, null);
    this._paletteSettings = this.service.getPaletteSettings(this._paletteSettings, this.format);
    this.setActiveView();
  }
  ngAfterViewInit() {
    const stylingInputs = ["size"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
    this.setHostElementAriaLabel();
    this.initDomEvents();
    this.setSizingVariables();
    this.ngZone.onStable.pipe(take(1)).subscribe(() => this.removeGradientAttributes());
  }
  ngOnChanges(changes) {
    if (isChanged("value", changes)) {
      this.selection = this.value;
      this.setHostElementAriaLabel();
    }
    if (isChanged("paletteSettings", changes)) {
      this.setSizingVariables();
    }
  }
  ngOnDestroy() {
    if (this.dynamicRTLSubscription) {
      this.dynamicRTLSubscription.unsubscribe();
    }
    this.subscriptions.unsubscribe();
  }
  /**
   * @hidden
   */
  focusFirstHeaderButton() {
    if (this.gradientElement.nativeElement === document.activeElement) {
      if (this.headerHasContent && !this.preview) {
        const firstHeaderButton = this.headerElement.nativeElement.querySelector(".k-button");
        firstHeaderButton.focus();
      }
    }
  }
  /**
   * @hidden
   */
  lastFocusable(event) {
    if (this.preview) {
      this.footer.lastButton.nativeElement.focus();
      return;
    }
    event.stopImmediatePropagation();
    const gradient = this.gradientElement?.nativeElement;
    const palette = this.palette?.host.nativeElement;
    this.activeView === "gradient" ? gradient.focus() : palette.focus();
  }
  /**
   * @hidden
   */
  onTab(ev) {
    const {
      shiftKey
    } = ev;
    const nextTabStop = this.preview ? this.footer.firstButton.nativeElement : this.headerHasContent ? findFocusableChild(this.headerElement.nativeElement) : null;
    const previousTabStop = this.headerHasContent ? findFocusableChild(this.headerElement.nativeElement) : this.preview ? this.footer.lastButton.nativeElement : null;
    if (!nextTabStop && !previousTabStop) {
      return;
    }
    ev.preventDefault();
    shiftKey ? previousTabStop?.focus() : nextTabStop?.focus();
  }
  /**
   * @hidden
   */
  get headerHasContent() {
    return this.preview || this.views.length > 1 || this.clearButton;
  }
  /**
   * @hidden
   * Used by the FloatingLabel to determine if the component is empty.
   */
  isEmpty() {
    return false;
  }
  /**
   * Focuses the wrapper of the FlatColorPicker.
   */
  focus() {
    if (this.disabled || this.focused) {
      return;
    }
    this.host.nativeElement.focus();
    this.focused = true;
  }
  /**
   * Blurs the wrapper of the FlatColorPicker.
   */
  blur() {
    if (!this.focused) {
      return;
    }
    this.notifyNgTouched();
    this.host.nativeElement.blur();
    this.focused = false;
  }
  /**
   * Clears the value of the FlatColorPicker.
   */
  reset() {
    if (!isPresent5(this.value)) {
      return;
    }
    this.value = void 0;
    this.notifyNgChanged(void 0);
    this.setHostElementAriaLabel();
  }
  /**
   * @hidden
   */
  onViewChange(view) {
    if (this.activeView === view) {
      return;
    }
    this.activeView = view;
    this.activeViewChange.emit(view);
    this.ngZone.runOutsideAngular(() => {
      setTimeout(() => {
        this[this.activeView]?.focus();
      });
    });
    if (this.activeView === "gradient") {
      this.removeGradientAttributes();
    }
  }
  /**
   * @hidden
   */
  onClearButtonClick() {
    this.resetInnerComponentValue();
    this.clearButtonClick.emit();
  }
  /**
   * @hidden
   */
  handleValueChange(color) {
    this.preview ? this.changeCurrentValue(color) : this.setFlatColorPickerValue(color);
  }
  /**
   * @hidden
   */
  onAction(ev) {
    ev.target === "apply" ? this.setFlatColorPickerValue(this.selection) : this.resetSelection(ev.originalEvent);
    this.actionButtonClick.emit();
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value;
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.notifyNgChanged = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.notifyNgTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.cdr.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * @hidden
   */
  resetSelection(ev) {
    const eventArgs = new ColorPickerCancelEvent(ev);
    this.cancel.emit(eventArgs);
    if (!eventArgs.isDefaultPrevented()) {
      this.selection = this.value;
    }
    this.notifyNgTouched();
  }
  setHostElementAriaLabel() {
    const parsed = parseColor4(this.value, this.format, this.gradientSettings.opacity);
    const ariaLabelValue = `${this.value ? parsed : this.localizationService.get("flatColorPickerNoColor")}`;
    this.renderer.setAttribute(this.host.nativeElement, "aria-label", ariaLabelValue);
  }
  setSizingVariables() {
    const paletteTileSize = this.service.paletteTileLayout(this.paletteSettings.tileSize);
    const element = this.host.nativeElement.querySelector(".k-coloreditor-views.k-vstack");
    const cssProperties = [`--kendo-color-preview-columns: ${this.paletteSettings.columns};`];
    if (paletteTileSize.width) {
      cssProperties.push(`--kendo-color-preview-width: ${paletteTileSize.width}px;`);
    }
    if (paletteTileSize.height) {
      cssProperties.push(`--kendo-color-preview-height: ${paletteTileSize.height}px;`);
    }
    this.renderer.setProperty(element, "style", cssProperties.join(" "));
  }
  changeCurrentValue(color) {
    this.selection = color;
    this.notifyNgTouched();
  }
  resetInnerComponentValue() {
    this.selection = null;
    if (this.gradient) {
      this.gradient.reset();
      return;
    }
    this.palette.reset();
  }
  setFlatColorPickerValue(color) {
    if (this.value === color) {
      return;
    }
    this.value = color;
    this.valueChange.emit(color);
    this.notifyNgChanged(color);
    this.setHostElementAriaLabel();
  }
  setActiveView() {
    if (!isPresent5(this.activeView)) {
      this.activeView = this.views[0];
      return;
    }
    if (isDevMode() && this.views.indexOf(this.activeView) === -1) {
      throw new Error("Invalid configuration: The current activeView is not present in the views collection");
    }
  }
  notifyNgChanged = () => {
  };
  notifyNgTouched = () => {
  };
  initDomEvents() {
    if (!this.host) {
      return;
    }
    const hostElement = this.host.nativeElement;
    this.ngZone.runOutsideAngular(() => {
      this.subscriptions.add(this.renderer.listen(hostElement, "focus", () => {
        this.focused = true;
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "blur", () => {
        this.focused = false;
        this.notifyNgTouched();
      }));
    });
  }
  removeGradientAttributes() {
    this.gradientElement && this.renderer.removeAttribute(this.gradientElement.nativeElement, "role");
    this.gradientElement && this.renderer.removeAttribute(this.gradientElement.nativeElement, "aria-label");
  }
  handleClasses(value, input) {
    const elem = this.host.nativeElement;
    const classes = getStylingClasses2("coloreditor", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  static ɵfac = function FlatColorPickerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FlatColorPickerComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(FlatColorPickerService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Injector));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FlatColorPickerComponent,
    selectors: [["kendo-flatcolorpicker"]],
    viewQuery: function FlatColorPickerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c432, 5);
        ɵɵviewQuery(_c432, 5, ElementRef);
        ɵɵviewQuery(_c44, 5);
        ɵɵviewQuery(_c44, 5, ElementRef);
        ɵɵviewQuery(_c45, 5);
        ɵɵviewQuery(_c46, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.header = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.gradient = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.gradientElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.palette = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footer = _t.first);
      }
    },
    hostVars: 14,
    hostBindings: function FlatColorPickerComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown.enter", function FlatColorPickerComponent_keydown_enter_HostBindingHandler($event) {
          return ctx.enterHandler($event);
        })("keydown.escape", function FlatColorPickerComponent_keydown_escape_HostBindingHandler() {
          return ctx.escapeHandler();
        })("focusin", function FlatColorPickerComponent_focusin_HostBindingHandler($event) {
          return ctx.focusHandler($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("aria-disabled", ctx.isDisabled)("aria-readonly", ctx.ariaReadonly)("dir", ctx.direction)("tabindex", ctx.hostTabindex)("role", ctx.ariaRole)("aria-invalid", ctx.isControlInvalid);
        ɵɵclassProp("k-flatcolorpicker", ctx.hostClasses)("k-coloreditor", ctx.hostClasses)("k-disabled", ctx.disabledClass)("k-readonly", ctx.readonly);
      }
    },
    inputs: {
      readonly: "readonly",
      disabled: "disabled",
      format: "format",
      value: "value",
      tabindex: "tabindex",
      clearButton: "clearButton",
      preview: "preview",
      actionsLayout: "actionsLayout",
      activeView: "activeView",
      views: "views",
      gradientSettings: "gradientSettings",
      adaptiveMode: "adaptiveMode",
      paletteSettings: "paletteSettings",
      size: "size"
    },
    outputs: {
      valueChange: "valueChange",
      cancel: "cancel",
      activeViewChange: "activeViewChange",
      clearButtonClick: "clearButtonClick",
      actionButtonClick: "actionButtonClick"
    },
    exportAs: ["kendoFlatColorPicker"],
    features: [ɵɵProvidersFeature([{
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _FlatColorPickerComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _FlatColorPickerComponent)
    }, FlatColorPickerService, FlatColorPickerLocalizationService, {
      provide: LocalizationService,
      useExisting: FlatColorPickerLocalizationService
    }, {
      provide: L10N_PREFIX,
      useValue: "kendo.flatcolorpicker"
    }]), ɵɵNgOnChangesFeature],
    decls: 6,
    vars: 4,
    consts: () => {
      let i18n_28;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_28 = goog.getMsg("Flatcolorpicker no color chosen");
        i18n_28 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_28;
      } else {
        i18n_28 = $localize`:kendo.flatcolorpicker.flatColorPickerNoColor|The aria-label applied to the FlatColorPicker component when the value is empty.:Flatcolorpicker no color chosen`;
      }
      let i18n_29;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_29 = goog.getMsg("Colorgradient no color chosen");
        i18n_29 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_29;
      } else {
        i18n_29 = $localize`:kendo.flatcolorpicker.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty.:Colorgradient no color chosen`;
      }
      let i18n_30;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_30 = goog.getMsg("Colorpalette no color chosen");
        i18n_30 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_30;
      } else {
        i18n_30 = $localize`:kendo.flatcolorpicker.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty.:Colorpalette no color chosen`;
      }
      let i18n_31;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_31 = goog.getMsg("Choose color");
        i18n_31 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_31;
      } else {
        i18n_31 = $localize`:kendo.flatcolorpicker.colorGradientHandle|The title for the gradient color drag handle chooser.:Choose color`;
      }
      let i18n_32;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_32 = goog.getMsg("Clear value");
        i18n_32 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_32;
      } else {
        i18n_32 = $localize`:kendo.flatcolorpicker.clearButton|The title for the clear button.:Clear value`;
      }
      let i18n_33;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_33 = goog.getMsg("Set hue");
        i18n_33 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_33;
      } else {
        i18n_33 = $localize`:kendo.flatcolorpicker.hueSliderHandle|The title for the hue slider handle.:Set hue`;
      }
      let i18n_34;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_34 = goog.getMsg("Set opacity");
        i18n_34 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_34;
      } else {
        i18n_34 = $localize`:kendo.flatcolorpicker.opacitySliderHandle|The title for the opacity slider handle.:Set opacity`;
      }
      let i18n_35;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_35 = goog.getMsg("Contrast ratio");
        i18n_35 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_35;
      } else {
        i18n_35 = $localize`:kendo.flatcolorpicker.contrastRatio|The contrast ratio message for the contrast tool.:Contrast ratio`;
      }
      let i18n_36;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_36 = goog.getMsg("Color preview");
        i18n_36 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_36;
      } else {
        i18n_36 = $localize`:kendo.flatcolorpicker.previewColor|The message for the color preview pane.:Color preview`;
      }
      let i18n_37;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_37 = goog.getMsg("Revert selection");
        i18n_37 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_37;
      } else {
        i18n_37 = $localize`:kendo.flatcolorpicker.revertSelection|The message for the selected color pane.:Revert selection`;
      }
      let i18n_38;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_38 = goog.getMsg("Gradient view");
        i18n_38 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_38;
      } else {
        i18n_38 = $localize`:kendo.flatcolorpicker.gradientView|The message for the gradient view button.:Gradient view`;
      }
      let i18n_39;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_39 = goog.getMsg("Palette view");
        i18n_39 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_39;
      } else {
        i18n_39 = $localize`:kendo.flatcolorpicker.paletteView|The message for the palette view button.:Palette view`;
      }
      let i18n_40;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_40 = goog.getMsg("Change color format");
        i18n_40 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_40;
      } else {
        i18n_40 = $localize`:kendo.flatcolorpicker.formatButton|The message for the input format toggle button.:Change color format`;
      }
      let i18n_41;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_41 = goog.getMsg("Apply");
        i18n_41 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_41;
      } else {
        i18n_41 = $localize`:kendo.flatcolorpicker.applyButton|The message for the Apply action button.:Apply`;
      }
      let i18n_42;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_42 = goog.getMsg("Cancel");
        i18n_42 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_42;
      } else {
        i18n_42 = $localize`:kendo.flatcolorpicker.cancelButton|The message for the Cancel action button.:Cancel`;
      }
      let i18n_43;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_43 = goog.getMsg("Red channel");
        i18n_43 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_43;
      } else {
        i18n_43 = $localize`:kendo.flatcolorpicker.redChannelLabel|The label of the NumericTextBox representing the red color channel.:Red channel`;
      }
      let i18n_44;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_44 = goog.getMsg("Green channel");
        i18n_44 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_44;
      } else {
        i18n_44 = $localize`:kendo.flatcolorpicker.greenChannelLabel|The label of the NumericTextBox representing the green color channel.:Green channel`;
      }
      let i18n_45;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_45 = goog.getMsg("Blue channel");
        i18n_45 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_45;
      } else {
        i18n_45 = $localize`:kendo.flatcolorpicker.blueChannelLabel|The label of the NumericTextBox representing the blue color channel.:Blue channel`;
      }
      let i18n_46;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_46 = goog.getMsg("Alpha channel");
        i18n_46 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_46;
      } else {
        i18n_46 = $localize`:kendo.flatcolorpicker.alphaChannelLabel|The label of the NumericTextBox representing the alpha color channel.:Alpha channel`;
      }
      let i18n_47;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_47 = goog.getMsg("R");
        i18n_47 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_47;
      } else {
        i18n_47 = $localize`:kendo.flatcolorpicker.redChannelLabel|The label of the NumericTextBox representing the red color channel.:R`;
      }
      let i18n_48;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_48 = goog.getMsg("G");
        i18n_48 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_48;
      } else {
        i18n_48 = $localize`:kendo.flatcolorpicker.greenInputPlaceholder|The placeholder for the green color input.:G`;
      }
      let i18n_49;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_49 = goog.getMsg("B");
        i18n_49 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_49;
      } else {
        i18n_49 = $localize`:kendo.flatcolorpicker.blueInputPlaceholder|The placeholder for the blue color input.:B`;
      }
      let i18n_50;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_50 = goog.getMsg("HEX");
        i18n_50 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_50;
      } else {
        i18n_50 = $localize`:kendo.flatcolorpicker.hexInputPlaceholder|The placeholder for the HEX color input.:HEX`;
      }
      return [["header", ""], ["gradient", ""], ["palette", ""], ["footer", ""], ["kendoFlatColorPickerLocalizedMessages", "", "flatColorPickerNoColor", i18n_28, "colorGradientNoColor", i18n_29, "colorPaletteNoColor", i18n_30, "colorGradientHandle", i18n_31, "clearButton", i18n_32, "hueSliderHandle", i18n_33, "opacitySliderHandle", i18n_34, "contrastRatio", i18n_35, "previewColor", i18n_36, "revertSelection", i18n_37, "gradientView", i18n_38, "paletteView", i18n_39, "formatButton", i18n_40, "applyButton", i18n_41, "cancelButton", i18n_42, "redChannelLabel", i18n_43, "greenChannelLabel", i18n_44, "blueChannelLabel", i18n_45, "alphaChannelLabel", i18n_46, "redChannelLabel", i18n_47, "greenInputPlaceholder", i18n_48, "blueInputPlaceholder", i18n_49, "hexInputPlaceholder", i18n_50], ["kendoFlatColorPickerHeader", "", 3, "innerTabIndex", "clearButton", "activeView", "views", "size", "value", "selection", "preview", "clearButtonClick", "viewChange", "valuePaneClick", "tabOut", 4, "ngIf"], [1, "k-coloreditor-views", "k-vstack"], [3, "tabindex", "value", "size", "adaptiveMode", "format", "opacity", "delay", "contrastTool", "gradientSliderSmallStep", "gradientSliderStep", "readonly", "keydown.tab", "valueChange", 4, "ngIf"], [3, "tabindex", "palette", "size", "columns", "tileSize", "format", "value", "readonly", "valueChange", 4, "ngIf"], ["kendoFlatColorPickerActionButtons", "", 3, "innerTabIndex", "size", "ngClass", "actionButtonClick", "tabOut", 4, "ngIf"], ["kendoFlatColorPickerHeader", "", 3, "clearButtonClick", "viewChange", "valuePaneClick", "tabOut", "innerTabIndex", "clearButton", "activeView", "views", "size", "value", "selection", "preview"], [3, "keydown.tab", "valueChange", "tabindex", "value", "size", "adaptiveMode", "format", "opacity", "delay", "contrastTool", "gradientSliderSmallStep", "gradientSliderStep", "readonly"], [3, "valueChange", "tabindex", "palette", "size", "columns", "tileSize", "format", "value", "readonly"], ["kendoFlatColorPickerActionButtons", "", 3, "actionButtonClick", "tabOut", "innerTabIndex", "size", "ngClass"]];
    },
    template: function FlatColorPickerComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 4);
        ɵɵtemplate(1, FlatColorPickerComponent_div_1_Template, 2, 8, "div", 5);
        ɵɵelementStart(2, "div", 6);
        ɵɵtemplate(3, FlatColorPickerComponent_kendo_colorgradient_3_Template, 2, 11, "kendo-colorgradient", 7)(4, FlatColorPickerComponent_kendo_colorpalette_4_Template, 2, 8, "kendo-colorpalette", 8);
        ɵɵelementEnd();
        ɵɵtemplate(5, FlatColorPickerComponent_div_5_Template, 2, 3, "div", 9);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.headerHasContent);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.activeView === "gradient");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.activeView === "palette");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.preview && !ctx.adaptiveMode);
      }
    },
    dependencies: [LocalizedColorPickerMessagesDirective, NgIf, FlatColorPickerHeaderComponent, ColorGradientComponent, ColorPaletteComponent, FlatColorPickerActionButtonsComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FlatColorPickerComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoFlatColorPicker",
      selector: "kendo-flatcolorpicker",
      providers: [{
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => FlatColorPickerComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => FlatColorPickerComponent)
      }, FlatColorPickerService, FlatColorPickerLocalizationService, {
        provide: LocalizationService,
        useExisting: FlatColorPickerLocalizationService
      }, {
        provide: L10N_PREFIX,
        useValue: "kendo.flatcolorpicker"
      }],
      template: `
        <ng-container kendoFlatColorPickerLocalizedMessages
            i18n-flatColorPickerNoColor="kendo.flatcolorpicker.flatColorPickerNoColor|The aria-label applied to the FlatColorPicker component when the value is empty."
            flatColorPickerNoColor="Flatcolorpicker no color chosen"
            i18n-colorGradientNoColor="kendo.flatcolorpicker.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty."
            colorGradientNoColor="Colorgradient no color chosen"
            i18n-colorPaletteNoColor="kendo.flatcolorpicker.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty."
            colorPaletteNoColor="Colorpalette no color chosen"
            i18n-colorGradientHandle="kendo.flatcolorpicker.colorGradientHandle|The title for the gradient color drag handle chooser."
            colorGradientHandle="Choose color"
            i18n-clearButton="kendo.flatcolorpicker.clearButton|The title for the clear button."
            clearButton="Clear value"
            i18n-hueSliderHandle="kendo.flatcolorpicker.hueSliderHandle|The title for the hue slider handle."
            hueSliderHandle="Set hue"
            i18n-opacitySliderHandle="kendo.flatcolorpicker.opacitySliderHandle|The title for the opacity slider handle."
            opacitySliderHandle="Set opacity"
            i18n-contrastRatio="kendo.flatcolorpicker.contrastRatio|The contrast ratio message for the contrast tool."
            contrastRatio="Contrast ratio"
            i18n-previewColor="kendo.flatcolorpicker.previewColor|The message for the color preview pane."
            previewColor="Color preview"
            i18n-revertSelection="kendo.flatcolorpicker.revertSelection|The message for the selected color pane."
            revertSelection="Revert selection"
            i18n-gradientView="kendo.flatcolorpicker.gradientView|The message for the gradient view button."
            gradientView="Gradient view"
            i18n-paletteView="kendo.flatcolorpicker.paletteView|The message for the palette view button."
            paletteView="Palette view"
            i18n-formatButton="kendo.flatcolorpicker.formatButton|The message for the input format toggle button."
            formatButton="Change color format"
            i18n-applyButton="kendo.flatcolorpicker.applyButton|The message for the Apply action button."
            applyButton="Apply"
            i18n-cancelButton="kendo.flatcolorpicker.cancelButton|The message for the Cancel action button."
            cancelButton="Cancel"
            i18n-redChannelLabel="kendo.flatcolorpicker.redChannelLabel|The label of the NumericTextBox representing the red color channel."
            redChannelLabel="Red channel"
            i18n-greenChannelLabel="kendo.flatcolorpicker.greenChannelLabel|The label of the NumericTextBox representing the green color channel."
            greenChannelLabel="Green channel"
            i18n-blueChannelLabel="kendo.flatcolorpicker.blueChannelLabel|The label of the NumericTextBox representing the blue color channel."
            blueChannelLabel="Blue channel"
            i18n-alphaChannelLabel="kendo.flatcolorpicker.alphaChannelLabel|The label of the NumericTextBox representing the alpha color channel."
            alphaChannelLabel="Alpha channel"
            i18n-redInputPlaceholder="kendo.flatcolorpicker.redInputPlaceholder|The placeholder for the red color input."
            redChannelLabel="R"
            i18n-greenInputPlaceholder="kendo.flatcolorpicker.greenInputPlaceholder|The placeholder for the green color input."
            greenInputPlaceholder="G"
            i18n-blueInputPlaceholder="kendo.flatcolorpicker.blueInputPlaceholder|The placeholder for the blue color input."
            blueInputPlaceholder="B"
            i18n-hexInputPlaceholder="kendo.flatcolorpicker.hexInputPlaceholder|The placeholder for the HEX color input."
            hexInputPlaceholder="HEX">
        </ng-container>
        <div kendoFlatColorPickerHeader
            [innerTabIndex]="innerTabIndex"
            *ngIf="headerHasContent"
            #header
            [clearButton]="clearButton"
            [activeView]="activeView"
            [views]="views"
            [size]="size"
            [value]="value"
            [selection]="selection"
            [preview]="preview"
            (clearButtonClick)="onClearButtonClick()"
            (viewChange)="onViewChange($event)"
            (valuePaneClick)="resetSelection($event)"
            (tabOut)="lastFocusable($event)"></div>
        <div class="k-coloreditor-views k-vstack">
            <kendo-colorgradient #gradient
                [tabindex]="innerTabIndex"
                *ngIf="activeView === 'gradient'"
                [value]="selection"
                [size]="size"
                [adaptiveMode]="adaptiveMode"
                [format]="format"
                [opacity]="gradientSettings.opacity"
                [delay]="gradientSettings.delay"
                [contrastTool]="gradientSettings.contrastTool"
                [gradientSliderSmallStep]="gradientSettings.gradientSliderSmallStep"
                [gradientSliderStep]="gradientSettings.gradientSliderStep"
                [readonly]="readonly"
                (keydown.tab)="focusFirstHeaderButton()"
                (valueChange)="handleValueChange($event)"
            ></kendo-colorgradient>
            <kendo-colorpalette #palette
                [tabindex]="innerTabIndex"
                *ngIf="activeView === 'palette'"
                [palette]="paletteSettings.palette"
                [size]="size"
                [columns]="paletteSettings.columns"
                [tileSize]="paletteSettings.tileSize"
                [format]="format"
                [value]="selection"
                [readonly]="readonly"
                (valueChange)="handleValueChange($event)"
            ></kendo-colorpalette>
        </div>
        <div *ngIf="preview && !adaptiveMode"
            #footer
            kendoFlatColorPickerActionButtons
            [innerTabIndex]="innerTabIndex"
            [size]="size"
            [ngClass]="'k-justify-content-' + actionsLayout"
            (actionButtonClick)="onAction($event)"
            (tabOut)="firstFocusable.focus()">
        </div>
`,
      standalone: true,
      imports: [LocalizedColorPickerMessagesDirective, NgIf, FlatColorPickerHeaderComponent, ColorGradientComponent, ColorPaletteComponent, FlatColorPickerActionButtonsComponent, NgClass]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: FlatColorPickerService
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: Injector
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-flatcolorpicker"]
    }, {
      type: HostBinding,
      args: ["class.k-coloreditor"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }, {
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    ariaReadonly: [{
      type: HostBinding,
      args: ["attr.aria-readonly"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    hostTabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    ariaRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    isControlInvalid: [{
      type: HostBinding,
      args: ["attr.aria-invalid"]
    }],
    isDisabled: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    enterHandler: [{
      type: HostListener,
      args: ["keydown.enter", ["$event"]]
    }],
    escapeHandler: [{
      type: HostListener,
      args: ["keydown.escape"]
    }],
    focusHandler: [{
      type: HostListener,
      args: ["focusin", ["$event"]]
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    disabled: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    preview: [{
      type: Input
    }],
    actionsLayout: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    views: [{
      type: Input
    }],
    gradientSettings: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    paletteSettings: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    cancel: [{
      type: Output
    }],
    activeViewChange: [{
      type: Output
    }],
    clearButtonClick: [{
      type: Output
    }],
    actionButtonClick: [{
      type: Output
    }],
    header: [{
      type: ViewChild,
      args: ["header"]
    }],
    headerElement: [{
      type: ViewChild,
      args: ["header", {
        read: ElementRef
      }]
    }],
    gradient: [{
      type: ViewChild,
      args: ["gradient"]
    }],
    gradientElement: [{
      type: ViewChild,
      args: ["gradient", {
        read: ElementRef
      }]
    }],
    palette: [{
      type: ViewChild,
      args: ["palette"]
    }],
    footer: [{
      type: ViewChild,
      args: ["footer"]
    }]
  });
})();
var animationDuration = 300;
var updateActionSheetAdaptiveAppearance = (actionSheet, windowSize, renderer) => {
  const element = actionSheet["element"].nativeElement.querySelector(".k-actionsheet");
  const animationContainer = actionSheet["element"].nativeElement.querySelector(".k-child-animation-container");
  renderer.addClass(element, "k-adaptive-actionsheet");
  renderer.setStyle(animationContainer, "width", "100%");
  if (windowSize === "medium") {
    renderer.removeClass(element, "k-actionsheet-fullscreen");
    renderer.addClass(element, "k-actionsheet-bottom");
    renderer.setStyle(animationContainer, "bottom", "0px");
  } else if (windowSize === "small") {
    renderer.removeClass(element, "k-actionsheet-bottom");
    renderer.addClass(element, "k-actionsheet-fullscreen");
    renderer.setStyle(animationContainer, "height", "100%");
  }
};
var AdaptiveCloseButtonComponent = class _AdaptiveCloseButtonComponent {
  title;
  icon;
  svgIcon;
  color;
  close = new EventEmitter();
  static ɵfac = function AdaptiveCloseButtonComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AdaptiveCloseButtonComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AdaptiveCloseButtonComponent,
    selectors: [["kendo-adaptive-close-button"]],
    inputs: {
      title: "title",
      icon: "icon",
      svgIcon: "svgIcon",
      color: "color"
    },
    outputs: {
      close: "close"
    },
    decls: 1,
    vars: 5,
    consts: [["kendoButton", "", "type", "button", "fillMode", "flat", "size", "large", 3, "click", "title", "icon", "svgIcon", "themeColor", "tabIndex"]],
    template: function AdaptiveCloseButtonComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "button", 0);
        ɵɵlistener("click", function AdaptiveCloseButtonComponent_Template_button_click_0_listener($event) {
          return ctx.close.emit($event);
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("title", ctx.title)("icon", ctx.icon)("svgIcon", ctx.svgIcon)("themeColor", ctx.color)("tabIndex", -1);
      }
    },
    dependencies: [ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AdaptiveCloseButtonComponent, [{
    type: Component,
    args: [{
      selector: "kendo-adaptive-close-button",
      template: `
        <button kendoButton
            type="button"
            [title]="title"
            [icon]="icon"
            [svgIcon]="svgIcon"
            [themeColor]="color"
            fillMode="flat"
            size="large"
            [tabIndex]="-1"
            (click)="close.emit($event)"
        ></button>
    `,
      standalone: true,
      imports: [ButtonComponent]
    }]
  }], null, {
    title: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    close: [{
      type: Output
    }]
  });
})();
var AdaptiveRendererComponent = class _AdaptiveRendererComponent {
  localization;
  title;
  subtitle;
  actionSheetTemplate;
  isActionSheetExpanded;
  preview;
  actionSheetClose = new EventEmitter();
  onExpand = new EventEmitter();
  onCollapse = new EventEmitter();
  onApply = new EventEmitter();
  onCancel = new EventEmitter();
  actionSheet;
  actionSheetSearchBar;
  cancelButton;
  applyButton;
  constructor(localization) {
    this.localization = localization;
  }
  animationDuration = animationDuration;
  xIcon = xIcon;
  checkIcon = checkIcon;
  messageFor(key) {
    return this.localization.get(key);
  }
  static ɵfac = function AdaptiveRendererComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AdaptiveRendererComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AdaptiveRendererComponent,
    selectors: [["kendo-adaptive-renderer"]],
    viewQuery: function AdaptiveRendererComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(ActionSheetComponent, 5);
        ɵɵviewQuery(_c47, 5);
        ɵɵviewQuery(_c48, 5);
        ɵɵviewQuery(_c49, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheet = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheetSearchBar = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cancelButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.applyButton = _t.first);
      }
    },
    inputs: {
      title: "title",
      subtitle: "subtitle",
      actionSheetTemplate: "actionSheetTemplate",
      isActionSheetExpanded: "isActionSheetExpanded",
      preview: "preview"
    },
    outputs: {
      actionSheetClose: "actionSheetClose",
      onExpand: "onExpand",
      onCollapse: "onCollapse",
      onApply: "onApply",
      onCancel: "onCancel"
    },
    decls: 3,
    vars: 4,
    consts: [["actionSheet", ""], ["cancel", ""], ["apply", ""], [3, "overlayClick", "expand", "collapse", "animation", "expanded"], ["kendoActionSheetTemplate", ""], [1, "k-text-center", "k-actionsheet-titlebar"], [1, "k-actionsheet-titlebar-group", "k-hbox"], [1, "k-actionsheet-title"], [1, "k-text-center"], [1, "k-actionsheet-subtitle", "k-text-center"], ["class", "k-actionsheet-actions", 4, "ngIf"], [1, "k-actionsheet-content", "!k-overflow-hidden"], [4, "ngTemplateOutlet"], ["class", "k-actions k-actions-stretched k-actions-horizontal k-actionsheet-footer", 4, "ngIf"], [1, "k-actionsheet-actions"], ["icon", "check", "color", "primary", 3, "close", "title", "svgIcon"], ["icon", "x", 3, "close", "title", "svgIcon"], [1, "k-actions", "k-actions-stretched", "k-actions-horizontal", "k-actionsheet-footer"], ["kendoButton", "", "size", "large", 3, "click", "title"], ["kendoButton", "", "size", "large", "themeColor", "primary", 3, "click", "title"]],
    template: function AdaptiveRendererComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "kendo-actionsheet", 3, 0);
        ɵɵlistener("overlayClick", function AdaptiveRendererComponent_Template_kendo_actionsheet_overlayClick_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.actionSheetClose.emit());
        })("expand", function AdaptiveRendererComponent_Template_kendo_actionsheet_expand_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onExpand.emit());
        })("collapse", function AdaptiveRendererComponent_Template_kendo_actionsheet_collapse_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onCollapse.emit());
        });
        ɵɵtemplate(2, AdaptiveRendererComponent_ng_template_2_Template, 11, 5, "ng-template", 4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("animation", ɵɵpureFunction1(2, _c50, ctx.animationDuration))("expanded", ctx.isActionSheetExpanded);
      }
    },
    dependencies: [ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, NgIf, NgTemplateOutlet, AdaptiveCloseButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AdaptiveRendererComponent, [{
    type: Component,
    args: [{
      selector: "kendo-adaptive-renderer",
      template: `
        <kendo-actionsheet
            #actionSheet
            [animation]="{ duration: animationDuration }"
            [expanded]="isActionSheetExpanded"
            (overlayClick)="actionSheetClose.emit()"
            (expand)="onExpand.emit()"
            (collapse)="onCollapse.emit()"
        >
            <ng-template kendoActionSheetTemplate>
                <div class="k-text-center k-actionsheet-titlebar">
                    <div class="k-actionsheet-titlebar-group k-hbox">
                        <div class="k-actionsheet-title">
                            <div class="k-text-center">{{ messageFor('adaptiveTitle') }}</div>
                            <div class="k-actionsheet-subtitle k-text-center"></div>
                        </div>
                        <div *ngIf="!preview" class="k-actionsheet-actions">
                            <kendo-adaptive-close-button
                                icon="check"
                                color="primary"
                                [title]="messageFor('closeButton')"
                                [svgIcon]="checkIcon"
                                (close)="onApply.emit($event)">
                            </kendo-adaptive-close-button>
                        </div>
                        <div *ngIf="preview" class="k-actionsheet-actions">
                            <kendo-adaptive-close-button
                                icon="x"
                                [title]="messageFor('closeButton')"
                                [svgIcon]="xIcon"
                                (close)="actionSheetClose.emit($event)">
                            </kendo-adaptive-close-button>
                        </div>
                    </div>
                </div>
                <div class="k-actionsheet-content !k-overflow-hidden">
                    <ng-container *ngTemplateOutlet="actionSheetTemplate"></ng-container>
                </div>
                <div *ngIf="preview" class="k-actions k-actions-stretched k-actions-horizontal k-actionsheet-footer">
                    <button 
                        #cancel
                        kendoButton
                        size="large"
                        (click)="onCancel.emit($event)"
                        [title]="messageFor('cancelButton')">
                        {{messageFor('cancelButton')}}
                    </button>
                    <button
                        #apply
                        kendoButton
                        size="large"
                        themeColor="primary"
                        (click)="onApply.emit()"
                        [title]="messageFor('applyButton')">
                        {{messageFor('applyButton')}}
                    </button>
                </div>
            </ng-template>
        </kendo-actionsheet>
    `,
      standalone: true,
      imports: [ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, NgIf, NgTemplateOutlet, AdaptiveCloseButtonComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, {
    title: [{
      type: Input
    }],
    subtitle: [{
      type: Input
    }],
    actionSheetTemplate: [{
      type: Input
    }],
    isActionSheetExpanded: [{
      type: Input
    }],
    preview: [{
      type: Input
    }],
    actionSheetClose: [{
      type: Output
    }],
    onExpand: [{
      type: Output
    }],
    onCollapse: [{
      type: Output
    }],
    onApply: [{
      type: Output
    }],
    onCancel: [{
      type: Output
    }],
    actionSheet: [{
      type: ViewChild,
      args: [ActionSheetComponent]
    }],
    actionSheetSearchBar: [{
      type: ViewChild,
      args: ["actionSheetSearchBar"]
    }],
    cancelButton: [{
      type: ViewChild,
      args: ["cancel"]
    }],
    applyButton: [{
      type: ViewChild,
      args: ["apply"]
    }]
  });
})();
var DOM_FOCUS_EVENTS = ["focus", "blur"];
var DEFAULT_SIZE$4 = "medium";
var DEFAULT_ROUNDED$3 = "medium";
var DEFAULT_FILL_MODE$3 = "solid";
var nextColorPickerId = 0;
var ColorPickerComponent = class _ColorPickerComponent {
  host;
  popupService;
  cdr;
  localizationService;
  ngZone;
  renderer;
  injector;
  adaptiveService;
  hostClasses = true;
  get focusedClass() {
    return this.isFocused;
  }
  get disabledClass() {
    return this.disabled;
  }
  get ariaReadonly() {
    return this.readonly;
  }
  get ariaExpanded() {
    return this.isOpen;
  }
  get hostTabindex() {
    return this.tabindex;
  }
  direction;
  role = "combobox";
  hasPopup = "dialog";
  get isControlInvalid() {
    return this.control?.invalid?.toString();
  }
  /**
   * @hidden
   */
  focusableId;
  /**
   * Specifies the views that will be rendered in the popup.
   * By default both the gradient and palette views will be rendered.
   */
  views = ["gradient", "palette"];
  /**
   * @hidden
   */
  set view(view) {
    this.views = [view];
  }
  get view() {
    return this.views && this.views.length > 0 ? this.views[0] : null;
  }
  /**
   * Enables or disables the adaptive mode. By default, adaptive rendering is disabled.
   */
  adaptiveMode = "none";
  /**
   * Sets the initially active view in the popup. The property supports two-way binding.
   *
   * The supported values are:
   * * `gradient`
   * * `palette`
   */
  activeView;
  /**
   * Sets the read-only state of the ColorPicker.
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the disabled state of the ColorPicker. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_colorpicker#toc-managing-the-colorpicker-disabled-state-in-reactive-forms).
   *
   * @default false
   */
  disabled = false;
  /**
   * Specifies the output format of the ColorPicker.
   *
   * If the input value is in a different format, it will be parsed into the specified output `format`.
   *
   * The supported values are:
   * * `rgba` (default)
   * * `hex`
   */
  format = "rgba";
  /**
   * Specifies the value of the initially selected color.
   */
  set value(value) {
    this._value = parseColor4(value, this.format, this.gradientSettings.opacity);
  }
  get value() {
    return this._value;
  }
  /**
   * Configures the popup of the ColorPicker.
   */
  set popupSettings(value) {
    this._popupSettings = Object.assign(this._popupSettings, value);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Configures the palette that is displayed in the ColorPicker popup.
   */
  set paletteSettings(value) {
    this._paletteSettings = Object.assign(this._paletteSettings, value);
  }
  get paletteSettings() {
    return this._paletteSettings;
  }
  /**
   * Configures the gradient that is displayed in the ColorPicker popup.
   */
  set gradientSettings(value) {
    this._gradientSettings = Object.assign(this._gradientSettings, value);
  }
  get gradientSettings() {
    return this._gradientSettings;
  }
  /**
   * Defines the name of an [existing icon in the Kendo UI theme]({% slug icons %}).
   * Provide only the name of the icon without the `k-icon` or the `k-i-` prefixes.
   *
   * For example, `pencil-tools` will be parsed to `k-icon k-i-pencil-tools`.
   */
  icon;
  /**
   * A CSS class name which displays an icon in the ColorPicker button.
   * `iconClass` is compatible with the `ngClass` syntax.
   *
   * Takes precedence over `icon` if both are defined.
   */
  iconClass;
  /**
   * Defines an SVGIcon to be rendered within the button.
   * The input can take either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
   */
  set svgIcon(icon) {
    if (isDevMode() && icon && this.icon && this.iconClass) {
      throw new Error("Setting both icon/svgIcon and iconClass options at the same time is not supported.");
    }
    this._svgIcon = icon;
  }
  get svgIcon() {
    return this._svgIcon;
  }
  /**
   * Specifies whether the ColorPicker should display a 'Clear color' button.
   *
   * @default true
   */
  clearButton = true;
  /**
   * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   *
   * @default 0
   */
  set tabindex(value) {
    const tabindex = Number(value);
    const defaultValue = 0;
    this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
  }
  get tabindex() {
    return !this.disabled ? this._tabindex : void 0;
  }
  /**
   * Displays `Apply` and `Cancel` action buttons and color preview panes.
   *
   * When enabled, the component value will not change immediately upon
   * color selection, but only after the `Apply` button is clicked.
   *
   * The `Cancel` button reverts the current selection to its
   * previous state i.e. to the current value.
   *
   * @default false
   */
  preview = false;
  /**
   * Configures the layout of the `Apply` and `Cancel` action buttons.
   *
   * The possible values are:
   * * `start`
   * * `center`
   * * `end` (default)
   * * `stretch`
   */
  actionsLayout = "end";
  /**
   * The size property specifies the padding of the ColorPicker internal elements
   * ([see example]({% slug appearance_colorpicker %}#toc-size)).
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$4;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * The rounded property specifies the border radius of the ColorPicker
   * ([see example](slug:appearance_colorpicker#toc-roundness)).
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `full`
   * * `none`
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED$3;
    this.handleClasses(newRounded, "rounded");
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * The fillMode property specifies the background and border styles of the ColorPicker
   * ([see example]({% slug appearance_colorpicker %}#toc-fill-mode)).
   *
   * The possible values are:
   * * `flat`
   * * `solid` (default)
   * * `outline`
   * * `none`
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$3;
    this.handleClasses(newFillMode, "fillMode");
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Fires each time the value is changed.
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the Popup (or ActionSheet in adaptive mode) is about to open.
   * This event is preventable. If you cancel it, the Popup (or the ActionSheet) will remain closed.
   */
  open = new EventEmitter();
  /**
   * Fires each time the Popup (or ActionSheet in adaptive mode) is about to close.
   * This event is preventable. If you cancel it, the Popup (or the ActionSheet) will remain open.
   */
  close = new EventEmitter();
  /**
   * Fires each time ColorPicker is focused.
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the ColorPicker is blurred.
   */
  onBlur = new EventEmitter();
  /**
   * Fires when the user cancels the current color selection.
   *
   * Fires on preview pane or 'Cancel' button click.
   */
  cancel = new EventEmitter();
  /**
   * Fires each time the left side of the ColorPicker wrapper is clicked.
   * The event is triggered regardless of whether a ColorPicker icon is set or not.
   *
   * The [ActiveColorClickEvent]({% slug api_inputs_activecolorclickevent %}) event provides the option to prevent the popup opening.
   */
  activeColorClick = new EventEmitter();
  /**
   * @hidden
   * Fires each time the clear button is clicked.
   */
  clearButtonClick = new EventEmitter();
  /**
   * Fires each time the view is about to change.
   * Used to provide a two-way binding for the `activeView` property.
   */
  activeViewChange = new EventEmitter();
  /**
   * Indicates whether the ColorPicker wrapper is focused.
   */
  isFocused = false;
  /**
  * @hidden
  */
  windowSize = "large";
  /**
   * Returns the current open state. Returns `true` if the Popup (or ActionSheet in adaptive mode) is currently open.
   */
  get isOpen() {
    return isPresent5(this.popupRef) || this.isActionSheetExpanded;
  }
  /**
   * @hidden
   */
  get customIconStyles() {
    if (this.iconClass) {
      let parsedIconClass = "";
      parseCSSClassNames(this.iconClass).forEach((iconClass) => {
        parsedIconClass += iconClass + " ";
      });
      return parsedIconClass.slice(0, -1);
    }
    return "";
  }
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  /**
   * @hidden
   */
  get actionSheet() {
    return this.adaptiveRenderer?.actionSheet;
  }
  /**
   * @hidden
   */
  get isActionSheetExpanded() {
    return Boolean(this.actionSheet?.expanded);
  }
  /**
   * @hidden
   */
  get iconStyles() {
    if (this.icon && !this.iconClass) {
      return `${this.icon}`;
    }
    return "";
  }
  /**
   * Provides a reference to a container element inside the component markup.
   * The container element references the location of the appended popup&mdash;
   * for example, inside the component markup.
   */
  container;
  activeColor;
  popupTemplate;
  flatColorPicker;
  /**
   * @hidden
   */
  adaptiveRenderer;
  /**
   * @hidden
   */
  arrowDownIcon = caretAltDownIcon;
  popupRef;
  _svgIcon;
  _value;
  _tabindex = 0;
  _popupSettings = {
    animate: true
  };
  _paletteSettings = {};
  _gradientSettings = {
    opacity: true,
    delay: 0
  };
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  dynamicRTLSubscription;
  subscriptions = new Subscription();
  popupSubs = new Subscription();
  colorPickerId;
  control;
  constructor(host, popupService, cdr, localizationService, ngZone, renderer, injector, adaptiveService) {
    this.host = host;
    this.popupService = popupService;
    this.cdr = cdr;
    this.localizationService = localizationService;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.injector = injector;
    this.adaptiveService = adaptiveService;
    validatePackage(packageMetadata5);
    this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
    this.colorPickerId = nextColorPickerId++;
  }
  ngOnInit() {
    const defaultPreset = this.format !== "name" ? DEFAULT_PRESET$1 : DEFAULT_ACCESSIBLE_PRESET$1;
    const settingsPalette = this._paletteSettings.palette;
    const presetColumns = typeof settingsPalette === "string" && PALETTEPRESETS[settingsPalette] ? PALETTEPRESETS[settingsPalette].columns : void 0;
    this._paletteSettings = {
      palette: settingsPalette || defaultPreset,
      tileSize: this._paletteSettings.tileSize,
      columns: this._paletteSettings.columns || presetColumns || 10
    };
    this.handleHostId();
    this.renderer.setAttribute(this.host.nativeElement, "aria-controls", `k-colorpicker-popup-${this.colorPickerId}`);
    this.control = this.injector.get(NgControl, null);
  }
  ngAfterViewInit() {
    const stylingInputs = ["size", "rounded", "fillMode"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
    this.setHostElementAriaLabel();
    this.initDomEvents();
    this.windowSize = this.adaptiveService.size;
    if (this.actionSheet && isDocumentAvailable()) {
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-height", "60vh");
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-max-height", "none");
    }
  }
  ngOnChanges(changes) {
    if (changes.format && changes.format.currentValue === "name") {
      this.activeView = "palette";
    }
    if (this.activeView === "gradient" && this.gradientSettings.opacity) {
      this.format = "rgba";
      this.value = parseColor4(this.value, this.format, this.gradientSettings.opacity);
    }
    if (isChanged("value", changes)) {
      this.setHostElementAriaLabel();
    }
  }
  ngOnDestroy() {
    this.closePopup();
    if (this.dynamicRTLSubscription) {
      this.dynamicRTLSubscription.unsubscribe();
    }
    this.subscriptions.unsubscribe();
    this.handleDomEvents("remove", DOM_FOCUS_EVENTS);
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (this.isAdaptiveModeEnabled && this.windowSize !== currentWindowSize) {
      if (this.isOpen) {
        this.toggleWithEvents(false);
      }
      this.windowSize = currentWindowSize;
    }
  }
  /**
   * @hidden
   */
  handleCancelEvent(ev) {
    this.cancel.emit(ev);
  }
  /**
   * @hidden
   */
  togglePopup() {
    if (!this.isActionSheetExpanded) {
      this.focus();
      this.toggleWithEvents(!this.isOpen);
    }
  }
  /**
   * @hidden
   */
  handleWrapperClick(event) {
    if (this.disabled) {
      return;
    }
    this.focus();
    if (closest(event.target, (element) => element === this.activeColor.nativeElement)) {
      const event2 = new ActiveColorClickEvent(this.value);
      this.activeColorClick.emit(event2);
      if (!event2.isOpenPrevented() || this.isOpen) {
        this.toggleWithEvents(!this.isOpen);
      }
      return;
    }
    if (!this.isActionSheetExpanded) {
      this.toggleWithEvents(!this.isOpen);
    }
  }
  /**
   * Focuses the wrapper of the ColorPicker.
   */
  focus() {
    this.isFocused = true;
    this.host.nativeElement.focus();
  }
  /**
   * @hidden
   */
  handleWrapperFocus() {
    if (this.isFocused) {
      return;
    }
    this.ngZone.run(() => {
      this.focus();
      this.onFocus.emit();
    });
  }
  /**
   * Blurs the ColorPicker.
   */
  blur() {
    this.isFocused = false;
    this.host.nativeElement.blur();
    this.notifyNgTouched();
  }
  /**
   * @hidden
   */
  handleWrapperBlur() {
    if (!this.isActionSheetExpanded) {
      if (this.isOpen) {
        return;
      }
      this.ngZone.run(() => {
        this.onBlur.emit();
        this.isFocused = false;
      });
    }
  }
  /**
   * Clears the value of the ColorPicker.
   */
  reset() {
    if (!isPresent5(this.value)) {
      return;
    }
    this._value = void 0;
    this.setHostElementAriaLabel();
    this.notifyNgChanged(void 0);
  }
  /**
   * Toggles the Popup (or ActionSheet in adaptive mode) of the ColorPicker.
   * Does not trigger the `open` and `close` events of the component.
   *
   * @param open An optional parameter. Specifies whether the popup will be opened or closed.
   */
  toggle(open) {
    this.windowSize = this.adaptiveService.size;
    if (this.disabled || this.readonly) {
      return;
    }
    this.cdr.markForCheck();
    if (this.isActionSheetExpanded) {
      this.closeActionSheet();
    } else {
      this.closePopup();
    }
    open = isPresent5(open) ? open : !this.isOpen;
    if (open) {
      if (this.isAdaptive && !this.isActionSheetExpanded) {
        this.openActionSheet();
      } else {
        this.openPopup();
      }
      this.focusFirstElement();
    }
  }
  /**
   * @hidden
   */
  handleValueChange(color) {
    const parsedColor = parseColor4(color, this.format, this.gradientSettings.opacity);
    const valueChange = parsedColor !== this.value;
    if (valueChange) {
      this.value = parsedColor;
      this.valueChange.emit(parsedColor);
      this.setHostElementAriaLabel();
      this.notifyNgChanged(parsedColor);
    }
  }
  /**
   * @hidden
   */
  handlePopupBlur(event) {
    if (!this.isActionSheetExpanded) {
      if (this.popupBlurInvalid(event)) {
        return;
      }
      this.isFocused = false;
      this.onBlur.emit();
      this.notifyNgTouched();
      this.toggleWithEvents(false);
    }
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value;
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.notifyNgChanged = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.notifyNgTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.cdr.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * @hidden
   */
  handleWrapperKeyDown(event) {
    if (event.keyCode === Keys.ArrowDown || event.keyCode === Keys.Enter) {
      event.preventDefault();
      this.ngZone.run(() => {
        this.toggleWithEvents(true);
      });
    }
  }
  /**
   * @hidden
   */
  onApply() {
    this.handleValueChange(this.flatColorPicker.selection);
    this.toggleWithEvents(false);
  }
  /**
   * @hidden
   */
  onCancel(e) {
    this.flatColorPicker.resetSelection(e);
    this.toggleWithEvents(false);
  }
  /**
   * @hidden
   */
  handlePopupKeyDown(event) {
    if (event.keyCode === Keys.Escape) {
      this.toggleWithEvents(false);
      this.host.nativeElement.focus();
    }
    if (event.keyCode === Keys.Tab) {
      const currentElement = event.shiftKey ? this.firstFocusableElement.nativeElement : this.lastFocusableElement.nativeElement;
      const nextElement = event.shiftKey ? this.lastFocusableElement.nativeElement : this.firstFocusableElement.nativeElement;
      if (event.target === currentElement) {
        event.preventDefault();
        nextElement.focus();
      }
    }
  }
  /**
   * @hidden
   * Used by the FloatingLabel to determine if the component is empty.
   */
  isEmpty() {
    return false;
  }
  setHostElementAriaLabel() {
    const ariaLabelValue = `${this.value ? this.value : this.localizationService.get("colorPickerNoColor")}`;
    this.renderer.setAttribute(this.host.nativeElement, "aria-label", ariaLabelValue);
  }
  handleClasses(value, input) {
    const elem = this.host.nativeElement;
    const classes = getStylingClasses2("picker", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  popupBlurInvalid(ev) {
    const focusInFlatColorPickerElement = this.popupRef?.popupElement?.contains(ev.relatedTarget);
    const hostClicked = closest(ev.relatedTarget, (element) => element === this.host.nativeElement);
    return Boolean(hostClicked || focusInFlatColorPickerElement);
  }
  toggleWithEvents(open) {
    const sameState = this.isOpen === open;
    if (this.disabled || this.readonly || sameState) {
      return;
    }
    let eventArgs;
    if (open) {
      eventArgs = new ColorPickerOpenEvent();
      this.open.emit(eventArgs);
    } else {
      eventArgs = new ColorPickerCloseEvent();
      this.close.emit(eventArgs);
    }
    if (!eventArgs.isDefaultPrevented()) {
      this.toggle(open);
    }
    if (open) {
      this.focusFirstElement();
    }
  }
  focusFirstElement() {
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      if (this.flatColorPicker) {
        const gradientDragHandle = this.flatColorPicker.gradient?.gradientDragHandle;
        const palette = this.flatColorPicker.palette?.host;
        const elementToFocus = gradientDragHandle ? gradientDragHandle : palette;
        elementToFocus.nativeElement.focus();
      }
    });
  }
  openActionSheet() {
    this.windowSize = this.adaptiveService.size;
    this.actionSheet.toggle(true);
    updateActionSheetAdaptiveAppearance(this.actionSheet, this.windowSize, this.renderer);
  }
  closeActionSheet() {
    this.actionSheet.toggle(false);
    this.focus();
  }
  openPopup() {
    const horizontalAlign = this.direction === "rtl" ? "right" : "left";
    const anchorPosition = {
      horizontal: horizontalAlign,
      vertical: "bottom"
    };
    const popupPosition = {
      horizontal: horizontalAlign,
      vertical: "top"
    };
    this.popupRef = this.popupService.open({
      anchor: this.activeColor,
      animate: this.popupSettings.animate,
      appendTo: this.popupSettings.appendTo,
      popupAlign: popupPosition,
      anchorAlign: anchorPosition,
      popupClass: "k-colorpicker-popup",
      content: this.popupTemplate,
      positionMode: "absolute"
    });
    this.renderer.setAttribute(this.popupRef.popupElement.querySelector(".k-colorpicker-popup"), "id", `k-colorpicker-popup-${this.colorPickerId}`);
    this.popupSubs.add(this.popupRef.popupAnchorViewportLeave.subscribe(() => {
      this.toggleWithEvents(false);
      if (!this.isOpen) {
        this.host.nativeElement.focus({
          preventScroll: true
        });
      }
    }));
  }
  closePopup() {
    if (!this.isOpen) {
      return;
    }
    this.popupSubs.unsubscribe();
    this.popupRef.close();
    this.popupRef = null;
  }
  get firstFocusableElement() {
    if (!this.flatColorPicker.header || this.views.length <= 1 && !this.flatColorPicker.clearButton) {
      const gradient = this.flatColorPicker.gradient;
      return gradient ? gradient.gradientDragHandle : this.flatColorPicker.palette.host;
    }
    return this.views.length > 1 ? this.flatColorPicker.header.viewButtonsCollection.toArray()[0] : this.flatColorPicker.header.clearButtonElement;
  }
  get lastFocusableElement() {
    if (this.preview) {
      return this.flatColorPicker.footer?.lastButton || this.adaptiveRenderer.applyButton.nativeElement;
    }
    if (this.flatColorPicker.palette) {
      return this.flatColorPicker.palette.host;
    }
    const gradient = this.flatColorPicker.gradient;
    const inputs = gradient && gradient.inputs;
    if (gradient && inputs && inputs.formatView === "hex") {
      return inputs.hexInput;
    }
    return this.gradientSettings.opacity ? inputs.opacityInput.numericInput : inputs.blueInput.numericInput;
  }
  notifyNgTouched = () => {
  };
  notifyNgChanged = () => {
  };
  handleDomEvents(action, events2) {
    const hostElement = this.host.nativeElement;
    events2.forEach((ev) => hostElement[`${action}EventListener`](ev, this.domFocusListener, true));
  }
  initDomEvents() {
    if (!this.host) {
      return;
    }
    const hostElement = this.host.nativeElement;
    this.ngZone.runOutsideAngular(() => {
      this.subscriptions.add(this.renderer.listen(hostElement, "focusin", () => {
        this.handleWrapperFocus();
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "focusout", (event) => {
        const closestPopup = this.popupRef ? closest(event.relatedTarget, (element) => element === this.flatColorPicker.host.nativeElement) : false;
        const closestWrapper = closest(event.relatedTarget, (element) => element === this.host.nativeElement);
        const closestActionSheet = this.isActionSheetExpanded ? closest(event.relatedTarget, (element) => element === this.actionSheet.element.nativeElement) : false;
        if (!closestPopup && !closestWrapper && !closestActionSheet) {
          this.handleWrapperBlur();
        }
      }));
      this.handleDomEvents("add", DOM_FOCUS_EVENTS);
      this.subscriptions.add(this.renderer.listen(hostElement, "keydown", (event) => {
        this.handleWrapperKeyDown(event);
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "click", (event) => {
        this.ngZone.run(() => {
          !this.isActionSheetExpanded && this.handleWrapperClick(event);
        });
      }));
    });
  }
  domFocusListener = (event) => event.stopImmediatePropagation();
  handleHostId() {
    const hostElement = this.host.nativeElement;
    const existingId = hostElement.getAttribute("id");
    if (existingId) {
      this.focusableId = existingId;
    } else {
      const id2 = `k-${guid()}`;
      hostElement.setAttribute("id", id2);
      this.focusableId = id2;
    }
  }
  static ɵfac = function ColorPickerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorPickerComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColorPickerComponent,
    selectors: [["kendo-colorpicker"]],
    viewQuery: function ColorPickerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c51, 7, ViewContainerRef);
        ɵɵviewQuery(_c522, 7);
        ɵɵviewQuery(_c532, 7);
        ɵɵviewQuery(_c54, 5);
        ɵɵviewQuery(AdaptiveRendererComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.activeColor = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.flatColorPicker = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.adaptiveRenderer = _t.first);
      }
    },
    hostVars: 20,
    hostBindings: function ColorPickerComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-disabled", ctx.disabledClass)("aria-readonly", ctx.ariaReadonly)("aria-expanded", ctx.ariaExpanded)("tabindex", ctx.hostTabindex)("dir", ctx.direction)("role", ctx.role)("aria-haspopup", ctx.hasPopup)("aria-invalid", ctx.isControlInvalid);
        ɵɵclassProp("k-colorpicker", ctx.hostClasses)("k-icon-picker", ctx.hostClasses)("k-picker", ctx.hostClasses)("k-focus", ctx.focusedClass)("k-disabled", ctx.disabledClass)("k-readonly", ctx.readonly);
      }
    },
    inputs: {
      views: "views",
      view: "view",
      adaptiveMode: "adaptiveMode",
      activeView: "activeView",
      readonly: "readonly",
      disabled: "disabled",
      format: "format",
      value: "value",
      popupSettings: "popupSettings",
      paletteSettings: "paletteSettings",
      gradientSettings: "gradientSettings",
      icon: "icon",
      iconClass: "iconClass",
      svgIcon: "svgIcon",
      clearButton: "clearButton",
      tabindex: "tabindex",
      preview: "preview",
      actionsLayout: "actionsLayout",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode"
    },
    outputs: {
      valueChange: "valueChange",
      open: "open",
      close: "close",
      onFocus: "focus",
      onBlur: "blur",
      cancel: "cancel",
      activeColorClick: "activeColorClick",
      clearButtonClick: "clearButtonClick",
      activeViewChange: "activeViewChange"
    },
    exportAs: ["kendoColorPicker"],
    features: [ɵɵProvidersFeature([{
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _ColorPickerComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _ColorPickerComponent)
    }, ColorPickerLocalizationService, {
      provide: LocalizationService,
      useExisting: ColorPickerLocalizationService
    }, {
      provide: L10N_PREFIX,
      useValue: "kendo.colorpicker"
    }]), ɵɵNgOnChangesFeature],
    decls: 13,
    vars: 15,
    consts: () => {
      let i18n_51;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_51 = goog.getMsg("Colorpicker no color chosen");
        i18n_51 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_51;
      } else {
        i18n_51 = $localize`:kendo.colorpicker.colorPickerNoColor|The aria-label applied to the ColorPicker component when the value is empty.:Colorpicker no color chosen`;
      }
      let i18n_52;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_52 = goog.getMsg("Flatcolorpicker no color chosen");
        i18n_52 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_52;
      } else {
        i18n_52 = $localize`:kendo.colorpicker.flatColorPickerNoColor|The aria-label applied to the FlatColorPicker component when the value is empty.:Flatcolorpicker no color chosen`;
      }
      let i18n_53;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_53 = goog.getMsg("Colorgradient no color chosen");
        i18n_53 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_53;
      } else {
        i18n_53 = $localize`:kendo.colorpicker.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty.:Colorgradient no color chosen`;
      }
      let i18n_54;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_54 = goog.getMsg("Colorpalette no color chosen");
        i18n_54 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_54;
      } else {
        i18n_54 = $localize`:kendo.colorpicker.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty.:Colorpalette no color chosen`;
      }
      let i18n_55;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_55 = goog.getMsg("Choose color");
        i18n_55 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_55;
      } else {
        i18n_55 = $localize`:kendo.colorpicker.colorGradientHandle|The title for the gradient color drag handle chooser.:Choose color`;
      }
      let i18n_56;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_56 = goog.getMsg("Clear value");
        i18n_56 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_56;
      } else {
        i18n_56 = $localize`:kendo.colorpicker.clearButton|The title for the clear button.:Clear value`;
      }
      let i18n_57;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_57 = goog.getMsg("Set hue");
        i18n_57 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_57;
      } else {
        i18n_57 = $localize`:kendo.colorpicker.hueSliderHandle|The title for the hue slider handle.:Set hue`;
      }
      let i18n_58;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_58 = goog.getMsg("Set opacity");
        i18n_58 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_58;
      } else {
        i18n_58 = $localize`:kendo.colorpicker.opacitySliderHandle|The title for the opacity slider handle.:Set opacity`;
      }
      let i18n_59;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_59 = goog.getMsg("Contrast ratio");
        i18n_59 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_59;
      } else {
        i18n_59 = $localize`:kendo.colorpicker.contrastRatio|The contrast ratio message for the contrast tool.:Contrast ratio`;
      }
      let i18n_60;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_60 = goog.getMsg("Color preview");
        i18n_60 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_60;
      } else {
        i18n_60 = $localize`:kendo.colorpicker.previewColor|The message for the color preview pane.:Color preview`;
      }
      let i18n_61;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_61 = goog.getMsg("Revert selection");
        i18n_61 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_61;
      } else {
        i18n_61 = $localize`:kendo.colorpicker.revertSelection|The message for the selected color pane.:Revert selection`;
      }
      let i18n_62;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_62 = goog.getMsg("Gradient view");
        i18n_62 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_62;
      } else {
        i18n_62 = $localize`:kendo.colorpicker.gradientView|The message for the gradient view button.:Gradient view`;
      }
      let i18n_63;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_63 = goog.getMsg("Palette view");
        i18n_63 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_63;
      } else {
        i18n_63 = $localize`:kendo.colorpicker.paletteView|The message for the palette view button.:Palette view`;
      }
      let i18n_64;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_64 = goog.getMsg("Change color format");
        i18n_64 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_64;
      } else {
        i18n_64 = $localize`:kendo.colorpicker.formatButton|The message for the input format toggle button.:Change color format`;
      }
      let i18n_65;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_65 = goog.getMsg("Apply");
        i18n_65 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_65;
      } else {
        i18n_65 = $localize`:kendo.colorpicker.applyButton|The message for the Apply action button.:Apply`;
      }
      let i18n_66;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_66 = goog.getMsg("Cancel");
        i18n_66 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_66;
      } else {
        i18n_66 = $localize`:kendo.colorpicker.cancelButton|The message for the Cancel action button.:Cancel`;
      }
      let i18n_67;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_67 = goog.getMsg("Close");
        i18n_67 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_67;
      } else {
        i18n_67 = $localize`:kendo.colorpicker.closeButton|The title for the Close button.:Close`;
      }
      let i18n_68;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_68 = goog.getMsg("Choose Color");
        i18n_68 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_68;
      } else {
        i18n_68 = $localize`:kendo.colorpicker.adaptiveTitle|The title for the ActionSheet when in adaptive mode.:Choose Color`;
      }
      let i18n_69;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_69 = goog.getMsg("Red channel");
        i18n_69 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_69;
      } else {
        i18n_69 = $localize`:kendo.colorpicker.redChannelLabel|The label of the NumericTextBox representing the red color channel.:Red channel`;
      }
      let i18n_70;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_70 = goog.getMsg("Green channel");
        i18n_70 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_70;
      } else {
        i18n_70 = $localize`:kendo.colorpicker.greenChannelLabel|The label of the NumericTextBox representing the green color channel.:Green channel`;
      }
      let i18n_71;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_71 = goog.getMsg("Blue channel");
        i18n_71 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_71;
      } else {
        i18n_71 = $localize`:kendo.colorpicker.blueChannelLabel|The label of the NumericTextBox representing the blue color channel.:Blue channel`;
      }
      let i18n_72;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_72 = goog.getMsg("Alpha channel");
        i18n_72 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_72;
      } else {
        i18n_72 = $localize`:kendo.colorpicker.alphaChannelLabel|The label of the NumericTextBox representing the alpha color channel.:Alpha channel`;
      }
      let i18n_73;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_73 = goog.getMsg("R");
        i18n_73 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_73;
      } else {
        i18n_73 = $localize`:kendo.colorpicker.redChannelLabel|The label of the NumericTextBox representing the red color channel.:R`;
      }
      let i18n_74;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_74 = goog.getMsg("G");
        i18n_74 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_74;
      } else {
        i18n_74 = $localize`:kendo.colorpicker.greenInputPlaceholder|The placeholder for the green color input.:G`;
      }
      let i18n_75;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_75 = goog.getMsg("B");
        i18n_75 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_75;
      } else {
        i18n_75 = $localize`:kendo.colorpicker.blueInputPlaceholder|The placeholder for the blue color input.:B`;
      }
      let i18n_76;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_76 = goog.getMsg("HEX");
        i18n_76 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_76;
      } else {
        i18n_76 = $localize`:kendo.colorpicker.hexInputPlaceholder|The placeholder for the HEX color input.:HEX`;
      }
      return [["activeColor", ""], ["popupTemplate", ""], ["container", ""], ["flatColorPicker", ""], ["kendoColorPickerLocalizedMessages", "", "colorPickerNoColor", i18n_51, "flatColorPickerNoColor", i18n_52, "colorGradientNoColor", i18n_53, "colorPaletteNoColor", i18n_54, "colorGradientHandle", i18n_55, "clearButton", i18n_56, "hueSliderHandle", i18n_57, "opacitySliderHandle", i18n_58, "contrastRatio", i18n_59, "previewColor", i18n_60, "revertSelection", i18n_61, "gradientView", i18n_62, "paletteView", i18n_63, "formatButton", i18n_64, "applyButton", i18n_65, "cancelButton", i18n_66, "closeButton", i18n_67, "adaptiveTitle", i18n_68, "redChannelLabel", i18n_69, "greenChannelLabel", i18n_70, "blueChannelLabel", i18n_71, "alphaChannelLabel", i18n_72, "redChannelLabel", i18n_73, "greenInputPlaceholder", i18n_74, "blueInputPlaceholder", i18n_75, "hexInputPlaceholder", i18n_76], [1, "k-input-inner"], [1, "k-value-icon", "k-color-preview", 3, "ngClass"], ["innerCssClass", "k-color-preview-icon", 3, "name", "customFontClass", "svgIcon", 4, "ngIf"], [1, "k-color-preview-mask"], ["kendoButton", "", "tabindex", "-1", "type", "button", "icon", "caret-alt-down", "rounded", "none", "aria-hidden", "true", 1, "k-input-button", 3, "size", "svgIcon", "fillMode", "disabled"], [3, "actionSheetClose", "onApply", "onCancel", "actionSheetTemplate", "isActionSheetExpanded", "preview"], [3, "resize", 4, "ngIf"], ["innerCssClass", "k-color-preview-icon", 3, "name", "customFontClass", "svgIcon"], [3, "cancel", "focusout", "valueChange", "keydown", "activeViewChange", "clearButtonClick", "actionButtonClick", "value", "format", "size", "views", "activeView", "actionsLayout", "adaptiveMode", "preview", "gradientSettings", "paletteSettings", "clearButton"], [3, "resize"]];
    },
    template: function ColorPickerComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 4);
        ɵɵelementStart(1, "span", 5, 0)(3, "span", 6);
        ɵɵtemplate(4, ColorPickerComponent_kendo_icon_wrapper_4_Template, 1, 3, "kendo-icon-wrapper", 7);
        ɵɵelement(5, "span", 8);
        ɵɵelementEnd()();
        ɵɵelement(6, "button", 9);
        ɵɵtemplate(7, ColorPickerComponent_ng_template_7_Template, 2, 11, "ng-template", null, 1, ɵɵtemplateRefExtractor);
        ɵɵelementContainer(9, null, 2);
        ɵɵelementStart(11, "kendo-adaptive-renderer", 10);
        ɵɵlistener("actionSheetClose", function ColorPickerComponent_Template_kendo_adaptive_renderer_actionSheetClose_11_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onCancel($event));
        })("onApply", function ColorPickerComponent_Template_kendo_adaptive_renderer_onApply_11_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onApply());
        })("onCancel", function ColorPickerComponent_Template_kendo_adaptive_renderer_onCancel_11_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onCancel($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(12, ColorPickerComponent_kendo_resize_sensor_12_Template, 1, 0, "kendo-resize-sensor", 11);
      }
      if (rf & 2) {
        const popupTemplate_r5 = ɵɵreference(8);
        ɵɵadvance(3);
        ɵɵproperty("ngClass", ɵɵpureFunction2(12, _c55, ctx.customIconStyles || ctx.iconStyles || ctx.svgIcon, !ctx.value));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.iconClass || ctx.icon || ctx.svgIcon);
        ɵɵadvance();
        ɵɵstyleProp("background-color", ctx.value);
        ɵɵadvance();
        ɵɵproperty("size", ctx.size)("svgIcon", ctx.arrowDownIcon)("fillMode", ctx.fillMode)("disabled", ctx.disabled);
        ɵɵadvance(5);
        ɵɵproperty("actionSheetTemplate", popupTemplate_r5)("isActionSheetExpanded", ctx.isActionSheetExpanded)("preview", ctx.preview);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isOpen || ctx.isAdaptiveModeEnabled);
      }
    },
    dependencies: [LocalizedColorPickerMessagesDirective, NgClass, NgIf, IconWrapperComponent, ButtonComponent, FlatColorPickerComponent, ResizeSensorComponent, AdaptiveRendererComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorPickerComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoColorPicker",
      selector: "kendo-colorpicker",
      providers: [{
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => ColorPickerComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => ColorPickerComponent)
      }, ColorPickerLocalizationService, {
        provide: LocalizationService,
        useExisting: ColorPickerLocalizationService
      }, {
        provide: L10N_PREFIX,
        useValue: "kendo.colorpicker"
      }],
      template: `
        <ng-container kendoColorPickerLocalizedMessages
            i18n-colorPickerNoColor="kendo.colorpicker.colorPickerNoColor|The aria-label applied to the ColorPicker component when the value is empty."
            colorPickerNoColor="Colorpicker no color chosen"
            i18n-flatColorPickerNoColor="kendo.colorpicker.flatColorPickerNoColor|The aria-label applied to the FlatColorPicker component when the value is empty."
            flatColorPickerNoColor="Flatcolorpicker no color chosen"
            i18n-colorGradientNoColor="kendo.colorpicker.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty."
            colorGradientNoColor="Colorgradient no color chosen"
            i18n-colorPaletteNoColor="kendo.colorpicker.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty."
            colorPaletteNoColor="Colorpalette no color chosen"
            i18n-colorGradientHandle="kendo.colorpicker.colorGradientHandle|The title for the gradient color drag handle chooser."
            colorGradientHandle="Choose color"
            i18n-clearButton="kendo.colorpicker.clearButton|The title for the clear button."
            clearButton="Clear value"
            i18n-hueSliderHandle="kendo.colorpicker.hueSliderHandle|The title for the hue slider handle."
            hueSliderHandle="Set hue"
            i18n-opacitySliderHandle="kendo.colorpicker.opacitySliderHandle|The title for the opacity slider handle."
            opacitySliderHandle="Set opacity"
            i18n-contrastRatio="kendo.colorpicker.contrastRatio|The contrast ratio message for the contrast tool."
            contrastRatio="Contrast ratio"
            i18n-previewColor="kendo.colorpicker.previewColor|The message for the color preview pane."
            previewColor="Color preview"
            i18n-revertSelection="kendo.colorpicker.revertSelection|The message for the selected color pane."
            revertSelection="Revert selection"
            i18n-gradientView="kendo.colorpicker.gradientView|The message for the gradient view button."
            gradientView="Gradient view"
            i18n-paletteView="kendo.colorpicker.paletteView|The message for the palette view button."
            paletteView="Palette view"
            i18n-formatButton="kendo.colorpicker.formatButton|The message for the input format toggle button."
            formatButton="Change color format"
            i18n-applyButton="kendo.colorpicker.applyButton|The message for the Apply action button."
            applyButton="Apply"
            i18n-cancelButton="kendo.colorpicker.cancelButton|The message for the Cancel action button."
            cancelButton="Cancel"
            i18n-closeButton="kendo.colorpicker.closeButton|The title for the Close button."
            closeButton="Close"
            i18n-adaptiveTitle="kendo.colorpicker.adaptiveTitle|The title for the ActionSheet when in adaptive mode."
            adaptiveTitle="Choose Color"
            i18n-redChannelLabel="kendo.colorpicker.redChannelLabel|The label of the NumericTextBox representing the red color channel."
            redChannelLabel="Red channel"
            i18n-greenChannelLabel="kendo.colorpicker.greenChannelLabel|The label of the NumericTextBox representing the green color channel."
            greenChannelLabel="Green channel"
            i18n-blueChannelLabel="kendo.colorpicker.blueChannelLabel|The label of the NumericTextBox representing the blue color channel."
            blueChannelLabel="Blue channel"
            i18n-alphaChannelLabel="kendo.colorpicker.alphaChannelLabel|The label of the NumericTextBox representing the alpha color channel."
            alphaChannelLabel="Alpha channel"
            i18n-redInputPlaceholder="kendo.colorpicker.redInputPlaceholder|The placeholder for the red color input."
            redChannelLabel="R"
            i18n-greenInputPlaceholder="kendo.colorpicker.greenInputPlaceholder|The placeholder for the green color input."
            greenInputPlaceholder="G"
            i18n-blueInputPlaceholder="kendo.colorpicker.blueInputPlaceholder|The placeholder for the blue color input."
            blueInputPlaceholder="B"
            i18n-hexInputPlaceholder="kendo.colorpicker.hexInputPlaceholder|The placeholder for the HEX color input."
            hexInputPlaceholder="HEX">
        </ng-container>
        <span #activeColor class="k-input-inner">
            <span
                class="k-value-icon k-color-preview"
                [ngClass]="{'k-icon-color-preview': customIconStyles || iconStyles || svgIcon, 'k-no-color': !value}"
            >
                <kendo-icon-wrapper
                    *ngIf="iconClass || icon || svgIcon"
                    [name]="iconStyles"
                    innerCssClass="k-color-preview-icon"
                    [customFontClass]="customIconStyles"
                    [svgIcon]="svgIcon"
                >
                </kendo-icon-wrapper>
                <span class="k-color-preview-mask" [style.background-color]="value"></span>
            </span>
        </span>
        <button
            kendoButton
            tabindex="-1"
            type="button"
            icon="caret-alt-down"
            [size]="size"
            [svgIcon]="arrowDownIcon"
            [fillMode]="fillMode"
            [disabled]="disabled"
            rounded="none"
            aria-hidden="true"
            class="k-input-button"
        >
        </button>
        <ng-template #popupTemplate>
            <kendo-flatcolorpicker
                #flatColorPicker
                [value]="value"
                [format]="format"
                [size]="isAdaptive ? 'large' : size"
                [views]="views"
                [activeView]="activeView"
                [actionsLayout]="actionsLayout"
                [adaptiveMode]="isActionSheetExpanded"
                [preview]="preview"
                [gradientSettings]="gradientSettings"
                [paletteSettings]="paletteSettings"
                [clearButton]="clearButton"
                (cancel)="handleCancelEvent($event)"
                (focusout)="handlePopupBlur($event)"
                (valueChange)="handleValueChange($event)"
                (keydown)="handlePopupKeyDown($event)"
                (activeViewChange)="activeViewChange.emit($event)"
                (clearButtonClick)="clearButtonClick.emit()"
                (actionButtonClick)="togglePopup()">
            </kendo-flatcolorpicker>
        </ng-template>
        <ng-container #container></ng-container>
        <kendo-adaptive-renderer
            [actionSheetTemplate]="popupTemplate"
            [isActionSheetExpanded]="isActionSheetExpanded"
            [preview]="preview"
            (actionSheetClose)="onCancel($event)"
            (onApply)="onApply()"
            (onCancel)="onCancel($event)"
        >
        </kendo-adaptive-renderer>
        <kendo-resize-sensor *ngIf="isOpen || isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>
        `,
      standalone: true,
      imports: [LocalizedColorPickerMessagesDirective, NgClass, NgIf, IconWrapperComponent, ButtonComponent, FlatColorPickerComponent, ResizeSensorComponent, AdaptiveRendererComponent]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: PopupService
    }, {
      type: ChangeDetectorRef
    }, {
      type: LocalizationService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: Injector
    }, {
      type: AdaptiveService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-colorpicker"]
    }, {
      type: HostBinding,
      args: ["class.k-icon-picker"]
    }, {
      type: HostBinding,
      args: ["class.k-picker"]
    }],
    focusedClass: [{
      type: HostBinding,
      args: ["class.k-focus"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }, {
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    ariaReadonly: [{
      type: HostBinding,
      args: ["attr.aria-readonly"]
    }],
    ariaExpanded: [{
      type: HostBinding,
      args: ["attr.aria-expanded"]
    }],
    hostTabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    hasPopup: [{
      type: HostBinding,
      args: ["attr.aria-haspopup"]
    }],
    isControlInvalid: [{
      type: HostBinding,
      args: ["attr.aria-invalid"]
    }],
    views: [{
      type: Input
    }],
    view: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    disabled: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    paletteSettings: [{
      type: Input
    }],
    gradientSettings: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    iconClass: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    preview: [{
      type: Input
    }],
    actionsLayout: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    open: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    cancel: [{
      type: Output
    }],
    activeColorClick: [{
      type: Output
    }],
    clearButtonClick: [{
      type: Output
    }],
    activeViewChange: [{
      type: Output
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    activeColor: [{
      type: ViewChild,
      args: ["activeColor", {
        static: true
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        static: true
      }]
    }],
    flatColorPicker: [{
      type: ViewChild,
      args: ["flatColorPicker", {
        static: false
      }]
    }],
    adaptiveRenderer: [{
      type: ViewChild,
      args: [AdaptiveRendererComponent]
    }]
  });
})();
var ColorPickerCustomMessagesComponent = class _ColorPickerCustomMessagesComponent extends ColorPickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function ColorPickerCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorPickerCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColorPickerCustomMessagesComponent,
    selectors: [["kendo-colorpicker-messages"], ["kendo-flatcolorpicker-messages"], ["kendo-colorgradient-messages"], ["kendo-colorpalette-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: ColorPickerMessages,
      useExisting: forwardRef(() => _ColorPickerCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function ColorPickerCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorPickerCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColorPickerMessages,
        useExisting: forwardRef(() => ColorPickerCustomMessagesComponent)
      }],
      selector: "kendo-colorpicker-messages, kendo-flatcolorpicker-messages, kendo-colorgradient-messages, kendo-colorpalette-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var serial$1 = 0;
var ErrorComponent = class _ErrorComponent {
  hostClass = true;
  /**
   * Specifies the alignment of the Error message.
   *
   * The possible values are:
   * * (Default) `start`
   * * `end`
   */
  align = "start";
  /**
   * @hidden
   */
  id = `kendo-error-${serial$1++}`;
  roleAttribute = "alert";
  get startClass() {
    return this.align === "start";
  }
  get endClass() {
    return this.align === "end";
  }
  get idAttribute() {
    return this.id;
  }
  static ɵfac = function ErrorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ErrorComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ErrorComponent,
    selectors: [["kendo-formerror"]],
    hostVars: 8,
    hostBindings: function ErrorComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.roleAttribute)("id", ctx.idAttribute);
        ɵɵclassProp("k-form-error", ctx.hostClass)("k-text-start", ctx.startClass)("k-text-end", ctx.endClass);
      }
    },
    inputs: {
      align: "align"
    },
    ngContentSelectors: _c56,
    decls: 1,
    vars: 0,
    template: function ErrorComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ErrorComponent, [{
    type: Component,
    args: [{
      selector: "kendo-formerror",
      template: `
        <ng-content></ng-content>
    `,
      standalone: true
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-form-error"]
    }],
    align: [{
      type: Input
    }],
    roleAttribute: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    startClass: [{
      type: HostBinding,
      args: ["class.k-text-start"]
    }],
    endClass: [{
      type: HostBinding,
      args: ["class.k-text-end"]
    }],
    idAttribute: [{
      type: HostBinding,
      args: ["attr.id"]
    }]
  });
})();
var serial = 0;
var HintComponent2 = class _HintComponent {
  /**
   * Specifies the alignment of the Hint message.
   *
   * The possible values are:
   * * (Default) `start`
   * * `end`
   */
  align = "start";
  /**
   * @hidden
   */
  id = `kendo-hint-${serial++}`;
  hostClass = true;
  get startClass() {
    return this.align === "start";
  }
  get endClass() {
    return this.align === "end";
  }
  get idAttribute() {
    return this.id;
  }
  static ɵfac = function HintComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HintComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _HintComponent,
    selectors: [["kendo-formhint"]],
    hostVars: 7,
    hostBindings: function HintComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("id", ctx.idAttribute);
        ɵɵclassProp("k-form-hint", ctx.hostClass)("k-text-start", ctx.startClass)("k-text-end", ctx.endClass);
      }
    },
    inputs: {
      align: "align"
    },
    ngContentSelectors: _c56,
    decls: 1,
    vars: 0,
    template: function HintComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HintComponent2, [{
    type: Component,
    args: [{
      selector: "kendo-formhint",
      template: `
        <ng-content></ng-content>
    `,
      standalone: true
    }]
  }], null, {
    align: [{
      type: Input
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-form-hint"]
    }],
    startClass: [{
      type: HostBinding,
      args: ["class.k-text-start"]
    }],
    endClass: [{
      type: HostBinding,
      args: ["class.k-text-end"]
    }],
    idAttribute: [{
      type: HostBinding,
      args: ["attr.id"]
    }]
  });
})();
var FormFieldComponent = class _FormFieldComponent {
  renderer;
  localizationService;
  hostElement;
  hostClass = true;
  /**
   * @hidden
   */
  direction;
  get errorClass() {
    if (!this.control) {
      return false;
    }
    return this.control.invalid && (this.control.touched || this.control.dirty);
  }
  get disabledClass() {
    if (!this.control) {
      return false;
    }
    if (this.isRadioControl(this.control)) {
      return false;
    }
    return this.disabledControl() || this.disabledElement() || this.disabledKendoInput();
  }
  set formControls(formControls) {
    this.validateFormControl(formControls);
    this.control = formControls.first;
  }
  controlElementRefs;
  kendoInput;
  errorChildren;
  hintChildren;
  /**
   *
   * Specifies when the Hint messages will be shown.
   *
   * The possible values are:
   *
   * * (Default) `initial`&mdash;Allows displaying hints when the form-bound component state is
   * `valid` or `untouched` and `pristine`.
   * * `always`&mdash;Allows full control over the visibility of the hints.
   *
   */
  showHints = "initial";
  /**
   * Specifies the layout orientation of the form field.
   *
   * * The possible values are:
   *
   * * (Default) `vertical`
   * * `horizontal`
   */
  orientation = "vertical";
  /**
   * Specifies when the Error messages will be shown.
   *
   * The possible values are:
   *
   * * (Default) `initial`&mdash;Allows displaying errors when the form-bound component state is
   * `invalid` and `touched` or `dirty`.
   * * `always`&mdash;Allows full control over the visibility of the errors.
   *
   */
  showErrors = "initial";
  /**
   * @hidden
   */
  get horizontal() {
    return this.orientation === "horizontal";
  }
  /**
   * @hidden
   */
  get hasHints() {
    return this.showHints === "always" ? true : this.showHintsInitial();
  }
  /**
   * @hidden
   */
  get hasErrors() {
    return this.showErrors === "always" ? true : this.showErrorsInitial();
  }
  control;
  subscriptions = new Subscription();
  rtl = false;
  constructor(renderer, localizationService, hostElement) {
    this.renderer = renderer;
    this.localizationService = localizationService;
    this.hostElement = hostElement;
    validatePackage(packageMetadata5);
    this.subscriptions.add(this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.rtl = rtl;
      this.direction = this.rtl ? "rtl" : "ltr";
    }));
  }
  ngAfterViewInit() {
    this.setDescription();
  }
  ngAfterViewChecked() {
    this.updateDescription();
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  disabledKendoInput() {
    return this.kendoInput && this.kendoInput.disabled;
  }
  disabledControl() {
    return this.control.disabled;
  }
  disabledElement() {
    const elements = this.controlElementRefs.toArray();
    return elements.every((e) => e.nativeElement.hasAttribute("disabled"));
  }
  validateFormControl(formControls) {
    if (isDevMode() && formControls.length !== 1 && !this.isControlGroup(formControls)) {
      throw new Error("The `kendo-formfield` component should contain only one control of type NgControl with a formControlName(https://angular.io/api/forms/FormControlName)or an ngModel(https://angular.io/api/forms/NgModel) binding.");
    }
  }
  isControlGroup(formControls) {
    if (!formControls.length) {
      return false;
    }
    const name2 = formControls.first.name;
    return formControls.toArray().every((c) => c.name === name2 && this.isRadioControl(c));
  }
  isRadioControl(control) {
    return control.valueAccessor instanceof RadioControlValueAccessor;
  }
  updateDescription() {
    const controls = this.findControlElements().filter((c) => !!c);
    if (!controls) {
      return;
    }
    controls.forEach((control) => {
      if (this.errorChildren.length > 0 || this.hintChildren.length > 0) {
        const ariaIds = this.generateDescriptionIds(control);
        if (ariaIds !== "") {
          this.renderer.setAttribute(control, "aria-describedby", ariaIds);
        } else {
          this.renderer.removeAttribute(control, "aria-describedby");
        }
      }
    });
  }
  findControlElements() {
    if (!this.controlElementRefs) {
      return;
    }
    if (this.kendoInput && this.kendoInput.focusableId && isDocumentAvailable()) {
      const isEditor = this.kendoInput.focusableId.startsWith("k-editor");
      return isEditor ? [this.kendoInput.viewMountElement] : [this.hostElement.nativeElement.querySelector(`#${this.kendoInput.focusableId}`)];
    }
    return this.controlElementRefs.map((el) => el.nativeElement);
  }
  generateDescriptionIds(control) {
    const ids = /* @__PURE__ */ new Set();
    let errorAttribute = "";
    if (control.hasAttribute("aria-describedby")) {
      const attributes = control.getAttribute("aria-describedby").split(" ");
      errorAttribute = attributes.filter((attr) => attr.includes("kendo-error-"))[0];
      attributes.forEach((attr) => {
        if (attr.includes("kendo-hint-") || attr.includes("kendo-error-")) {
          return;
        }
        ids.add(attr);
      });
    }
    this.hintChildren.forEach((hint) => {
      ids.add(hint.id);
    });
    if (this.hasErrors) {
      this.errorChildren.forEach((error2) => {
        ids.add(error2.id);
      });
    } else {
      ids.delete(errorAttribute);
    }
    return Array.from(ids).join(" ");
  }
  showHintsInitial() {
    if (!this.control) {
      return true;
    }
    const {
      valid,
      untouched,
      pristine
    } = this.control;
    return valid || untouched && pristine;
  }
  showErrorsInitial() {
    if (!this.control) {
      return false;
    }
    const {
      invalid,
      dirty,
      touched
    } = this.control;
    return invalid && (dirty || touched);
  }
  setDescription() {
    this.updateDescription();
    this.subscriptions.add(this.errorChildren.changes.subscribe(() => this.updateDescription()));
    this.subscriptions.add(this.hintChildren.changes.subscribe(() => this.updateDescription()));
  }
  static ɵfac = function FormFieldComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormFieldComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FormFieldComponent,
    selectors: [["kendo-formfield"]],
    contentQueries: function FormFieldComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, KendoInput, 7);
        ɵɵcontentQuery(dirIndex, NgControl, 5);
        ɵɵcontentQuery(dirIndex, NgControl, 5, ElementRef);
        ɵɵcontentQuery(dirIndex, ErrorComponent, 5);
        ɵɵcontentQuery(dirIndex, HintComponent2, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.kendoInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.formControls = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.controlElementRefs = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.errorChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.hintChildren = _t);
      }
    },
    hostVars: 7,
    hostBindings: function FormFieldComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-form-field", ctx.hostClass)("k-form-field-error", ctx.errorClass)("k-form-field-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      showHints: "showHints",
      orientation: "orientation",
      showErrors: "showErrors"
    },
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.formfield"
    }])],
    ngContentSelectors: _c58,
    decls: 5,
    vars: 2,
    consts: [[1, "k-form-field-wrap"], [4, "ngIf"]],
    template: function FormFieldComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c57);
        ɵɵprojection(0);
        ɵɵelementStart(1, "div", 0);
        ɵɵprojection(2, 1);
        ɵɵtemplate(3, FormFieldComponent_ng_content_3_Template, 1, 0, "ng-content", 1)(4, FormFieldComponent_ng_content_4_Template, 1, 0, "ng-content", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.hasHints);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hasErrors);
      }
    },
    dependencies: [NgIf],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormFieldComponent, [{
    type: Component,
    args: [{
      selector: "kendo-formfield",
      template: `
        <ng-content select="label, kendo-label"></ng-content>
        <div class="k-form-field-wrap">
            <ng-content></ng-content>
            <ng-content select="kendo-formhint" *ngIf="hasHints"></ng-content>
            <ng-content select="kendo-formerror" *ngIf="hasErrors"></ng-content>
        </div>
    `,
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.formfield"
      }],
      standalone: true,
      imports: [NgIf]
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: LocalizationService
    }, {
      type: ElementRef
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-form-field"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    errorClass: [{
      type: HostBinding,
      args: ["class.k-form-field-error"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-form-field-disabled"]
    }],
    formControls: [{
      type: ContentChildren,
      args: [NgControl, {
        descendants: true
      }]
    }],
    controlElementRefs: [{
      type: ContentChildren,
      args: [NgControl, {
        read: ElementRef,
        descendants: true
      }]
    }],
    kendoInput: [{
      type: ContentChild,
      args: [KendoInput, {
        static: true
      }]
    }],
    errorChildren: [{
      type: ContentChildren,
      args: [ErrorComponent, {
        descendants: true
      }]
    }],
    hintChildren: [{
      type: ContentChildren,
      args: [HintComponent2, {
        descendants: true
      }]
    }],
    showHints: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    showErrors: [{
      type: Input
    }]
  });
})();
var RadioButtonComponent = class _RadioButtonComponent extends RadioCheckBoxBase {
  renderer;
  hostElement;
  cdr;
  ngZone;
  injector;
  localizationService;
  hostClass = true;
  direction;
  /**
   * Specifies the checked state of the RadioButton.
   *
   * @default false
   */
  checked = false;
  /**
   * Fires each time the checked state is changed.
   * When the state of the component is programmatically changed to `ngModel` or `formControl`
   * through its API or form binding, the `checkedStateChange` event is not triggered because it
   * might cause a mix-up with the built-in mechanisms of the `ngModel` or `formControl` bindings.
   *
   * Used to provide a two-way binding for the `checked` property.
   */
  checkedChange = new EventEmitter();
  subs = new Subscription();
  get defaultAttributes() {
    return {
      type: "radio",
      id: this.focusableId,
      title: this.title,
      tabindex: this.tabindex,
      tabIndex: this.tabindex,
      disabled: this.disabled ? "" : null,
      value: this.value,
      checked: this.checked,
      name: this.name,
      "aria-invalid": this.isControlInvalid
    };
  }
  constructor(renderer, hostElement, cdr, ngZone, injector, localizationService) {
    super("radio", hostElement, renderer, cdr, ngZone, injector);
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.cdr = cdr;
    this.ngZone = ngZone;
    this.injector = injector;
    this.localizationService = localizationService;
    validatePackage(packageMetadata5);
    this.direction = localizationService.rtl ? "rtl" : "ltr";
  }
  ngOnInit() {
    super.ngOnInit();
    this.subs.add(this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    }));
  }
  ngAfterViewInit() {
    const stylingInputs = ["size"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
    if (this.control) {
      this.subs.add(this.control.valueChanges.subscribe((e) => {
        this.control.control.setValue(e, {
          emitEvent: false
        });
      }));
    }
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  /**
   * @hidden
   */
  handleChange = ($event) => {
    this.ngZone.run(() => {
      this.checked = $event.target.checked;
      this.checkedChange.emit(this.checked);
      this.ngChange($event.target.value);
    });
  };
  /**
   * @hidden
   */
  writeValue(value) {
    this.checked = value === this.value;
  }
  static ɵfac = function RadioButtonComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RadioButtonComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _RadioButtonComponent,
    selectors: [["kendo-radiobutton"]],
    hostVars: 3,
    hostBindings: function RadioButtonComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-radio-wrap", ctx.hostClass);
      }
    },
    inputs: {
      checked: "checked"
    },
    outputs: {
      checkedChange: "checkedChange"
    },
    exportAs: ["kendoRadioButton"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.radiobutton"
    }, {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _RadioButtonComponent),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _RadioButtonComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 3,
    vars: 21,
    consts: [["input", ""], ["kendoInputSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused"], ["type", "radio", 1, "k-radio", 3, "id", "disabled", "value", "name", "checked", "kendoEventsOutsideAngular"]],
    template: function RadioButtonComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainerStart(0, 1);
        ɵɵtwoWayListener("isFocusedChange", function RadioButtonComponent_Template_ng_container_isFocusedChange_0_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.isFocused, $event) || (ctx.isFocused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function RadioButtonComponent_Template_ng_container_handleBlur_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function RadioButtonComponent_Template_ng_container_onFocus_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵelement(1, "input", 2, 0);
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.isFocused);
        ɵɵadvance();
        ɵɵclassProp("k-disabled", ctx.disabled)("k-checked", ctx.checked)("k-invalid", ctx.isControlInvalid);
        ɵɵproperty("id", ctx.focusableId)("disabled", ctx.disabled)("value", ctx.value)("name", ctx.name)("checked", ctx.checked)("kendoEventsOutsideAngular", ɵɵpureFunction2(18, _c19, ctx.handleInputBlur, ctx.handleChange));
        ɵɵattribute("title", ctx.title)("tabindex", ctx.disabled ? void 0 : ctx.tabindex)("aria-invalid", ctx.isControlInvalid)("required", ctx.isControlRequired ? "" : null);
      }
    },
    dependencies: [SharedInputEventsDirective, EventsOutsideAngularDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioButtonComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoRadioButton",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.radiobutton"
      }, {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => RadioButtonComponent),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => RadioButtonComponent)
      }],
      selector: "kendo-radiobutton",
      template: `
        <ng-container
            kendoInputSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="isFocused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
        >
            <input #input
                type="radio"
                class="k-radio"
                [id]="focusableId"
                [attr.title]="title"
                [disabled]="disabled"
                [class.k-disabled]="disabled"
                [attr.tabindex]="disabled ? undefined : tabindex"
                [value]="value"
                [name]="name"
                [checked]="checked"
                [class.k-checked]="checked"
                [attr.aria-invalid]="isControlInvalid"
                [class.k-invalid]="isControlInvalid"
                [attr.required]="isControlRequired ? '' : null"
                [kendoEventsOutsideAngular]="{
                    blur: handleInputBlur,
                    change: handleChange
                }"
            />
        </ng-container>
    `,
      standalone: true,
      imports: [SharedInputEventsDirective, EventsOutsideAngularDirective]
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: NgZone
    }, {
      type: Injector
    }, {
      type: LocalizationService
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-radio-wrap"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    checked: [{
      type: Input
    }],
    checkedChange: [{
      type: Output
    }]
  });
})();
var DEFAULT_SIZE$3 = "medium";
var RadioButtonDirective = class _RadioButtonDirective {
  renderer;
  hostElement;
  kendoClass = true;
  /**
   * The size property specifies the width and height of the RadioButton
   * ([see example]({% slug appearance_radiobuttondirective %}#toc-size)).
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$3;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  _size = "medium";
  constructor(renderer, hostElement) {
    this.renderer = renderer;
    this.hostElement = hostElement;
    validatePackage(packageMetadata5);
  }
  ngAfterViewInit() {
    const stylingInputs = ["size"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
  }
  handleClasses(value, input) {
    const elem = this.hostElement.nativeElement;
    const classes = getStylingClasses2("radio", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  static ɵfac = function RadioButtonDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RadioButtonDirective)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RadioButtonDirective,
    selectors: [["input", "kendoRadioButton", ""]],
    hostVars: 2,
    hostBindings: function RadioButtonDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-radio", ctx.kendoClass);
      }
    },
    inputs: {
      size: "size"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioButtonDirective, [{
    type: Directive,
    args: [{
      selector: "input[kendoRadioButton]",
      standalone: true
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, {
    kendoClass: [{
      type: HostBinding,
      args: ["class.k-radio"]
    }],
    size: [{
      type: Input
    }]
  });
})();
var RangeSliderCustomMessagesComponent = class _RangeSliderCustomMessagesComponent extends RangeSliderMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function RangeSliderCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RangeSliderCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _RangeSliderCustomMessagesComponent,
    selectors: [["kendo-rangeslider-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: RangeSliderMessages,
      useExisting: forwardRef(() => _RangeSliderCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function RangeSliderCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeSliderCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: RangeSliderMessages,
        useExisting: forwardRef(() => RangeSliderCustomMessagesComponent)
      }],
      selector: "kendo-rangeslider-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var RatingHoveredItemTemplateDirective = class _RatingHoveredItemTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function RatingHoveredItemTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RatingHoveredItemTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RatingHoveredItemTemplateDirective,
    selectors: [["", "kendoRatingHoveredItemTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RatingHoveredItemTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoRatingHoveredItemTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var RatingItemTemplateDirective = class _RatingItemTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function RatingItemTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RatingItemTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RatingItemTemplateDirective,
    selectors: [["", "kendoRatingItemTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RatingItemTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoRatingItemTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var RatingSelectedItemTemplateDirective = class _RatingSelectedItemTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function RatingSelectedItemTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RatingSelectedItemTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RatingSelectedItemTemplateDirective,
    selectors: [["", "kendoRatingSelectedItemTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RatingSelectedItemTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoRatingSelectedItemTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var RatingComponent = class _RatingComponent {
  element;
  renderer;
  localizationService;
  cdr;
  zone;
  itemTemplate;
  hoveredItemTemplate;
  selectedItemTemplate;
  /**
   * Determines whether the Rating is disabled ([see example]({% slug disabledstate_rating %})). To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_rating#toc-managing-the-rating-disabled-state-in-reactive-forms).
   *
   * @default false
   *
   */
  disabled = false;
  /**
   * Determines whether the Rating is in its read-only state ([see example]({% slug readonly_rating %})).
   *
   * @default false
   *
   */
  readonly = false;
  /**
   * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Rating.
   *
   * @default 0
   *
   */
  tabindex = 0;
  /**
   * Sets the number of rating items ([see example]({% slug itemscount_rating %})).
   *
   * @default 5
   *
   */
  itemsCount = 5;
  /**
   * The initial value of the Rating component.
   * The component can use either NgModel or the `value` binding but not both of them at the same time.
   *
   */
  set value(value) {
    this._value = value;
    this.updateRatingItems();
  }
  get value() {
    return this._value;
  }
  /**
   * Sets the selection mode of the Rating ([see example]({% slug selection_rating %})).
   *
   * @default 'continuous'
   *
   */
  set selection(selection) {
    this._selection = selection;
    this.updateRatingItems();
  }
  get selection() {
    return this._selection;
  }
  /**
   * Determines the precision of the Rating ([see example]({% slug precision_rating %})).
   *
   * @default 'item'
   *
   */
  set precision(precision) {
    this._precision = precision;
    this.updateRatingItems();
  }
  get precision() {
    return this._precision;
  }
  /**
   * Sets the Rating label. It is not the native HTML `label` element, it is just a `span` element with the provided text ([see example]({% slug label_rating %})).
   */
  label;
  /**
   * Sets custom Rating font icon ([see example]({% slug icon_rating %})).
   */
  icon;
  /**
   * Sets custom Rating SVG icon. It is the icon that is used for selected/hovered state ([see example]({% slug icon_rating %})).
   */
  svgIcon = starIcon;
  /**
   * Sets custom Rating SVG icon. It is the icon that is used for not selected/hovered state ([see example]({% slug icon_rating %})).
   */
  svgIconOutline = starOutlineIcon;
  /**
   * Fires each time the user selects a new value.
   */
  valueChange = new EventEmitter();
  hostClass = true;
  direction;
  get isControlInvalid() {
    return this.control?.invalid?.toString();
  }
  valueMin = 0;
  get valueMax() {
    return this.itemsCount;
  }
  get valueNow() {
    return this.value;
  }
  ariaRole = "slider";
  /**
   * @hidden
   */
  ratingItems = [];
  control;
  ngChange = (_2) => {
  };
  ngTouched = () => {
  };
  rect;
  _value;
  _selection = "continuous";
  _precision = "item";
  subscriptions = new Subscription();
  constructor(element, renderer, localizationService, cdr, zone) {
    this.element = element;
    this.renderer = renderer;
    this.localizationService = localizationService;
    this.cdr = cdr;
    this.zone = zone;
    validatePackage(packageMetadata5);
  }
  ngOnInit() {
    this.subscriptions.add(this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    }));
    this.subscriptions.add(this.renderer.listen(this.element.nativeElement, "blur", () => this.ngTouched()));
    this.subscriptions.add(this.renderer.listen(this.element.nativeElement, "keydown", (event) => this.onKeyDown(event)));
    this.createRatingItems();
  }
  ngAfterViewInit() {
    const items = this.element.nativeElement.querySelectorAll(".k-rating-item");
    this.zone.runOutsideAngular(() => {
      items.forEach((item, index) => this.subscriptions.add(this.renderer.listen(item, "mousemove", (event) => this.onMouseMove(index, event))));
    });
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  /**
   * Focuses the Rating component.
   */
  focus() {
    if (isDocumentAvailable() && !this.disabled) {
      this.element.nativeElement.focus();
    }
  }
  /**
   * Blurs the Rating component.
   */
  blur() {
    if (isDocumentAvailable()) {
      this.element.nativeElement.blur();
    }
  }
  /**
   * @hidden
   */
  createRatingItems() {
    for (let i = 0; i < this.itemsCount; i++) {
      const item = {
        title: this.isHalf(i, this.value) ? String(i + 0.5) : String(i + 1),
        selected: this.isSelected(i, this.value),
        selectedIndicator: false,
        hovered: false,
        half: this.isHalf(i, this.value)
      };
      this.ratingItems.push(item);
    }
  }
  /**
   * @hidden
   */
  onMouseEnter(event) {
    this.rect = event.target.getBoundingClientRect();
  }
  /**
   * @hidden
   */
  onMouseMove(value, event) {
    const halfPrecision = this.precision === "half";
    const isFirstHalf = halfPrecision && this.isFirstHalf(this.rect, event.clientX);
    this.zone.run(() => this.ratingItems.forEach((item, index) => {
      item.title = halfPrecision && value === index && isFirstHalf ? String(index + 0.5) : String(index + 1);
      item.selected = item.hovered = this.isSelected(index, value + 1);
      item.selectedIndicator = this.isSelected(index, this.value);
      item.half = halfPrecision && value === index ? isFirstHalf : false;
    }));
  }
  /**
   * @hidden
   */
  onMouseOut() {
    this.rect = null;
    this.updateRatingItems();
  }
  /**
   * @hidden
   * Called when the status of the component changes to or from `disabled`.
   * Depending on the value, it enables or disables the appropriate DOM element.
   *
   * @param isDisabled
   */
  setDisabledState(isDisabled2) {
    this.disabled = isDisabled2;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  changeValue(index, event) {
    const rect = event.target.getBoundingClientRect();
    const isFirstHalf = this.isFirstHalf(rect, event.clientX);
    const value = this.precision === "half" && isFirstHalf ? index + 0.5 : index + 1;
    if (!areSame(this.value, value)) {
      this.value = value;
      this.ngChange(this.value);
      this.valueChange.emit(this.value);
      this.updateRatingItems();
      this.cdr.markForCheck();
    }
  }
  /**
   * @hidden
   */
  updateRatingItems() {
    this.ratingItems.forEach((item, index) => {
      item.title = this.isHalf(index, this.value) ? String(index + 0.5) : String(index + 1);
      item.selected = this.isSelected(index, this.value);
      item.selectedIndicator = this.isSelected(index, this.value);
      item.hovered = false;
      item.half = this.isHalf(index, this.value);
    });
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value;
    this.updateRatingItems();
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.ngChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.ngTouched = fn;
  }
  isSelected(index, value) {
    return this.selection === "single" ? index === Math.ceil(value - 1) : index <= Math.ceil(value - 1);
  }
  isHalf(index, value) {
    return this.precision === "half" && value > index && value < index + 1;
  }
  isFirstHalf(rect, clientX) {
    const elementPosition = rect.x + rect.width / 2;
    return this.direction === "ltr" ? clientX < elementPosition : clientX > elementPosition;
  }
  onKeyDown(event) {
    const decreaseValue = () => {
      if (this.value <= 0) {
        return;
      }
      this.value = this.precision === "half" ? this.value - 0.5 : this.value - 1;
      this.ngChange(this.value);
      this.valueChange.emit(this.value);
      this.updateRatingItems();
      this.cdr.markForCheck();
    };
    const increaseValue = () => {
      if (this.value >= this.itemsCount) {
        return;
      }
      this.value = this.precision === "half" ? this.value + 0.5 : this.value + 1;
      this.ngChange(this.value);
      this.valueChange.emit(this.value);
      this.updateRatingItems();
      this.cdr.markForCheck();
    };
    const setMinValue = () => {
      if (!areSame(this.value, this.valueMin)) {
        this.value = this.valueMin;
        this.ngChange(this.value);
        this.valueChange.emit(this.value);
        this.updateRatingItems();
        this.cdr.markForCheck();
      }
    };
    const setMaxValue = () => {
      if (!areSame(this.value, this.valueMax)) {
        this.value = this.valueMax;
        this.ngChange(this.value);
        this.valueChange.emit(this.value);
        this.updateRatingItems();
        this.cdr.markForCheck();
      }
    };
    if (event.keyCode === Keys.ArrowDown) {
      decreaseValue();
    }
    if (event.keyCode === Keys.ArrowLeft) {
      if (this.direction === "ltr") {
        decreaseValue();
      } else {
        increaseValue();
      }
    }
    if (event.keyCode === Keys.ArrowUp) {
      increaseValue();
    }
    if (event.keyCode === Keys.ArrowRight) {
      if (this.direction === "ltr") {
        increaseValue();
      } else {
        decreaseValue();
      }
    }
    if (event.keyCode === Keys.Home) {
      setMinValue();
    }
    if (event.keyCode === Keys.End) {
      setMaxValue();
    }
  }
  static ɵfac = function RatingComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RatingComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _RatingComponent,
    selectors: [["kendo-rating"]],
    contentQueries: function RatingComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, RatingItemTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, RatingHoveredItemTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, RatingSelectedItemTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.hoveredItemTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.selectedItemTemplate = _t.first);
      }
    },
    hostVars: 15,
    hostBindings: function RatingComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-disabled", ctx.disabled)("aria-readonly", ctx.readonly)("tabindex", ctx.tabindex)("dir", ctx.direction)("aria-invalid", ctx.isControlInvalid)("aria-valuemin", ctx.valueMin)("aria-valuemax", ctx.valueMax)("aria-valuenow", ctx.valueNow)("role", ctx.ariaRole);
        ɵɵclassProp("k-disabled", ctx.disabled)("k-readonly", ctx.readonly)("k-rating", ctx.hostClass);
      }
    },
    inputs: {
      disabled: "disabled",
      readonly: "readonly",
      tabindex: "tabindex",
      itemsCount: "itemsCount",
      value: "value",
      selection: "selection",
      precision: "precision",
      label: "label",
      icon: "icon",
      svgIcon: "svgIcon",
      svgIconOutline: "svgIconOutline"
    },
    outputs: {
      valueChange: "valueChange"
    },
    exportAs: ["kendoRating"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.rating"
    }, {
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _RatingComponent)
      /* eslint-disable-line*/
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _RatingComponent)
    }])],
    decls: 3,
    vars: 2,
    consts: [[1, "k-rating-container"], ["class", "k-rating-item", 3, "title", "ngClass", "mouseenter", "mouseout", "click", 4, "ngFor", "ngForOf"], ["class", "k-rating-label", 4, "ngIf"], [1, "k-rating-item", 3, "mouseenter", "mouseout", "click", "title", "ngClass"], [4, "ngIf"], ["size", "xlarge", 3, "name", "svgIcon", 4, "ngIf"], ["size", "xlarge", 3, "name", 4, "ngIf"], ["size", "xlarge", 3, "name", "svgIcon"], ["size", "xlarge", 3, "name"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-rating-precision-complement"], ["class", "k-rating-precision-part", 3, "ngStyle", 4, "ngIf"], [1, "k-rating-precision-part", 3, "ngStyle"], [1, "k-rating-label"]],
    template: function RatingComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "span", 0);
        ɵɵtemplate(1, RatingComponent_span_1_Template, 3, 7, "span", 1);
        ɵɵelementEnd();
        ɵɵtemplate(2, RatingComponent_span_2_Template, 2, 1, "span", 2);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.ratingItems);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.label);
      }
    },
    dependencies: [NgForOf, NgClass, NgIf, IconWrapperComponent, NgTemplateOutlet, NgStyle],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RatingComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoRating",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.rating"
      }, {
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => RatingComponent)
        /* eslint-disable-line*/
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => RatingComponent)
      }],
      selector: "kendo-rating",
      template: `
        <span class="k-rating-container">
            <span
                *ngFor="let item of ratingItems; index as i"
                class="k-rating-item"
                [title]="item.title"
                [ngClass]="{
                    'k-selected': item.selected || item.selectedIndicator,
                    'k-hover': item.hovered
                }"
                (mouseenter)="onMouseEnter($event)"
                (mouseout)="onMouseOut()"
                (click)="changeValue(i, $event)"
            >
                <ng-container *ngIf="!item.half">
                    <ng-container *ngIf="!itemTemplate">
                        <kendo-icon-wrapper
                            *ngIf="!icon"
                            size="xlarge"
                            [name]="item.selected || item.hovered ? 'star' : 'star-outline'"
                            [svgIcon]="item.selected || item.hovered ? svgIcon : svgIconOutline"
                        >
                        </kendo-icon-wrapper>

                        <kendo-icon-wrapper
                            *ngIf="icon"
                            size="xlarge"
                            [name]="item.selected || item.hovered ? icon : icon + '-outline'"
                        >
                        </kendo-icon-wrapper>
                    </ng-container>

                    <ng-template
                        *ngIf="itemTemplate && (!item.selected && !item.hovered)"
                        [ngTemplateOutlet]="itemTemplate?.templateRef"
                        [ngTemplateOutletContext]="{index: i}"
                    >
                    </ng-template>

                    <ng-template
                        *ngIf="hoveredItemTemplate && item.hovered"
                        [ngTemplateOutlet]="hoveredItemTemplate?.templateRef"
                        [ngTemplateOutletContext]="{index: i}"
                    >
                    </ng-template>

                    <ng-template
                        *ngIf="selectedItemTemplate && (item.selected && !item.hovered)"
                        [ngTemplateOutlet]="selectedItemTemplate?.templateRef"
                        [ngTemplateOutletContext]="{index: i}"
                    >
                    </ng-template>
                </ng-container>

                <ng-container *ngIf="item.half">
                    <ng-container *ngIf="!itemTemplate">
                        <span class="k-rating-precision-complement">
                            <kendo-icon-wrapper
                                *ngIf="!icon"
                                size="xlarge"
                                [name]="'star-outline'"
                                [svgIcon]="svgIconOutline"
                            >
                            </kendo-icon-wrapper>

                            <kendo-icon-wrapper
                                *ngIf="icon"
                                size="xlarge"
                                [name]="icon + '-outline'"
                            >
                            </kendo-icon-wrapper>
                        </span>

                        <span
                            class="k-rating-precision-part"
                            [ngStyle]="{'clipPath': direction === 'rtl' ? 'inset(0 0 0 50%)' : 'inset(0 50% 0 0)'}"
                        >
                            <kendo-icon-wrapper
                                *ngIf="!icon"
                                size="xlarge"
                                [name]="'star'"
                                [svgIcon]="svgIcon"
                            >
                            </kendo-icon-wrapper>

                            <kendo-icon-wrapper
                                *ngIf="icon"
                                size="xlarge"
                                [name]="icon"
                            >
                            </kendo-icon-wrapper>
                        </span>
                    </ng-container>

                    <span
                        class="k-rating-precision-complement"
                    >
                        <ng-template
                            [ngTemplateOutlet]="itemTemplate?.templateRef"
                            [ngTemplateOutletContext]="{index: i}"
                        >
                        </ng-template>
                    </span>

                    <span
                        *ngIf="hoveredItemTemplate && item.hovered"
                        class="k-rating-precision-part"
                        [ngStyle]="{'clipPath': direction === 'rtl' ? 'inset(0 0 0 50%)' : 'inset(0 50% 0 0)'}"
                    >
                        <ng-template
                            [ngTemplateOutlet]="hoveredItemTemplate?.templateRef"
                            [ngTemplateOutletContext]="{index: i}"
                        >
                        </ng-template>
                    </span>

                    <span
                        *ngIf="selectedItemTemplate && (item.selected && !item.hovered)"
                        class="k-rating-precision-part"
                        [ngStyle]="{'clipPath': direction === 'rtl' ? 'inset(0 0 0 50%)' : 'inset(0 50% 0 0)'}"
                    >
                        <ng-template
                            [ngTemplateOutlet]="selectedItemTemplate?.templateRef"
                            [ngTemplateOutletContext]="{index: i}"
                        >
                        </ng-template>
                    </span>

                    <span [style.width.px]="24" [style.height.px]="24" [style.display]="'block'"></span>
                </ng-container>
            </span>
        </span>

        <span 
            *ngIf="label"
            class="k-rating-label"
        >{{ label }}</span>
  `,
      standalone: true,
      imports: [NgForOf, NgClass, NgIf, IconWrapperComponent, NgTemplateOutlet, NgStyle]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: NgZone
    }];
  }, {
    itemTemplate: [{
      type: ContentChild,
      args: [RatingItemTemplateDirective]
    }],
    hoveredItemTemplate: [{
      type: ContentChild,
      args: [RatingHoveredItemTemplateDirective]
    }],
    selectedItemTemplate: [{
      type: ContentChild,
      args: [RatingSelectedItemTemplateDirective]
    }],
    disabled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }, {
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.aria-readonly"]
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    tabindex: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    itemsCount: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    selection: [{
      type: Input
    }],
    precision: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }],
    svgIconOutline: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-rating"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    isControlInvalid: [{
      type: HostBinding,
      args: ["attr.aria-invalid"]
    }],
    valueMin: [{
      type: HostBinding,
      args: ["attr.aria-valuemin"]
    }],
    valueMax: [{
      type: HostBinding,
      args: ["attr.aria-valuemax"]
    }],
    valueNow: [{
      type: HostBinding,
      args: ["attr.aria-valuenow"]
    }],
    ariaRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var SignatureMessages = class _SignatureMessages extends ComponentMessages {
  /**
   * The title of the Clear button of the Signature.
   */
  clear;
  /**
   * The title of the Minimize button of the Signature.
   */
  minimize;
  /**
   * The title of the Maximize button of the Signature.
   */
  maximize;
  /**
   * The value of the Signature canvas element aria-label attribute.
   */
  canvasLabel;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵSignatureMessages_BaseFactory;
    return function SignatureMessages_Factory(__ngFactoryType__) {
      return (ɵSignatureMessages_BaseFactory || (ɵSignatureMessages_BaseFactory = ɵɵgetInheritedFactory(_SignatureMessages)))(__ngFactoryType__ || _SignatureMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _SignatureMessages,
    selectors: [["kendo-signature-messages-base"]],
    inputs: {
      clear: "clear",
      minimize: "minimize",
      maximize: "maximize",
      canvasLabel: "canvasLabel"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SignatureMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-signature-messages-base"
    }]
  }], null, {
    clear: [{
      type: Input
    }],
    minimize: [{
      type: Input
    }],
    maximize: [{
      type: Input
    }],
    canvasLabel: [{
      type: Input
    }]
  });
})();
var SignatureCustomMessagesComponent = class _SignatureCustomMessagesComponent extends SignatureMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function SignatureCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SignatureCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SignatureCustomMessagesComponent,
    selectors: [["kendo-signature-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: SignatureMessages,
      useExisting: forwardRef(() => _SignatureCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function SignatureCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SignatureCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: SignatureMessages,
        useExisting: forwardRef(() => SignatureCustomMessagesComponent)
      }],
      selector: "kendo-signature-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var SignatureCloseEvent = class extends PreventableEvent {
};
var SignatureOpenEvent = class extends PreventableEvent {
};
var LocalizedSignatureMessagesDirective = class _LocalizedSignatureMessagesDirective extends SignatureMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedSignatureMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedSignatureMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedSignatureMessagesDirective,
    selectors: [["", "kendoSignatureLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: SignatureMessages,
      useExisting: forwardRef(() => _LocalizedSignatureMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedSignatureMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: SignatureMessages,
        useExisting: forwardRef(() => LocalizedSignatureMessagesDirective)
      }],
      selector: "[kendoSignatureLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var noop4 = () => {
};
var _id = 0;
var nextId = () => "k-signature-focusable-" + _id++;
var FOCUSED_CLASS = "k-focus";
var DEFAULT_SIZE$2 = "medium";
var DEFAULT_ROUNDED$2 = "medium";
var DEFAULT_FILL_MODE$2 = "solid";
var DEFAULT_POPUP_SCALE = 3;
var DEFAULT_EXPORT_SCALE2 = 2;
var DEFAULT_COLOR2 = "#000000";
var DEFAULT_BACKGROUND_COLOR2 = "#ffffff";
var iconsMap = {
  xIcon,
  hyperlinkOpenIcon
};
var SignatureComponent = class _SignatureComponent {
  element;
  renderer;
  ngZone;
  cd;
  localization;
  cdr;
  staticHostClasses = true;
  /**
   * @hidden
   */
  focusableId = nextId();
  direction;
  /**
   * Sets the read-only state of the Signature.
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the disabled state of the Signature. To disable the component in reactive forms, visit the following [article](slug:formssupport_signature#toc-managing-the-signature-disabled-state-in-reactive-forms)
   *
   * @default false
   */
  disabled = false;
  /**
   * Sets the width of the signature in pixels.
   *
   * The width can also be set using inline styles and CSS.
   */
  width;
  /**
   * The height of the signature in pixels.
   *
   * The height can also be set using inline styles and CSS.
   */
  height;
  /**
   * Gets or sets the value of the signature.
   *
   * The value is a Base64-encoded PNG image.
   */
  set value(value) {
    if (value !== this._value) {
      this._value = value;
      if (this.instance) {
        this.instance.loadImage(value);
      }
    }
  }
  get value() {
    return this._value;
  }
  /**
   * @hidden
   */
  svgIcon(name2) {
    return iconsMap[name2];
  }
  /**
   * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   *
   * @default 0
   */
  set tabindex(value) {
    const tabindex = Number(value);
    const defaultValue = 0;
    this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
  }
  get tabindex() {
    return !this.disabled ? this._tabindex : void 0;
  }
  /**
   * The size property specifies the padding of the Signature internal controls
   * ([see example]({% slug appearance_signature %}#toc-size)).
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  size = DEFAULT_SIZE$2;
  /**
   * The `rounded` property specifies the border radius of the signature
   * ([see example](slug:appearance_signature#rounded-corners)).
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `full` (not supported by the Signature)
   * * `none`
   */
  rounded = DEFAULT_ROUNDED$2;
  /**
   * The `fillMode` property specifies the background and border styles of the signature
   * ([see example](slug:appearance_signature#toc-fill-mode)).
   *
   * The possible values are:
   * * `flat`
   * * `solid` (default)
   * * `outline`
   * * `none`
   */
  fillMode = DEFAULT_FILL_MODE$2;
  /**
   * The stroke color of the signature.
   *
   * Accepts CSS color names and hex values.
   *
   * The default value is determined by the theme `$kendo-input-text` variable.
   */
  color;
  /**
   * The background color of the signature.
   *
   * Accepts CSS color names and hex values.
   *
   * The default value is determined by the theme `$kendo-input-bg` variable.
   */
  backgroundColor;
  /**
   * The stroke width of the signature.
   *
   * @default 1
   */
  strokeWidth = 1;
  /**
   * A flag indicating whether to smooth out signature lines.
   *
   * @default false
   */
  smooth = false;
  /**
   * A flag indicating if the signature can be maximized.
   *
   * @default true
   */
  maximizable = true;
  /**
   * @hidden
   */
  maximized = false;
  /**
   * The scale factor for the popup.
   *
   * The Signature width and height will be multiplied by the scale when showing the popup.
   *
   * @default 3
   */
  popupScale = DEFAULT_POPUP_SCALE;
  /**
   * The scale factor for the exported image.
   *
   * The Signature width and height will be multiplied by the scale when converting the signature to an image.
   *
   * @default 2
   */
  exportScale = DEFAULT_EXPORT_SCALE2;
  /**
   * @hidden
   */
  parentLocalization;
  /**
   * A flag indicating whether the dotted line should be displayed in the background.
   *
   * @default false
   */
  hideLine = false;
  /**
   * Fires each time the signature value is changed.
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the popup is about to open.
   * This event is preventable. If you cancel it, the popup will remain closed.
   */
  open = new EventEmitter();
  /**
   * Fires each time the popup is about to close.
   * This event is preventable. If you cancel it, the popup will remain open.
   */
  close = new EventEmitter();
  /**
   * Fires each time Signature is focused.
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the Signature is blurred.
   */
  onBlur = new EventEmitter();
  /**
   * @hidden
   */
  minimize = new EventEmitter();
  canvas;
  minimizeButton;
  maximizeButton;
  /**
   * Indicates whether the Signature wrapper is focused.
   */
  isFocused = false;
  /**
   * Indicates whether the Signature popup is open.
   */
  isOpen;
  /**
   * @hidden
   */
  get isEmpty() {
    return !this.value;
  }
  /**
   * @hidden
   */
  get canvasLabel() {
    return this.getMessage("canvasLabel");
  }
  /**
   * @hidden
   */
  get clearTitle() {
    return this.getMessage("clear");
  }
  /**
   * @hidden
   */
  get minimizeTitle() {
    return this.getMessage("minimize");
  }
  /**
   * @hidden
   */
  get maximizeTitle() {
    return this.getMessage("maximize");
  }
  /**
   * @hidden
   */
  get baseWidth() {
    return this.width || this.element.nativeElement.offsetWidth;
  }
  /**
   * @hidden
   */
  get baseHeight() {
    return this.height || this.element.nativeElement.offsetHeight;
  }
  /**
   * @hidden
   */
  get popupWidth() {
    return this.baseWidth * this.popupScale;
  }
  /**
   * @hidden
   */
  get popupHeight() {
    return this.baseHeight * this.popupScale;
  }
  /**
   * @hidden
   */
  isDrawing = false;
  /**
   * @hidden
   */
  get showMaximize() {
    return !(this.maximized || this.isDrawing || !this.maximizable || this.disabled);
  }
  /**
   * @hidden
   */
  get showMinimize() {
    return this.maximized && !this.isDrawing;
  }
  /**
   * @hidden
   */
  get showClear() {
    return !(this.isEmpty || this.isDrawing || this.readonly || this.disabled);
  }
  /**
   * @hidden
   */
  get focused() {
    return this.isFocused;
  }
  set focused(value) {
    if (this.isFocused !== value && this.element) {
      const wrap2 = this.element.nativeElement;
      if (value && !this.maximized) {
        this.renderer.addClass(wrap2, FOCUSED_CLASS);
      } else {
        this.renderer.removeClass(wrap2, FOCUSED_CLASS);
      }
      this.isFocused = value;
    }
  }
  get options() {
    return {
      scale: this.maximized ? this.popupScale : 1,
      color: this.color,
      backgroundColor: this.backgroundColor,
      strokeWidth: this.strokeWidth,
      smooth: this.smooth,
      readonly: this.readonly
    };
  }
  notifyNgTouched = noop4;
  notifyNgChanged = noop4;
  instance;
  _value;
  _tabindex = 0;
  subscriptions;
  unsubscribe;
  hostClasses = [];
  constructor(element, renderer, ngZone, cd, localization, cdr) {
    this.element = element;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.cd = cd;
    this.localization = localization;
    this.cdr = cdr;
    validatePackage(packageMetadata5);
    this.direction = localization.rtl ? "rtl" : "ltr";
  }
  ngOnInit() {
    this.subscriptions = this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
  }
  ngAfterViewInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.applyHostClasses();
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      this.readThemeColors();
      this.instance.setOptions(this.options);
    });
    this.ngZone.runOutsideAngular(() => {
      const element = this.canvas.nativeElement;
      this.instance = new SignaturePad(element, __spreadProps(__spreadValues({}, this.options), {
        onChange: () => this.onValueChange(),
        onDraw: () => this.onDraw(),
        onDrawEnd: () => this.onDrawEnd()
      }));
      if (this.value) {
        this.instance.loadImage(this.value);
      }
      if (this.maximized) {
        this.ngZone.onStable.pipe(take(1)).subscribe(() => {
          this.minimizeButton?.nativeElement.focus();
        });
      }
      this.addEventListeners();
    });
  }
  ngOnChanges(changes) {
    if (anyChanged(["readonly", "color", "backgroundColor", "strokeWidth", "smooth"], changes, true)) {
      this.instance.setOptions(this.options);
    }
    this.applyHostClasses();
  }
  ngOnDestroy() {
    if (this.instance) {
      this.instance.destroy();
      this.instance = null;
    }
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
      this.subscriptions = null;
    }
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
    }
  }
  /**
   * @hidden
   */
  onClear() {
    this.reset();
    this.valueChange.emit(void 0);
    this.canvas.nativeElement.focus();
  }
  /**
   * @hidden
   */
  onValueChange() {
    return __async(this, null, function* () {
      const value = yield this.instance.exportImage({
        width: this.baseWidth * this.exportScale,
        height: this.baseHeight * this.exportScale
      });
      this._value = value;
      this.cd.markForCheck();
      this.ngZone.run(() => {
        this.valueChange.emit(value);
        this.notifyNgChanged(value);
      });
    });
  }
  /**
   * @hidden
   */
  onDialogValueChange(value) {
    this.value = value;
    this.valueChange.emit(value);
    this.notifyNgTouched();
    this.notifyNgChanged(value);
  }
  /**
   * @hidden
   */
  onDialogClick(e) {
    if (e.target.classList.contains("k-overlay")) {
      this.isOpen = false;
      this.maximizeButton?.nativeElement.focus();
    }
  }
  /**
   * @hidden
   */
  onDialogKeydown(e) {
    if (e.keyCode === Keys.Escape) {
      this.isOpen = false;
      this.cd.detectChanges();
      this.maximizeButton?.nativeElement.focus();
    }
  }
  /**
   * @hidden
   */
  onDialogClose() {
    const args = new SignatureCloseEvent();
    this.close.next(args);
    if (!args.isDefaultPrevented()) {
      this.isOpen = false;
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        (this.maximizeButton || this.element)?.nativeElement?.focus();
      });
    }
  }
  /**
   * Clears the value of the Signature.
   */
  reset() {
    if (!isPresent5(this.value)) {
      return;
    }
    this.instance?.clear();
    this.value = this._value = void 0;
    this.notifyNgChanged(void 0);
  }
  /**
   * Toggles the popup of the Signature.
   * Does not trigger the `open` and `close` events of the component.
   *
   * @param open An optional parameter. Specifies whether the popup will be opened or closed.
   */
  toggle(open) {
    if (this.disabled || this.readonly) {
      return;
    }
    open = isPresent5(open) ? open : !this.isOpen;
    this.isOpen = open;
  }
  /**
   * @hidden
   */
  onMaximize() {
    return __async(this, null, function* () {
      const args = new SignatureOpenEvent();
      this.open.next(args);
      if (!args.isDefaultPrevented()) {
        this.popupValue = yield this.instance.exportImage({
          width: this.popupWidth * this.exportScale,
          height: this.popupHeight * this.exportScale
        });
        this.isOpen = true;
        this.cd.detectChanges();
      }
    });
  }
  /**
   * @hidden
   */
  onMinimize() {
    this.minimize.next();
  }
  applyHostClasses() {
    const classList = this.element.nativeElement.classList;
    this.hostClasses.forEach(([name2]) => classList.remove(name2));
    this.hostClasses = [[`k-signature-${SIZE_MAP[this.size || DEFAULT_SIZE$2]}`, !isNone(this.size)], [`k-input-${this.fillMode || DEFAULT_FILL_MODE$2}`, !isNone(this.fillMode)], [`k-rounded-${ROUNDED_MAP[this.rounded || DEFAULT_ROUNDED$2]}`, !isNone(this.rounded)]];
    this.hostClasses.forEach(([name2, enabled]) => classList.toggle(name2, enabled));
  }
  readThemeColors() {
    let defaultColor2 = DEFAULT_COLOR2;
    let defaultBackgroundColor = DEFAULT_BACKGROUND_COLOR2;
    if (isDocumentAvailable()) {
      const el = this.element.nativeElement;
      defaultColor2 = getComputedStyle(el).color;
      defaultBackgroundColor = getComputedStyle(el).backgroundColor;
    }
    this.color = this.color || defaultColor2;
    this.backgroundColor = this.backgroundColor || defaultBackgroundColor;
  }
  /**
   * Focuses the wrapper of the Signature.
   */
  focus() {
    this.focused = true;
    this.element.nativeElement.focus();
  }
  /**
   * @hidden
   */
  onWrapperFocus() {
    if (this.focused) {
      return;
    }
    this.ngZone.run(() => {
      this.focus();
      this.onFocus.emit();
    });
  }
  /**
   * Blurs the Signature.
   */
  blur() {
    this.focused = false;
    this.element.nativeElement.blur();
    this.notifyNgTouched();
  }
  /**
   * @hidden
   */
  onWrapperBlur() {
    if (this.isOpen) {
      return;
    }
    this.ngZone.run(() => {
      this.onBlur.emit();
      this.focused = false;
      this.notifyNgTouched();
    });
  }
  /**
   * @hidden
   */
  onWrapperClick(_event) {
    if (this.disabled) {
      return;
    }
    this.focus();
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value;
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.notifyNgChanged = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.notifyNgTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.disabled = isDisabled2;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  popupValue;
  onDraw() {
    this.isDrawing = true;
    this.cd.markForCheck();
  }
  onDrawEnd() {
    this.isDrawing = false;
    this.cd.markForCheck();
  }
  addEventListeners() {
    const element = this.element.nativeElement;
    const focusIn = this.renderer.listen(element, "focusin", () => this.onWrapperFocus());
    const focusOut = this.renderer.listen(element, "focusout", (e) => {
      const insideWrapper = closest(e.relatedTarget, (element2) => element2 === this.element.nativeElement);
      if (!insideWrapper) {
        this.onWrapperBlur();
      }
    });
    const click = this.renderer.listen(element, "click", () => {
      this.ngZone.run((e) => {
        this.onWrapperClick(e);
      });
    });
    this.unsubscribe = () => {
      focusIn();
      focusOut();
      click();
    };
  }
  getMessage(key) {
    if (this.maximized && this.parentLocalization) {
      return this.parentLocalization.get(key);
    }
    return this.localization.get(key);
  }
  static ɵfac = function SignatureComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SignatureComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SignatureComponent,
    selectors: [["kendo-signature"]],
    viewQuery: function SignatureComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c622, 5);
        ɵɵviewQuery(_c632, 5, ElementRef);
        ɵɵviewQuery(_c64, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.canvas = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.minimizeButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.maximizeButton = _t.first);
      }
    },
    hostVars: 13,
    hostBindings: function SignatureComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵstyleProp("width", ctx.width, "px")("height", ctx.height, "px");
        ɵɵclassProp("k-signature", ctx.staticHostClasses)("k-input", ctx.staticHostClasses)("k-readonly", ctx.readonly)("k-disabled", ctx.disabled);
      }
    },
    inputs: {
      focusableId: "focusableId",
      readonly: "readonly",
      disabled: "disabled",
      width: "width",
      height: "height",
      value: "value",
      tabindex: "tabindex",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      color: "color",
      backgroundColor: "backgroundColor",
      strokeWidth: "strokeWidth",
      smooth: "smooth",
      maximizable: "maximizable",
      maximized: "maximized",
      popupScale: "popupScale",
      exportScale: "exportScale",
      parentLocalization: "parentLocalization",
      hideLine: "hideLine"
    },
    outputs: {
      valueChange: "valueChange",
      open: "open",
      close: "close",
      onFocus: "focus",
      onBlur: "blur",
      minimize: "minimize"
    },
    exportAs: ["kendoSignature"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.signature"
    }, {
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _SignatureComponent)
    }]), ɵɵNgOnChangesFeature],
    decls: 10,
    vars: 8,
    consts: () => {
      let i18n_77;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_77 = goog.getMsg("Clear");
        i18n_77 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_77;
      } else {
        i18n_77 = $localize`:kendo.signature.clear|The message for the Clear button.:Clear`;
      }
      let i18n_78;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_78 = goog.getMsg("Maximize");
        i18n_78 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_78;
      } else {
        i18n_78 = $localize`:kendo.signature.maximize|The message for the Maximize button.:Maximize`;
      }
      let i18n_79;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_79 = goog.getMsg("Minimize");
        i18n_79 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_79;
      } else {
        i18n_79 = $localize`:kendo.signature.minimize|The message for the Minimize button.:Minimize`;
      }
      let i18n_80;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_80 = goog.getMsg("Signature canvas");
        i18n_80 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_80;
      } else {
        i18n_80 = $localize`:kendo.signature.canvasLabel|The message for the Canvas element aria-label.:Signature canvas`;
      }
      return [["canvas", ""], ["maximize", ""], ["minimize", ""], ["kendoSignatureLocalizedMessages", "", "clear", i18n_77, "maximize", i18n_78, "minimize", i18n_79, "canvasLabel", i18n_80], ["role", "img", 1, "k-signature-canvas", 3, "id"], [1, "k-signature-actions", "k-signature-actions-top"], ["kendoButton", "", "type", "button", "class", "k-signature-action k-signature-maximize", "icon", "hyperlink-open", "fillMode", "flat", 3, "svgIcon", "size", "title", "click", 4, "ngIf"], ["kendoButton", "", "type", "button", "class", "k-signature-action k-signature-minimize k-rotate-180", "icon", "hyperlink-open", "fillMode", "flat", 3, "svgIcon", "size", "title", "click", 4, "ngIf"], ["class", "k-signature-line", 4, "ngIf"], [1, "k-signature-actions", "k-signature-actions-bottom"], ["kendoButton", "", "class", "k-signature-action k-signature-clear", "icon", "close", "type", "button", "fillMode", "flat", 3, "svgIcon", "size", "title", "click", 4, "ngIf"], ["autoFocusedElement", ".k-signature-action.k-signature-minimize", 3, "click", "keydown", 4, "ngIf"], ["kendoButton", "", "type", "button", "icon", "hyperlink-open", "fillMode", "flat", 1, "k-signature-action", "k-signature-maximize", 3, "click", "svgIcon", "size", "title"], ["kendoButton", "", "type", "button", "icon", "hyperlink-open", "fillMode", "flat", 1, "k-signature-action", "k-signature-minimize", "k-rotate-180", 3, "click", "svgIcon", "size", "title"], [1, "k-signature-line"], ["kendoButton", "", "icon", "close", "type", "button", "fillMode", "flat", 1, "k-signature-action", "k-signature-clear", 3, "click", "svgIcon", "size", "title"], ["autoFocusedElement", ".k-signature-action.k-signature-minimize", 3, "click", "keydown"], [3, "valueChange", "minimize", "readonly", "disabled", "size", "rounded", "fillMode", "color", "backgroundColor", "strokeWidth", "smooth", "value", "hideLine", "maximized", "width", "height", "popupScale", "exportScale", "parentLocalization"]];
    },
    template: function SignatureComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 3);
        ɵɵelement(1, "div", 4, 0);
        ɵɵelementStart(3, "div", 5);
        ɵɵtemplate(4, SignatureComponent_button_4_Template, 2, 4, "button", 6)(5, SignatureComponent_button_5_Template, 2, 4, "button", 7);
        ɵɵelementEnd();
        ɵɵtemplate(6, SignatureComponent_div_6_Template, 1, 0, "div", 8);
        ɵɵelementStart(7, "div", 9);
        ɵɵtemplate(8, SignatureComponent_button_8_Template, 1, 4, "button", 10);
        ɵɵelementEnd();
        ɵɵtemplate(9, SignatureComponent_kendo_dialog_9_Template, 2, 19, "kendo-dialog", 11);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("id", ctx.focusableId);
        ɵɵattribute("tabindex", ctx.tabindex)("aria-label", ctx.canvasLabel);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.showMaximize);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showMinimize);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.hideLine);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.showClear);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isOpen);
      }
    },
    dependencies: [_SignatureComponent, LocalizedSignatureMessagesDirective, NgIf, ButtonComponent, DialogComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SignatureComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoSignature",
      selector: "kendo-signature",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.signature"
      }, {
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => SignatureComponent)
      }],
      template: `
        <ng-container kendoSignatureLocalizedMessages
            i18n-clear="kendo.signature.clear|The message for the Clear button."
            clear="Clear"
            i18n-maximize="kendo.signature.maximize|The message for the Maximize button."
            maximize="Maximize"
            i18n-minimize="kendo.signature.minimize|The message for the Minimize button."
            minimize="Minimize"
            i18n-canvasLabel="kendo.signature.canvasLabel|The message for the Canvas element aria-label."
            canvasLabel="Signature canvas">
        </ng-container>

        <div
            #canvas
            class="k-signature-canvas"
            [attr.tabindex]="tabindex"
            [id]="focusableId"
            role="img"
            [attr.aria-label]="canvasLabel"
        ></div>

        <div class="k-signature-actions k-signature-actions-top">
            <button
                #maximize
                *ngIf="showMaximize"
                kendoButton
                type="button"
                class="k-signature-action k-signature-maximize"
                icon="hyperlink-open"
                [svgIcon]="svgIcon('hyperlinkOpenIcon')"
                fillMode="flat"
                [size]="size"
                (click)="onMaximize()"
                [attr.aria-label]="maximizeTitle"
                [title]="maximizeTitle">
            </button>
            <button
                #minimize
                *ngIf="showMinimize"
                kendoButton
                type="button"
                class="k-signature-action k-signature-minimize k-rotate-180"
                icon="hyperlink-open"
                [svgIcon]="svgIcon('hyperlinkOpenIcon')"
                fillMode="flat"
                [size]="size"
                (click)="onMinimize()"
                [attr.aria-label]="minimizeTitle"
                [title]="minimizeTitle">
            </button>
        </div>
        <div
            *ngIf="!hideLine"
            class="k-signature-line"
        ></div>
        <div class="k-signature-actions k-signature-actions-bottom">
            <button
                *ngIf="showClear"
                kendoButton
                class="k-signature-action k-signature-clear"
                icon="close"
                type="button"
                [svgIcon]="svgIcon('xIcon')"
                fillMode="flat"
                [size]="size"
                [attr.aria-label]="clearTitle"
                [title]="clearTitle"
                (click)="onClear()" >
            </button>
        </div>

        <kendo-dialog
            *ngIf="isOpen"
            autoFocusedElement=".k-signature-action.k-signature-minimize"
            (click)="onDialogClick($event)"
            (keydown)="onDialogKeydown($event)">
            <kendo-signature
                [readonly]="readonly"
                [disabled]="disabled"
                [size]="size"
                [rounded]="rounded"
                [fillMode]="fillMode"
                [color]="color"
                [backgroundColor]="backgroundColor"
                [strokeWidth]="strokeWidth"
                [smooth]="smooth"
                [value]="popupValue"
                (valueChange)="onDialogValueChange($event)"
                [hideLine]="hideLine"
                [class.k-signature-maximized]="true"
                [maximized]="true"
                (minimize)="onDialogClose()"
                [width]="popupWidth"
                [height]="popupHeight"
                [popupScale]="popupScale"
                [exportScale]="(1 / popupScale) * exportScale"
                [parentLocalization]="localization">
            </kendo-signature>
        </kendo-dialog>
    `,
      standalone: true,
      imports: [LocalizedSignatureMessagesDirective, NgIf, ButtonComponent, DialogComponent]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    staticHostClasses: [{
      type: HostBinding,
      args: ["class.k-signature"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    focusableId: [{
      type: Input
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    readonly: [{
      type: HostBinding,
      args: ["class.k-readonly"]
    }, {
      type: Input
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }, {
      type: Input
    }],
    width: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["style.width.px"]
    }],
    height: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["style.height.px"]
    }],
    value: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    backgroundColor: [{
      type: Input
    }],
    strokeWidth: [{
      type: Input
    }],
    smooth: [{
      type: Input
    }],
    maximizable: [{
      type: Input
    }],
    maximized: [{
      type: Input
    }],
    popupScale: [{
      type: Input
    }],
    exportScale: [{
      type: Input
    }],
    parentLocalization: [{
      type: Input
    }],
    hideLine: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    open: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    minimize: [{
      type: Output
    }],
    canvas: [{
      type: ViewChild,
      args: ["canvas"]
    }],
    minimizeButton: [{
      type: ViewChild,
      args: ["minimize", {
        read: ElementRef
      }]
    }],
    maximizeButton: [{
      type: ViewChild,
      args: ["maximize", {
        read: ElementRef
      }]
    }]
  });
})();
var SliderCustomMessagesComponent = class _SliderCustomMessagesComponent extends SliderMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function SliderCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SliderCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SliderCustomMessagesComponent,
    selectors: [["kendo-slider-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: SliderMessages,
      useExisting: forwardRef(() => _SliderCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function SliderCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SliderCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: SliderMessages,
        useExisting: forwardRef(() => SliderCustomMessagesComponent)
      }],
      selector: "kendo-slider-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var SwitchCustomMessagesComponent = class _SwitchCustomMessagesComponent extends Messages2 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function SwitchCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SwitchCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SwitchCustomMessagesComponent,
    selectors: [["kendo-switch-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: Messages2,
      useExisting: forwardRef(() => _SwitchCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function SwitchCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SwitchCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: Messages2,
        useExisting: forwardRef(() => SwitchCustomMessagesComponent)
      }],
      selector: "kendo-switch-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var TextAreaPrefixComponent = class _TextAreaPrefixComponent {
  /**
   * @hidden
   */
  flow = "vertical";
  /**
   * @hidden
   */
  orientation = "horizontal";
  hostClass = true;
  get verticalOrientation() {
    return this.orientation === "vertical";
  }
  get horizontalOrientation() {
    return this.orientation === "horizontal";
  }
  get alignItems() {
    return this.flow === this.orientation;
  }
  static ɵfac = function TextAreaPrefixComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextAreaPrefixComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TextAreaPrefixComponent,
    selectors: [["kendo-textarea-prefix"]],
    hostVars: 8,
    hostBindings: function TextAreaPrefixComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-input-prefix", ctx.hostClass)("k-input-prefix-vertical", ctx.verticalOrientation)("k-input-prefix-horizontal", ctx.horizontalOrientation)("!k-align-items-start", ctx.alignItems);
      }
    },
    inputs: {
      flow: "flow",
      orientation: "orientation"
    },
    exportAs: ["kendoTextAreaPrefix"],
    ngContentSelectors: _c56,
    decls: 1,
    vars: 0,
    template: function TextAreaPrefixComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextAreaPrefixComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoTextAreaPrefix",
      selector: "kendo-textarea-prefix",
      template: `<ng-content></ng-content>`,
      standalone: true
    }]
  }], null, {
    flow: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-input-prefix"]
    }],
    verticalOrientation: [{
      type: HostBinding,
      args: ["class.k-input-prefix-vertical"]
    }],
    horizontalOrientation: [{
      type: HostBinding,
      args: ["class.k-input-prefix-horizontal"]
    }],
    alignItems: [{
      type: HostBinding,
      args: ["class.!k-align-items-start"]
    }]
  });
})();
var TextAreaSuffixComponent = class _TextAreaSuffixComponent {
  /**
   * @hidden
   */
  flow = "vertical";
  /**
   * @hidden
   */
  orientation = "horizontal";
  hostClass = true;
  get verticalOrientation() {
    return this.orientation === "vertical";
  }
  get horizontalOrientation() {
    return this.orientation === "horizontal";
  }
  get alignItems() {
    return this.flow === this.orientation;
  }
  static ɵfac = function TextAreaSuffixComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextAreaSuffixComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TextAreaSuffixComponent,
    selectors: [["kendo-textarea-suffix"]],
    hostVars: 8,
    hostBindings: function TextAreaSuffixComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-input-suffix", ctx.hostClass)("k-input-suffix-vertical", ctx.verticalOrientation)("k-input-suffix-horizontal", ctx.horizontalOrientation)("!k-align-items-start", ctx.alignItems);
      }
    },
    inputs: {
      flow: "flow",
      orientation: "orientation"
    },
    exportAs: ["kendoTextAreaSuffix"],
    ngContentSelectors: _c56,
    decls: 1,
    vars: 0,
    template: function TextAreaSuffixComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextAreaSuffixComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoTextAreaSuffix",
      selector: "kendo-textarea-suffix",
      template: `<ng-content></ng-content>`,
      standalone: true
    }]
  }], null, {
    flow: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-input-suffix"]
    }],
    verticalOrientation: [{
      type: HostBinding,
      args: ["class.k-input-suffix-vertical"]
    }],
    horizontalOrientation: [{
      type: HostBinding,
      args: ["class.k-input-suffix-horizontal"]
    }],
    alignItems: [{
      type: HostBinding,
      args: ["class.!k-align-items-start"]
    }]
  });
})();
var TextFieldsBase = class _TextFieldsBase {
  localizationService;
  ngZone;
  changeDetector;
  renderer;
  injector;
  hostElement;
  /**
   * Sets the `title` attribute of the internal textarea input element of the component.
   */
  title = "";
  /**
   * Sets the disabled state of the TextArea component. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_textarea#toc-managing-the-textarea-disabled-state-in-reactive-forms).
   *
   * @default false
   */
  disabled = false;
  /**
   * Sets the read-only state of the TextArea component.
   *
   * @default false
   */
  readonly = false;
  /**
   * Provides a value for the TextArea component.
   */
  value = null;
  /**
   * Determines whether the whole value will be selected when the TextArea is clicked. Defaults to `false`.
   *
   * @default false
   */
  selectOnFocus = false;
  /**
   * The hint, which is displayed when the Textarea is empty.
   */
  placeholder;
  /**
   * Fires each time the user focuses the internal textarea element of the component.
   * This event is useful when you need to distinguish between focusing the textarea element and focusing one of its adornments.
   */
  inputFocus = new EventEmitter();
  /**
   * Fires each time the internal textarea element gets blurred.
   * This event is useful when adornments are used, in order to distinguish between blurring the textarea element and blurring the whole TextArea component.
   */
  inputBlur = new EventEmitter();
  /**
   * Represents the visible textarea element of the component.
   */
  input;
  get disabledClass() {
    return this.disabled;
  }
  direction;
  /**
   * @hidden
   */
  control;
  subscriptions = new Subscription();
  _isFocused = false;
  focusChangedProgrammatically = false;
  constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {
    this.localizationService = localizationService;
    this.ngZone = ngZone;
    this.changeDetector = changeDetector;
    this.renderer = renderer;
    this.injector = injector;
    this.hostElement = hostElement;
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  /**
   * @hidden
   */
  handleInputBlur = () => {
    this.changeDetector.markForCheck();
    if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {
      this.ngZone.run(() => {
        this.ngTouched();
        this.inputBlur.emit();
      });
    }
  };
  /**
   * @hidden
   * Called when the status of the component changes to or from `disabled`.
   * Depending on the value, it enables or disables the appropriate DOM element.
   *
   * @param isDisabled
   */
  setDisabledState(isDisabled2) {
    this.changeDetector.markForCheck();
    this.disabled = isDisabled2;
  }
  ngChange = (_2) => {
  };
  ngTouched = () => {
  };
  static ɵfac = function TextFieldsBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextFieldsBase)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TextFieldsBase,
    selectors: [["kendo-textfield-base"]],
    viewQuery: function TextFieldsBase_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c172, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
      }
    },
    hostVars: 5,
    hostBindings: function TextFieldsBase_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      title: "title",
      disabled: "disabled",
      readonly: "readonly",
      value: "value",
      selectOnFocus: "selectOnFocus",
      placeholder: "placeholder"
    },
    outputs: {
      inputFocus: "inputFocus",
      inputBlur: "inputBlur"
    },
    standalone: false,
    decls: 0,
    vars: 0,
    template: function TextFieldsBase_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextFieldsBase, [{
    type: Component,
    args: [{
      selector: "kendo-textfield-base",
      template: ``
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }, {
      type: Injector
    }, {
      type: ElementRef
    }];
  }, {
    title: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    value: [{
      type: Input
    }],
    selectOnFocus: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    inputFocus: [{
      type: Output
    }],
    inputBlur: [{
      type: Output
    }],
    input: [{
      type: ViewChild,
      args: ["input", {
        static: true
      }]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }]
  });
})();
var resizeClasses = {
  "vertical": "k-resize-y",
  "horizontal": "k-resize-x",
  "both": "k-resize",
  "none": "k-resize-none",
  "auto": "k-resize-none"
};
var FOCUSED = "k-focus";
var DEFAULT_SIZE$1 = "medium";
var DEFAULT_ROUNDED$1 = "medium";
var DEFAULT_FILL_MODE$1 = "solid";
var TextAreaComponent = class _TextAreaComponent extends TextFieldsBase {
  localizationService;
  ngZone;
  changeDetector;
  renderer;
  injector;
  hostElement;
  /**
   * @hidden
   */
  focusableId = `k-${guid()}`;
  hostClasses = true;
  get flowCol() {
    return this.flow === "vertical";
  }
  get flowRow() {
    return this.flow === "horizontal";
  }
  _flow = "vertical";
  /**
   * Specifies the flow direction of the TextArea sections. This property is useful when adornments are used, in order to specify
   * their position in relation to the textarea element.
   *
   * The possible values are:
   * * `vertical`(Default) &mdash;TextArea sections are placed from top to bottom.
   * * `horizontal`&mdash;TextArea sections are placed from left to right in `ltr`, and from right to left in `rtl` mode.
   */
  set flow(flow) {
    this._flow = flow;
    if (this.prefix) {
      this.prefix.flow = flow;
    }
    if (this.suffix) {
      this.suffix.flow = flow;
    }
  }
  get flow() {
    return this._flow;
  }
  /**
   * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
   */
  set inputAttributes(attributes) {
    if (isObjectPresent(this.parsedAttributes)) {
      removeHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement);
    }
    this._inputAttributes = attributes;
    this.parsedAttributes = this.inputAttributes ? parseAttributes(this.inputAttributes, this.defaultAttributes) : this.inputAttributes;
    this.setInputAttributes();
  }
  get inputAttributes() {
    return this._inputAttributes;
  }
  /**
   * Specifies the orientation of the TextArea adornments. This property is used in order to specify
   * the adornments' position relative to themselves.
   *
   * The possible values are:
   * * `horizontal`(Default) &mdash;TextArea adornments are placed from left to right in `ltr`, and from right to left in `rtl` mode.
   * * `vertical`&mdash;TextArea adornments are placed from top to bottom.
   */
  set adornmentsOrientation(orientation) {
    this._adornmentsOrientation = orientation;
    if (this.prefix) {
      this.prefix.orientation = orientation;
    }
    if (this.suffix) {
      this.suffix.orientation = orientation;
    }
  }
  get adornmentsOrientation() {
    return this._adornmentsOrientation;
  }
  /**
   *  Specifies the visible height of the textarea element in lines.
   */
  rows;
  /**
   * Specifies the visible width of the textarea element (in average character width).
   */
  cols;
  /**
   * Specifies the maximum number of characters that the user can enter in the TextArea component.
   */
  maxlength;
  /**
   * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Configures the resize behavior of the TextArea.
   *
   * The possible values are:
   * * `vertical`(Default)&mdash;The TextArea component can be resized only vertically.
   * * `horizontal`&mdash;The TextArea component can be resized only horizontally.
   * * `both`&mdash;The TextArea component can be resized in both (horizontal and vertical) directions.
   * * `auto`&mdash;Specifies whether the TextArea component will adjust its height automatically, based on the content.
   * * `none`&mdash;The TextArea cannot be resized.
   *
   */
  resizable = "vertical";
  /**
   * The size property specifies the padding of the internal textarea element
   * ([see example]({% slug appearance_textarea %}#toc-size)).
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$1;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * The `rounded` property specifies the border radius of the TextArea
   * ([see example](slug:appearance_textarea#toc-roundness)).
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED$1;
    this.handleClasses(newRounded, "rounded");
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * The `fillMode` property specifies the background and border styles of the TextArea
   * ([see example](slug:appearance_textarea#toc-fill-mode)).
   *
   * The possible values are:
   * * `flat`
   * * `solid` (default)
   * * `outline`
   * * `none`
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$1;
    this.handleClasses(newFillMode, "fillMode");
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Specifies whether the prefix separator of the TextArea is rendered.
   * If a prefix template is not declared, the separator will not be rendered, regardless of the parameter value.
   *
   * @default false
   */
  showPrefixSeparator = false;
  /**
   * Specifies whether the suffix separator of the TextArea is rendered.
   * If a suffix template is not declared, the separator will not be rendered, regardless of the parameter value.
   *
   * @default false
   */
  showSuffixSeparator = false;
  /**
   * Fires each time the user focuses the TextArea component.
   *
   * > To wire the event programmatically, use the `onFocus` property.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <kendo-textarea (focus)="handleFocus()"></kendo-textarea>
   * `
   * })
   * class AppComponent {
   *   public handleFocus(): void {
   *      console.log('Component is focused.');
   *   }
   * }
   * ```
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the TextArea component gets blurred.
   *
   * > To wire the event programmatically, use the `onBlur` property.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <kendo-textarea (blur)="handleBlur()"></kendo-textarea>
   * `
   * })
   * class AppComponent {
   *   public handleBlur(): void {
   *      console.log('Component is blurred');
   *   }
   * }
   * ```
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the value is changed or the component is blurred
   * ([see example](slug:events_textarea)).
   * When the component value is changed programmatically or via its form control binding, the valueChange event is not emitted.
   */
  valueChange = new EventEmitter();
  initialHeight;
  resizeSubscription;
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  _adornmentsOrientation = "horizontal";
  _inputAttributes;
  parsedAttributes = {};
  get defaultAttributes() {
    return {
      id: this.focusableId,
      disabled: this.disabled ? "" : null,
      readonly: this.readonly ? "" : null,
      tabindex: this.disabled ? void 0 : this.tabIndex,
      placeholder: this.placeholder,
      title: this.title,
      maxlength: this.maxlength,
      rows: this.rows,
      cols: this.cols,
      "aria-disabled": this.disabled ? true : void 0,
      "aria-readonly": this.readonly ? true : void 0,
      "aria-invalid": this.isControlInvalid,
      required: this.isControlRequired ? "" : null
    };
  }
  get mutableAttributes() {
    return {
      "aria-multiline": "true"
    };
  }
  constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {
    super(localizationService, ngZone, changeDetector, renderer, injector, hostElement);
    this.localizationService = localizationService;
    this.ngZone = ngZone;
    this.changeDetector = changeDetector;
    this.renderer = renderer;
    this.injector = injector;
    this.hostElement = hostElement;
    validatePackage(packageMetadata5);
    this.direction = localizationService.rtl ? "rtl" : "ltr";
  }
  ngAfterViewInit() {
    this.ngZone.runOutsideAngular(() => {
      this.handleFlow();
    });
    const stylingInputs = ["size", "rounded", "fillMode"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
  }
  ngOnInit() {
    this.control = this.injector.get(NgControl, null);
    if (isDocumentAvailable() && this.resizable === "auto") {
      this.resizeSubscription = fromEvent(window, "resize").pipe(debounceTime(50)).subscribe(() => this.resize());
    }
    if (this.hostElement) {
      this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
    }
    this.subscriptions = this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
  }
  ngOnChanges(changes) {
    const hostElement = this.hostElement.nativeElement;
    const element = this.input.nativeElement;
    if (changes.flow) {
      this.handleFlow();
    }
    if (changes.resizable) {
      if (this.resizable === "auto") {
        this.renderer.removeClass(element, "!k-overflow-y-auto");
        this.initialHeight = element.offsetHeight;
      } else if (this.resizable !== "both") {
        this.renderer.addClass(element, "!k-overflow-y-auto");
        element.style.height = `${this.initialHeight}px`;
      }
    }
    if (changes.cols) {
      if (isPresent5(changes.cols.currentValue)) {
        this.renderer.setStyle(hostElement, "width", "auto");
      } else {
        this.renderer.removeStyle(hostElement, "width");
      }
    }
    if (changes.value) {
      this.resize();
    }
  }
  /**
   * @hidden
   */
  prefix;
  /**
   * @hidden
   */
  suffix;
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value;
    this.resize();
    this.changeDetector.markForCheck();
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.ngChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.ngTouched = fn;
  }
  updateValue(value) {
    if (!areSame(this.value, value)) {
      this.ngZone.run(() => {
        this.value = value;
        this.ngChange(value);
        this.valueChange.emit(value);
        this.changeDetector.markForCheck();
      });
    }
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    if (this.resizeSubscription) {
      this.resizeSubscription.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  get resizableClass() {
    return resizeClasses[this.resizable];
  }
  /**
   * @hidden
   */
  get isControlInvalid() {
    return this.control && this.control.touched && !this.control.valid;
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.control?.control);
  }
  /**
   * @hidden
   */
  get separatorOrientation() {
    return this.flow === "horizontal" ? "vertical" : "horizontal";
  }
  /**
   * @hidden
   */
  get isFocused() {
    return this._isFocused;
  }
  /**
   * @hidden
   */
  set isFocused(value) {
    if (this._isFocused !== value && this.hostElement) {
      const element = this.hostElement.nativeElement;
      if (value && !this.disabled) {
        this.renderer.addClass(element, FOCUSED);
      } else {
        this.renderer.removeClass(element, FOCUSED);
      }
      this._isFocused = value;
    }
  }
  /**
   * @hidden
   */
  handleInput = (ev) => {
    const incomingValue = ev.target.value;
    this.updateValue(incomingValue);
    this.resize();
  };
  /**
   * @hidden
   */
  handleInputFocus = () => {
    if (!this.disabled) {
      if (this.selectOnFocus && this.value) {
        this.ngZone.run(() => {
          setTimeout(() => {
            this.selectAll();
          });
        });
      }
      if (!this.isFocused) {
        this.handleFocus();
      }
      if (hasObservers(this.inputFocus)) {
        if (!this.focusChangedProgrammatically) {
          this.ngZone.run(() => {
            this.inputFocus.emit();
          });
        }
      }
    }
  };
  /**
   * Focuses the TextArea component.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="textarea.focus()">Focus the textarea</button>
   *  <kendo-textarea #textarea></kendo-textarea>
   * `
   * })
   * class AppComponent { }
   * ```
   */
  focus() {
    if (!this.input) {
      return;
    }
    this.focusChangedProgrammatically = true;
    this.isFocused = true;
    this.input.nativeElement.focus();
    this.focusChangedProgrammatically = false;
  }
  /**
   * Blurs the TextArea component.
   */
  blur() {
    this.focusChangedProgrammatically = true;
    const isFocusedElement = this.hostElement.nativeElement.querySelector(":focus");
    if (isFocusedElement) {
      isFocusedElement.blur();
    }
    this.isFocused = false;
    this.focusChangedProgrammatically = false;
  }
  resize() {
    if (this.resizable !== "auto") {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      setTimeout(() => {
        const hostElement = this.hostElement.nativeElement;
        const element = this.input.nativeElement;
        this.renderer.setStyle(element, "height", `${this.initialHeight}px`);
        const scrollHeight = element.scrollHeight;
        this.renderer.setStyle(hostElement, "min-height", `${scrollHeight}px`);
        if (scrollHeight > this.initialHeight) {
          this.renderer.setStyle(element, "height", `${scrollHeight}px`);
        }
      }, 0);
    });
  }
  /**
   * @hidden
   */
  handleFocus() {
    this.ngZone.run(() => {
      if (!this.focusChangedProgrammatically && hasObservers(this.onFocus)) {
        this.onFocus.emit();
      }
      this.isFocused = true;
    });
  }
  /**
   * @hidden
   */
  handleBlur() {
    this.changeDetector.markForCheck();
    this.ngZone.run(() => {
      if (!this.focusChangedProgrammatically) {
        this.onBlur.emit();
      }
      this.isFocused = false;
    });
  }
  setSelection(start, end) {
    if (this.isFocused) {
      invokeElementMethod(this.input, "setSelectionRange", start, end);
    }
  }
  selectAll() {
    if (this.value) {
      this.setSelection(0, this.value.length);
    }
  }
  handleClasses(value, input) {
    const elem = this.hostElement.nativeElement;
    const classes = getStylingClasses2("input", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  handleFlow() {
    const isVertical = this.flow === "vertical";
    const element = this.input.nativeElement;
    this.renderer[isVertical ? "addClass" : "removeClass"](element, "!k-flex-none");
  }
  setInputAttributes() {
    const attributesToRender = Object.assign({}, this.mutableAttributes, this.parsedAttributes);
    setHTMLAttributes(attributesToRender, this.renderer, this.input.nativeElement, this.ngZone);
  }
  static ɵfac = function TextAreaComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextAreaComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TextAreaComponent,
    selectors: [["kendo-textarea"]],
    contentQueries: function TextAreaComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, TextAreaPrefixComponent, 5);
        ɵɵcontentQuery(dirIndex, TextAreaSuffixComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.prefix = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.suffix = _t.first);
      }
    },
    hostVars: 8,
    hostBindings: function TextAreaComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-textarea", ctx.hostClasses)("k-input", ctx.hostClasses)("!k-flex-col", ctx.flowCol)("!k-flex-row", ctx.flowRow);
      }
    },
    inputs: {
      focusableId: "focusableId",
      flow: "flow",
      inputAttributes: "inputAttributes",
      adornmentsOrientation: "adornmentsOrientation",
      rows: "rows",
      cols: "cols",
      maxlength: "maxlength",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      resizable: "resizable",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      showPrefixSeparator: "showPrefixSeparator",
      showSuffixSeparator: "showSuffixSeparator"
    },
    outputs: {
      onFocus: "focus",
      onBlur: "blur",
      valueChange: "valueChange"
    },
    exportAs: ["kendoTextArea"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.textarea"
    }, {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _TextAreaComponent),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _TextAreaComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    ngContentSelectors: _c66,
    decls: 7,
    vars: 26,
    consts: [["input", ""], ["kendoInputSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused"], [3, "orientation", 4, "ngIf"], [1, "k-input-inner", "!k-overflow-auto", 3, "id", "ngClass", "value", "disabled", "readonly", "kendoEventsOutsideAngular"], [3, "orientation"]],
    template: function TextAreaComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵprojectionDef(_c65);
        ɵɵelementContainerStart(0, 1);
        ɵɵtwoWayListener("isFocusedChange", function TextAreaComponent_Template_ng_container_isFocusedChange_0_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.isFocused, $event) || (ctx.isFocused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function TextAreaComponent_Template_ng_container_handleBlur_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function TextAreaComponent_Template_ng_container_onFocus_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵprojection(1);
        ɵɵtemplate(2, TextAreaComponent_kendo_input_separator_2_Template, 1, 1, "kendo-input-separator", 2);
        ɵɵelement(3, "textarea", 3, 0);
        ɵɵtemplate(5, TextAreaComponent_kendo_input_separator_5_Template, 1, 1, "kendo-input-separator", 2);
        ɵɵprojection(6, 1);
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.isFocused);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.prefix && ctx.showPrefixSeparator);
        ɵɵadvance();
        ɵɵproperty("id", ctx.focusableId)("ngClass", ctx.resizableClass)("value", ctx.value)("disabled", ctx.disabled)("readonly", ctx.readonly)("kendoEventsOutsideAngular", ɵɵpureFunction3(22, _c20, ctx.handleInputFocus, ctx.handleInputBlur, ctx.handleInput));
        ɵɵattribute("aria-multiline", true)("aria-disabled", ctx.disabled ? true : void 0)("aria-readonly", ctx.readonly ? true : void 0)("aria-invalid", ctx.isControlInvalid)("required", ctx.isControlRequired ? "" : null)("placeholder", ctx.placeholder)("rows", ctx.rows)("cols", ctx.cols)("tabindex", ctx.tabIndex)("title", ctx.title)("maxlength", ctx.maxlength)("aria-invalid", ctx.isControlInvalid);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.suffix && ctx.showSuffixSeparator);
      }
    },
    dependencies: [SharedInputEventsDirective, NgIf, InputSeparatorComponent, NgClass, EventsOutsideAngularDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextAreaComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoTextArea",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.textarea"
      }, {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => TextAreaComponent),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => TextAreaComponent)
      }],
      selector: "kendo-textarea",
      template: `
        <ng-container
            kendoInputSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="isFocused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
        >
            <ng-content select="kendo-textarea-prefix"></ng-content>
            <kendo-input-separator
                *ngIf="prefix && showPrefixSeparator"
                [orientation]="separatorOrientation"
            ></kendo-input-separator>
            <textarea #input
                class="k-input-inner !k-overflow-auto"
                [attr.aria-multiline]="true"
                [attr.aria-disabled]="disabled ? true : undefined"
                [attr.aria-readonly]="readonly ? true : undefined"
                [attr.aria-invalid]="isControlInvalid"
                [id]="focusableId"
                [attr.required]="isControlRequired ? '' : null"
                [ngClass]="resizableClass"
                [value]="value"
                [attr.placeholder]="placeholder"
                [disabled]="disabled"
                [readonly]="readonly"
                [attr.rows]="rows"
                [attr.cols]="cols"
                [attr.tabindex]="tabIndex"
                [attr.title]="title"
                [attr.maxlength]="maxlength"
                [attr.aria-invalid]="isControlInvalid"
                [kendoEventsOutsideAngular]="{
                    focus: handleInputFocus,
                    blur: handleInputBlur,
                    input: handleInput}"
            ></textarea>
            <kendo-input-separator
                *ngIf="suffix && showSuffixSeparator"
                [orientation]="separatorOrientation"
            ></kendo-input-separator>
            <ng-content select="kendo-textarea-suffix"></ng-content>
        </ng-container>
    `,
      standalone: true,
      imports: [SharedInputEventsDirective, NgIf, InputSeparatorComponent, NgClass, EventsOutsideAngularDirective]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }, {
      type: Injector
    }, {
      type: ElementRef
    }];
  }, {
    focusableId: [{
      type: Input
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-textarea"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    flowCol: [{
      type: HostBinding,
      args: ["class.!k-flex-col"]
    }],
    flowRow: [{
      type: HostBinding,
      args: ["class.!k-flex-row"]
    }],
    flow: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    adornmentsOrientation: [{
      type: Input
    }],
    rows: [{
      type: Input
    }],
    cols: [{
      type: Input
    }],
    maxlength: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    resizable: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    showPrefixSeparator: [{
      type: Input
    }],
    showSuffixSeparator: [{
      type: Input
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    valueChange: [{
      type: Output
    }],
    prefix: [{
      type: ContentChild,
      args: [TextAreaPrefixComponent]
    }],
    suffix: [{
      type: ContentChild,
      args: [TextAreaSuffixComponent]
    }]
  });
})();
var TextBoxCustomMessagesComponent = class _TextBoxCustomMessagesComponent extends TextBoxMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function TextBoxCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextBoxCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TextBoxCustomMessagesComponent,
    selectors: [["kendo-textbox-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: TextBoxMessages,
      useExisting: forwardRef(() => _TextBoxCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function TextBoxCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextBoxCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: TextBoxMessages,
        useExisting: forwardRef(() => TextBoxCustomMessagesComponent)
      }],
      selector: "kendo-textbox-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var OTPInputSeparatorComponent = class _OTPInputSeparatorComponent {
  set separator(otpSeparator) {
    this._separator = otpSeparator;
    this.clearSeparator();
    if (!isPresent(otpSeparator)) {
      return;
    }
    if (typeof otpSeparator === "string") {
      this.hasText = true;
      return;
    }
    if (typeof otpSeparator.value !== "string") {
      this.hasSVGIcon = otpSeparator?.type === "svgIcon";
      this.separatorSVGIcon = otpSeparator.value;
      return;
    }
    this.hasIconClass = otpSeparator?.type === "iconClass";
    this.hasFontIcon = otpSeparator?.type === "fontIcon";
    this.separatorIconString = otpSeparator.value;
  }
  get separator() {
    return this._separator;
  }
  wrapperClass = true;
  hasText;
  hasIconClass;
  hasSVGIcon;
  hasFontIcon;
  separatorIconString;
  separatorSVGIcon;
  _separator;
  clearSeparator() {
    this.hasText = false;
    this.hasFontIcon = false;
    this.hasIconClass = false;
    this.hasSVGIcon = false;
  }
  static ɵfac = function OTPInputSeparatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _OTPInputSeparatorComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _OTPInputSeparatorComponent,
    selectors: [["kendo-otpinput-separator"]],
    hostVars: 2,
    hostBindings: function OTPInputSeparatorComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-otp-separator", ctx.wrapperClass);
      }
    },
    inputs: {
      separator: "separator"
    },
    exportAs: ["kendoOTPInputSeparator"],
    decls: 3,
    vars: 3,
    consts: [[4, "ngIf"], [3, "ngClass", 4, "ngIf"], [3, "name", "svgIcon", 4, "ngIf"], [3, "ngClass"], [3, "name", "svgIcon"]],
    template: function OTPInputSeparatorComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, OTPInputSeparatorComponent_ng_container_0_Template, 2, 1, "ng-container", 0)(1, OTPInputSeparatorComponent_span_1_Template, 1, 1, "span", 1)(2, OTPInputSeparatorComponent_kendo_icon_wrapper_2_Template, 1, 2, "kendo-icon-wrapper", 2);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.hasText);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hasIconClass);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hasFontIcon || ctx.hasSVGIcon);
      }
    },
    dependencies: [NgIf, NgClass, IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OTPInputSeparatorComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoOTPInputSeparator",
      selector: "kendo-otpinput-separator",
      template: `
        <ng-container *ngIf="hasText">{{this.separator}}</ng-container>
        <span *ngIf="hasIconClass" [ngClass]="separatorIconString"></span>
        <kendo-icon-wrapper
            *ngIf="hasFontIcon || hasSVGIcon"
            [name]="separatorIconString"
            [svgIcon]="separatorSVGIcon"
        ></kendo-icon-wrapper>
    `,
      standalone: true,
      imports: [NgIf, NgClass, IconWrapperComponent]
    }]
  }], null, {
    separator: [{
      type: Input
    }],
    wrapperClass: [{
      type: HostBinding,
      args: ["class.k-otp-separator"]
    }]
  });
})();
var OTPInputMessages = class _OTPInputMessages extends ComponentMessages {
  /**
   * The aria-label of the OTP Input. Follows the pattern **Input {currentInput} of {totalInputs}, current value {value}** by default.
   * Тhe default label text when the current input is 1, and the total number of inputs is 4 will be
   * **Input 1 of 4, current value null**.
   *
   * The message consists of several parts - the current input number, the total number of inputs, the current value and a localizable string.
   * To allow for reordering its parts, the `ariaLabel` input accepts a string with placeholders for the current input,
   * total number of inputs and current value. The `{currentInput}`, `{totalInputs}` and `{currentValue}` placeholders will be
   * replaced internally with the respective actual values.
   */
  ariaLabel;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵOTPInputMessages_BaseFactory;
    return function OTPInputMessages_Factory(__ngFactoryType__) {
      return (ɵOTPInputMessages_BaseFactory || (ɵOTPInputMessages_BaseFactory = ɵɵgetInheritedFactory(_OTPInputMessages)))(__ngFactoryType__ || _OTPInputMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _OTPInputMessages,
    selectors: [["kendo-otpinput-messages-base"]],
    inputs: {
      ariaLabel: "ariaLabel"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OTPInputMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-otpinput-messages-base"
    }]
  }], null, {
    ariaLabel: [{
      type: Input
    }]
  });
})();
var LocalizedOTPInputMessagesDirective = class _LocalizedOTPInputMessagesDirective extends OTPInputMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedOTPInputMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedOTPInputMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedOTPInputMessagesDirective,
    selectors: [["", "kendoOTPInputLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: OTPInputMessages,
      useExisting: forwardRef(() => _LocalizedOTPInputMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedOTPInputMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: OTPInputMessages,
        useExisting: forwardRef(() => LocalizedOTPInputMessagesDirective)
      }],
      selector: "[kendoOTPInputLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var DEFAULT_SIZE2 = "medium";
var DEFAULT_ROUNDED = "medium";
var DEFAULT_FILL_MODE = "solid";
var DEFAULT_OTPINPUT_LENGTH = 4;
var OTPInputComponent = class _OTPInputComponent {
  hostElement;
  cdr;
  injector;
  renderer;
  localizationService;
  zone;
  /**
   * Configures the total number of input fields.
   *
   * @default 4
   */
  set length(value) {
    if (value < 1 || this._length === value) {
      return;
    }
    this._length = value;
    this.inputsArray = new Array(this._length);
  }
  get length() {
    return this._length;
  }
  /**
   * Configures the input type.
   *
   * * The possible values are:
   * * `text` (default)
   * * `number`
   * * `password`
   *
   * @default 'text'
   */
  type = "text";
  /**
   * Configures whether the input fields are separate or adjacent to each other.
   *
   * @default true
   */
  spacing = true;
  /**
   * Specifies the separator between groups of input fields.
   *
   * > The configuration can only be applied when `groupLength` is set.
   */
  separator;
  /**
   * Configures whether the component is enabled or disabled.
   *
   * @default false
   */
  disabled = false;
  /**
   * Configures whether the component is readonly.
   *
   * @default false
   */
  readonly = false;
  /**
   * Configures the placeholder of the input fields.
   */
  placeholder;
  /**
   * Configures the length of the groups. If `groupLength` is a number, all groups will have the same length. If it's an array, each group can have a different length.
   */
  get groupLength() {
    return this._groupLength;
  }
  set groupLength(length) {
    const isNumber5 = typeof length === "number";
    if (this._groupLength === length || isPresent(length) && (isNumber5 && (length < 1 || length > this.length) || !isNumber5 && !this.isValidGroupArray(length))) {
      return;
    }
    if (!isPresent(length)) {
      this.clearGroups();
    } else if (isNumber5) {
      this.populateGroupArray(length);
    } else {
      this.groupLengthArray = length;
      if (!this.spacing) {
        this.adjacentGroups = this.groupLengthArray;
      }
    }
    this._groupLength = length;
    this.populateSeparatorPositions();
  }
  /**
   * Configures the value of the component. Unfilled input fields are represented with space.
   */
  get value() {
    return this._value;
  }
  set value(input) {
    const isInvalidInput = this.type === "number" && isPresent(input) && !this.containsDigitsOrSpaces(input);
    if (this._value === input || isInvalidInput) {
      return;
    }
    if (!isPresent(input)) {
      this.clearInputValues();
      this._value = null;
    } else {
      this._value = input.slice(0, this.length);
      if (!this.inputFieldValueChanged) {
        this.fillInputs(input, 0, true);
      }
    }
    if (this.inputAttributes) {
      this.setInputAttributes();
    } else {
      this.setDefaultAttributes();
    }
  }
  /**
   * The `size` property specifies the padding of the input fields.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set size(size) {
    const newSize = size || DEFAULT_SIZE2;
    const elem = this.hostElement.nativeElement;
    this.renderer.removeClass(elem, `k-otp-${SIZE_MAP[this._size]}`);
    this.renderer.addClass(elem, `k-otp-${SIZE_MAP[newSize]}`);
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * The `rounded` property specifies the border radius of the OTP Input.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `full`
   * * `none`
   */
  set rounded(rounded) {
    this._rounded = rounded || DEFAULT_ROUNDED;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * The `fillMode` property specifies the background and border styles of the OTP Input.
   *
   * The possible values are:
   * * `flat`
   * * `solid` (default)
   * * `outline`
   * * `none`
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode || DEFAULT_FILL_MODE;
    this.setGroupFillMode(newFillMode, this._fillMode);
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
   */
  set inputAttributes(attributes) {
    this._inputAttributes = attributes;
    this.parsedAttributes = this.inputAttributes ? __spreadValues(__spreadValues({}, this.defaultAttributes), this.inputAttributes) : this.inputAttributes;
    this.setInputAttributes();
  }
  get inputAttributes() {
    return this._inputAttributes;
  }
  /**
   * Fires each time the value is changed by the user&mdash;
   * When the value of the component is programmatically changed to `ngModel` or `formControl`
   * through its API or form binding, the `valueChange` event is not triggered because it
   * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the user focuses the OTP Input.
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the user blurs the OTP Input.
   */
  onBlur = new EventEmitter();
  wrapperClass = true;
  get invalidClass() {
    return this.isControlInvalid;
  }
  direction;
  role = "group";
  /**
   * @hidden
   */
  inputFields;
  /**
   * @hidden
   */
  set inputGroups(elements) {
    this._inputGroups = elements;
    this.setGroupFillMode(this.fillMode);
  }
  get inputGroups() {
    return this._inputGroups;
  }
  /**
   * @hidden
   */
  groupLengthArray;
  /**
   * @hidden
   */
  inputsArray;
  /**
   * @hidden
   */
  inputsValues = [].constructor(DEFAULT_OTPINPUT_LENGTH);
  /**
   * @hidden
   */
  adjacentGroups;
  _length = DEFAULT_OTPINPUT_LENGTH;
  _groupLength;
  _inputGroups;
  separatorPositions = /* @__PURE__ */ new Set();
  _value = null;
  _size = DEFAULT_SIZE2;
  _rounded = DEFAULT_ROUNDED;
  _fillMode = DEFAULT_FILL_MODE;
  _isFocused = false;
  focusChangedProgrammatically = false;
  inputFieldValueChanged = false;
  focusedInput;
  _inputAttributes;
  parsedAttributes = {};
  get defaultAttributes() {
    return {
      autocomplete: "off"
    };
  }
  subscriptions;
  ngChange = (_2) => {
  };
  ngTouched = () => {
  };
  constructor(hostElement, cdr, injector, renderer, localizationService, zone) {
    this.hostElement = hostElement;
    this.cdr = cdr;
    this.injector = injector;
    this.renderer = renderer;
    this.localizationService = localizationService;
    this.zone = zone;
    this.direction = localizationService.rtl ? "rtl" : "ltr";
  }
  ngOnInit() {
    this.inputsArray = Array.from({
      length: this._length
    });
    this.subscriptions = this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
    this.zone.runOutsideAngular(() => {
      this.subscriptions.add(this.renderer.listen(this.hostElement.nativeElement, "paste", this.handlePaste.bind(this)));
      this.subscriptions.add(this.renderer.listen(this.hostElement.nativeElement, "keydown", this.handleKeydown.bind(this)));
    });
  }
  ngAfterViewInit() {
    this.subscriptions.add(this.inputFields.changes.subscribe(this.handleInputChanges.bind(this)));
    this.handleInputChanges();
    this.renderer.addClass(this.hostElement.nativeElement, `k-otp-${SIZE_MAP[this._size]}`);
    this.setGroupFillMode(this.fillMode);
    this.zone.onStable.pipe(take(1)).subscribe(() => {
      this.fillInputs(this.value);
    });
  }
  ngOnChanges(changes) {
    if (changes.length) {
      if (typeof this.groupLength === "number") {
        this.populateGroupArray(this.groupLength);
      }
      this.populateSeparatorPositions();
    }
    if (changes.spacing) {
      if (this.spacing === true) {
        this.adjacentGroups = null;
      } else {
        this.adjacentGroups = this.groupLengthArray ?? [this.length];
      }
    }
    if (changes.type && this.type === "number") {
      if (isPresent(this.value) && !this.containsDigitsOrSpaces(this.value)) {
        this.value = null;
        this.zone.runOutsideAngular(() => setTimeout(() => this.zone.run(() => {
          this.ngChange(null);
          this.cdr.markForCheck();
        })));
      }
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value;
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.ngChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.ngTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.cdr.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * @hidden
   */
  get isControlInvalid() {
    return this.formControl?.touched && this.formControl.invalid;
  }
  /**
   * @hidden
   */
  get isFocused() {
    return this._isFocused;
  }
  /**
   * @hidden
   */
  set isFocused(value) {
    if (this._isFocused !== value && this.hostElement) {
      this._isFocused = value;
    }
  }
  /**
   * @hidden
   */
  get hasGroups() {
    if (!this.spacing && isPresent(this.groupLength)) {
      return true;
    }
  }
  /**
   * @hidden
   */
  showGroupSeparator(index) {
    return this.groupLengthArray && index < this.groupLengthArray.length - 1;
  }
  /**
   * @hidden
   */
  showSeparator(index) {
    return this.groupLength ? this.separatorPositions.has(index) : false;
  }
  /**
   * @hidden
   */
  handleValueChange(index, groupIndex) {
    this.inputFieldValueChanged = true;
    if (groupIndex) {
      index = this.getIndexByGroup(groupIndex, index);
    }
    let newValue = "";
    this.inputFields.forEach((input) => newValue = newValue.concat(input.value?.toString() || " "));
    if (!areSame(this.value, newValue)) {
      this.zone.run(() => {
        this.value = newValue;
        this.ngChange(newValue);
        this.valueChange.emit(newValue);
        this.cdr.markForCheck();
      });
    }
    this.inputFieldValueChanged = false;
    if (isPresent(index) && isPresent(this.inputFields?.get(index).value)) {
      this.focusNext();
    }
  }
  /**
   * @hidden
   */
  handleInputFocus(index, groupIndex) {
    if (this.focusChangedProgrammatically) {
      return;
    }
    if (groupIndex) {
      index = this.getIndexByGroup(groupIndex, index);
    }
    this.focusedInput = index;
  }
  /**
   * @hidden
   */
  handleInput(event, index, groupIndex) {
    if (this.type === "number" && !this.isValidNumber(event?.data)) {
      const inputIndex = groupIndex ? this.getIndexByGroup(groupIndex, index) : index;
      const textbox = this.inputFields.get(inputIndex);
      if (this.value && this.isValidNumber(this.value[inputIndex])) {
        textbox.value = this.value[inputIndex];
      } else {
        textbox.value = null;
      }
      this.showInvalidInput(inputIndex);
      return;
    }
    this.handleValueChange(index, groupIndex);
  }
  /**
   * @hidden
   */
  fillInputs(text, start = 0, replaceLast = false) {
    if (!isPresent(text)) {
      return;
    }
    let charCounter = 0;
    this.inputFields?.forEach((otpInput, i) => {
      if (i < start) {
        return;
      }
      if (charCounter < text.length) {
        if (text[charCounter] === " ") {
          otpInput.value = null;
        } else {
          otpInput.value = text[charCounter];
        }
        charCounter++;
      } else if (replaceLast) {
        otpInput.value = null;
      }
    });
  }
  /**
   * Focuses the OTP Input.
   */
  focus(index) {
    if (!this.inputFields || index < 0 || index >= this.length) {
      return;
    }
    this.focusChangedProgrammatically = true;
    this.isFocused = true;
    this.inputFields.get(index || 0).focus();
    this.focusedInput = index || 0;
    this.focusChangedProgrammatically = false;
  }
  /**
   * Blurs the OTP Input.
   */
  blur() {
    this.focusChangedProgrammatically = true;
    const isFocusedElement = this.hostElement.nativeElement.querySelector(":focus");
    if (isFocusedElement) {
      isFocusedElement.blur();
    }
    this.isFocused = false;
    this.focusChangedProgrammatically = false;
  }
  /**
   * @hidden
   */
  handleFocus() {
    this.zone.run(() => {
      if (!this.focusChangedProgrammatically && hasObservers(this.onFocus)) {
        this.onFocus.emit();
      }
      this.isFocused = true;
    });
  }
  /**
   * @hidden
   */
  handleBlur() {
    this.zone.run(() => {
      if (!this.focusChangedProgrammatically) {
        this.ngTouched();
        this.onBlur.emit();
      }
      this.isFocused = false;
    });
  }
  getIndexByGroup(groupIndex, itemIndex2) {
    return this.groupLengthArray.slice(0, groupIndex).reduce((sum, current) => sum + current, 0) + itemIndex2;
  }
  focusNext() {
    if (!this.inputFields || this.focusedInput === this.length - 1) {
      return;
    }
    this.focusChangedProgrammatically = true;
    this.isFocused = true;
    this.inputFields.get(this.focusedInput).blur();
    this.inputFields.get(this.focusedInput + 1).focus();
    this.focusedInput++;
    this.focusChangedProgrammatically = false;
  }
  focusPrevious() {
    if (!this.inputFields || this.focusedInput === 0) {
      return;
    }
    this.focusChangedProgrammatically = true;
    this.isFocused = true;
    this.inputFields.get(this.focusedInput).blur();
    this.inputFields.get(this.focusedInput - 1).focus();
    this.focusedInput--;
    this.focusChangedProgrammatically = false;
  }
  handlePaste(event) {
    event.preventDefault();
    const text = event.clipboardData.getData("text").trim();
    if (text === "") {
      return;
    }
    if (this.type === "number" && !this.isValidNumber(text)) {
      this.showInvalidInput(this.focusedInput);
      return;
    }
    this.inputFieldValueChanged = true;
    this.fillInputs(text, this.focusedInput);
    this.handleValueChange();
    this.inputFieldValueChanged = false;
    const focusedInput = this.focusedInput + text.length < this.inputFields?.length ? this.focusedInput + text.length : this.inputFields.length - 1;
    this.inputFields.get(this.focusedInput).blur();
    this.focusedInput = focusedInput;
    this.inputFields.get(this.focusedInput).focus();
  }
  handleKeydown(event) {
    if (this.readonly) {
      const isCopyCommand = (event.ctrlKey || event.metaKey) && event.keyCode === Keys.KeyC;
      if (!(event.keyCode === Keys.Tab || isCopyCommand)) {
        event.preventDefault();
        return;
      }
    }
    switch (event.keyCode) {
      case Keys.ArrowRight:
        event.preventDefault();
        this.direction === "ltr" ? this.focusNext() : this.focusPrevious();
        break;
      case Keys.ArrowLeft:
        event.preventDefault();
        this.direction === "ltr" ? this.focusPrevious() : this.focusNext();
        break;
      case Keys.Backspace:
        event.preventDefault();
        this.inputFields.get(this.focusedInput).value = null;
        this.handleValueChange();
        this.focusPrevious();
        break;
      case Keys.Delete:
        event.preventDefault();
        this.inputFields.get(this.focusedInput).value = null;
        this.handleValueChange();
        break;
      default:
        break;
    }
  }
  isValidGroupArray(groups) {
    if (!isPresent(groups)) {
      return;
    }
    const sum = groups.reduce((sum2, current) => sum2 + current, 0);
    return sum === this.length;
  }
  populateGroupArray(length) {
    const groupsCount = Math.floor(this.length / length);
    const remainder2 = this.length % length;
    const result = Array(groupsCount).fill(length);
    if (remainder2 > 0) {
      result.push(remainder2);
    }
    this.groupLengthArray = [...result];
    if (!this.spacing) {
      this.adjacentGroups = [...this.groupLengthArray];
    }
  }
  populateSeparatorPositions() {
    let itemIndex2 = 0;
    this.separatorPositions.clear();
    if (!isPresent(this.groupLengthArray)) {
      return;
    }
    for (let i = 0; i < this.groupLengthArray.length - 1; i++) {
      itemIndex2 += this.groupLengthArray[i];
      this.separatorPositions.add(itemIndex2 - 1);
    }
  }
  clearGroups() {
    this.groupLengthArray = null;
    if (!this.spacing) {
      this.adjacentGroups = [this.length];
    } else {
      this.adjacentGroups = null;
    }
    this.separatorPositions.clear();
  }
  clearInputValues() {
    this.inputFields?.forEach((input) => input.value = null);
  }
  handleInputChanges() {
    this.zone.onStable.pipe(take(1)).subscribe(() => {
      this.fillInputs(this.value?.trim());
      if (this.inputAttributes) {
        this.setInputAttributes();
      } else {
        this.setDefaultAttributes();
      }
      this.cdr.detectChanges();
    });
  }
  setGroupFillMode(fillMode, previousFillMode) {
    this.inputGroups?.forEach((element) => {
      if (previousFillMode !== "none") {
        this.renderer.removeClass(element.nativeElement, `k-input-group-${previousFillMode}`);
      }
      if (fillMode !== "none") {
        this.renderer.addClass(element.nativeElement, `k-input-group-${fillMode}`);
      }
    });
  }
  setInputAttributes() {
    this.inputFields?.forEach((input, index) => {
      if (!this.parsedAttributes || !this.parsedAttributes?.["aria-label"]) {
        input.inputAttributes = __spreadProps(__spreadValues({}, this.parsedAttributes), {
          "aria-label": this.ariaLabel(index)
        });
      } else {
        input.inputAttributes = this.parsedAttributes;
      }
    });
  }
  setDefaultAttributes() {
    this.inputFields?.forEach((input, index) => {
      input.inputAttributes = {
        autocomplete: "off",
        "aria-label": this.ariaLabel(index)
      };
    });
  }
  ariaLabel(index) {
    const localizationMsg = this.localizationService.get("ariaLabel") || "";
    return replaceMessagePlaceholder(replaceMessagePlaceholder(replaceMessagePlaceholder(localizationMsg, "currentInput", (index + 1).toString()), "totalInputs", this.length.toString()), "value", this.value);
  }
  isValidNumber(value) {
    if (!isPresent(value)) {
      return;
    }
    const trimmedValue = value.trim();
    return trimmedValue !== "" && trimmedValue !== "Infinity" && trimmedValue !== "-Infinity" && !isNaN(Number(trimmedValue));
  }
  showInvalidInput(index) {
    const textbox = this.inputFields.get(index);
    const textboxElement = this.inputFields.get(index).hostElement.nativeElement;
    const inputElement = textbox.input.nativeElement;
    this.renderer.addClass(textboxElement, "k-invalid");
    if (textbox.value && this.isValidNumber(textbox.value)) {
      this.zone.onStable.pipe(take(1)).subscribe(() => inputElement.select());
    }
    this.zone.runOutsideAngular(() => {
      setTimeout(() => {
        if (!this.isControlInvalid && textboxElement) {
          this.renderer.removeClass(textboxElement, "k-invalid");
        }
      }, 300);
    });
  }
  containsDigitsOrSpaces(value) {
    const isDigitOrSpace = (char) => char == +char || char === " ";
    for (let i = 0; i < value.length; i++) {
      if (!isDigitOrSpace(value[i])) {
        return false;
      }
    }
    return true;
  }
  static ɵfac = function OTPInputComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _OTPInputComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _OTPInputComponent,
    selectors: [["kendo-otpinput"]],
    viewQuery: function OTPInputComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(TextBoxComponent, 5);
        ɵɵviewQuery(_c67, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputFields = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputGroups = _t);
      }
    },
    hostVars: 6,
    hostBindings: function OTPInputComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction)("role", ctx.role);
        ɵɵclassProp("k-otp", ctx.wrapperClass)("k-invalid", ctx.invalidClass);
      }
    },
    inputs: {
      length: "length",
      type: "type",
      spacing: "spacing",
      separator: "separator",
      disabled: "disabled",
      readonly: "readonly",
      placeholder: "placeholder",
      groupLength: "groupLength",
      value: "value",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      inputAttributes: "inputAttributes"
    },
    outputs: {
      valueChange: "valueChange",
      onFocus: "focus",
      onBlur: "blur"
    },
    exportAs: ["kendoOTPInput"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.otpinput"
    }, {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _OTPInputComponent),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _OTPInputComponent)
    }]), ɵɵNgOnChangesFeature],
    decls: 7,
    vars: 5,
    consts: () => {
      let i18n_81;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_81 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ 'Input {currentInput} of {totalInputs}, current value {value}' }}"
          }
        });
        i18n_81 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_81;
      } else {
        i18n_81 = $localize`:kendo.otpinput.ariaLabel|The value of the aria-label attribute of the input fields.:${"�0�"}:INTERPOLATION:`;
      }
      return [["groups", ""], ["inputGroup", ""], ["ariaLabel", i18n_81], ["kendoOTPInputLocalizedMessages", "", 6, "ariaLabel"], ["kendoInputSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused"], [4, "ngIf", "ngIfElse"], [4, "ngFor", "ngForOf"], [1, "k-otp-input", 3, "focus", "input", "selectOnFocus", "maxlength", "type", "placeholder", "size", "rounded", "fillMode", "disabled", "readonly"], [3, "separator", 4, "ngIf"], [3, "separator"], [1, "k-input-group"], ["class", "k-otp-input", 3, "k-invalid", "selectOnFocus", "maxlength", "type", "placeholder", "size", "rounded", "fillMode", "disabled", "readonly", "focus", "input", 4, "ngFor", "ngForOf"]];
    },
    template: function OTPInputComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainerStart(0, 3);
        ɵɵi18nAttributes(1, 2);
        ɵɵelementContainerEnd();
        ɵɵelementContainerStart(2, 4);
        ɵɵtwoWayListener("isFocusedChange", function OTPInputComponent_Template_ng_container_isFocusedChange_2_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.isFocused, $event) || (ctx.isFocused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function OTPInputComponent_Template_ng_container_handleBlur_2_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function OTPInputComponent_Template_ng_container_onFocus_2_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵtemplate(3, OTPInputComponent_ng_container_3_Template, 2, 1, "ng-container", 5)(4, OTPInputComponent_ng_template_4_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        ɵɵelementContainer(6);
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        const groups_r9 = ɵɵreference(5);
        ɵɵi18nExp("Input {currentInput} of {totalInputs}, current value {value}");
        ɵɵi18nApply(1);
        ɵɵadvance(2);
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.isFocused);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.spacing)("ngIfElse", groups_r9);
      }
    },
    dependencies: [SharedInputEventsDirective, TextBoxComponent, OTPInputSeparatorComponent, NgForOf, NgIf, LocalizedOTPInputMessagesDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OTPInputComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoOTPInput",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.otpinput"
      }, {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => OTPInputComponent),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => OTPInputComponent)
      }],
      selector: "kendo-otpinput",
      template: `
        <ng-container kendoOTPInputLocalizedMessages
            i18n-ariaLabel="kendo.otpinput.ariaLabel|The value of the aria-label attribute of the input fields."
            ariaLabel="{{ 'Input {currentInput} of {totalInputs}, current value {value}' }}"
        ></ng-container>
        <ng-container
            kendoInputSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="isFocused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
        >
            <ng-container *ngIf="spacing; else groups">
                <ng-container *ngFor="let input of inputsArray; let i = index">
                    <kendo-textbox
                        class="k-otp-input"
                        [class.k-invalid]="isControlInvalid"
                        [selectOnFocus]="true"
                        [maxlength]="1"
                        [type]="type !== 'number' ? type : null"
                        [placeholder]="placeholder"
                        [size]="size"
                        [rounded]="rounded"
                        [fillMode]="fillMode"
                        [disabled]="disabled"
                        [readonly]="readonly"
                        (focus)="handleInputFocus(i)"
                        (input)="handleInput($event, i)"
                    ></kendo-textbox>
                    <kendo-otpinput-separator *ngIf="showSeparator(i)" [separator]="separator"></kendo-otpinput-separator>
                </ng-container>
            </ng-container>
            <ng-template #groups>
                <ng-container *ngFor="let group of adjacentGroups; let i = index">
                    <div #inputGroup class="k-input-group">
                        <kendo-textbox
                            *ngFor="let input of [].constructor(group); let j = index"
                            class="k-otp-input"
                            [class.k-invalid]="isControlInvalid"
                            [selectOnFocus]="true"
                            [maxlength]="1"
                            [type]="type !== 'number' ? type : null"
                            [placeholder]="placeholder"
                            [size]="size"
                            [rounded]="rounded"
                            [fillMode]="fillMode"
                            [disabled]="disabled"
                            [readonly]="readonly"
                            (focus)="handleInputFocus(j, i)"
                            (input)="handleInput($event, j, i)"
                        ></kendo-textbox>
                    </div>
                    <kendo-otpinput-separator *ngIf="showGroupSeparator(i)" [separator]="separator"></kendo-otpinput-separator>
                </ng-container>
            </ng-template>
        <ng-container>
    `,
      standalone: true,
      imports: [SharedInputEventsDirective, TextBoxComponent, OTPInputSeparatorComponent, NgForOf, NgIf, LocalizedOTPInputMessagesDirective]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: Injector
    }, {
      type: Renderer2
    }, {
      type: LocalizationService
    }, {
      type: NgZone
    }];
  }, {
    length: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    spacing: [{
      type: Input
    }],
    separator: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    groupLength: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    wrapperClass: [{
      type: HostBinding,
      args: ["class.k-otp"]
    }],
    invalidClass: [{
      type: HostBinding,
      args: ["class.k-invalid"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    inputFields: [{
      type: ViewChildren,
      args: [TextBoxComponent]
    }],
    inputGroups: [{
      type: ViewChildren,
      args: ["inputGroup"]
    }]
  });
})();
var OTPInputCustomMessagesComponent = class _OTPInputCustomMessagesComponent extends OTPInputMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function OTPInputCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _OTPInputCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _OTPInputCustomMessagesComponent,
    selectors: [["kendo-otpinput-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: OTPInputMessages,
      useExisting: forwardRef(() => _OTPInputCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function OTPInputCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OTPInputCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: OTPInputMessages,
        useExisting: forwardRef(() => OTPInputCustomMessagesComponent)
      }],
      selector: "kendo-otpinput-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var KENDO_TEXTBOX = [TextBoxDirective, TextBoxComponent, InputSeparatorComponent, TextBoxSuffixTemplateDirective, TextBoxPrefixTemplateDirective, TextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent];
var KENDO_NUMERICTEXTBOX = [NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent];
var KENDO_MASKEDTEXTBOX = [MaskedTextBoxComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent];
var KENDO_OTPINPUT = [OTPInputComponent, OTPInputCustomMessagesComponent];
var KENDO_TEXTAREA = [TextAreaComponent, TextAreaDirective, TextAreaPrefixComponent, TextAreaSuffixComponent, SeparatorComponent];
var KENDO_CHECKBOX = [CheckBoxComponent, CheckBoxDirective];
var KENDO_RADIOBUTTON = [RadioButtonComponent, RadioButtonDirective];
var KENDO_SWITCH = [SwitchComponent, SwitchCustomMessagesComponent];
var KENDO_FORMFIELD = [FormFieldComponent, HintComponent2, ErrorComponent];
var KENDO_SLIDER = [SliderComponent, SliderCustomMessagesComponent, LabelTemplateDirective];
var KENDO_RANGESLIDER = [RangeSliderComponent, RangeSliderCustomMessagesComponent, LabelTemplateDirective];
var KENDO_RATING = [RatingComponent, RatingItemTemplateDirective, RatingHoveredItemTemplateDirective, RatingSelectedItemTemplateDirective];
var KENDO_SIGNATURE = [SignatureComponent, SignatureCustomMessagesComponent];
var KENDO_COLORPICKER = [ColorPickerComponent, ColorPickerCustomMessagesComponent];
var KENDO_FLATCOLORPICKER = [FlatColorPickerComponent, ColorPickerCustomMessagesComponent];
var KENDO_COLORPALETTE = [ColorPaletteComponent, ColorPickerCustomMessagesComponent];
var KENDO_COLORGRADIENT = [ColorGradientComponent, ColorPickerCustomMessagesComponent];
var KENDO_INPUTS = [...KENDO_TEXTBOX, ...KENDO_NUMERICTEXTBOX, ...KENDO_MASKEDTEXTBOX, ...KENDO_TEXTAREA, ...KENDO_CHECKBOX, ...KENDO_RADIOBUTTON, ...KENDO_SWITCH, ...KENDO_FORMFIELD, ...KENDO_SLIDER, ...KENDO_RANGESLIDER, ...KENDO_RATING, ...KENDO_SIGNATURE, ...KENDO_COLORPICKER, ...KENDO_FLATCOLORPICKER, ...KENDO_COLORGRADIENT, ...KENDO_COLORPALETTE, ...KENDO_OTPINPUT];
var InputsModule = class _InputsModule {
  static ɵfac = function InputsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InputsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _InputsModule,
    imports: [TextBoxDirective, TextBoxComponent, InputSeparatorComponent, TextBoxSuffixTemplateDirective, TextBoxPrefixTemplateDirective, TextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, MaskedTextBoxComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, TextAreaComponent, TextAreaDirective, TextAreaPrefixComponent, TextAreaSuffixComponent, SeparatorComponent, CheckBoxComponent, CheckBoxDirective, RadioButtonComponent, RadioButtonDirective, SwitchComponent, SwitchCustomMessagesComponent, FormFieldComponent, HintComponent2, ErrorComponent, SliderComponent, SliderCustomMessagesComponent, LabelTemplateDirective, RangeSliderComponent, RangeSliderCustomMessagesComponent, LabelTemplateDirective, RatingComponent, RatingItemTemplateDirective, RatingHoveredItemTemplateDirective, RatingSelectedItemTemplateDirective, SignatureComponent, SignatureCustomMessagesComponent, ColorPickerComponent, ColorPickerCustomMessagesComponent, FlatColorPickerComponent, ColorPickerCustomMessagesComponent, ColorGradientComponent, ColorPickerCustomMessagesComponent, ColorPaletteComponent, ColorPickerCustomMessagesComponent, OTPInputComponent, OTPInputCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent],
    exports: [TextBoxDirective, TextBoxComponent, InputSeparatorComponent, TextBoxSuffixTemplateDirective, TextBoxPrefixTemplateDirective, TextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, MaskedTextBoxComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, TextAreaComponent, TextAreaDirective, TextAreaPrefixComponent, TextAreaSuffixComponent, SeparatorComponent, CheckBoxComponent, CheckBoxDirective, RadioButtonComponent, RadioButtonDirective, SwitchComponent, SwitchCustomMessagesComponent, FormFieldComponent, HintComponent2, ErrorComponent, SliderComponent, SliderCustomMessagesComponent, LabelTemplateDirective, RangeSliderComponent, RangeSliderCustomMessagesComponent, LabelTemplateDirective, RatingComponent, RatingItemTemplateDirective, RatingHoveredItemTemplateDirective, RatingSelectedItemTemplateDirective, SignatureComponent, SignatureCustomMessagesComponent, ColorPickerComponent, ColorPickerCustomMessagesComponent, FlatColorPickerComponent, ColorPickerCustomMessagesComponent, ColorGradientComponent, ColorPickerCustomMessagesComponent, ColorPaletteComponent, ColorPickerCustomMessagesComponent, OTPInputComponent, OTPInputCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService, AdaptiveService],
    imports: [TextBoxComponent, SeparatorComponent, NumericTextBoxComponent, SeparatorComponent, SeparatorComponent, SeparatorComponent, SliderComponent, RangeSliderComponent, RatingComponent, SignatureComponent, ColorPickerComponent, FlatColorPickerComponent, ColorGradientComponent, OTPInputComponent, SeparatorComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InputsModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_INPUTS, ...KENDO_ADORNMENTS],
      exports: [...KENDO_INPUTS, ...KENDO_ADORNMENTS],
      providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService, AdaptiveService]
    }]
  }], null, null);
})();
var SliderModule = class _SliderModule {
  static ɵfac = function SliderModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SliderModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _SliderModule,
    imports: [SliderComponent, SliderCustomMessagesComponent, LabelTemplateDirective],
    exports: [SliderComponent, SliderCustomMessagesComponent, LabelTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, PopupService, ResizeBatchService],
    imports: [SliderComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SliderModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_SLIDER],
      exports: [...KENDO_SLIDER],
      providers: [IconsService, PopupService, ResizeBatchService]
    }]
  }], null, null);
})();
var RangeSliderModule = class _RangeSliderModule {
  static ɵfac = function RangeSliderModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RangeSliderModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _RangeSliderModule,
    imports: [RangeSliderComponent, RangeSliderCustomMessagesComponent, LabelTemplateDirective],
    exports: [RangeSliderComponent, RangeSliderCustomMessagesComponent, LabelTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [ResizeBatchService],
    imports: [RangeSliderComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeSliderModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_RANGESLIDER],
      exports: [...KENDO_RANGESLIDER],
      providers: [ResizeBatchService]
    }]
  }], null, null);
})();
var SwitchModule = class _SwitchModule {
  static ɵfac = function SwitchModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SwitchModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _SwitchModule,
    imports: [SwitchComponent, SwitchCustomMessagesComponent],
    exports: [SwitchComponent, SwitchCustomMessagesComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [ResizeBatchService]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SwitchModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_SWITCH],
      exports: [...KENDO_SWITCH],
      providers: [ResizeBatchService]
    }]
  }], null, null);
})();
var NumericTextBoxModule = class _NumericTextBoxModule {
  static ɵfac = function NumericTextBoxModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NumericTextBoxModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _NumericTextBoxModule,
    imports: [NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent],
    exports: [NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService],
    imports: [NumericTextBoxComponent, SeparatorComponent, SeparatorComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericTextBoxModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_NUMERICTEXTBOX, ...KENDO_ADORNMENTS],
      exports: [...KENDO_NUMERICTEXTBOX, ...KENDO_ADORNMENTS],
      providers: [IconsService]
    }]
  }], null, null);
})();
var MaskedTextBoxModule = class _MaskedTextBoxModule {
  static ɵfac = function MaskedTextBoxModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MaskedTextBoxModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _MaskedTextBoxModule,
    imports: [MaskedTextBoxComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent],
    exports: [MaskedTextBoxComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [SeparatorComponent, SeparatorComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaskedTextBoxModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_MASKEDTEXTBOX, ...KENDO_ADORNMENTS],
      exports: [...KENDO_MASKEDTEXTBOX, ...KENDO_ADORNMENTS]
    }]
  }], null, null);
})();
var TextBoxModule = class _TextBoxModule {
  static ɵfac = function TextBoxModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextBoxModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _TextBoxModule,
    imports: [TextBoxDirective, TextBoxComponent, InputSeparatorComponent, TextBoxSuffixTemplateDirective, TextBoxPrefixTemplateDirective, TextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent],
    exports: [TextBoxDirective, TextBoxComponent, InputSeparatorComponent, TextBoxSuffixTemplateDirective, TextBoxPrefixTemplateDirective, TextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService],
    imports: [TextBoxComponent, SeparatorComponent, SeparatorComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextBoxModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_TEXTBOX, ...KENDO_ADORNMENTS],
      exports: [...KENDO_TEXTBOX, ...KENDO_ADORNMENTS],
      providers: [IconsService]
    }]
  }], null, null);
})();
var TextAreaModule = class _TextAreaModule {
  static ɵfac = function TextAreaModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextAreaModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _TextAreaModule,
    imports: [TextAreaComponent, TextAreaDirective, TextAreaPrefixComponent, TextAreaSuffixComponent, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent],
    exports: [TextAreaComponent, TextAreaDirective, TextAreaPrefixComponent, TextAreaSuffixComponent, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [SeparatorComponent, SeparatorComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextAreaModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_TEXTAREA, ...KENDO_ADORNMENTS],
      exports: [...KENDO_TEXTAREA, ...KENDO_ADORNMENTS]
    }]
  }], null, null);
})();
var CheckBoxModule = class _CheckBoxModule {
  static ɵfac = function CheckBoxModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CheckBoxModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _CheckBoxModule,
    imports: [CheckBoxComponent, CheckBoxDirective],
    exports: [CheckBoxComponent, CheckBoxDirective]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckBoxModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_CHECKBOX],
      exports: [...KENDO_CHECKBOX]
    }]
  }], null, null);
})();
var RadioButtonModule = class _RadioButtonModule {
  static ɵfac = function RadioButtonModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RadioButtonModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _RadioButtonModule,
    imports: [RadioButtonComponent, RadioButtonDirective],
    exports: [RadioButtonComponent, RadioButtonDirective]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioButtonModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_RADIOBUTTON],
      exports: [...KENDO_RADIOBUTTON]
    }]
  }], null, null);
})();
var ColorPickerModule = class _ColorPickerModule {
  static ɵfac = function ColorPickerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorPickerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ColorPickerModule,
    imports: [ColorPickerComponent, ColorPickerCustomMessagesComponent, FlatColorPickerComponent, ColorPickerCustomMessagesComponent, ColorGradientComponent, ColorPickerCustomMessagesComponent, ColorPaletteComponent, ColorPickerCustomMessagesComponent],
    exports: [ColorPickerComponent, ColorPickerCustomMessagesComponent, FlatColorPickerComponent, ColorPickerCustomMessagesComponent, ColorGradientComponent, ColorPickerCustomMessagesComponent, ColorPaletteComponent, ColorPickerCustomMessagesComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, IconsService, ResizeBatchService, AdaptiveService],
    imports: [ColorPickerComponent, FlatColorPickerComponent, ColorGradientComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorPickerModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_COLORPICKER, ...KENDO_FLATCOLORPICKER, ...KENDO_COLORGRADIENT, ...KENDO_COLORPALETTE],
      exports: [...KENDO_COLORPICKER, ...KENDO_FLATCOLORPICKER, ...KENDO_COLORGRADIENT, ...KENDO_COLORPALETTE],
      providers: [PopupService, IconsService, ResizeBatchService, AdaptiveService]
    }]
  }], null, null);
})();
var FormFieldModule = class _FormFieldModule {
  static ɵfac = function FormFieldModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormFieldModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _FormFieldModule,
    imports: [FormFieldComponent, HintComponent2, ErrorComponent],
    exports: [FormFieldComponent, HintComponent2, ErrorComponent]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormFieldModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_FORMFIELD],
      exports: [...KENDO_FORMFIELD]
    }]
  }], null, null);
})();
var SignatureModule = class _SignatureModule {
  static ɵfac = function SignatureModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SignatureModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _SignatureModule,
    imports: [SignatureComponent, SignatureCustomMessagesComponent],
    exports: [SignatureComponent, SignatureCustomMessagesComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService],
    imports: [SignatureComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SignatureModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_SIGNATURE],
      exports: [...KENDO_SIGNATURE],
      providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService]
    }]
  }], null, null);
})();
var RatingModule = class _RatingModule {
  static ɵfac = function RatingModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RatingModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _RatingModule,
    imports: [RatingComponent, RatingItemTemplateDirective, RatingHoveredItemTemplateDirective, RatingSelectedItemTemplateDirective],
    exports: [RatingComponent, RatingItemTemplateDirective, RatingHoveredItemTemplateDirective, RatingSelectedItemTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService],
    imports: [RatingComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RatingModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_RATING],
      exports: [...KENDO_RATING],
      providers: [IconsService]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-angular-treeview/fesm2022/progress-kendo-angular-treeview.mjs
var _c05 = ["kendoTreeViewGroup", ""];
var _c110 = (a0, a1) => ({
  $implicit: a0,
  index: a1
});
var _c210 = (a0) => ({
  index: a0
});
function TreeViewGroupComponent_li_0_span_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 13);
    ɵɵlistener("click", function TreeViewGroupComponent_li_0_span_2_Template_span_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      const node_r3 = ctx_r1.$implicit;
      const index_r4 = ctx_r1.index;
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.expandNode(ctx_r4.nodeIndex(index_r4), node_r3, !ctx_r4.isExpanded(node_r3, ctx_r4.nodeIndex(index_r4))));
    });
    ɵɵelement(1, "kendo-icon-wrapper", 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const node_r3 = ctx_r1.$implicit;
    const index_r4 = ctx_r1.index;
    const ctx_r4 = ɵɵnextContext();
    ɵɵclassProp("k-disabled", !ctx_r4.isItemExpandable(node_r3, index_r4));
    ɵɵproperty("kendoTreeViewLoading", ctx_r4.nodeIndex(index_r4));
    ɵɵadvance();
    ɵɵproperty("name", ctx_r4.getFontIcon(node_r3, ctx_r4.nodeIndex(index_r4)))("svgIcon", ctx_r4.getSvgIcon(node_r3, ctx_r4.nodeIndex(index_r4)));
  }
}
function TreeViewGroupComponent_li_0_kendo_checkbox_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-checkbox", 15, 0);
    ɵɵlistener("checkedStateChange", function TreeViewGroupComponent_li_0_kendo_checkbox_3_Template_kendo_checkbox_checkedStateChange_0_listener() {
      ɵɵrestoreView(_r6);
      const checkbox_r7 = ɵɵreference(1);
      const index_r4 = ɵɵnextContext().index;
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.checkNode(ctx_r4.nodeIndex(index_r4), checkbox_r7));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const node_r3 = ctx_r1.$implicit;
    const index_r4 = ctx_r1.index;
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r4.isItemDisabled(node_r3, index_r4))("size", ctx_r4.size)("checkedState", ctx_r4.getCheckBoxState(node_r3, ctx_r4.nodeIndex(index_r4)))("tabindex", -1)("inputAttributes", ctx_r4.getCheckboxAttributes(index_r4));
  }
}
function TreeViewGroupComponent_li_0_ng_container_7_ng_template_1_Template(rf, ctx) {
}
function TreeViewGroupComponent_li_0_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TreeViewGroupComponent_li_0_ng_container_7_ng_template_1_Template, 0, 0, "ng-template", 16);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const node_r3 = ctx_r1.$implicit;
    const index_r4 = ctx_r1.index;
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r4.nodeTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c110, node_r3, ctx_r4.nodeIndex(index_r4)));
  }
}
function TreeViewGroupComponent_li_0_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const node_r3 = ɵɵnextContext().$implicit;
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.nodeText(node_r3), " ");
  }
}
function TreeViewGroupComponent_li_0_ul_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "ul", 17);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const node_r3 = ctx_r1.$implicit;
    const index_r4 = ctx_r1.index;
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("size", ctx_r4.size)("nodes", ctx_r4.fetchChildren)("loadOnDemand", ctx_r4.loadOnDemand)("checkboxes", ctx_r4.checkboxes)("expandIcons", ctx_r4.expandIcons)("selectable", ctx_r4.selectable)("touchActions", ctx_r4.touchActions)("children", ctx_r4.children)("hasChildren", ctx_r4.hasChildren)("isChecked", ctx_r4.isChecked)("isDisabled", ctx_r4.isDisabled)("hasCheckbox", ctx_r4.hasCheckbox)("disabled", ctx_r4.isItemDisabled(node_r3, index_r4))("expandDisabledNodes", ctx_r4.expandDisabledNodes)("isExpanded", ctx_r4.isExpanded)("isSelected", ctx_r4.isSelected)("isVisible", ctx_r4.isVisible)("nodeTemplateRef", ctx_r4.nodeTemplateRef)("loadMoreButtonTemplateRef", ctx_r4.loadMoreButtonTemplateRef)("parentIndex", ctx_r4.nodeIndex(index_r4))("parentDataItem", node_r3)("textField", ctx_r4.nextFields)("loadMoreService", ctx_r4.loadMoreService)("@toggle", true)("trackBy", ctx_r4.trackBy)("disableParentNodesOnly", ctx_r4.disableParentNodesOnly);
  }
}
function TreeViewGroupComponent_li_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 3)(1, "div", 4);
    ɵɵtemplate(2, TreeViewGroupComponent_li_0_span_2_Template, 2, 5, "span", 5)(3, TreeViewGroupComponent_li_0_kendo_checkbox_3_Template, 2, 5, "kendo-checkbox", 6);
    ɵɵelementStart(4, "span", 7)(5, "span", 8);
    ɵɵelementContainerStart(6, 9);
    ɵɵtemplate(7, TreeViewGroupComponent_li_0_ng_container_7_Template, 2, 5, "ng-container", 10)(8, TreeViewGroupComponent_li_0_ng_container_8_Template, 2, 1, "ng-container", 11);
    ɵɵelementContainerEnd();
    ɵɵelementEnd()()();
    ɵɵtemplate(9, TreeViewGroupComponent_li_0_ul_9_Template, 1, 26, "ul", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const node_r3 = ctx.$implicit;
    const index_r4 = ctx.index;
    const ctx_r4 = ɵɵnextContext();
    ɵɵclassProp("k-hidden", !ctx_r4.isVisible(node_r3, ctx_r4.nodeIndex(index_r4)));
    ɵɵproperty("dataItem", node_r3)("index", ctx_r4.nodeIndex(index_r4))("parentDataItem", ctx_r4.parentDataItem)("parentIndex", ctx_r4.parentIndex)("loadOnDemand", ctx_r4.loadOnDemand)("checkable", ctx_r4.checkboxes)("isChecked", ctx_r4.isChecked(node_r3, ctx_r4.nodeIndex(index_r4)))("isDisabled", ctx_r4.isItemDisabled(node_r3, index_r4))("isVisible", ctx_r4.isVisible(node_r3, ctx_r4.nodeIndex(index_r4)))("expandable", ctx_r4.expandIcons && ctx_r4.hasChildren(node_r3))("isExpanded", ctx_r4.isExpanded(node_r3, ctx_r4.nodeIndex(index_r4)))("selectable", ctx_r4.selectable)("isSelected", ctx_r4.isSelected(node_r3, ctx_r4.nodeIndex(index_r4)));
    ɵɵattribute("aria-setsize", ctx_r4.totalNodesCount)("data-treeindex", ctx_r4.nodeIndex(index_r4));
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r4.setItemClasses(ctx_r4.data.length, index_r4));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.expandIcons && ctx_r4.hasChildren(node_r3));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.checkboxes && ctx_r4.hasCheckbox(node_r3, ctx_r4.nodeIndex(index_r4)));
    ɵɵadvance();
    ɵɵstyleProp("touch-action", ctx_r4.touchActions ? "" : "none");
    ɵɵclassProp("k-disabled", ctx_r4.isItemDisabled(node_r3, index_r4));
    ɵɵproperty("id", ctx_r4.nodeIndex(index_r4))("dataItem", node_r3)("index", ctx_r4.nodeIndex(index_r4))("initialSelection", ctx_r4.isSelected(node_r3, ctx_r4.nodeIndex(index_r4)))("isSelected", ctx_r4.isSelected);
    ɵɵattribute("data-treeindex", ctx_r4.nodeIndex(index_r4));
    ɵɵadvance(2);
    ɵɵproperty("ngSwitch", ctx_r4.hasTemplate);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", true);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r4.isExpanded(node_r3, ctx_r4.nodeIndex(index_r4)) && ctx_r4.hasChildren(node_r3));
  }
}
function TreeViewGroupComponent_li_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 23);
  }
}
function TreeViewGroupComponent_li_1_5_ng_template_0_Template(rf, ctx) {
}
function TreeViewGroupComponent_li_1_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TreeViewGroupComponent_li_1_5_ng_template_0_Template, 0, 0, "ng-template", 16);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r4.loadMoreButtonTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c210, ctx_r4.loadMoreButtonIndex));
  }
}
function TreeViewGroupComponent_li_1_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.loadMoreTitle, " ");
  }
}
function TreeViewGroupComponent_li_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 18)(1, "div", 19);
    ɵɵtemplate(2, TreeViewGroupComponent_li_1_span_2_Template, 1, 0, "span", 20);
    ɵɵelementStart(3, "span", 21)(4, "span", 8);
    ɵɵtemplate(5, TreeViewGroupComponent_li_1_5_Template, 1, 4, null, 22)(6, TreeViewGroupComponent_li_1_ng_container_6_Template, 2, 1, "ng-container", 22);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵclassProp("k-treeview-load-more-checkboxes-container", ctx_r4.checkboxes);
    ɵɵproperty("selectable", false)("checkable", false)("expandable", false)("index", ctx_r4.loadMoreButtonIndex)("parentDataItem", ctx_r4.parentDataItem)("parentIndex", ctx_r4.parentIndex);
    ɵɵattribute("data-treeindex", ctx_r4.loadMoreButtonIndex);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r4.loadingMoreNodes);
    ɵɵadvance();
    ɵɵproperty("index", ctx_r4.loadMoreButtonIndex);
    ɵɵattribute("data-treeindex", ctx_r4.loadMoreButtonIndex);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r4.loadMoreButtonTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r4.loadMoreButtonTemplateRef);
  }
}
var _c310 = ["assetsContainer"];
var _c410 = ["searchbox"];
function TreeViewComponent_span_1_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 8);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("svgIcon", ctx_r1.searchIcon);
  }
}
function TreeViewComponent_span_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 5)(1, "kendo-textbox", 6, 1);
    ɵɵlistener("valueChange", function TreeViewComponent_span_1_Template_kendo_textbox_valueChange_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.filterChange.emit($event));
    });
    ɵɵtemplate(3, TreeViewComponent_span_1_ng_template_3_Template, 1, 1, "ng-template", 7);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("size", ctx_r1.size)("value", ctx_r1.filter)("clearButton", true)("placeholder", ctx_r1.filterInputPlaceholder);
  }
}
var _c510 = (a0, a1, a2, a3) => ({
  text: a0,
  action: a1,
  sourceItem: a2,
  destinationItem: a3
});
function DragClueComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "kendo-icon-wrapper", 1);
    ɵɵelementStart(2, "span");
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("name", ctx_r0.statusIconClass)("svgIcon", ctx_r0.statusSVGIcon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.text);
  }
}
function DragClueComponent_1_ng_template_0_Template(rf, ctx) {
}
function DragClueComponent_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DragClueComponent_1_ng_template_0_Template, 0, 0, "ng-template", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.template)("ngTemplateOutletContext", ɵɵpureFunction4(2, _c510, ctx_r0.text, ctx_r0.action, ctx_r0.sourceItem, ctx_r0.destinationItem));
  }
}
var _c69 = (a0, a1, a2) => ({
  action: a0,
  sourceItem: a1,
  destinationItem: a2
});
function DropHintComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵelement(1, "div", 3)(2, "div", 4);
    ɵɵelementEnd();
  }
}
function DropHintComponent_1_ng_template_0_ng_template_0_Template(rf, ctx) {
}
function DropHintComponent_1_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropHintComponent_1_ng_template_0_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function DropHintComponent_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropHintComponent_1_ng_template_0_Template, 1, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.template)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c69, ctx_r0.action, ctx_r0.sourceItem, ctx_r0.destinationItem));
  }
}
var packageMetadata6 = {
  name: "@progress/kendo-angular-treeview",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 1745303933,
  version: "18.5.2",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var DataChangeNotificationService = class {
  changes = new EventEmitter();
  notify() {
    this.changes.emit();
  }
};
var hasChildren = () => false;
var isChecked = () => "none";
var isDisabled = () => false;
var hasCheckbox = () => true;
var isExpanded = () => true;
var isSelected = () => false;
var isVisible2 = () => true;
var trackBy = (_2, item) => item;
var ExpandStateService = class _ExpandStateService {
  changes = new Subject();
  expand(index, dataItem) {
    this.changes.next({
      dataItem,
      index,
      expand: true
    });
  }
  collapse(index, dataItem) {
    this.changes.next({
      dataItem,
      index,
      expand: false
    });
  }
  static ɵfac = function ExpandStateService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ExpandStateService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ExpandStateService,
    factory: _ExpandStateService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpandStateService, [{
    type: Injectable
  }], null, null);
})();
var IndexBuilderService = class _IndexBuilderService {
  INDEX_SEPARATOR = "_";
  nodeIndex(index = "", parentIndex = "") {
    return `${parentIndex}${parentIndex ? this.INDEX_SEPARATOR : ""}${index}`;
  }
  indexForLevel(index, level) {
    return index.split(this.INDEX_SEPARATOR).slice(0, level).join(this.INDEX_SEPARATOR);
  }
  lastLevelIndex(index = "") {
    const parts = index.split(this.INDEX_SEPARATOR);
    if (!parts.length) {
      return NaN;
    }
    return parseInt(parts[parts.length - 1], 10);
  }
  level(index) {
    return index.split(this.INDEX_SEPARATOR).length;
  }
  static ɵfac = function IndexBuilderService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _IndexBuilderService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _IndexBuilderService,
    factory: _IndexBuilderService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IndexBuilderService, [{
    type: Injectable
  }], null, null);
})();
var LoadingNotificationService = class _LoadingNotificationService {
  changes = new Subject();
  notifyLoaded(index) {
    this.changes.next(index);
  }
  static ɵfac = function LoadingNotificationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LoadingNotificationService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _LoadingNotificationService,
    factory: _LoadingNotificationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LoadingNotificationService, [{
    type: Injectable
  }], null, null);
})();
var focusableRegex2 = /^(?:a|input|select|option|textarea|button|object)$/i;
var match = (element, selector) => {
  const matcher = element.matches || element.msMatchesSelector || element.webkitMatchesSelector;
  if (!matcher) {
    return false;
  }
  return matcher.call(element, selector.toLowerCase());
};
var closestWithMatch = (element, selector) => {
  if (!document.documentElement.contains(element)) {
    return null;
  }
  let parent = element;
  while (parent !== null && parent.nodeType === 1) {
    if (match(parent, selector)) {
      return parent;
    }
    parent = parent.parentElement || parent.parentNode;
  }
  return null;
};
var noop5 = () => {
};
var isPresent6 = (value) => value !== null && value !== void 0;
var isBlank = (value) => value === null || value === void 0;
var isArray2 = (value) => Array.isArray(value);
var isNullOrEmptyString = (value) => isBlank(value) || value.trim().length === 0;
var isBoolean = (value) => typeof value === "boolean";
var closestNode = (element) => {
  const selector = "li.k-treeview-item";
  if (!isDocumentAvailable()) {
    return null;
  }
  if (element.closest) {
    return element.closest(selector);
  } else {
    return closestWithMatch(element, selector);
  }
};
var isFocusable3 = (element) => {
  if (element.tagName) {
    const tagName = element.tagName.toLowerCase();
    const tabIndex = element.getAttribute("tabIndex");
    const skipTab = tabIndex === "-1";
    let focusable = tabIndex !== null && !skipTab;
    if (focusableRegex2.test(tagName)) {
      focusable = !element.disabled && !skipTab;
    }
    return focusable;
  }
  return false;
};
var isContent = (element) => {
  const scopeSelector = ".k-treeview-leaf:not(.k-treeview-load-more-button),.k-treeview-item,.k-treeview";
  if (!isDocumentAvailable()) {
    return null;
  }
  let node = element;
  while (node && !match(node, scopeSelector)) {
    node = node.parentNode;
  }
  if (node) {
    return match(node, ".k-treeview-leaf:not(.k-treeview-load-more-button)");
  }
};
var getContentElement = (parent) => {
  if (!isPresent6(parent)) {
    return null;
  }
  const selector = ".k-treeview-leaf:not(.k-treeview-load-more-button)";
  if (match(parent, selector)) {
    return parent;
  }
  return parent.querySelector(selector);
};
var isLoadMoreButton = (element) => {
  return isPresent6(closestWithMatch(element, ".k-treeview-leaf.k-treeview-load-more-button"));
};
var closest4 = (node, predicate) => {
  while (node && !predicate(node)) {
    node = node.parentNode;
  }
  return node;
};
var hasParent = (element, container) => {
  return Boolean(closest4(element, (node) => node === container));
};
var focusableNode = (element) => element.nativeElement.querySelector('li[tabindex="0"]');
var nodeId = (node) => node ? node.getAttribute("data-treeindex") : "";
var nodeIndex = (item) => (item || {}).index;
var dataItemsEqual = (first, second) => {
  if (!isPresent6(first) && !isPresent6(second)) {
    return true;
  }
  return isPresent6(first) && isPresent6(second) && first.item.dataItem === second.item.dataItem;
};
var getDataItem = (lookup) => {
  if (!isPresent6(lookup)) {
    return lookup;
  }
  return lookup.item.dataItem;
};
var isArrayWithAtLeastOneItem = (v) => v && Array.isArray(v) && v.length !== 0;
var filterTree = (items, term, {
  operator,
  ignoreCase,
  mode
}, textField, depth = 0) => {
  const field = typeof textField === "string" ? textField : textField[depth];
  items.forEach((wrapper) => {
    const matcher = typeof operator === "string" ? matchByFieldAndCase(field, operator, ignoreCase) : operator;
    const isMatch = matcher(wrapper.dataItem, term);
    wrapper.isMatch = isMatch;
    wrapper.visible = isMatch;
    wrapper.containsMatches = false;
    if (isMatch) {
      setParentChain(wrapper.parent);
    }
    if (wrapper.children && wrapper.children.length > 0) {
      if (mode === "strict" || !isMatch) {
        filterTree(wrapper.children, term, {
          operator,
          ignoreCase,
          mode
        }, textField, depth + 1);
      } else {
        makeAllVisible(wrapper.children);
      }
    }
  });
};
var setParentChain = (node) => {
  if (!isPresent6(node)) {
    return;
  }
  node.containsMatches = true;
  node.visible = true;
  if (isPresent6(node.parent) && !node.parent.containsMatches) {
    setParentChain(node.parent);
  }
};
var makeAllVisible = (nodes) => {
  nodes.forEach((node) => {
    node.visible = true;
    if (node.children) {
      makeAllVisible(node.children);
    }
  });
};
var operators = {
  contains: (a, b) => a.indexOf(b) >= 0,
  doesnotcontain: (a, b) => a.indexOf(b) === -1,
  startswith: (a, b) => a.lastIndexOf(b, 0) === 0,
  doesnotstartwith: (a, b) => a.lastIndexOf(b, 0) === -1,
  endswith: (a, b) => a.indexOf(b, a.length - b.length) >= 0,
  doesnotendwith: (a, b) => a.indexOf(b, a.length - b.length) < 0
};
var matchByCase = (matcher, ignoreCase) => (a, b) => {
  if (ignoreCase) {
    return matcher(a.toLowerCase(), b.toLowerCase());
  }
  return matcher(a, b);
};
var matchByFieldAndCase = (field, operator, ignoreCase) => (dataItem, term) => matchByCase(operators[operator], ignoreCase)(getter(field)(dataItem), term);
var buildTreeIndex = (parentIndex, itemIndex2) => {
  return [parentIndex, itemIndex2].filter((part) => isPresent6(part)).join("_");
};
var buildTreeItem = (dataItem, currentLevelIndex, parentIndex) => {
  if (!isPresent6(dataItem)) {
    return null;
  }
  return {
    dataItem,
    index: buildTreeIndex(parentIndex, currentLevelIndex)
  };
};
var fetchLoadedDescendants = (lookup, filterExpression) => {
  if (!isPresent6(lookup) || lookup.children.length === 0) {
    return [];
  }
  let descendants = lookup.children;
  if (isPresent6(filterExpression)) {
    descendants = descendants.filter(filterExpression);
  }
  descendants.forEach((child) => descendants = descendants.concat(fetchLoadedDescendants(child, filterExpression)));
  return descendants;
};
var sameValues = (as, bs) => {
  if (as.size !== bs.size) {
    return false;
  }
  return Array.from(as).every((v) => bs.has(v));
};
var getSizeClass = (component, size) => {
  const SIZE_CLASSES = {
    "small": `k-${component}-sm`,
    "medium": `k-${component}-md`,
    "large": `k-${component}-lg`
  };
  return SIZE_CLASSES[size];
};
var safe = (node) => node || {};
var safeChildren = (node) => safe(node).children || [];
var lastVisibleNode = (nodes) => {
  if (!Array.isArray(nodes) || nodes.length === 0) {
    return null;
  }
  const nodesCount = nodes.length;
  const lastIndex = nodesCount - 1;
  for (let index = lastIndex; index >= 0; index -= 1) {
    const node = nodes[index];
    if (node.visible) {
      return node;
    }
  }
  return null;
};
var NavigationModel = class {
  ib = new IndexBuilderService();
  nodes = [];
  firstVisibleNode() {
    return (this.nodes || []).find((node) => node.visible);
  }
  lastVisibleNode() {
    let node = lastVisibleNode(this.nodes);
    while (isPresent6(node) && safeChildren(node).length > 0) {
      const children = safeChildren(node);
      const lastVisibleChild = lastVisibleNode(children);
      if (!isPresent6(lastVisibleChild)) {
        return node;
      }
      node = lastVisibleChild;
    }
    return node;
  }
  closestNode(index) {
    const {
      prev
    } = safe(this.findNode(index));
    const sibling = prev || this.firstVisibleNode();
    return safe(sibling).index === index ? this.visibleSibling(sibling, 1) : sibling;
  }
  firstFocusableNode() {
    return this.nodes.find((node) => {
      return !node.disabled && node.visible;
    });
  }
  findNode(index) {
    return this.find(index, this.nodes);
  }
  findParent(index) {
    const parentLevel = this.ib.level(index) - 1;
    return this.findNode(this.ib.indexForLevel(index, parentLevel));
  }
  findVisibleChild(index) {
    const node = this.findNode(index);
    const children = safeChildren(node);
    return children.find((child) => child.visible);
  }
  findVisiblePrev(item) {
    const index = item.index;
    const parent = this.findParent(index);
    const levelIndex = this.ib.lastLevelIndex(index);
    const prevNodes = this.container(parent).slice(0, levelIndex);
    const prevNodesHidden = prevNodes.every((node) => !node.visible);
    if (levelIndex === 0 || prevNodesHidden) {
      return parent;
    }
    const currentNode = this.findNode(index);
    let prev = this.visibleSibling(currentNode, -1);
    if (prev) {
      let children = this.container(prev);
      while (children.length > 0 && children.some((node) => node.visible)) {
        prev = lastVisibleNode(children);
        children = this.container(prev);
      }
    }
    return prev;
  }
  findVisibleNext(item) {
    const children = this.container(item);
    const hasVisibleChildren = children.some((child) => child.visible);
    if (children.length === 0 || !hasVisibleChildren) {
      return this.visibleSibling(item, 1);
    }
    return children.find((child) => child.visible);
  }
  registerItem(id2, index, disabled, loadMoreButton = false, visible = true) {
    const children = [];
    const level = this.ib.level(index);
    const parent = this.findParent(index);
    if (parent || level === 1) {
      const node = {
        id: id2,
        children,
        index,
        parent,
        disabled,
        loadMoreButton,
        visible
      };
      this.insert(node, parent);
    }
  }
  unregisterItem(id2, index) {
    const node = this.find(index, this.nodes);
    if (!node || node.id !== id2) {
      return;
    }
    const children = this.container(node.parent);
    children.splice(children.indexOf(node), 1);
  }
  childLevel(nodes) {
    const children = nodes.filter((node) => isPresent6(node));
    if (!children || !children.length) {
      return 1;
    }
    return this.ib.level(children[0].index);
  }
  container(node) {
    return node ? node.children : this.nodes;
  }
  find(index, nodes) {
    const childLevel = this.childLevel(nodes);
    const indexToMatch = this.ib.indexForLevel(index, childLevel);
    const isLeaf = childLevel === this.ib.level(index);
    const node = nodes.find((n) => n && n.index === indexToMatch);
    if (!node) {
      return null;
    }
    return isLeaf ? node : this.find(index, node.children);
  }
  insert(node, parent) {
    const nodes = this.container(parent);
    nodes.splice(this.ib.lastLevelIndex(node.index), 0, node);
  }
  visibleSibling(node, offset) {
    if (!node) {
      return null;
    }
    const parent = this.findParent(node.index);
    const container = this.container(parent);
    let nextItemIndex = container.indexOf(node) + offset;
    let nextItem = container[nextItemIndex];
    while (isPresent6(nextItem)) {
      if (nextItem.visible) {
        return nextItem;
      }
      nextItemIndex += offset;
      nextItem = container[nextItemIndex];
    }
    return this.visibleSibling(parent, offset);
  }
};
var NavigationService2 = class _NavigationService {
  localization;
  expands = new Subject();
  moves = new Subject();
  checks = new Subject();
  selects = new Subject();
  deselectAllButCurrentItem = new Subject();
  loadMore = new Subject();
  navigable = true;
  selection = "single";
  isTreeViewActive = false;
  get model() {
    return this._model;
  }
  set model(model) {
    this._model = model;
  }
  actions = {
    [Keys.ArrowUp]: () => this.activate(this.model.findVisiblePrev(this.focusableItem), true),
    [Keys.ArrowDown]: () => this.activate(this.model.findVisibleNext(this.focusableItem), true),
    [Keys.ArrowLeft]: () => !this.isLoadMoreButton && this.expand({
      expand: this.localization.rtl,
      intercept: this.localization.rtl ? this.moveToFirstVisibleChild : this.moveToParent
    }),
    [Keys.ArrowRight]: () => !this.isLoadMoreButton && this.expand({
      expand: !this.localization.rtl,
      intercept: this.localization.rtl ? this.moveToParent : this.moveToFirstVisibleChild
    }),
    [Keys.Home]: () => this.activate(this.model.firstVisibleNode(), true),
    [Keys.End]: () => this.activate(this.model.lastVisibleNode(), true),
    [Keys.Enter]: (e) => this.handleEnter(e),
    [Keys.Space]: () => this.handleSpace()
  };
  activeItem;
  isFocused = false;
  shouldScroll = false;
  _model = new NavigationModel();
  get activeIndex() {
    return nodeIndex(this.activeItem) || null;
  }
  get isActiveExpanded() {
    return this.activeItem && this.activeItem.children.length > 0;
  }
  get isLoadMoreButton() {
    return this.activeItem && this.activeItem.loadMoreButton;
  }
  get focusableItem() {
    return this.activeItem || this.model.firstFocusableNode();
  }
  constructor(localization) {
    this.localization = localization;
    this.moveToFirstVisibleChild = this.moveToFirstVisibleChild.bind(this);
    this.moveToParent = this.moveToParent.bind(this);
  }
  activate(item, shouldScroll = false) {
    if (!this.navigable || !item || this.isActive(nodeIndex(item))) {
      return;
    }
    this.isFocused = true;
    this.activeItem = item || this.activeItem;
    this.shouldScroll = shouldScroll;
    this.notifyMove();
  }
  activateParent(index) {
    this.activate(this.model.findParent(index));
  }
  activateIndex(index) {
    if (!index) {
      return;
    }
    this.activate(this.model.findNode(index));
  }
  activateClosest(index) {
    if (!index || nodeIndex(this.focusableItem) !== index) {
      return;
    }
    this.activeItem = this.model.closestNode(index);
    this.notifyMove();
  }
  activateFocusable() {
    if (this.activeItem) {
      return;
    }
    this.activeItem = this.model.firstVisibleNode();
    this.notifyMove();
  }
  deactivate() {
    if (!this.navigable || !this.isFocused) {
      return;
    }
    this.isFocused = false;
    this.notifyMove();
  }
  checkIndex(index) {
    if (!this.isDisabled(index)) {
      this.checks.next(index);
    }
  }
  selectIndex(index) {
    if (!this.isDisabled(index)) {
      this.selects.next(index);
    }
  }
  notifyLoadMore(index) {
    if (!isPresent6(index)) {
      return;
    }
    this.loadMore.next(index);
  }
  isActive(index) {
    if (!index) {
      return false;
    }
    return this.isFocused && this.activeIndex === index;
  }
  isFocusable(index) {
    return nodeIndex(this.focusableItem) === index;
  }
  isDisabled(index) {
    if (!index) {
      return false;
    }
    return this.model.findNode(index).disabled;
  }
  registerItem(id2, index, disabled, loadMoreButton = false, visible = true) {
    const itemAtIndex = this.model.findNode(index);
    if (isPresent6(itemAtIndex)) {
      this.model.unregisterItem(itemAtIndex.id, itemAtIndex.index);
      if (this.isActive(index)) {
        this.deactivate();
      }
    }
    this.model.registerItem(id2, index, disabled, loadMoreButton, visible);
  }
  updateItem(index, disabled, visible = true) {
    const itemAtIndex = this.model.findNode(index);
    if (isPresent6(itemAtIndex)) {
      if (this.isActive(index)) {
        this.deactivate();
      }
    }
    itemAtIndex.disabled = disabled;
    itemAtIndex.visible = visible;
  }
  unregisterItem(id2, index) {
    if (this.isActive(index)) {
      this.activateParent(index);
    }
    this.model.unregisterItem(id2, index);
  }
  move(e) {
    if (!this.navigable) {
      return;
    }
    const moveAction = this.actions[e.keyCode];
    if (!moveAction) {
      return;
    }
    moveAction(e);
    e.preventDefault();
  }
  expand({
    expand,
    intercept
  }) {
    const index = nodeIndex(this.activeItem);
    if (!index || intercept(index)) {
      return;
    }
    this.notifyExpand(expand);
  }
  moveToParent() {
    if (this.isActiveExpanded) {
      return false;
    }
    this.activate(this.model.findParent(nodeIndex(this.activeItem)));
    return true;
  }
  moveToFirstVisibleChild() {
    if (!this.isActiveExpanded) {
      return false;
    }
    this.activate(this.model.findVisibleChild(nodeIndex(this.activeItem)));
    return true;
  }
  notifyExpand(expand) {
    this.expands.next(this.navigationState(expand));
  }
  notifyMove() {
    this.moves.next(this.navigationState());
  }
  navigationState(expand = false) {
    return {
      expand,
      index: this.activeIndex,
      isFocused: this.isFocused,
      shouldScroll: this.shouldScroll
    };
  }
  handleEnter(event) {
    if (!this.navigable) {
      return;
    }
    if (this.isLoadMoreButton) {
      this.notifyLoadMore(this.activeIndex);
    } else {
      const isCtrlPressed = event.ctrlKey || event.metaKey;
      if (isCtrlPressed) {
        this.selectIndex(this.activeIndex);
      } else {
        if (this.selection === "multiple") {
          this.deselectAllButCurrentItem.next({
            dataItem: this.activeItem,
            index: this.activeIndex
          });
        } else {
          this.selectIndex(this.activeIndex);
        }
      }
    }
  }
  handleSpace() {
    if (!this.navigable) {
      return;
    }
    if (this.isLoadMoreButton) {
      this.notifyLoadMore(this.activeIndex);
    } else {
      this.checkIndex(this.activeIndex);
    }
  }
  static ɵfac = function NavigationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NavigationService)(ɵɵinject(LocalizationService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _NavigationService,
    factory: _NavigationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationService2, [{
    type: Injectable
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var NodeChildrenService = class _NodeChildrenService {
  changes = new Subject();
  childrenLoaded(item, children) {
    this.changes.next({
      item,
      children
    });
  }
  static ɵfac = function NodeChildrenService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NodeChildrenService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _NodeChildrenService,
    factory: _NodeChildrenService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NodeChildrenService, [{
    type: Injectable
  }], null, null);
})();
var NodeTemplateDirective = class _NodeTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function NodeTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NodeTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NodeTemplateDirective,
    selectors: [["", "kendoTreeViewNodeTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NodeTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewNodeTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var LoadMoreButtonTemplateDirective = class _LoadMoreButtonTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function LoadMoreButtonTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LoadMoreButtonTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LoadMoreButtonTemplateDirective,
    selectors: [["", "kendoTreeViewLoadMoreButtonTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LoadMoreButtonTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewLoadMoreButtonTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var DataBoundComponent = class _DataBoundComponent {
  static ɵfac = function DataBoundComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DataBoundComponent)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DataBoundComponent,
    factory: _DataBoundComponent.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DataBoundComponent, [{
    type: Injectable
  }], null, null);
})();
var ExpandableComponent = class _ExpandableComponent {
  static ɵfac = function ExpandableComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ExpandableComponent)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ExpandableComponent,
    factory: _ExpandableComponent.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpandableComponent, [{
    type: Injectable
  }], null, null);
})();
var SelectionService = class _SelectionService {
  changes = new Subject();
  firstIndex;
  isFirstSelected(index) {
    return this.firstIndex === index;
  }
  setFirstSelected(index, selected) {
    if (this.firstIndex === index && selected === false) {
      this.firstIndex = null;
    } else if (!this.firstIndex && selected) {
      this.firstIndex = index;
    }
  }
  select(index, dataItem) {
    this.changes.next({
      dataItem,
      index
    });
  }
  static ɵfac = function SelectionService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SelectionService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SelectionService,
    factory: _SelectionService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectionService, [{
    type: Injectable
  }], null, null);
})();
var INDEX_REGEX = /\d+$/;
var TreeViewLookupService = class _TreeViewLookupService {
  map = /* @__PURE__ */ new Map();
  reset() {
    this.map.clear();
  }
  registerItem(item, parent) {
    const currentLookup = {
      children: [],
      item,
      parent: this.item(nodeIndex(parent))
    };
    this.map.set(item.index, currentLookup);
  }
  registerChildren(index, children) {
    const item = this.item(index);
    if (!item) {
      return;
    }
    item.children = children;
  }
  unregisterItem(index, dataItem) {
    const current = this.item(index);
    if (current && current.item.dataItem === dataItem) {
      this.map.delete(index);
      if (current.parent && current.parent.children) {
        current.parent.children = current.parent.children.filter((item) => item.dataItem !== dataItem);
      }
    }
  }
  replaceItem(index, item, parent) {
    if (!item) {
      return;
    }
    this.unregisterItem(index, item.dataItem);
    this.registerItem(item, parent);
    this.addToParent(item, parent);
  }
  itemLookup(index) {
    const item = this.item(index);
    if (!item) {
      return null;
    }
    return {
      children: this.mapChildren(item.children),
      item: item.item,
      parent: item.parent
    };
  }
  hasItem(index) {
    return this.map.has(index);
  }
  item(index) {
    return this.map.get(index) || null;
  }
  addToParent(item, parent) {
    if (parent) {
      const parentItem = this.item(parent.index);
      const index = parseInt(INDEX_REGEX.exec(item.index)[0], 10);
      parentItem.children = parentItem.children || [];
      parentItem.children.splice(index, 0, item);
    }
  }
  mapChildren(children = []) {
    return children.map((c) => {
      const {
        item,
        parent,
        children: children2
      } = this.item(c.index);
      return {
        children: this.mapChildren(children2),
        item,
        parent
      };
    });
  }
  static ɵfac = function TreeViewLookupService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TreeViewLookupService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _TreeViewLookupService,
    factory: _TreeViewLookupService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeViewLookupService, [{
    type: Injectable
  }], null, null);
})();
var TreeViewItemContentDirective = class _TreeViewItemContentDirective {
  element;
  navigationService;
  selectionService;
  renderer;
  dataItem;
  index;
  initialSelection = false;
  isSelected = isSelected;
  subscriptions = new Subscription();
  constructor(element, navigationService, selectionService, renderer) {
    this.element = element;
    this.navigationService = navigationService;
    this.selectionService = selectionService;
    this.renderer = renderer;
    this.subscriptions.add(this.navigationService.moves.subscribe(this.updateFocusClass.bind(this)));
    this.subscriptions.add(this.navigationService.selects.pipe(filter((index) => index === this.index)).subscribe((index) => this.selectionService.select(index, this.dataItem)));
    this.subscriptions.add(this.selectionService.changes.subscribe(() => {
      this.updateSelectionClass(this.isSelected(this.dataItem, this.index));
    }));
  }
  ngOnChanges(changes) {
    if (changes["initialSelection"]) {
      this.updateSelectionClass(this.initialSelection);
    }
    if (changes["index"]) {
      this.updateFocusClass();
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  updateFocusClass() {
    this.render(this.navigationService.isActive(this.index), "k-focus");
  }
  updateSelectionClass(selected) {
    this.render(selected, "k-selected");
  }
  render(addClass2, className) {
    const action = addClass2 ? "addClass" : "removeClass";
    this.renderer[action](this.element.nativeElement, className);
  }
  static ɵfac = function TreeViewItemContentDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TreeViewItemContentDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(SelectionService), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TreeViewItemContentDirective,
    selectors: [["", "kendoTreeViewItemContent", ""]],
    inputs: {
      dataItem: "dataItem",
      index: "index",
      initialSelection: "initialSelection",
      isSelected: "isSelected"
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeViewItemContentDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewItemContent]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NavigationService2
    }, {
      type: SelectionService
    }, {
      type: Renderer2
    }];
  }, {
    dataItem: [{
      type: Input
    }],
    index: [{
      type: Input
    }],
    initialSelection: [{
      type: Input
    }],
    isSelected: [{
      type: Input
    }]
  });
})();
var LoadingIndicatorDirective = class _LoadingIndicatorDirective {
  expandService;
  loadingService;
  cd;
  get loading() {
    return this._loading;
  }
  set loading(value) {
    this._loading = value;
    this.cd.markForCheck();
  }
  index;
  _loading = false;
  subscription;
  constructor(expandService, loadingService, cd) {
    this.expandService = expandService;
    this.loadingService = loadingService;
    this.cd = cd;
  }
  ngOnInit() {
    const loadingNotifications = this.loadingService.changes.pipe(filter((index) => index === this.index));
    this.subscription = this.expandService.changes.pipe(filter(({
      index
    }) => index === this.index), tap(({
      expand
    }) => {
      if (!expand && this.loading) {
        this.loading = false;
      }
    }), filter(({
      expand
    }) => expand), switchMap((x) => of(x).pipe(delay(100), takeUntil(loadingNotifications)))).subscribe(() => this.loading = true);
    this.subscription.add(loadingNotifications.subscribe(() => this.loading = false));
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  static ɵfac = function LoadingIndicatorDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LoadingIndicatorDirective)(ɵɵdirectiveInject(ExpandStateService), ɵɵdirectiveInject(LoadingNotificationService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LoadingIndicatorDirective,
    selectors: [["", "kendoTreeViewLoading", ""]],
    hostVars: 2,
    hostBindings: function LoadingIndicatorDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-i-loading", ctx.loading);
      }
    },
    inputs: {
      index: [0, "kendoTreeViewLoading", "index"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LoadingIndicatorDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewLoading]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ExpandStateService
    }, {
      type: LoadingNotificationService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    loading: [{
      type: HostBinding,
      args: ["class.k-i-loading"]
    }],
    index: [{
      type: Input,
      args: ["kendoTreeViewLoading"]
    }]
  });
})();
var buildItem = (index, dataItem) => ({
  dataItem,
  index
});
var id = 0;
var TREE_ITEM_ROLE = "treeitem";
var BUTTON_ROLE = "button";
var TreeViewItemDirective = class _TreeViewItemDirective {
  element;
  expandService;
  navigationService;
  selectionService;
  lookupService;
  renderer;
  ib;
  dataItem;
  index;
  parentDataItem;
  parentIndex;
  role = TREE_ITEM_ROLE;
  loadOnDemand = true;
  checkable;
  selectable;
  expandable;
  set isChecked(checked) {
    if (checked === "checked") {
      this.ariaChecked = "true";
    } else if (checked === "indeterminate") {
      this.ariaChecked = "mixed";
    } else {
      this.ariaChecked = "false";
    }
  }
  isDisabled = false;
  isVisible = true;
  get isExpanded() {
    return this._isExpanded || false;
  }
  set isExpanded(isExpanded2) {
    this._isExpanded = isExpanded2;
  }
  get isSelected() {
    return this._isSelected || false;
  }
  set isSelected(isSelected2) {
    this._isSelected = isSelected2;
  }
  get isButton() {
    return this.role === BUTTON_ROLE;
  }
  get treeItem() {
    return buildItem(this.index, this.dataItem);
  }
  get parentTreeItem() {
    return this.parentDataItem ? buildItem(this.parentIndex, this.parentDataItem) : null;
  }
  ariaChecked = "false";
  id = id++;
  _isExpanded;
  _isSelected;
  isInitialized = false;
  subscriptions = [];
  constructor(element, expandService, navigationService, selectionService, lookupService, renderer, ib) {
    this.element = element;
    this.expandService = expandService;
    this.navigationService = navigationService;
    this.selectionService = selectionService;
    this.lookupService = lookupService;
    this.renderer = renderer;
    this.ib = ib;
    this.subscribe();
  }
  ngOnInit() {
    if (this.loadOnDemand && !this.isButton) {
      this.lookupService.registerItem(this.treeItem, this.parentTreeItem);
    }
    this.registerNavigationItem();
    this.isInitialized = true;
    this.setAttribute("role", this.role);
    this.setAriaAttributes();
    this.updateTabIndex();
  }
  ngOnChanges(changes) {
    const {
      index
    } = changes;
    if (anyChanged(["index", "checkable", "isChecked", "expandable", "isExpanded", "selectable", "isSelected"], changes)) {
      this.setAriaAttributes();
    }
    if (this.loadOnDemand && !this.isButton) {
      this.moveLookupItem(changes);
    }
    this.moveNavigationItem(index);
    if (anyChanged(["isDisabled", "isVisible"], changes)) {
      this.updateNodeAvailability();
    }
  }
  ngOnDestroy() {
    this.navigationService.unregisterItem(this.id, this.index);
    if (this.loadOnDemand && !this.isButton) {
      this.lookupService.unregisterItem(this.index, this.dataItem);
    }
    this.subscriptions = this.subscriptions.reduce((list, callback) => (callback.unsubscribe(), list), []);
  }
  subscribe() {
    this.subscriptions = [this.navigationService.moves.subscribe((navState) => {
      this.updateTabIndex();
      this.focusItem(navState.shouldScroll);
    }), this.navigationService.expands.pipe(filter(({
      index
    }) => index === this.index && !this.isDisabled)).subscribe(({
      expand
    }) => this.expand(expand))];
  }
  registerNavigationItem() {
    this.navigationService.registerItem(this.id, this.index, this.isDisabled, this.isButton, this.isVisible);
    this.activateItem();
  }
  activateItem() {
    if (this.isDisabled) {
      return;
    }
    const navigationService = this.navigationService;
    const selectionService = this.selectionService;
    const index = this.index;
    selectionService.setFirstSelected(index, this.isSelected);
    if (!navigationService.isActive(index) && selectionService.isFirstSelected(index)) {
      navigationService.activateIndex(index);
    }
  }
  expand(shouldExpand) {
    this.expandService[shouldExpand ? "expand" : "collapse"](this.index, this.dataItem);
  }
  isFocusable() {
    return !this.isDisabled && this.navigationService.isFocusable(this.index);
  }
  focusItem(scrollIntoView = false) {
    if (this.isInitialized && this.navigationService.isActive(this.index)) {
      this.element.nativeElement.focus({
        preventScroll: !scrollIntoView
      });
    }
  }
  moveLookupItem(changes = {}) {
    const {
      dataItem,
      index,
      parentDataItem,
      parentIndex
    } = changes;
    if (index && index.firstChange || //skip first change
    !dataItem && !index && !parentDataItem && !parentIndex) {
      return;
    }
    const oldIndex = (index || {}).previousValue || this.index;
    this.lookupService.replaceItem(oldIndex, this.treeItem, this.parentTreeItem);
  }
  moveNavigationItem(indexChange = {}) {
    const {
      currentValue,
      firstChange,
      previousValue
    } = indexChange;
    if (!firstChange && isPresent6(currentValue) && isPresent6(previousValue)) {
      this.navigationService.unregisterItem(this.id, previousValue);
      this.navigationService.registerItem(this.id, currentValue, this.isDisabled, this.isButton);
    }
  }
  updateNodeAvailability() {
    const service = this.navigationService;
    if (this.isDisabled || !this.isVisible && this.navigationService.isTreeViewActive) {
      service.activateClosest(this.index);
    } else {
      service.activateFocusable();
    }
    service.updateItem(this.index, this.isDisabled, this.isVisible);
  }
  setAriaAttributes() {
    this.setAttribute("aria-level", this.ib.level(this.index).toString());
    this.setAttribute("aria-expanded", this.expandable ? this.isExpanded.toString() : null);
    this.setAttribute("aria-selected", this.selectable ? this.isSelected.toString() : null);
    this.setAttribute("aria-checked", this.checkable ? this.ariaChecked : null);
  }
  updateTabIndex() {
    this.setAttribute("tabIndex", this.isFocusable() ? "0" : "-1");
  }
  setAttribute(attr, value) {
    if (!isPresent6(value)) {
      this.renderer.removeAttribute(this.element.nativeElement, attr);
      return;
    }
    this.renderer.setAttribute(this.element.nativeElement, attr, value);
  }
  static ɵfac = function TreeViewItemDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TreeViewItemDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ExpandStateService), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(SelectionService), ɵɵdirectiveInject(TreeViewLookupService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(IndexBuilderService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TreeViewItemDirective,
    selectors: [["", "kendoTreeViewItem", ""]],
    inputs: {
      dataItem: "dataItem",
      index: "index",
      parentDataItem: "parentDataItem",
      parentIndex: "parentIndex",
      role: "role",
      loadOnDemand: "loadOnDemand",
      checkable: "checkable",
      selectable: "selectable",
      expandable: "expandable",
      isChecked: "isChecked",
      isDisabled: "isDisabled",
      isVisible: "isVisible",
      isExpanded: "isExpanded",
      isSelected: "isSelected"
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeViewItemDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewItem]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ExpandStateService
    }, {
      type: NavigationService2
    }, {
      type: SelectionService
    }, {
      type: TreeViewLookupService
    }, {
      type: Renderer2
    }, {
      type: IndexBuilderService
    }];
  }, {
    dataItem: [{
      type: Input
    }],
    index: [{
      type: Input
    }],
    parentDataItem: [{
      type: Input
    }],
    parentIndex: [{
      type: Input
    }],
    role: [{
      type: Input
    }],
    loadOnDemand: [{
      type: Input
    }],
    checkable: [{
      type: Input
    }],
    selectable: [{
      type: Input
    }],
    expandable: [{
      type: Input
    }],
    isChecked: [{
      type: Input
    }],
    isDisabled: [{
      type: Input
    }],
    isVisible: [{
      type: Input
    }],
    isExpanded: [{
      type: Input
    }],
    isSelected: [{
      type: Input
    }]
  });
})();
var TOP_ITEM = "k-treeview-top";
var MID_ITEM = "k-treeview-mid";
var BOT_ITEM = "k-treeview-bot";
var TreeViewGroupComponent = class _TreeViewGroupComponent {
  expandService;
  loadingService;
  indexBuilder;
  treeViewLookupService;
  navigationService;
  nodeChildrenService;
  dataChangeNotification;
  changeDetectorRef;
  localization;
  renderer;
  /**
   * @hidden
   */
  caretAltDownIcon = caretAltDownIcon;
  /**
   * @hidden
   */
  caretAltRightIcon = caretAltRightIcon;
  /**
   * @hidden
   */
  caretAltLeftIcon = caretAltLeftIcon;
  /**
   * @hidden
   */
  loadMoreTitle;
  kGroupClass = true;
  get role() {
    return this.parentIndex ? "group" : "tree";
  }
  checkboxes;
  expandIcons;
  disabled;
  selectable;
  touchActions;
  disableParentNodesOnly;
  loadOnDemand = true;
  trackBy;
  nodes;
  textField = "";
  parentDataItem;
  parentIndex;
  nodeTemplateRef;
  loadMoreButtonTemplateRef;
  loadMoreService;
  size = "medium";
  expandDisabledNodes;
  initialNodesLoaded = false;
  loadingMoreNodes = false;
  isItemExpandable = (node, index) => this.expandDisabledNodes || !this.isItemDisabled(node, index);
  getFontIcon(node, index) {
    return this.isExpanded(node, index) ? "caret-alt-down" : !this.localization.rtl ? "caret-alt-right" : "caret-alt-left";
  }
  getSvgIcon(node, index) {
    return this.isExpanded(node, index) ? caretAltDownIcon : !this.localization.rtl ? caretAltRightIcon : caretAltLeftIcon;
  }
  get moreNodesAvailable() {
    if (!isPresent6(this.loadMoreService) || this.data.length === 0) {
      return false;
    }
    return this.pageSize < this.totalNodesCount;
  }
  get pageSize() {
    if (!isPresent6(this.loadMoreService)) {
      return null;
    }
    return this.loadMoreService.getGroupSize(this.parentDataItem);
  }
  set pageSize(pageSize) {
    this.loadMoreService.setGroupSize(this.parentDataItem, pageSize);
  }
  get data() {
    if (isPresent6(this.pageSize)) {
      const normalizedSizeValue = this.pageSize > 0 ? this.pageSize : 0;
      return this._data.slice(0, normalizedSizeValue);
    }
    return this._data;
  }
  set data(data) {
    this._data = data;
    this.registerLoadedNodes(this.data);
  }
  get loadMoreButtonIndex() {
    if (!this.loadMoreService) {
      return null;
    }
    return this.nodeIndex(this.data.length);
  }
  /**
   * Represents the total number of nodes for the current level.
   */
  get totalNodesCount() {
    if (!this.loadMoreService) {
      return this.data.length;
    }
    return this.loadMoreService.getTotalNodesCount(this.parentDataItem, this._data.length);
  }
  _data = [];
  nodesSubscription;
  loadMoreNodesSubscription;
  singleRecordSubscriptions = new Subscription();
  localizationSubscriptions = new Subscription();
  constructor(expandService, loadingService, indexBuilder2, treeViewLookupService, navigationService, nodeChildrenService, dataChangeNotification, changeDetectorRef, localization, renderer) {
    this.expandService = expandService;
    this.loadingService = loadingService;
    this.indexBuilder = indexBuilder2;
    this.treeViewLookupService = treeViewLookupService;
    this.navigationService = navigationService;
    this.nodeChildrenService = nodeChildrenService;
    this.dataChangeNotification = dataChangeNotification;
    this.changeDetectorRef = changeDetectorRef;
    this.localization = localization;
    this.renderer = renderer;
  }
  isChecked = () => "none";
  isDisabled = () => false;
  hasCheckbox = () => true;
  isExpanded = () => false;
  isVisible = () => true;
  isSelected = () => false;
  children = () => of([]);
  hasChildren = () => false;
  get hasTemplate() {
    return isPresent6(this.nodeTemplateRef);
  }
  expandNode(index, dataItem, expand) {
    if (expand) {
      this.expandService.expand(index, dataItem);
    } else {
      this.expandService.collapse(index, dataItem);
    }
  }
  checkNode(index, checkBox) {
    this.navigationService.checkIndex(index);
    this.navigationService.activateIndex(index);
    if (checkBox?.input) {
      this.renderer.removeClass(checkBox.input.nativeElement, "k-focus");
    }
  }
  nodeIndex(index) {
    return this.indexBuilder.nodeIndex(index.toString(), this.parentIndex);
  }
  nodeText(dataItem) {
    const textField = isArray2(this.textField) ? this.textField[0] : this.textField;
    return getter(textField)(dataItem);
  }
  getCheckBoxState(item, index) {
    const state2 = this.isChecked(item, index);
    if (state2 === "indeterminate") {
      return state2;
    }
    return state2 === "checked";
  }
  getCheckboxAttributes(index) {
    return {
      "aria-hidden": "true",
      role: "none",
      "aria-labelledby": this.nodeIndex(index)
    };
  }
  ngOnDestroy() {
    if (isPresent6(this.nodesSubscription)) {
      this.nodesSubscription.unsubscribe();
    }
    if (isPresent6(this.loadMoreNodesSubscription)) {
      this.loadMoreNodesSubscription.unsubscribe();
    }
    this.singleRecordSubscriptions.unsubscribe();
    this.localizationSubscriptions.unsubscribe();
  }
  ngOnInit() {
    this.subscribeToNodesChange();
    this.singleRecordSubscriptions.add(this.dataChangeNotification.changes.subscribe(this.subscribeToNodesChange.bind(this)));
    this.singleRecordSubscriptions.add(this.navigationService.loadMore.pipe(filter((index) => index === this.loadMoreButtonIndex)).subscribe(this.loadMoreNodes.bind(this)));
    this.localizationSubscriptions.add(this.localization.changes.subscribe(this.l10nChange.bind(this)));
  }
  ngOnChanges(changes) {
    if (changes.parentIndex && this.loadOnDemand) {
      this.setNodeChildren(this.mapToTreeItem(this.data));
    }
    if (this.localization.get("loadMore")) {
      this.loadMoreTitle = this.localization.get("loadMore");
    }
  }
  l10nChange() {
    if (this.localization.get("loadMore")) {
      this.loadMoreTitle = this.localization.get("loadMore");
    }
    this.changeDetectorRef.markForCheck();
  }
  fetchChildren(node, index) {
    return this.children(node).pipe(catchError(() => {
      this.loadingService.notifyLoaded(index);
      return EMPTY;
    }), tap(() => this.loadingService.notifyLoaded(index)));
  }
  get nextFields() {
    if (isArray2(this.textField)) {
      return this.textField.length > 1 ? this.textField.slice(1) : this.textField;
    }
    return [this.textField];
  }
  loadMoreNodes() {
    if (isPresent6(this.loadMoreService.loadMoreNodes)) {
      this.fetchMoreNodes();
    } else {
      this.loadMoreLocalNodes();
    }
  }
  /**
   * @hidden
   */
  isItemDisabled(node, index) {
    return this.disabled && !this.disableParentNodesOnly || this.isDisabled(node, this.nodeIndex(index));
  }
  /**
   * @hidden
   */
  setItemClasses(dataLength, index) {
    if (dataLength === 1) {
      return this.parentIndex ? BOT_ITEM : `${TOP_ITEM} ${BOT_ITEM}`;
    }
    if (index === 0) {
      return TOP_ITEM;
    }
    if (index > 0 && index < dataLength - 1) {
      return MID_ITEM;
    }
    return index === this.totalNodesCount - 1 ? BOT_ITEM : MID_ITEM;
  }
  loadMoreLocalNodes() {
    const initialLoadMoreButtonIndex = this.loadMoreButtonIndex;
    this.pageSize += this.loadMoreService.getInitialPageSize(this.parentDataItem);
    this.registerLoadedNodes(this.data);
    this.changeDetectorRef.detectChanges();
    this.reselectItemAt(initialLoadMoreButtonIndex);
  }
  fetchMoreNodes() {
    if (this.loadingMoreNodes) {
      return;
    }
    this.loadingMoreNodes = true;
    if (isPresent6(this.loadMoreNodesSubscription)) {
      this.loadMoreNodesSubscription.unsubscribe();
    }
    this.loadMoreNodesSubscription = this.loadMoreService.loadMoreNodes({
      dataItem: this.parentDataItem,
      skip: this.data.length,
      take: this.loadMoreService.getInitialPageSize(this.parentDataItem)
    }).pipe(finalize(() => this.loadingMoreNodes = false)).subscribe((items) => {
      if (!(Array.isArray(items) && items.length > 0)) {
        return;
      }
      const initialLoadMoreButtonIndex = this.loadMoreButtonIndex;
      this.pageSize += items.length;
      this.data = this.data.concat(items);
      if (this.navigationService.isActive(initialLoadMoreButtonIndex)) {
        this.changeDetectorRef.detectChanges();
        this.reselectItemAt(initialLoadMoreButtonIndex);
      }
    });
  }
  setNodeChildren(children) {
    this.treeViewLookupService.registerChildren(this.parentIndex, children);
  }
  mapToTreeItem(data) {
    if (!this.parentIndex) {
      return [];
    }
    return data.map((dataItem, idx2) => ({
      dataItem,
      index: this.nodeIndex(idx2)
    }));
  }
  emitChildrenLoaded(children) {
    if (!this.parentIndex) {
      return;
    }
    const contentChildren = children.filter((item) => item.dataItem);
    this.nodeChildrenService.childrenLoaded({
      dataItem: this.parentDataItem,
      index: this.parentIndex
    }, contentChildren);
  }
  subscribeToNodesChange() {
    if (this.nodesSubscription) {
      this.nodesSubscription.unsubscribe();
    }
    this.nodesSubscription = this.nodes(this.parentDataItem, this.parentIndex).subscribe((data) => {
      this.data = data;
      this.initialNodesLoaded = true;
    });
  }
  reselectItemAt(index) {
    if (!isPresent6(index)) {
      return;
    }
    this.navigationService.deactivate();
    this.navigationService.activateIndex(index);
  }
  registerLoadedNodes(nodes = []) {
    const mappedChildren = this.mapToTreeItem(nodes);
    if (this.loadOnDemand) {
      this.setNodeChildren(mappedChildren);
    }
    this.emitChildrenLoaded(mappedChildren);
  }
  static ɵfac = function TreeViewGroupComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TreeViewGroupComponent)(ɵɵdirectiveInject(ExpandStateService), ɵɵdirectiveInject(LoadingNotificationService), ɵɵdirectiveInject(IndexBuilderService), ɵɵdirectiveInject(TreeViewLookupService), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(NodeChildrenService), ɵɵdirectiveInject(DataChangeNotificationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TreeViewGroupComponent,
    selectors: [["", "kendoTreeViewGroup", ""]],
    hostVars: 3,
    hostBindings: function TreeViewGroupComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.role);
        ɵɵclassProp("k-treeview-group", ctx.kGroupClass);
      }
    },
    inputs: {
      checkboxes: "checkboxes",
      expandIcons: "expandIcons",
      disabled: "disabled",
      selectable: "selectable",
      touchActions: "touchActions",
      disableParentNodesOnly: "disableParentNodesOnly",
      loadOnDemand: "loadOnDemand",
      trackBy: "trackBy",
      nodes: "nodes",
      textField: "textField",
      parentDataItem: "parentDataItem",
      parentIndex: "parentIndex",
      nodeTemplateRef: "nodeTemplateRef",
      loadMoreButtonTemplateRef: "loadMoreButtonTemplateRef",
      loadMoreService: "loadMoreService",
      size: "size",
      expandDisabledNodes: "expandDisabledNodes",
      isChecked: "isChecked",
      isDisabled: "isDisabled",
      hasCheckbox: "hasCheckbox",
      isExpanded: "isExpanded",
      isVisible: "isVisible",
      isSelected: "isSelected",
      children: "children",
      hasChildren: "hasChildren"
    },
    features: [ɵɵNgOnChangesFeature],
    attrs: _c05,
    decls: 2,
    vars: 3,
    consts: [["checkbox", ""], ["class", "k-treeview-item", "kendoTreeViewItem", "", 3, "k-hidden", "dataItem", "index", "parentDataItem", "parentIndex", "loadOnDemand", "checkable", "isChecked", "isDisabled", "isVisible", "expandable", "isExpanded", "selectable", "isSelected", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "k-treeview-item", "kendoTreeViewItem", "", "role", "button", 3, "k-treeview-load-more-checkboxes-container", "selectable", "checkable", "expandable", "index", "parentDataItem", "parentIndex", 4, "ngIf"], ["kendoTreeViewItem", "", 1, "k-treeview-item", 3, "dataItem", "index", "parentDataItem", "parentIndex", "loadOnDemand", "checkable", "isChecked", "isDisabled", "isVisible", "expandable", "isExpanded", "selectable", "isSelected"], [3, "ngClass"], ["class", "k-treeview-toggle", 3, "k-disabled", "kendoTreeViewLoading", "click", 4, "ngIf"], [3, "disabled", "size", "checkedState", "tabindex", "inputAttributes", "checkedStateChange", 4, "ngIf"], ["kendoTreeViewItemContent", "", 1, "k-treeview-leaf", 3, "id", "dataItem", "index", "initialSelection", "isSelected"], [1, "k-treeview-leaf-text"], [3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"], ["kendoTreeViewGroup", "", "role", "group", 3, "size", "nodes", "loadOnDemand", "checkboxes", "expandIcons", "selectable", "touchActions", "children", "hasChildren", "isChecked", "isDisabled", "hasCheckbox", "disabled", "expandDisabledNodes", "isExpanded", "isSelected", "isVisible", "nodeTemplateRef", "loadMoreButtonTemplateRef", "parentIndex", "parentDataItem", "textField", "loadMoreService", "trackBy", "disableParentNodesOnly", 4, "ngIf"], [1, "k-treeview-toggle", 3, "click", "kendoTreeViewLoading"], [3, "name", "svgIcon"], [3, "checkedStateChange", "disabled", "size", "checkedState", "tabindex", "inputAttributes"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["kendoTreeViewGroup", "", "role", "group", 3, "size", "nodes", "loadOnDemand", "checkboxes", "expandIcons", "selectable", "touchActions", "children", "hasChildren", "isChecked", "isDisabled", "hasCheckbox", "disabled", "expandDisabledNodes", "isExpanded", "isSelected", "isVisible", "nodeTemplateRef", "loadMoreButtonTemplateRef", "parentIndex", "parentDataItem", "textField", "loadMoreService", "trackBy", "disableParentNodesOnly"], ["kendoTreeViewItem", "", "role", "button", 1, "k-treeview-item", 3, "selectable", "checkable", "expandable", "index", "parentDataItem", "parentIndex"], [1, "k-treeview-bot"], ["class", "k-icon k-i-loading", 4, "ngIf"], ["kendoTreeViewItemContent", "", 1, "k-treeview-leaf", "k-treeview-load-more-button", 3, "index"], [4, "ngIf"], [1, "k-icon", "k-i-loading"]],
    template: function TreeViewGroupComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, TreeViewGroupComponent_li_0_Template, 10, 33, "li", 1)(1, TreeViewGroupComponent_li_1_Template, 7, 14, "li", 2);
      }
      if (rf & 2) {
        ɵɵproperty("ngForOf", ctx.data)("ngForTrackBy", ctx.trackBy);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.initialNodesLoaded && ctx.moreNodesAvailable);
      }
    },
    dependencies: [_TreeViewGroupComponent, NgForOf, TreeViewItemDirective, NgClass, NgIf, LoadingIndicatorDirective, IconWrapperComponent, CheckBoxComponent, TreeViewItemContentDirective, NgSwitch, NgSwitchCase, NgTemplateOutlet, NgSwitchDefault],
    encapsulation: 2,
    data: {
      animation: [trigger("toggle", [transition("void => *", [style({
        height: 0
      }), animate("0.1s ease-in", style({
        height: "*"
      }))]), transition("* => void", [style({
        height: "*"
      }), animate("0.1s ease-in", style({
        height: 0
      }))])])]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeViewGroupComponent, [{
    type: Component,
    args: [{
      animations: [trigger("toggle", [transition("void => *", [style({
        height: 0
      }), animate("0.1s ease-in", style({
        height: "*"
      }))]), transition("* => void", [style({
        height: "*"
      }), animate("0.1s ease-in", style({
        height: 0
      }))])])],
      // eslint-disable-next-line
      selector: "[kendoTreeViewGroup]",
      template: `
        <li
            *ngFor="let node of data; let index = index; trackBy: trackBy"
            class="k-treeview-item"
            [class.k-hidden]="!isVisible(node, nodeIndex(index))"
            kendoTreeViewItem
            [attr.aria-setsize]="totalNodesCount"
            [dataItem]="node"
            [index]="nodeIndex(index)"
            [parentDataItem]="parentDataItem"
            [parentIndex]="parentIndex"
            [loadOnDemand]="loadOnDemand"
            [checkable]="checkboxes"
            [isChecked]="isChecked(node, nodeIndex(index))"
            [isDisabled]="isItemDisabled(node, index)"
            [isVisible]="isVisible(node, nodeIndex(index))"
            [expandable]="expandIcons && hasChildren(node)"
            [isExpanded]="isExpanded(node, nodeIndex(index))"
            [selectable]="selectable"
            [isSelected]="isSelected(node, nodeIndex(index))"
            [attr.data-treeindex]="nodeIndex(index)"
        >
            <div [ngClass]="setItemClasses(data.length, index)">
                <span
                    [class.k-disabled]="!isItemExpandable(node, index)"
                    class="k-treeview-toggle"
                    [kendoTreeViewLoading]="nodeIndex(index)"
                    (click)="expandNode(nodeIndex(index), node, !isExpanded(node, nodeIndex(index)))"
                    *ngIf="expandIcons && hasChildren(node)"
                >
                    <kendo-icon-wrapper
                        [name]="getFontIcon(node, nodeIndex(index))"
                        [svgIcon]="getSvgIcon(node, nodeIndex(index))">
                    </kendo-icon-wrapper>
                </span>
                <kendo-checkbox
                    #checkbox
                    *ngIf="checkboxes && hasCheckbox(node, nodeIndex(index))"
                    [disabled]="isItemDisabled(node, index)"
                    [size]="size"
                    [checkedState]="getCheckBoxState(node, nodeIndex(index))"
                    (checkedStateChange)="checkNode(nodeIndex(index), checkbox)"
                    [tabindex]="-1"
                    [inputAttributes]="getCheckboxAttributes(index)"
                ></kendo-checkbox>
                <span kendoTreeViewItemContent
                    [id]="nodeIndex(index)"
                    [attr.data-treeindex]="nodeIndex(index)"
                    [dataItem]="node"
                    [index]="nodeIndex(index)"
                    [initialSelection]="isSelected(node, nodeIndex(index))"
                    [isSelected]="isSelected"
                    class="k-treeview-leaf"
                    [style.touch-action]="touchActions ? '' : 'none'"
                    [class.k-disabled]="isItemDisabled(node, index)"
                >
                    <span class="k-treeview-leaf-text">
                        <ng-container [ngSwitch]="hasTemplate">
                            <ng-container *ngSwitchCase="true">
                                <ng-template
                                    [ngTemplateOutlet]="nodeTemplateRef"
                                    [ngTemplateOutletContext]="{
                                        $implicit: node,
                                        index: nodeIndex(index)
                                    }"
                                >
                                </ng-template>
                            </ng-container>
                            <ng-container *ngSwitchDefault>
                                {{nodeText(node)}}
                            </ng-container>
                        </ng-container>
                    </span>
                </span>
            </div>
            <ul
                *ngIf="isExpanded(node, nodeIndex(index)) && hasChildren(node)"
                kendoTreeViewGroup
                role="group"
                [size]="size"
                [nodes]="fetchChildren"
                [loadOnDemand]="loadOnDemand"
                [checkboxes]="checkboxes"
                [expandIcons]="expandIcons"
                [selectable]="selectable"
                [touchActions]="touchActions"
                [children]="children"
                [hasChildren]="hasChildren"
                [isChecked]="isChecked"
                [isDisabled]="isDisabled"
                [hasCheckbox]="hasCheckbox"
                [disabled]="isItemDisabled(node, index)"
                [expandDisabledNodes]="expandDisabledNodes"
                [isExpanded]="isExpanded"
                [isSelected]="isSelected"
                [isVisible]="isVisible"
                [nodeTemplateRef]="nodeTemplateRef"
                [loadMoreButtonTemplateRef]="loadMoreButtonTemplateRef"
                [parentIndex]="nodeIndex(index)"
                [parentDataItem]="node"
                [textField]="nextFields"
                [loadMoreService]="loadMoreService"
                [@toggle]="true"
                [trackBy]="trackBy"
                [disableParentNodesOnly]="disableParentNodesOnly"
            >
            </ul>
        </li>
        <li
            *ngIf="initialNodesLoaded && moreNodesAvailable"
            class="k-treeview-item"
            [class.k-treeview-load-more-checkboxes-container]="checkboxes"
            kendoTreeViewItem
            role="button"
            [selectable]="false"
            [checkable]="false"
            [expandable]="false"
            [index]="loadMoreButtonIndex"
            [parentDataItem]="parentDataItem"
            [parentIndex]="parentIndex"
            [attr.data-treeindex]="loadMoreButtonIndex"
        >
            <div class="k-treeview-bot">
                <span
                    *ngIf="loadingMoreNodes"
                    class="k-icon k-i-loading"
                >
                </span>
                <span
                    class="k-treeview-leaf k-treeview-load-more-button"
                    [attr.data-treeindex]="loadMoreButtonIndex"
                    kendoTreeViewItemContent
                    [index]="loadMoreButtonIndex"
                >
                    <span class="k-treeview-leaf-text">
                        <ng-template
                            *ngIf="loadMoreButtonTemplateRef"
                            [ngTemplateOutlet]="loadMoreButtonTemplateRef"
                            [ngTemplateOutletContext]="{
                                index: loadMoreButtonIndex
                            }"
                        >
                        </ng-template>
                        <ng-container *ngIf="!loadMoreButtonTemplateRef">
                            {{ loadMoreTitle }}
                        </ng-container>
                    </span>
                </span>
            </div>
        </li>
    `,
      standalone: true,
      imports: [NgForOf, TreeViewItemDirective, NgClass, NgIf, LoadingIndicatorDirective, IconWrapperComponent, CheckBoxComponent, TreeViewItemContentDirective, NgSwitch, NgSwitchCase, NgTemplateOutlet, NgSwitchDefault]
    }]
  }], function() {
    return [{
      type: ExpandStateService
    }, {
      type: LoadingNotificationService
    }, {
      type: IndexBuilderService
    }, {
      type: TreeViewLookupService
    }, {
      type: NavigationService2
    }, {
      type: NodeChildrenService
    }, {
      type: DataChangeNotificationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: LocalizationService
    }, {
      type: Renderer2
    }];
  }, {
    kGroupClass: [{
      type: HostBinding,
      args: ["class.k-treeview-group"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    checkboxes: [{
      type: Input
    }],
    expandIcons: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    selectable: [{
      type: Input
    }],
    touchActions: [{
      type: Input
    }],
    disableParentNodesOnly: [{
      type: Input
    }],
    loadOnDemand: [{
      type: Input
    }],
    trackBy: [{
      type: Input
    }],
    nodes: [{
      type: Input
    }],
    textField: [{
      type: Input
    }],
    parentDataItem: [{
      type: Input
    }],
    parentIndex: [{
      type: Input
    }],
    nodeTemplateRef: [{
      type: Input
    }],
    loadMoreButtonTemplateRef: [{
      type: Input
    }],
    loadMoreService: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    expandDisabledNodes: [{
      type: Input
    }],
    isChecked: [{
      type: Input
    }],
    isDisabled: [{
      type: Input
    }],
    hasCheckbox: [{
      type: Input
    }],
    isExpanded: [{
      type: Input
    }],
    isVisible: [{
      type: Input
    }],
    isSelected: [{
      type: Input
    }],
    children: [{
      type: Input
    }],
    hasChildren: [{
      type: Input
    }]
  });
})();
var TreeViewMessages = class _TreeViewMessages extends ComponentMessages {
  /**
   * The text of the `Load More` button title.
   */
  loadMore;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵTreeViewMessages_BaseFactory;
    return function TreeViewMessages_Factory(__ngFactoryType__) {
      return (ɵTreeViewMessages_BaseFactory || (ɵTreeViewMessages_BaseFactory = ɵɵgetInheritedFactory(_TreeViewMessages)))(__ngFactoryType__ || _TreeViewMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _TreeViewMessages,
    selectors: [["kendo-treeview-messages-base"]],
    inputs: {
      loadMore: "loadMore"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeViewMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-treeview-messages-base"
    }]
  }], null, {
    loadMore: [{
      type: Input
    }]
  });
})();
var LocalizedMessagesDirective2 = class _LocalizedMessagesDirective extends TreeViewMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedMessagesDirective,
    selectors: [["", "kendoTreeViewLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: TreeViewMessages,
      useExisting: forwardRef(() => _LocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedMessagesDirective2, [{
    type: Directive,
    args: [{
      providers: [{
        provide: TreeViewMessages,
        useExisting: forwardRef(() => LocalizedMessagesDirective2)
      }],
      selector: "[kendoTreeViewLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var nextId2 = 0;
var LOAD_MORE_DOC_LINK$1 = "https://www.telerik.com/kendo-angular-ui/components/treeview/load-more-button/";
var providers = [ExpandStateService, IndexBuilderService, TreeViewLookupService, LoadingNotificationService, NodeChildrenService, NavigationService2, SelectionService, DataChangeNotificationService, LocalizationService, {
  provide: L10N_PREFIX,
  useValue: "kendo.treeview"
}, {
  provide: DataBoundComponent,
  useExisting: forwardRef(() => TreeViewComponent)
}, {
  provide: ExpandableComponent,
  useExisting: forwardRef(() => TreeViewComponent)
}];
var TreeViewComponent = class _TreeViewComponent {
  element;
  changeDetectorRef;
  expandService;
  navigationService;
  nodeChildrenService;
  selectionService;
  treeViewLookupService;
  ngZone;
  renderer;
  dataChangeNotification;
  localization;
  /**
   * @hidden
   */
  searchIcon = searchIcon;
  classNames = true;
  /** @hidden */
  get direction() {
    return this.localization.rtl ? "rtl" : "ltr";
  }
  /**
   * @hidden
   */
  assetsContainer;
  /**
   * @hidden
   */
  searchbox;
  /**
   * The hint which is displayed when the component is empty.
   */
  filterInputPlaceholder = "";
  /**
   * Determines whether to allow expanding disabled nodes.
   * @default false
   */
  expandDisabledNodes;
  /**
   * Determines whether the content animation is enabled.
   */
  set animate(value) {
    this._animate = value;
  }
  get animate() {
    return !this._animate;
  }
  /** @hidden */
  fetchNodes = () => this.data;
  /**
   * Fires when the children of the expanded node are loaded.
   */
  childrenLoaded = new EventEmitter();
  /**
   * Fires when the user blurs the component.
   */
  onBlur = new EventEmitter();
  /**
   * Fires when the user focuses the component.
   */
  onFocus = new EventEmitter();
  /**
   * Fires when the user expands a TreeView node.
   */
  expand = new EventEmitter();
  /**
   * Fires when the user collapses a TreeView node.
   */
  collapse = new EventEmitter();
  /**
   * Fires just before the dragging of the node starts ([see example]({% slug draganddrop_treeview %}#toc-setup)). This event is preventable.
   * If you prevent the event default, no drag hint will be created and the subsequent drag-related events will not be fired.
   */
  nodeDragStart = new EventEmitter();
  /**
   * Fires when an item is being dragged ([see example]({% slug draganddrop_treeview %}#toc-setup)).
   */
  nodeDrag = new EventEmitter();
  /**
   * Emits when the built-in filtering mechanism in the data-binding directives updates the node's visibility.
   * Used for the built-in auto-expand functionalities of the component and available for custom implementations.
   */
  filterStateChange = new EventEmitter();
  /**
   * Fires on the target TreeView when a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
   * This event is preventable. If you prevent the event default (`event.preventDefualt()`) or invalidate its state (`event.setValid(false)`),
   * the `addItem` and `removeItem` events will not be triggered.
   *
   * Both operations cancel the default drop operation, but the indication to the user is different. `event.setValid(false)` indicates that the operation was
   * unsuccessful by animating the drag clue to its original position. `event.preventDefault()` simply removes the clue, as if it has been dropped successfully.
   * As a general rule, use `preventDefault` to manually handle the add and remove operations, and `setValid(false)` to indicate the operation was unsuccessful.
   */
  nodeDrop = new EventEmitter();
  /**
   * Fires on the source TreeView after the dragged item has been dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
   */
  nodeDragEnd = new EventEmitter();
  /**
   * Fires after a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
   * Called on the TreeView where the item is dropped.
   */
  addItem = new EventEmitter();
  /**
   * Fires after a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
   * Called on the TreeView from where the item is dragged.
   */
  removeItem = new EventEmitter();
  /**
   * Fires when the user selects a TreeView node checkbox
   * ([see example]({% slug checkboxes_treeview %}#toc-modifying-the-checked-state)).
   */
  checkedChange = new EventEmitter();
  /**
   * Fires when the user selects a TreeView node
   * ([see example]({% slug selection_treeview %}#toc-modifying-the-selection)).
   */
  selectionChange = new EventEmitter();
  /**
   * Fires when the value of the built-in filter input element changes.
   */
  filterChange = new EventEmitter();
  /**
   * Fires when the user clicks a TreeView node.
   */
  nodeClick = new EventEmitter();
  /**
   * Fires when the user double clicks a TreeView node.
   */
  nodeDblClick = new EventEmitter();
  /**
   * @hidden
   *
   * Queries the template for a node template declaration.
   * Ignored if a `[nodeTemplate]` value is explicitly provided.
   */
  nodeTemplateQuery;
  /**
   * @hidden
   *
   * Defines the template for each node.
   * Takes precedence over nested templates in the TreeView tag.
   */
  set nodeTemplateRef(template2) {
    this._nodeTemplateRef = template2;
  }
  get nodeTemplateRef() {
    return this._nodeTemplateRef || this.nodeTemplateQuery;
  }
  /**
   * @hidden
   *
   * Queries the template for a load-more button template declaration.
   * Ignored if a `[loadMoreButtonTemplate]` value is explicitly provided.
   */
  loadMoreButtonTemplateQuery;
  /**
   * @hidden
   *
   * Defines the template for each load-more button.
   * Takes precedence over nested templates in the TreeView tag.
   */
  set loadMoreButtonTemplateRef(template2) {
    this._loadMoreButtonTemplateRef = template2;
  }
  get loadMoreButtonTemplateRef() {
    return this._loadMoreButtonTemplateRef || this.loadMoreButtonTemplateQuery;
  }
  /**
   * A function that defines how to track node changes.
   * By default, the TreeView tracks the nodes by data item object reference.
   *
   * @example
   * ```ts
   *  @Component({
   *      selector: 'my-app',
   *      template: `
   *          <kendo-treeview
   *              [nodes]="data"
   *              textField="text"
   *              [trackBy]="trackBy"
   *          >
   *          </kendo-treeview>
   *      `
   *  })
   *  export class AppComponent {
   *      public data: any[] = [
   *          { text: "Furniture" },
   *          { text: "Decor" }
   *      ];
   *
   *      public trackBy(index: number, item: any): any {
   *          return item.text;
   *      }
   *  }
   * ```
   */
  trackBy = trackBy;
  /**
   * The nodes which will be displayed by the TreeView
   * ([see example]({% slug databinding_treeview %})).
   */
  set nodes(value) {
    this.data.next(value || []);
    this.dataChangeNotification.notify();
  }
  get nodes() {
    return this.data.value;
  }
  /**
   * The fields of the data item that provide the text content of the nodes
   * ([see example]({% slug databinding_treeview %})). If the `textField` input is set
   * to an array, each hierarchical level uses the field that corresponds to the same
   * index in the array, or the last item in the array.
   */
  textField;
  /**
   * A function which determines if a specific node has child nodes
   * ([see example]({% slug databinding_treeview %})).
   */
  get hasChildren() {
    return this._hasChildren || hasChildren;
  }
  set hasChildren(callback) {
    this._hasChildren = callback;
    this.expandIcons = Boolean(this._isExpanded && this._hasChildren);
  }
  /**
   * A function which determines if a specific node is checked
   * ([see example]({% slug checkboxes_treeview %}#toc-modifying-the-checked-state)).
   */
  get isChecked() {
    return this._isChecked || isChecked;
  }
  set isChecked(callback) {
    this._isChecked = callback;
    this.checkboxes = Boolean(this._isChecked);
  }
  /**
   * A function which determines if a specific node is disabled.
   */
  isDisabled = isDisabled;
  /**
   * A function which determines if a specific node has a checkbox.
   *
   * > If there is no checkbox for a node, then this node is not checkable and is excluded from any built-in check functionality.
   */
  hasCheckbox = hasCheckbox;
  /**
   * A function which determines if a specific node is expanded.
   */
  get isExpanded() {
    return this._isExpanded || isExpanded;
  }
  set isExpanded(callback) {
    this._isExpanded = callback;
    this.expandIcons = Boolean(this._isExpanded && this._hasChildren);
  }
  /**
   * A function which determines if a specific node is selected
   * ([see example]({% slug selection_treeview %}#toc-modifying-the-selection)).
   */
  get isSelected() {
    return this._isSelected || isSelected;
  }
  set isSelected(callback) {
    this._isSelected = callback;
    this.selectable = Boolean(this._isSelected);
  }
  /**
   * A callback which determines whether a TreeView node should be rendered as hidden. The utility .k-hidden class is used to hide the nodes.
   * Useful for custom filtering implementations.
   */
  isVisible = isVisible2;
  /**
   * Determines whether the TreeView keyboard navigable is enabled.
   */
  navigable = true;
  /**
   * A function which provides the child nodes for a given parent node
   * ([see example]({% slug databinding_treeview %})).
   */
  children = () => of([]);
  /**
   * Indicates whether the child nodes will be fetched on node expand or will be initially prefetched.
   * @default true
   */
  loadOnDemand = true;
  /**
   * Renders the built-in input element for filtering the TreeView.
   * If set to `true`, the component emits the `filterChange` event, which can be used to [filter the TreeView manually]({% slug filtering_treeview %}#toc-manual-filtering).
   * A built-in filtering implementation is available to use with the [`kendoTreeViewHierarchyBinding`]({% slug api_treeview_hierarchybindingdirective %}) and [`kendoTreeViewFlatDataBinding`]({% slug api_treeview_flatdatabindingdirective %}) directives.
   */
  filterable = false;
  /**
   * Sets an initial value of the built-in input element used for filtering.
   */
  filter = "";
  /**
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set size(size) {
    const newSize = size ? size : "medium";
    if (this.size !== "none") {
      this.renderer.removeClass(this.element.nativeElement, getSizeClass("treeview", this.size));
    }
    this.renderer.addClass(this.element.nativeElement, getSizeClass("treeview", newSize));
    this._size = size;
  }
  get size() {
    return this._size;
  }
  get isActive() {
    return this.navigationService.isTreeViewActive;
  }
  /**
   * @hidden
   */
  get treeviewId() {
    return `treeview_${this._nextId}`;
  }
  /**
   * Indicates whether only parent nodes should be disabled or their child nodes as well
   * @default false
   */
  disableParentNodesOnly = false;
  /**
   * @hidden
   */
  loadMoreService;
  /**
   * @hidden
   */
  editService;
  checkboxes = false;
  expandIcons = false;
  selectable = false;
  touchActions = true;
  data = new BehaviorSubject([]);
  _animate = true;
  _isChecked;
  _isExpanded;
  _isSelected;
  _hasChildren;
  _nodeTemplateRef;
  _loadMoreButtonTemplateRef;
  _size = "medium";
  subscriptions = new Subscription();
  domSubscriptions = [];
  _nextId = nextId2;
  constructor(element, changeDetectorRef, expandService, navigationService, nodeChildrenService, selectionService, treeViewLookupService, ngZone, renderer, dataChangeNotification, localization) {
    this.element = element;
    this.changeDetectorRef = changeDetectorRef;
    this.expandService = expandService;
    this.navigationService = navigationService;
    this.nodeChildrenService = nodeChildrenService;
    this.selectionService = selectionService;
    this.treeViewLookupService = treeViewLookupService;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.dataChangeNotification = dataChangeNotification;
    this.localization = localization;
    validatePackage(packageMetadata6);
    nextId2++;
  }
  ngOnChanges(changes) {
    this.navigationService.navigable = Boolean(this.navigable);
    if (anyChanged(["nodes", "children", "hasChildren", "loadOnDemand"], changes, false) && !this.loadOnDemand) {
      this.preloadChildNodes();
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.domSubscriptions.forEach((subscription) => subscription());
  }
  ngOnInit() {
    this.subscriptions.add(this.nodeChildrenService.changes.subscribe((x) => this.childrenLoaded.emit(x)));
    this.subscriptions.add(this.expandService.changes.subscribe(({
      index,
      dataItem,
      expand
    }) => expand ? this.expand.emit({
      index,
      dataItem
    }) : this.collapse.emit({
      index,
      dataItem
    })));
    this.subscriptions.add(this.navigationService.checks.subscribe((x) => this.checkedChange.emit(this.treeViewLookupService.itemLookup(x))));
    this.subscriptions.add(this.selectionService.changes.subscribe((x) => {
      if (hasObservers(this.selectionChange)) {
        this.ngZone.run(() => {
          this.selectionChange.emit(x);
        });
      }
    }));
    if (this.element) {
      this.ngZone.runOutsideAngular(() => {
        this.attachDomHandlers();
      });
    }
    if (this.size) {
      this.renderer.addClass(this.element.nativeElement, getSizeClass("treeview", this.size));
    }
  }
  ngAfterViewInit() {
    if (this.searchbox) {
      this.renderer.setAttribute(this.searchbox.input.nativeElement, "role", "searchbox");
      this.renderer.setAttribute(this.searchbox.input.nativeElement, "aria-controls", this.treeviewId);
      this.renderer.setAttribute(this.searchbox.input.nativeElement, "aria-label", "searchbar");
    }
  }
  /**
   * Blurs the focused TreeView item.
   */
  blur() {
    if (!isDocumentAvailable()) {
      return;
    }
    const target = focusableNode(this.element);
    if (document.activeElement === target) {
      target.blur();
    }
  }
  /**
   * Focuses the first focusable item in the TreeView component if no hierarchical index is provided.
   *
   * @example
   * ```ts
   * import { Component } from '@angular/core';
   *
   *  @Component({
   *      selector: 'my-app',
   *      template: `
   *      <button (click)="treeview.focus('1')">Focuses the second node</button>
   *      <kendo-treeview
   *          #treeview
   *          [nodes]="data"
   *          textField="text"
   *      >
   *      </kendo-treeview>
   *  `
   *  })
   *  export class AppComponent {
   *      public data: any[] = [
   *          { text: "Furniture" },
   *          { text: "Decor" }
   *      ];
   *  }
   * ```
   */
  focus(index) {
    const focusIndex = index || nodeIndex(this.navigationService.focusableItem);
    this.navigationService.activateIndex(focusIndex);
    const target = focusableNode(this.element);
    if (target) {
      target.focus();
    }
  }
  /**
   * Based on the specified index, returns the TreeItemLookup node.
   *
   * @param index - The index of the node.
   * @returns {TreeItemLookup} - The item that was searched (looked up).
   */
  itemLookup(index) {
    return this.treeViewLookupService.itemLookup(index);
  }
  /**
   * Triggers the [`children`]({% slug api_treeview_treeviewcomponent %}#toc-children) function for every expanded node,
   * causing all rendered child nodes to be fetched again.
   */
  rebindChildren() {
    this.dataChangeNotification.notify();
  }
  /**
   * Triggers the `expand` event for the provided node and displays it's loading indicator.
   */
  expandNode(item, index) {
    this.expandService.expand(index, item);
  }
  /**
   * Triggers the `collapse` event for the provided node.
   */
  collapseNode(item, index) {
    this.expandService.collapse(index, item);
  }
  /**
   * Gets the current page size of the checked data item children collection
   * ([see example]({% slug loadmorebutton_treeview %}#toc-managing-page-sizes)).
   *
   * > Since the root nodes collection is not associated with any parent data item, pass `null` as `dataItem` param to get its page size.
   *
   * @param dataItem {any} - The parent data item of the targeted collection.
   * @returns {number} - The page size of the checked data item children collection.
   */
  getNodePageSize(dataItem) {
    this.verifyLoadMoreService();
    return this.loadMoreService.getGroupSize(dataItem);
  }
  /**
   * Sets the page size of the targeted data item children collection
   * ([see example]({% slug loadmorebutton_treeview %}#toc-managing-page-sizes)).
   *
   * > Since the root nodes collection is not associated with any parent data item, pass `null` as `dataItem` param to target its page size.
   *
   * @param dataItem {any} - The parent data item of the targeted collection.
   * @param pageSize {number} - The new page size.
   */
  setNodePageSize(dataItem, pageSize) {
    this.verifyLoadMoreService();
    this.loadMoreService.setGroupSize(dataItem, pageSize);
  }
  /**
   * @hidden
   *
   * Clears the current TreeViewLookupService node map and re-registers all nodes anew.
   * Child nodes are acquired through the provided `children` callback.
   */
  preloadChildNodes() {
    this.treeViewLookupService.reset();
    this.registerLookupItems(this.nodes);
  }
  attachDomHandlers() {
    const element = this.element.nativeElement;
    this.clickHandler = this.clickHandler.bind(this);
    this.domSubscriptions.push(this.renderer.listen(element, "contextmenu", this.clickHandler), this.renderer.listen(element, "click", this.clickHandler), this.renderer.listen(element, "dblclick", this.clickHandler), this.renderer.listen(element, "focusin", this.focusHandler.bind(this)), this.renderer.listen(element, "focusout", this.blurHandler.bind(this)), this.renderer.listen(element, "keydown", this.keydownHandler.bind(this)));
  }
  focusHandler(e) {
    let focusItem;
    if (match(e.target, ".k-treeview-item")) {
      focusItem = e.target;
    } else if (!isFocusable3(e.target)) {
      focusItem = closestNode(e.target);
    }
    if (focusItem) {
      const nodeIndex3 = nodeId(e.target);
      if (this.navigationService.isDisabled(nodeIndex3)) {
        return;
      }
      this.navigationService.activateIndex(nodeIndex3);
      if (!this.isActive && hasObservers(this.onFocus)) {
        this.ngZone.run(() => {
          this.onFocus.emit();
        });
      }
      this.navigationService.isTreeViewActive = true;
    }
  }
  blurHandler(e) {
    if (this.isActive && match(e.target, ".k-treeview-item") && (!e.relatedTarget || !match(e.relatedTarget, ".k-treeview-item") || !hasParent(e.relatedTarget, this.element.nativeElement))) {
      this.navigationService.deactivate();
      this.navigationService.isTreeViewActive = false;
      if (hasObservers(this.onBlur)) {
        this.ngZone.run(() => {
          this.onBlur.emit();
        });
      }
    }
  }
  clickHandler(e) {
    const target = e.target;
    if (e.type === "contextmenu" && !hasObservers(this.nodeClick) || e.type === "click" && !hasObservers(this.nodeClick) && !hasObservers(this.selectionChange) && !isLoadMoreButton(target) || e.type === "dblclick" && !hasObservers(this.nodeDblClick) || isFocusable3(target) || !isContent(target) && !isLoadMoreButton(target) || !hasParent(target, this.element.nativeElement)) {
      return;
    }
    const index = nodeId(closestNode(target));
    if (!index || this.navigationService.isDisabled(index)) {
      return;
    }
    this.ngZone.run(() => {
      const lookup = this.treeViewLookupService.itemLookup(index);
      if (e.type === "click") {
        const loadMoreButton = this.navigationService.model.findNode(index).loadMoreButton;
        if (loadMoreButton) {
          this.navigationService.notifyLoadMore(index);
          return;
        } else {
          this.navigationService.selectIndex(index);
        }
      }
      const emitter = e.type === "dblclick" ? this.nodeDblClick : this.nodeClick;
      emitter.emit({
        item: lookup.item,
        originalEvent: e,
        type: e.type
      });
    });
  }
  keydownHandler(e) {
    if (this.isActive && this.navigable) {
      this.ngZone.run(() => {
        this.navigationService.move(e);
      });
    }
  }
  verifyLoadMoreService() {
    if (isDevMode() && !isPresent6(this.loadMoreService)) {
      throw new Error(`To use the TreeView paging functionality, you need to assign the \`kendoTreeViewLoadMore\` directive. See ${LOAD_MORE_DOC_LINK$1}.`);
    }
  }
  registerLookupItems(data, parentItem = null) {
    if (!isPresent6(data) || data.length === 0) {
      return;
    }
    const parentIndex = nodeIndex(parentItem);
    const treeItems = data.map((node, index) => buildTreeItem(node, index, parentIndex));
    if (isPresent6(parentItem)) {
      this.treeViewLookupService.registerChildren(parentIndex, treeItems);
    }
    treeItems.forEach((item) => {
      this.treeViewLookupService.registerItem(item, parentItem);
      if (this.hasChildren(item.dataItem)) {
        this.children(item.dataItem).subscribe((children) => this.registerLookupItems(children, item));
      }
    });
  }
  static ɵfac = function TreeViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TreeViewComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ExpandStateService), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(NodeChildrenService), ɵɵdirectiveInject(SelectionService), ɵɵdirectiveInject(TreeViewLookupService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DataChangeNotificationService), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TreeViewComponent,
    selectors: [["kendo-treeview"]],
    contentQueries: function TreeViewComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, NodeTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, LoadMoreButtonTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.nodeTemplateQuery = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.loadMoreButtonTemplateQuery = _t.first);
      }
    },
    viewQuery: function TreeViewComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c310, 7, ViewContainerRef);
        ɵɵviewQuery(_c410, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.assetsContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.searchbox = _t.first);
      }
    },
    hostVars: 4,
    hostBindings: function TreeViewComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵsyntheticHostProperty("@.disabled", ctx.animate);
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-treeview", ctx.classNames);
      }
    },
    inputs: {
      filterInputPlaceholder: "filterInputPlaceholder",
      expandDisabledNodes: "expandDisabledNodes",
      animate: "animate",
      nodeTemplateRef: [0, "nodeTemplate", "nodeTemplateRef"],
      loadMoreButtonTemplateRef: [0, "loadMoreButtonTemplate", "loadMoreButtonTemplateRef"],
      trackBy: "trackBy",
      nodes: "nodes",
      textField: "textField",
      hasChildren: "hasChildren",
      isChecked: "isChecked",
      isDisabled: "isDisabled",
      hasCheckbox: "hasCheckbox",
      isExpanded: "isExpanded",
      isSelected: "isSelected",
      isVisible: "isVisible",
      navigable: "navigable",
      children: "children",
      loadOnDemand: "loadOnDemand",
      filterable: "filterable",
      filter: "filter",
      size: "size",
      disableParentNodesOnly: "disableParentNodesOnly"
    },
    outputs: {
      childrenLoaded: "childrenLoaded",
      onBlur: "blur",
      onFocus: "focus",
      expand: "expand",
      collapse: "collapse",
      nodeDragStart: "nodeDragStart",
      nodeDrag: "nodeDrag",
      filterStateChange: "filterStateChange",
      nodeDrop: "nodeDrop",
      nodeDragEnd: "nodeDragEnd",
      addItem: "addItem",
      removeItem: "removeItem",
      checkedChange: "checkedChange",
      selectionChange: "selectionChange",
      filterChange: "filterChange",
      nodeClick: "nodeClick",
      nodeDblClick: "nodeDblClick"
    },
    exportAs: ["kendoTreeView"],
    features: [ɵɵProvidersFeature(providers), ɵɵNgOnChangesFeature],
    decls: 5,
    vars: 24,
    consts: () => {
      let i18n_0;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_TREEVIEW_FESM2022_PROGRESS_KENDO_ANGULAR_TREEVIEW_MJS_0 = goog.getMsg("Load more...");
        i18n_0 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_TREEVIEW_FESM2022_PROGRESS_KENDO_ANGULAR_TREEVIEW_MJS_0;
      } else {
        i18n_0 = $localize`:kendo.treeview.loadMore|The title of the Load More button:Load more...`;
      }
      return [["assetsContainer", ""], ["searchbox", ""], ["kendoTreeViewLocalizedMessages", "", "loadMore", i18n_0], ["class", "k-treeview-filter", 4, "ngIf"], ["kendoTreeViewGroup", "", "role", "tree", 1, "k-treeview-lines", 3, "size", "loadOnDemand", "checkboxes", "expandIcons", "selectable", "touchActions", "children", "hasChildren", "isChecked", "isDisabled", "hasCheckbox", "disableParentNodesOnly", "isExpanded", "isSelected", "isVisible", "nodeTemplateRef", "loadMoreButtonTemplateRef", "textField", "nodes", "loadMoreService", "trackBy", "expandDisabledNodes"], [1, "k-treeview-filter"], [3, "valueChange", "size", "value", "clearButton", "placeholder"], ["kendoTextBoxPrefixTemplate", ""], ["innerCssClass", "k-input-icon", "name", "search", 3, "svgIcon"]];
    },
    template: function TreeViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 2);
        ɵɵtemplate(1, TreeViewComponent_span_1_Template, 4, 4, "span", 3);
        ɵɵelement(2, "ul", 4);
        ɵɵelementContainer(3, null, 0);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.filterable);
        ɵɵadvance();
        ɵɵproperty("size", ctx.size)("loadOnDemand", ctx.loadOnDemand)("checkboxes", ctx.checkboxes)("expandIcons", ctx.expandIcons)("selectable", ctx.selectable)("touchActions", ctx.touchActions)("children", ctx.children)("hasChildren", ctx.hasChildren)("isChecked", ctx.isChecked)("isDisabled", ctx.isDisabled)("hasCheckbox", ctx.hasCheckbox)("disableParentNodesOnly", ctx.disableParentNodesOnly)("isExpanded", ctx.isExpanded)("isSelected", ctx.isSelected)("isVisible", ctx.isVisible)("nodeTemplateRef", ctx.nodeTemplateRef == null ? null : ctx.nodeTemplateRef.templateRef)("loadMoreButtonTemplateRef", ctx.loadMoreButtonTemplateRef == null ? null : ctx.loadMoreButtonTemplateRef.templateRef)("textField", ctx.textField)("nodes", ctx.fetchNodes)("loadMoreService", ctx.loadMoreService)("trackBy", ctx.trackBy)("expandDisabledNodes", ctx.expandDisabledNodes);
        ɵɵattribute("id", ctx.treeviewId);
      }
    },
    dependencies: [LocalizedMessagesDirective2, NgIf, TextBoxComponent, TextBoxPrefixTemplateDirective, IconWrapperComponent, TreeViewGroupComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeViewComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.Default,
      exportAs: "kendoTreeView",
      providers,
      selector: "kendo-treeview",
      template: `
        <ng-container kendoTreeViewLocalizedMessages
            i18n-loadMore="kendo.treeview.loadMore|The title of the Load More button"
            loadMore="Load more..."
        >
        </ng-container>
        <span
            class="k-treeview-filter"
            *ngIf="filterable"
        >
            <kendo-textbox
                #searchbox
                [size]="size"
                [value]="filter"
                [clearButton]="true"
                (valueChange)="filterChange.emit($event)"
                [placeholder]="filterInputPlaceholder"
            >
                <ng-template kendoTextBoxPrefixTemplate>
                    <kendo-icon-wrapper
                        innerCssClass="k-input-icon"
                        name="search"
                        [svgIcon]="searchIcon"
                        >
                    </kendo-icon-wrapper>
                </ng-template>
            </kendo-textbox>
        </span>
        <ul class="k-treeview-lines"
            kendoTreeViewGroup
            [attr.id]="treeviewId"
            role="tree"
            [size]="size"
            [loadOnDemand]="loadOnDemand"
            [checkboxes]="checkboxes"
            [expandIcons]="expandIcons"
            [selectable]="selectable"
            [touchActions]="touchActions"
            [children]="children"
            [hasChildren]="hasChildren"
            [isChecked]="isChecked"
            [isDisabled]="isDisabled"
            [hasCheckbox]="hasCheckbox"
            [disableParentNodesOnly]="disableParentNodesOnly"
            [isExpanded]="isExpanded"
            [isSelected]="isSelected"
            [isVisible]="isVisible"
            [nodeTemplateRef]="nodeTemplateRef?.templateRef"
            [loadMoreButtonTemplateRef]="loadMoreButtonTemplateRef?.templateRef"
            [textField]="textField"
            [nodes]="fetchNodes"
            [loadMoreService]="loadMoreService"
            [trackBy]="trackBy"
            [expandDisabledNodes]="expandDisabledNodes"
        >
        </ul>
        <ng-container #assetsContainer></ng-container>
    `,
      standalone: true,
      imports: [LocalizedMessagesDirective2, NgIf, TextBoxComponent, TextBoxPrefixTemplateDirective, IconWrapperComponent, TreeViewGroupComponent]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: ExpandStateService
    }, {
      type: NavigationService2
    }, {
      type: NodeChildrenService
    }, {
      type: SelectionService
    }, {
      type: TreeViewLookupService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: DataChangeNotificationService
    }, {
      type: LocalizationService
    }];
  }, {
    classNames: [{
      type: HostBinding,
      args: ["class.k-treeview"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    assetsContainer: [{
      type: ViewChild,
      args: ["assetsContainer", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    searchbox: [{
      type: ViewChild,
      args: ["searchbox"]
    }],
    filterInputPlaceholder: [{
      type: Input
    }],
    expandDisabledNodes: [{
      type: Input
    }],
    animate: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["@.disabled"]
    }],
    childrenLoaded: [{
      type: Output
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    expand: [{
      type: Output
    }],
    collapse: [{
      type: Output
    }],
    nodeDragStart: [{
      type: Output
    }],
    nodeDrag: [{
      type: Output
    }],
    filterStateChange: [{
      type: Output
    }],
    nodeDrop: [{
      type: Output
    }],
    nodeDragEnd: [{
      type: Output
    }],
    addItem: [{
      type: Output
    }],
    removeItem: [{
      type: Output
    }],
    checkedChange: [{
      type: Output
    }],
    selectionChange: [{
      type: Output
    }],
    filterChange: [{
      type: Output
    }],
    nodeClick: [{
      type: Output
    }],
    nodeDblClick: [{
      type: Output
    }],
    nodeTemplateQuery: [{
      type: ContentChild,
      args: [NodeTemplateDirective, {
        static: false
      }]
    }],
    nodeTemplateRef: [{
      type: Input,
      args: ["nodeTemplate"]
    }],
    loadMoreButtonTemplateQuery: [{
      type: ContentChild,
      args: [LoadMoreButtonTemplateDirective, {
        static: false
      }]
    }],
    loadMoreButtonTemplateRef: [{
      type: Input,
      args: ["loadMoreButtonTemplate"]
    }],
    trackBy: [{
      type: Input
    }],
    nodes: [{
      type: Input
    }],
    textField: [{
      type: Input
    }],
    hasChildren: [{
      type: Input
    }],
    isChecked: [{
      type: Input
    }],
    isDisabled: [{
      type: Input
    }],
    hasCheckbox: [{
      type: Input
    }],
    isExpanded: [{
      type: Input
    }],
    isSelected: [{
      type: Input
    }],
    isVisible: [{
      type: Input
    }],
    navigable: [{
      type: Input
    }],
    children: [{
      type: Input
    }],
    loadOnDemand: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    disableParentNodesOnly: [{
      type: Input
    }]
  });
})();
var indexChecked = (keys, index) => keys.filter((k) => k === index).length > 0;
var matchKey = (index) => (k) => {
  if (index === k) {
    return true;
  }
  if (!k.split) {
    return false;
  }
  return k.split("_").reduce(({
    key,
    result
  }, part) => {
    key += part;
    if (index === key || result) {
      return {
        result: true
      };
    }
    key += "_";
    return {
      key,
      result: false
    };
  }, {
    key: "",
    result: false
  }).result;
};
var CheckDirective = class _CheckDirective {
  treeView;
  zone;
  /**
   * @hidden
   */
  set isChecked(value) {
    this.treeView.isChecked = value;
  }
  /**
   * Defines the item key that will be stored in the `checkedKeys` collection.
   */
  checkKey;
  /**
   * Defines the collection that will store the checked keys
   * ([see example]({% slug checkboxes_treeview %})).
   */
  checkedKeys;
  /**
   * Defines the checkable settings ([see example]({% slug checkboxes_treeview %}#toc-setup)).
   * If no value is provided, the default [`CheckableSettings`]({% slug api_treeview_checkablesettings %}) are applied.
   */
  checkable;
  /**
   * Fires when the `checkedKeys` collection was updated.
   */
  checkedKeysChange = new EventEmitter();
  subscriptions = new Subscription();
  get options() {
    const defaultOptions = {
      checkChildren: true,
      checkParents: true,
      enabled: true,
      mode: "multiple",
      uncheckCollapsedChildren: false
    };
    if (!isPresent6(this.checkable) || typeof this.checkable === "string") {
      return defaultOptions;
    }
    const checkSettings = isBoolean(this.checkable) ? {
      enabled: this.checkable
    } : this.checkable;
    return Object.assign(defaultOptions, checkSettings);
  }
  checkActions = {
    "multiple": (e) => this.checkMultiple(e),
    "single": (e) => this.checkSingle(e)
  };
  /**
   * Reflectes the internal `checkedKeys` state.
   */
  state = /* @__PURE__ */ new Set();
  clickSubscription;
  /**
   * Holds the last emitted `checkedKeys` collection.
   */
  lastChange;
  constructor(treeView, zone) {
    this.treeView = treeView;
    this.zone = zone;
    this.subscriptions.add(this.treeView.checkedChange.subscribe((e) => this.check(e)));
    const expandedItems = [];
    this.subscriptions.add(this.treeView.childrenLoaded.pipe(filter(() => this.options.checkChildren && this.treeView.loadOnDemand), tap((item) => expandedItems.push(item)), switchMap(() => this.zone.onStable.pipe(take(1)))).subscribe(() => this.addCheckedItemsChildren(expandedItems)));
    this.treeView.isChecked = this.isItemChecked.bind(this);
  }
  ngOnChanges(changes) {
    if (changes.checkable) {
      this.treeView.checkboxes = this.options.enabled;
      this.toggleCheckOnClick();
    }
    if (isChanged("checkedKeys", changes, false) && changes.checkedKeys.currentValue !== this.lastChange) {
      this.state = new Set(changes.checkedKeys.currentValue);
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.unsubscribeClick();
  }
  isItemChecked(dataItem, index) {
    if (!this.checkKey) {
      return this.isIndexChecked(index);
    }
    const hasKey = this.state.has(this.itemKey({
      dataItem,
      index
    }));
    return hasKey ? "checked" : "none";
  }
  isIndexChecked(index) {
    const checkedKeys = Array.from(this.state).filter(matchKey(index));
    if (indexChecked(checkedKeys, index)) {
      return "checked";
    }
    const {
      mode,
      checkParents
    } = this.options;
    if (mode === "multiple" && checkParents && checkedKeys.length) {
      return "indeterminate";
    }
    return "none";
  }
  itemKey(item) {
    if (!isPresent6(this.checkKey)) {
      return item.index;
    }
    if (typeof this.checkKey === "string" && isPresent6(item.dataItem)) {
      return item.dataItem[this.checkKey];
    }
    if (typeof this.checkKey === "function") {
      return this.checkKey(item);
    }
  }
  check(e) {
    const {
      enabled,
      mode
    } = this.options;
    const performSelection = this.checkActions[mode] || noop5;
    if (!enabled) {
      return;
    }
    performSelection(e);
  }
  checkSingle(node) {
    const key = this.itemKey(node.item);
    const hasKey = this.state.has(key);
    this.state.clear();
    if (!hasKey) {
      this.state.add(key);
    }
    this.notify();
  }
  checkMultiple(node) {
    this.checkNode(node);
    if (this.options.checkParents) {
      this.checkParents(node.parent);
    }
    this.notify();
  }
  toggleCheckOnClick() {
    this.unsubscribeClick();
    if (this.options.checkOnClick) {
      this.clickSubscription = this.treeView.nodeClick.subscribe((args) => {
        if (args.type === "click") {
          const lookup = this.treeView.itemLookup(args.item.index);
          this.check(lookup);
        }
      });
    }
  }
  unsubscribeClick() {
    if (this.clickSubscription) {
      this.clickSubscription.unsubscribe();
      this.clickSubscription = null;
    }
  }
  checkNode(node) {
    if (!isPresent6(node.item.dataItem) || this.treeView.isDisabled(node.item.dataItem, node.item.index) || !this.treeView.hasCheckbox(node.item.dataItem, node.item.index)) {
      return;
    }
    const currentKey = this.itemKey(node.item);
    if (!isPresent6(currentKey)) {
      return;
    }
    const pendingCheck = [currentKey];
    if (this.options.checkChildren) {
      const descendants = fetchLoadedDescendants(node, ({
        item
      }) => this.treeView.disableParentNodesOnly || this.options.checkDisabledChildren ? this.treeView.isVisible(item.dataItem, item.index) : this.treeView.isVisible(item.dataItem, item.index) && !this.treeView.isDisabled(item.dataItem, item.index) && this.treeView.hasCheckbox(item.dataItem, item.index));
      pendingCheck.push(...descendants.filter((item) => this.options.checkDisabledChildren || !this.treeView.isDisabled(item.item.dataItem, item.item.index) || this.treeView.hasCheckbox(item.item.dataItem, item.item.index)).map(({
        item
      }) => this.itemKey(item)));
    }
    const shouldCheck = !this.state.has(currentKey);
    pendingCheck.forEach((key) => {
      if (shouldCheck) {
        this.state.add(key);
      } else {
        this.state.delete(key);
        if (this.options.uncheckCollapsedChildren && this.options.mode === "multiple" && this.treeView.loadOnDemand) {
          if (this.checkKey && this.treeView.hasChildren(node.item.dataItem)) {
            this.uncheckChildren(node.item.dataItem, node.item.index);
            return;
          }
          const checkedKeys = Array.from(this.state).filter(matchKey(node.item.index));
          checkedKeys.forEach((key2) => this.state.delete(key2));
        }
      }
    });
  }
  uncheckChildren(dataItem, parentNodeIndex) {
    this.treeView.children(dataItem).subscribe((children) => children.forEach((item, index) => {
      const nodeIndex3 = `${parentNodeIndex}_${index}`;
      this.state.delete(this.itemKey({
        dataItem: item,
        index: nodeIndex3
      }));
      if (this.treeView.hasChildren(item)) {
        this.uncheckChildren(item, nodeIndex3);
      }
    }));
  }
  checkParents(parent) {
    if (!isPresent6(parent)) {
      return;
    }
    let currentParent = parent;
    while (currentParent) {
      const parentKey = this.itemKey(currentParent.item);
      const isDisabled2 = this.treeView.isDisabled(currentParent.item.dataItem, currentParent.item.index);
      const allChildrenSelected = currentParent.children.every((item) => this.state.has(this.itemKey(item)));
      const hasCheckbox2 = this.treeView.hasCheckbox(currentParent.item.dataItem, currentParent.item.index);
      if (hasCheckbox2 && (!isDisabled2 || this.options.checkDisabledChildren) && allChildrenSelected) {
        this.state.add(parentKey);
      } else {
        this.state.delete(parentKey);
      }
      currentParent = currentParent.parent;
    }
  }
  allChildrenSelected(children) {
    return children.every((item) => {
      const childrenSel = this.allChildrenSelected(item.children);
      return this.state.has(this.itemKey(item.item)) && childrenSel;
    });
  }
  notify() {
    this.lastChange = Array.from(this.state);
    this.checkedKeysChange.emit(this.lastChange);
  }
  addCheckedItemsChildren(lookups) {
    if (!isPresent6(lookups) || lookups.length === 0) {
      return;
    }
    const initiallyCheckedItemsCount = this.state.size;
    const disabledItems = /* @__PURE__ */ new Set();
    lookups.forEach((lookup) => {
      const itemKey = this.itemKey(lookup.item);
      if (!this.state.has(itemKey)) {
        return;
      }
      lookup.children.forEach((item) => {
        if (!this.treeView.isDisabled(lookup.item.dataItem, lookup.item.index) && !this.treeView.isDisabled(item.dataItem, item.index) && this.treeView.hasCheckbox(lookup.item.dataItem, lookup.item.index) && this.treeView.hasCheckbox(item.dataItem, item.index) || this.treeView.disableParentNodesOnly || this.options.checkDisabledChildren) {
          this.state.add(this.itemKey(item));
        }
        if (this.treeView.disableParentNodesOnly && !this.options.checkDisabledChildren && (this.treeView.isDisabled(item.dataItem, item.index) || !this.treeView.hasCheckbox(item.dataItem, item.index))) {
          disabledItems.add(this.itemKey(item));
        }
      });
    });
    disabledItems.forEach((item) => this.state.delete(item));
    const hasNewlyCheckedItems = initiallyCheckedItemsCount !== this.state.size;
    if (hasNewlyCheckedItems) {
      this.zone.run(() => this.notify());
    }
  }
  static ɵfac = function CheckDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CheckDirective)(ɵɵdirectiveInject(TreeViewComponent), ɵɵdirectiveInject(NgZone));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CheckDirective,
    selectors: [["", "kendoTreeViewCheckable", ""]],
    inputs: {
      isChecked: "isChecked",
      checkKey: [0, "checkBy", "checkKey"],
      checkedKeys: "checkedKeys",
      checkable: [0, "kendoTreeViewCheckable", "checkable"]
    },
    outputs: {
      checkedKeysChange: "checkedKeysChange"
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewCheckable]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TreeViewComponent
    }, {
      type: NgZone
    }];
  }, {
    isChecked: [{
      type: Input
    }],
    checkKey: [{
      type: Input,
      args: ["checkBy"]
    }],
    checkedKeys: [{
      type: Input
    }],
    checkable: [{
      type: Input,
      args: ["kendoTreeViewCheckable"]
    }],
    checkedKeysChange: [{
      type: Output
    }]
  });
})();
var DisableDirective = class _DisableDirective {
  treeView;
  cdr;
  /**
   * @hidden
   */
  set isDisabled(value) {
    this.treeView.isDisabled = value;
  }
  /**
   * Defines the item key that will be stored in the `disabledKeys` collection.
   */
  disableKey;
  /**
   * Defines the collection that will store the disabled keys.
   */
  disabledKeys = [];
  constructor(treeView, cdr) {
    this.treeView = treeView;
    this.cdr = cdr;
    this.treeView.isDisabled = (dataItem, index) => this.disabledKeys.indexOf(this.itemKey({
      dataItem,
      index
    })) > -1;
  }
  ngOnChanges(changes = {}) {
    const {
      disabledKeys
    } = changes;
    if (disabledKeys && !disabledKeys.firstChange) {
      this.cdr.markForCheck();
    }
  }
  itemKey(e) {
    if (!this.disableKey) {
      return e.index;
    }
    if (typeof this.disableKey === "string") {
      return e.dataItem[this.disableKey];
    }
    if (typeof this.disableKey === "function") {
      return this.disableKey(e);
    }
  }
  static ɵfac = function DisableDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DisableDirective)(ɵɵdirectiveInject(TreeViewComponent), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DisableDirective,
    selectors: [["", "kendoTreeViewDisable", ""]],
    inputs: {
      isDisabled: "isDisabled",
      disableKey: [0, "kendoTreeViewDisable", "disableKey"],
      disabledKeys: "disabledKeys"
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DisableDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewDisable]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TreeViewComponent
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    isDisabled: [{
      type: Input
    }],
    disableKey: [{
      type: Input,
      args: ["kendoTreeViewDisable"]
    }],
    disabledKeys: [{
      type: Input
    }]
  });
})();
var DragAndDropEditingDirective = class _DragAndDropEditingDirective {
  treeview;
  /**
   * Specifies the handlers called on drag-and-drop [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem)
   * and [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem) events.
   */
  set editService(service) {
    this.treeview.editService = service;
  }
  subscriptions = new Subscription();
  constructor(treeview) {
    this.treeview = treeview;
    this.subscriptions.add(this.treeview.addItem.subscribe(this.handleAdd.bind(this)));
    this.subscriptions.add(this.treeview.removeItem.subscribe(this.handleRemove.bind(this)));
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  handleAdd(args) {
    if (!isPresent6(this.treeview.editService)) {
      throw new Error("No `editService` provided. Either provide your own implementation or use this directive in combination with one of the data binding directives (`kendoTreeViewHierarchyBinding` or `kendoTreeViewFlatDataBinding`).");
    }
    this.treeview.editService.add(args);
  }
  handleRemove(args) {
    if (!isPresent6(this.treeview.editService)) {
      throw new Error("No `editService` provided. Either provide your own implementation or use this directive in combination with one of the data binding directives (`kendoTreeViewHierarchyBinding` or `kendoTreeViewFlatDataBinding`).");
    }
    this.treeview.editService.remove(args);
  }
  static ɵfac = function DragAndDropEditingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragAndDropEditingDirective)(ɵɵdirectiveInject(TreeViewComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DragAndDropEditingDirective,
    selectors: [["", "kendoTreeViewDragAndDropEditing", ""]],
    inputs: {
      editService: "editService"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragAndDropEditingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewDragAndDropEditing]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TreeViewComponent
    }];
  }, {
    editService: [{
      type: Input
    }]
  });
})();
var DropAction;
(function(DropAction2) {
  DropAction2[DropAction2["Add"] = 0] = "Add";
  DropAction2[DropAction2["InsertTop"] = 1] = "InsertTop";
  DropAction2[DropAction2["InsertBottom"] = 2] = "InsertBottom";
  DropAction2[DropAction2["InsertMiddle"] = 3] = "InsertMiddle";
  DropAction2[DropAction2["Invalid"] = 4] = "Invalid";
})(DropAction || (DropAction = {}));
var DropPosition;
(function(DropPosition2) {
  DropPosition2[DropPosition2["Over"] = 0] = "Over";
  DropPosition2[DropPosition2["Before"] = 1] = "Before";
  DropPosition2[DropPosition2["After"] = 2] = "After";
})(DropPosition || (DropPosition = {}));
var ScrollDirection;
(function(ScrollDirection2) {
  ScrollDirection2[ScrollDirection2["Up"] = -1] = "Up";
  ScrollDirection2[ScrollDirection2["Down"] = 1] = "Down";
})(ScrollDirection || (ScrollDirection = {}));
var PreventableEvent4 = class {
  prevented = false;
  /**
   * Prevents the default action for a specified event.
   * In this way, the source component suppresses the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * If the event is prevented by any of its subscribers, returns `true`.
   *
   * @returns `true` if the default action was prevented. Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
};
var TreeItemDropEvent = class extends PreventableEvent4 {
  /**
   * A reference of the TreeView from which the dragged item originates.
   */
  sourceTree;
  /**
   * A reference of the TreeView onto which the dragged item is dropped.
   */
  destinationTree;
  /**
   * The look-up info for the dragged item.
   */
  sourceItem;
  /**
   * The look-up info for the item onto which the dragged item is dropped.
   */
  destinationItem;
  /**
   * Describes where the dragged item is dropped relative to the drop target item.
   */
  dropPosition;
  /**
   * The original pointer event holding details about the current pointer position.
   */
  originalEvent;
  /**
   * @hidden
   */
  isValid = true;
  /**
   * @hidden
   */
  constructor(initializer, originalEvent) {
    super();
    Object.assign(this, initializer);
    this.originalEvent = originalEvent;
  }
  /**
   * Specifies if the drop action should be marked as valid.
   * If set to `false`, the [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and
   * [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem) events will not be fired and the drag clue
   * will be animated back to the source item to indicate the action is marked as invalid.
   */
  setValid(isValid) {
    this.isValid = isValid;
  }
};
var TreeItemDragStartEvent = class extends PreventableEvent4 {
  /**
   * The look-up info for the dragged item.
   */
  sourceItem;
  /**
   * The original pointer event holding details about the current pointer position.
   */
  originalEvent;
  /**
   * @hidden
   */
  constructor(initializer) {
    super();
    Object.assign(this, initializer);
  }
};
var DragClueComponent = class _DragClueComponent {
  cdr;
  hostClasses = true;
  /**
   * The text value of the dragged TreeView item.
   */
  text;
  /**
   * The attempted operation according to the current drop target.
   */
  action;
  /**
   * The look-up info for the currently dragged item.
   */
  sourceItem;
  /**
   * The look-up info for the destination item (if hovering a valid drop target).
   */
  destinationItem;
  /**
   * Defines the drag clue content template.
   */
  template;
  posistionStyle = "fixed";
  get statusIconClass() {
    switch (this.action) {
      case DropAction.Add:
        return "plus";
      case DropAction.InsertTop:
        return "insert-top";
      case DropAction.InsertBottom:
        return "insert-bottom";
      case DropAction.InsertMiddle:
        return "insert-middle";
      case DropAction.Invalid:
      default:
        return "cancel";
    }
  }
  get statusSVGIcon() {
    switch (this.action) {
      case DropAction.Add:
        return plusIcon;
      case DropAction.InsertTop:
        return insertTopIcon;
      case DropAction.InsertBottom:
        return insertBottomIcon;
      case DropAction.InsertMiddle:
        return insertMiddleIcon;
      case DropAction.Invalid:
      default:
        return cancelIcon;
    }
  }
  constructor(cdr) {
    this.cdr = cdr;
  }
  // exposed as a public method that can be called from outside as the component uses `OnPush` strategy
  detectChanges() {
    this.cdr.detectChanges();
  }
  static ɵfac = function DragClueComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragClueComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DragClueComponent,
    selectors: [["kendo-treeview-drag-clue"]],
    hostVars: 6,
    hostBindings: function DragClueComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("position", ctx.posistionStyle);
        ɵɵclassProp("k-header", ctx.hostClasses)("k-drag-clue", ctx.hostClasses);
      }
    },
    decls: 2,
    vars: 2,
    consts: [[4, "ngIf"], ["innerCssClass", "k-drag-status", 3, "name", "svgIcon"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function DragClueComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, DragClueComponent_ng_container_0_Template, 4, 3, "ng-container", 0)(1, DragClueComponent_1_Template, 1, 7, null, 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", !ctx.template);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.template);
      }
    },
    dependencies: [NgIf, IconWrapperComponent, NgTemplateOutlet],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragClueComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-treeview-drag-clue",
      template: `
        <ng-container *ngIf="!template">
            <kendo-icon-wrapper
                innerCssClass="k-drag-status"
                [name]="statusIconClass"
                [svgIcon]="statusSVGIcon"
                >
            </kendo-icon-wrapper>
            <span>{{text}}</span>
        </ng-container>

        <ng-template
            *ngIf="template"
            [ngTemplateOutlet]="template"
            [ngTemplateOutletContext]="{
                text: text,
                action: action,
                sourceItem: sourceItem,
                destinationItem: destinationItem
            }"
        >
        </ng-template>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent, NgTemplateOutlet]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-header"]
    }, {
      type: HostBinding,
      args: ["class.k-drag-clue"]
    }],
    posistionStyle: [{
      type: HostBinding,
      args: ["style.position"]
    }]
  });
})();
var DragAndDropAssetService = class _DragAndDropAssetService {
  get componentRef() {
    if (!isPresent6(this._componentRef)) {
      throw new Error("The `initalize` method must be called before calling other service methods.");
    }
    return this._componentRef;
  }
  set componentRef(componentRef) {
    this._componentRef = componentRef;
  }
  get element() {
    return this.componentRef.location.nativeElement;
  }
  _componentRef;
  ngOnDestroy() {
    if (!isPresent6(this._componentRef)) {
      return;
    }
    this.element.parentElement.removeChild(this.element);
    this.componentRef.destroy();
    this.componentRef = null;
  }
  show() {
    this.element.style.display = "";
  }
  hide() {
    this.element.style.display = "none";
  }
  move(left, top, offset = 0) {
    this.element.style.left = `${left + offset}px`;
    this.element.style.top = `${top + offset}px`;
  }
  static ɵfac = function DragAndDropAssetService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragAndDropAssetService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DragAndDropAssetService,
    factory: _DragAndDropAssetService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragAndDropAssetService, [{
    type: Injectable
  }], null, null);
})();
var hasRelativeStackingContext = memoize(() => {
  if (!(isDocumentAvailable() && isPresent6(document.body))) {
    return false;
  }
  const top = 10;
  const parent = document.createElement("div");
  parent.style.transform = "matrix(10, 0, 0, 10, 0, 0)";
  const innerDiv = document.createElement("div");
  innerDiv.innerText = "child";
  innerDiv.style.position = "fixed";
  innerDiv.style.top = `${top}px`;
  parent.appendChild(innerDiv);
  document.body.appendChild(parent);
  const isDifferent = parent.children[0].getBoundingClientRect().top !== top;
  document.body.removeChild(parent);
  return isDifferent;
});
function memoize(fn) {
  let result;
  let called = false;
  return (...args) => {
    if (called) {
      return result;
    }
    result = fn(...args);
    called = true;
    return result;
  };
}
var getContainerOffset = (element) => {
  if (!(element && hasRelativeStackingContext())) {
    return {
      left: 0,
      top: 0
    };
  }
  let offsetParent = element.parentElement;
  while (offsetParent) {
    if (window.getComputedStyle(offsetParent).transform !== "none") {
      break;
    }
    offsetParent = offsetParent.parentElement;
  }
  if (offsetParent) {
    const rect = offsetParent.getBoundingClientRect();
    return {
      left: rect.left - offsetParent.scrollLeft,
      top: rect.top - offsetParent.scrollTop
    };
  }
  return {
    left: 0,
    top: 0
  };
};
var getDropAction = (dropPosition, dropTarget) => {
  if (!(isPresent6(dropPosition) && isPresent6(dropTarget))) {
    return DropAction.Invalid;
  }
  switch (dropPosition) {
    case DropPosition.Over:
      return DropAction.Add;
    case DropPosition.Before:
      return isPresent6(closestNode(dropTarget).previousElementSibling) ? DropAction.InsertMiddle : DropAction.InsertTop;
    case DropPosition.After:
      return isPresent6(closestNode(dropTarget).nextElementSibling) ? DropAction.InsertMiddle : DropAction.InsertBottom;
    default:
      return DropAction.Invalid;
  }
};
var getDropPosition = (draggedItem, target, clientY, targetTreeView, containerOffset) => {
  if (!(isPresent6(draggedItem) && isPresent6(target) && isPresent6(targetTreeView) && isPresent6(containerOffset))) {
    return;
  }
  const item = closestWithMatch(target, ".k-treeview-top, .k-treeview-mid, .k-treeview-bot");
  if (!isPresent6(item)) {
    return;
  }
  const content = getContentElement(item);
  const targetChildOfDraggedItem = hasParent(item, closestNode(draggedItem));
  if (!isPresent6(content) || content === draggedItem || targetChildOfDraggedItem) {
    return;
  }
  const itemViewPortCoords = content.getBoundingClientRect();
  const itemDivisionHeight = itemViewPortCoords.height / (isContent(target) ? 4 : 2);
  const pointerPosition = clientY - containerOffset.top;
  const itemTop = itemViewPortCoords.top - containerOffset.top;
  if (pointerPosition < itemTop + itemDivisionHeight) {
    return DropPosition.Before;
  }
  if (pointerPosition >= itemTop + itemViewPortCoords.height - itemDivisionHeight) {
    return DropPosition.After;
  }
  return DropPosition.Over;
};
var treeItemFromEventTarget = (treeView, dropTarget) => {
  if (!(isPresent6(treeView) && isPresent6(dropTarget))) {
    return null;
  }
  const node = closestNode(dropTarget);
  const index = nodeId(node);
  const lookup = treeView.itemLookup(index);
  if (!(isPresent6(lookup) && isPresent6(lookup.item.dataItem))) {
    return null;
  }
  return lookup;
};
var collapseEmptyParent = (parent, parentNodes, treeview) => {
  if (isPresent6(parent) && parentNodes.length === 0 && treeview.isExpanded(parent.item.dataItem, parent.item.index)) {
    treeview.collapseNode(parent.item.dataItem, parent.item.index);
  }
};
var expandDropTarget = (dropTarget, treeView) => {
  if (!treeView.isExpanded(dropTarget.item.dataItem, dropTarget.item.index)) {
    treeView.expandNode(dropTarget.item.dataItem, dropTarget.item.index);
  }
};
var getDropTarget = (event) => {
  if (!(isDocumentAvailable() && isPresent6(document.elementFromPoint))) {
    return event.target;
  }
  return document.elementFromPoint(event.clientX, event.clientY);
};
var updateMovedItemIndex = (newIndex, originalIndex) => {
  const movedItemNewIndexParts = newIndex.split("_");
  const originalItemIndexParts = originalIndex.split("_");
  if (movedItemNewIndexParts.length < originalItemIndexParts.length) {
    return newIndex;
  }
  const originalItemParentPathLength = originalItemIndexParts.length - 1;
  const originalItemParentPath = originalItemIndexParts.slice(0, originalItemParentPathLength).join("_");
  const movedItemParentPath = movedItemNewIndexParts.slice(0, originalItemParentPathLength).join("_");
  const originalItemIndexLevel = originalItemIndexParts.length - 1;
  const originalItemLevelIndex = Number(originalItemIndexParts[originalItemIndexLevel]);
  const movedItemLevelIndex = Number(movedItemNewIndexParts[originalItemIndexLevel]);
  if (originalItemParentPath === movedItemParentPath && movedItemLevelIndex > originalItemLevelIndex) {
    movedItemNewIndexParts[originalItemIndexLevel] = String(movedItemLevelIndex - 1);
    return movedItemNewIndexParts.join("_");
  }
  return newIndex;
};
var SCROLLBAR_REG_EXP = new RegExp("(auto|scroll)");
var getScrollableContainer = (node) => {
  while (isPresent6(node) && node.nodeName !== "HTML") {
    const hasOverflow = node.scrollHeight > node.clientHeight;
    const hasScrollbar = SCROLLBAR_REG_EXP.test(getComputedStyle(node).overflowY);
    if (hasOverflow && hasScrollbar) {
      return node;
    }
    node = node.parentNode;
  }
  return node;
};
var isTopReached = (element) => Math.floor(element.scrollTop) <= 0;
var isBottomReached = (element) => Math.ceil(element.scrollTop) >= element.scrollHeight - element.clientHeight;
var scrollElementBy = (element, step, direction) => {
  if (!(isPresent6(element) && isDocumentAvailable())) {
    return;
  }
  const initialScrollTop = element.scrollTop;
  let currentStep = step;
  let iterations = 0;
  while (initialScrollTop === element.scrollTop && !(direction === ScrollDirection.Up && isTopReached(element)) && !(direction === ScrollDirection.Down && isBottomReached(element)) && iterations < 20) {
    element.scrollTop += currentStep * direction;
    currentStep += 1;
    iterations += 1;
  }
};
var CLUE_OFFSET = 10;
var RETURN_ANIMATION_DURATION = 200;
var DragClueService = class _DragClueService extends DragAndDropAssetService {
  returnAnimation;
  scrollInterval;
  constructor() {
    super();
  }
  initialize(container, template2) {
    if (isPresent6(this._componentRef)) {
      this.ngOnDestroy();
    }
    this.componentRef = container.createComponent(DragClueComponent);
    this.hide();
    this.componentRef.instance.template = template2;
    this.componentRef.changeDetectorRef.detectChanges();
  }
  ngOnDestroy() {
    this.cancelReturnAnimation();
    this.cancelScroll();
    super.ngOnDestroy();
  }
  move(left, top) {
    super.move(left, top, CLUE_OFFSET);
  }
  animateDragClueToElementPosition(target) {
    if (!(isPresent6(target) && isPresent6(this.element.animate))) {
      this.hide();
      return;
    }
    const targetElementViewPortCoords = target.getBoundingClientRect();
    const clueElementViewPortCoords = this.element.getBoundingClientRect();
    this.returnAnimation = this.element.animate([{
      transform: "translate(0, 0)"
    }, {
      transform: `translate(${targetElementViewPortCoords.left - clueElementViewPortCoords.left}px, ${targetElementViewPortCoords.top - clueElementViewPortCoords.top}px)`
    }], RETURN_ANIMATION_DURATION);
    this.returnAnimation.onfinish = () => this.hide();
  }
  cancelReturnAnimation() {
    if (!isPresent6(this.returnAnimation)) {
      return;
    }
    this.returnAnimation.cancel();
    this.returnAnimation = null;
  }
  updateDragClueData(action, sourceItem, destinationItem) {
    const dragClue = this.componentRef.instance;
    if (action === dragClue.action && dataItemsEqual(sourceItem, dragClue.sourceItem) && dataItemsEqual(destinationItem, dragClue.destinationItem)) {
      return;
    }
    dragClue.action = action;
    dragClue.sourceItem = sourceItem;
    dragClue.destinationItem = destinationItem;
    dragClue.detectChanges();
  }
  updateText(text) {
    if (text === this.componentRef.instance.text) {
      return;
    }
    this.componentRef.instance.text = text;
    this.componentRef.instance.detectChanges();
  }
  /**
   * Triggers the first scrollable parent to scroll upwards or downwards.
   * Uses setInterval, so should be called outside the angular zone.
   */
  scrollIntoView({
    step,
    interval: interval2
  }) {
    this.cancelScroll();
    const scrollableContainer = getScrollableContainer(this.element);
    if (!isPresent6(scrollableContainer)) {
      return;
    }
    const containerRect = scrollableContainer.getBoundingClientRect();
    const clueRect = this.element.getBoundingClientRect();
    const firstVisibleClientTopPart = Math.max(containerRect.top, 0);
    const topLimit = firstVisibleClientTopPart + clueRect.height;
    const bottomLimit = firstVisibleClientTopPart + Math.min(containerRect.bottom, scrollableContainer.clientHeight);
    if (clueRect.top < topLimit) {
      this.scrollInterval = setInterval(() => scrollElementBy(scrollableContainer, step, ScrollDirection.Up), interval2);
    } else if (clueRect.bottom > bottomLimit) {
      this.scrollInterval = setInterval(() => scrollElementBy(scrollableContainer, step, ScrollDirection.Down), interval2);
    }
  }
  /**
   * Cancels out the on-going scroll animation, if present.
   */
  cancelScroll() {
    if (isPresent6(this.scrollInterval)) {
      clearInterval(this.scrollInterval);
      this.scrollInterval = null;
    }
  }
  static ɵfac = function DragClueService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragClueService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DragClueService,
    factory: _DragClueService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragClueService, [{
    type: Injectable
  }], function() {
    return [];
  }, null);
})();
var DropHintComponent = class _DropHintComponent {
  changeDetectorRef;
  hostClass = true;
  /**
   * Defines the drag hint content template.
   */
  template;
  position = "fixed";
  pointerEvents = "none";
  /**
   * The attempted operation according to the current drop target.
   */
  action;
  /**
   * The look-up info for the currently dragged item.
   */
  sourceItem;
  /**
   * The look-up info for the destination item.
   */
  destinationItem;
  constructor(changeDetectorRef) {
    this.changeDetectorRef = changeDetectorRef;
  }
  // exposed as a public method that can be called from outside as the component uses `OnPush` strategy
  detectChanges() {
    this.changeDetectorRef.detectChanges();
  }
  static ɵfac = function DropHintComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropHintComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DropHintComponent,
    selectors: [["kendo-treeview-drop-hint"]],
    hostVars: 6,
    hostBindings: function DropHintComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("position", ctx.position)("pointer-events", ctx.pointerEvents);
        ɵɵclassProp("k-drop-hint-container", ctx.hostClass);
      }
    },
    decls: 2,
    vars: 2,
    consts: [["class", "k-drop-hint k-drop-hint-h", 4, "ngIf"], [4, "ngIf"], [1, "k-drop-hint", "k-drop-hint-h"], [1, "k-drop-hint-start"], [1, "k-drop-hint-line"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function DropHintComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, DropHintComponent_div_0_Template, 3, 0, "div", 0)(1, DropHintComponent_1_Template, 1, 6, null, 1);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", !ctx.template);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.template);
      }
    },
    dependencies: [NgIf, NgTemplateOutlet],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropHintComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-treeview-drop-hint",
      template: `
        <div
            *ngIf="!template"
            class="k-drop-hint k-drop-hint-h"
        >
            <div class='k-drop-hint-start'></div>
            <div class='k-drop-hint-line'></div>
        </div>

        <ng-template
            *ngIf="template"
            [ngTemplateOutlet]="template"
            [ngTemplateOutletContext]="{
                action: action,
                sourceItem: sourceItem,
                destinationItem: destinationItem
            }"
        >
        <ng-template>
    `,
      standalone: true,
      imports: [NgIf, NgTemplateOutlet]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-drop-hint-container"]
    }],
    position: [{
      type: HostBinding,
      args: ["style.position"]
    }],
    pointerEvents: [{
      type: HostBinding,
      args: ["style.pointer-events"]
    }]
  });
})();
var DropHintService = class _DropHintService extends DragAndDropAssetService {
  constructor() {
    super();
  }
  initialize(container, template2) {
    if (isPresent6(this._componentRef)) {
      this.ngOnDestroy();
    }
    this.componentRef = container.createComponent(DropHintComponent);
    this.hide();
    this.componentRef.instance.template = template2;
    this.componentRef.changeDetectorRef.detectChanges();
  }
  updateDropHintData(action, sourceItem, destinationItem) {
    const dropHint = this.componentRef.instance;
    if (action === dropHint.action && dataItemsEqual(sourceItem, dropHint.sourceItem) && dataItemsEqual(destinationItem, dropHint.destinationItem)) {
      return;
    }
    dropHint.action = action;
    dropHint.sourceItem = sourceItem;
    dropHint.destinationItem = destinationItem;
    dropHint.detectChanges();
  }
  static ɵfac = function DropHintService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropHintService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DropHintService,
    factory: _DropHintService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropHintService, [{
    type: Injectable
  }], function() {
    return [];
  }, null);
})();
var DragClueTemplateDirective = class _DragClueTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function DragClueTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragClueTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DragClueTemplateDirective,
    selectors: [["", "kendoTreeViewDragClueTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragClueTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewDragClueTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var DropHintTemplateDirective = class _DropHintTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function DropHintTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropHintTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DropHintTemplateDirective,
    selectors: [["", "kendoTreeViewDropHintTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropHintTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewDropHintTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var DEFAULT_SCROLL_SETTINGS = {
  enabled: true,
  step: 1,
  interval: 1
};
var DragAndDropDirective = class _DragAndDropDirective {
  element;
  zone;
  treeview;
  dragClueService;
  dropHintService;
  /**
   * Specifies whether the `removeItem` event will be fired after an item is dropped when the `ctrl` key is pressed.
   * If enabled, the `removeItem` event will not be fired on the source TreeView
   * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).
   *
   * @default false
   */
  allowCopy = false;
  /**
   * Specifes the TreeViewComponent instances into which dragged items from the current TreeViewComponent can be dropped
   * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).
   */
  dropZoneTreeViews = [];
  /**
   * Specifies the distance in pixels from the initial item pointerdown event, before the dragging is initiated.
   * The `nodeDragStart` and all consequent TreeView drag events will not be fired until the actual dragging begins.
   *
   * @default 5
   */
  startDragAfter = 5;
  /**
   * Controlls the auto-scrolling behavior during drag-and-drop ([see example]({% slug draganddrop_treeview %}#toc-auto-scrolling)).
   * Enbaled by default. To turn the auto-scrolling off, set this prop to `false`.
   *
   * By default, the scrolling will be performed by 1 pixel at every 1 millisecond, when the dragged item reaches the top or the bottom of the scrollable container.
   * The `step` and `interval` can be overridden by providing a `DragAndDropScrollSettings` object to this prop.
   *
   * @default true
   */
  autoScroll = true;
  /**
   * @hidden
   */
  dragClueTemplate;
  /**
   * @hidden
   */
  dropHintTemplate;
  /**
   * @hidden
   */
  userSelectStyle = "none";
  draggable;
  draggedItem;
  /**
   * The pointer event of the last successful item pointerdown event (the draggable `press` event).
   * Used for determining whether the `startDragAfter` distance is covered and for the `nodeDragStart` event args.
   * Used also as a flag for whether a drag attempt is pending. Should be set to `null` once the dragging begins.
   */
  pendingDragStartEvent;
  get scrollSettings() {
    const userProvidedSettings = typeof this.autoScroll === "boolean" ? {
      enabled: this.autoScroll
    } : this.autoScroll;
    return Object.assign({}, DEFAULT_SCROLL_SETTINGS, userProvidedSettings);
  }
  /**
   * Describes the offset of the parent element if the latter has the `transform` CSS prop applied.
   * Transformed parents create new stacking context and the fixed children must be position based on the transformed parent.
   * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
   */
  containerOffset = {
    top: 0,
    left: 0
  };
  constructor(element, zone, treeview, dragClueService, dropHintService) {
    this.element = element;
    this.zone = zone;
    this.treeview = treeview;
    this.dragClueService = dragClueService;
    this.dropHintService = dropHintService;
    this.treeview.touchActions = false;
  }
  ngAfterContentInit() {
    this.initalizeDraggable();
    this.dragClueService.initialize(this.treeview.assetsContainer, this.dragClueTemplate && this.dragClueTemplate.templateRef);
    this.dropHintService.initialize(this.treeview.assetsContainer, this.dropHintTemplate && this.dropHintTemplate.templateRef);
  }
  ngOnDestroy() {
    this.draggable.destroy();
  }
  /**
   * @hidden
   */
  handlePress({
    originalEvent
  }) {
    if (!isContent(originalEvent.target)) {
      return;
    }
    this.draggedItem = closestWithMatch(originalEvent.target, ".k-treeview-leaf");
    this.pendingDragStartEvent = originalEvent;
  }
  /**
   * @hidden
   */
  handleDrag({
    originalEvent,
    clientX,
    clientY
  }) {
    if (this.shouldInitiateDragStart({
      clientX,
      clientY
    })) {
      this.initiateDragStart();
    }
    if (!isPresent6(this.draggedItem) || isPresent6(this.pendingDragStartEvent)) {
      return;
    }
    const dropTarget = getDropTarget(originalEvent);
    if (hasObservers(this.treeview.nodeDrag)) {
      this.zone.run(() => this.notifyDrag(originalEvent, dropTarget));
    }
    const targetTreeView = this.getTargetTreeView(dropTarget);
    const dropPosition = getDropPosition(this.draggedItem, dropTarget, clientY, targetTreeView, this.containerOffset);
    const dropHintAnchor = closestWithMatch(dropTarget, ".k-treeview-top, .k-treeview-mid, .k-treeview-bot");
    const dropAction = getDropAction(dropPosition, dropTarget);
    const sourceItem = treeItemFromEventTarget(this.treeview, this.draggedItem);
    const destinationItem = treeItemFromEventTarget(targetTreeView, dropTarget);
    this.updateDropHintState(dropPosition, dropHintAnchor, dropAction, sourceItem, destinationItem);
    this.updateDragClueState(dropAction, clientX, clientY, sourceItem, destinationItem);
    if (this.scrollSettings.enabled) {
      this.dragClueService.scrollIntoView(this.scrollSettings);
    }
  }
  /**
   * @hidden
   */
  handleRelease({
    originalEvent,
    clientY
  }) {
    if (this.scrollSettings.enabled) {
      this.dragClueService.cancelScroll();
    }
    if (!isPresent6(this.draggedItem) || isPresent6(this.pendingDragStartEvent)) {
      this.pendingDragStartEvent = null;
      this.draggedItem = null;
      return;
    }
    const dropTarget = getDropTarget(originalEvent);
    const sourceTree = this.treeview;
    const destinationTree = this.getTargetTreeView(dropTarget);
    const dropPosition = getDropPosition(this.draggedItem, dropTarget, clientY, this.getTargetTreeView(dropTarget), this.containerOffset);
    const sourceItem = treeItemFromEventTarget(sourceTree, this.draggedItem);
    const destinationItem = treeItemFromEventTarget(destinationTree, dropTarget);
    if (isPresent6(destinationItem) && isPresent6(dropPosition)) {
      this.zone.run(() => this.notifyDrop({
        sourceItem,
        destinationItem,
        dropPosition,
        sourceTree,
        destinationTree
      }, originalEvent));
    } else {
      this.dragClueService.animateDragClueToElementPosition(this.draggedItem);
    }
    if (hasObservers(this.treeview.nodeDragEnd)) {
      this.zone.run(() => this.notifyDragEnd({
        sourceItem,
        destinationItem,
        originalEvent
      }));
    }
    this.dropHintService.hide();
    this.draggedItem = null;
  }
  updateDropHintState(dropPosition, dropHintAnchor, dropAction, sourceItem, destinationItem) {
    if (!isPresent6(dropHintAnchor) || dropPosition === DropPosition.Over || !isPresent6(dropPosition)) {
      this.dropHintService.hide();
      return;
    }
    const anchorViewPortCoords = dropHintAnchor.getBoundingClientRect();
    const insertBefore = dropPosition === DropPosition.Before;
    const top = insertBefore ? anchorViewPortCoords.top : anchorViewPortCoords.top + anchorViewPortCoords.height;
    this.dropHintService.updateDropHintData(dropAction, sourceItem, destinationItem);
    this.dropHintService.move(anchorViewPortCoords.left - this.containerOffset.left, top - this.containerOffset.top);
    this.dropHintService.show();
  }
  updateDragClueState(dropAction, clientX, clientY, sourceItem, destinationItem) {
    this.dragClueService.move(clientX - this.containerOffset.left, clientY - this.containerOffset.top);
    this.dragClueService.updateDragClueData(dropAction, sourceItem, destinationItem);
    this.dragClueService.show();
  }
  initalizeDraggable() {
    this.draggable = new Draggable({
      press: this.handlePress.bind(this),
      drag: this.handleDrag.bind(this),
      release: this.handleRelease.bind(this)
    });
    this.zone.runOutsideAngular(() => this.draggable.bindTo(this.element.nativeElement));
  }
  notifyDragStart(originalEvent, dropTarget) {
    const sourceItem = treeItemFromEventTarget(this.treeview, dropTarget);
    const event = new TreeItemDragStartEvent({
      sourceItem,
      originalEvent
    });
    this.treeview.nodeDragStart.emit(event);
    return event;
  }
  notifyDrag(originalEvent, dropTarget) {
    const dragEvent = {
      sourceItem: treeItemFromEventTarget(this.treeview, this.draggedItem),
      destinationItem: treeItemFromEventTarget(this.getTargetTreeView(dropTarget), dropTarget),
      originalEvent
    };
    this.treeview.nodeDrag.emit(dragEvent);
  }
  notifyDrop(args, originalEvent) {
    const event = new TreeItemDropEvent(args, originalEvent);
    args.destinationTree.nodeDrop.emit(event);
    this.disableAnimationsForNextTick(args.destinationTree);
    if (args.sourceTree !== args.destinationTree) {
      this.disableAnimationsForNextTick(args.sourceTree);
    }
    if (!event.isDefaultPrevented() && event.isValid) {
      this.dragClueService.hide();
      args.destinationTree.addItem.emit(args);
      if (!(originalEvent.ctrlKey && this.allowCopy)) {
        args.sourceTree.removeItem.emit(args);
      }
    } else if (event.isDefaultPrevented()) {
      this.dragClueService.hide();
    } else if (!event.isValid) {
      this.dragClueService.animateDragClueToElementPosition(this.draggedItem);
    }
  }
  notifyDragEnd(dragEndEvent) {
    this.treeview.nodeDragEnd.emit(dragEndEvent);
  }
  getTargetTreeView(dropTarget) {
    const treeViewTagName = this.treeview.element.nativeElement.tagName;
    const targetTreeView = closestWithMatch(dropTarget, treeViewTagName);
    return [this.treeview, ...this.dropZoneTreeViews].find((treeView) => isPresent6(treeView) && treeView.element.nativeElement === targetTreeView);
  }
  disableAnimationsForNextTick(treeView) {
    if (treeView.animate) {
      return;
    }
    treeView.animate = false;
    this.zone.runOutsideAngular(() => setTimeout(() => treeView.animate = true));
  }
  shouldInitiateDragStart(currentPointerCoords) {
    if (!isPresent6(this.pendingDragStartEvent)) {
      return false;
    }
    const distanceFromPointerDown = Math.sqrt(Math.pow(this.pendingDragStartEvent.clientX - currentPointerCoords.clientX, 2) + Math.pow(this.pendingDragStartEvent.clientY - currentPointerCoords.clientY, 2));
    return distanceFromPointerDown >= this.startDragAfter;
  }
  initiateDragStart() {
    if (hasObservers(this.treeview.nodeDragStart)) {
      const dragStartEvent = this.zone.run(() => this.notifyDragStart(this.pendingDragStartEvent, getDropTarget(this.pendingDragStartEvent)));
      if (dragStartEvent.isDefaultPrevented()) {
        this.pendingDragStartEvent = null;
        this.draggedItem = null;
        return;
      }
    }
    this.dragClueService.cancelReturnAnimation();
    this.dragClueService.updateText(this.draggedItem.innerText);
    this.containerOffset = getContainerOffset(this.draggedItem);
    this.pendingDragStartEvent = null;
  }
  static ɵfac = function DragAndDropDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragAndDropDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(TreeViewComponent), ɵɵdirectiveInject(DragClueService), ɵɵdirectiveInject(DropHintService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DragAndDropDirective,
    selectors: [["", "kendoTreeViewDragAndDrop", ""]],
    contentQueries: function DragAndDropDirective_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, DragClueTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, DropHintTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dragClueTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropHintTemplate = _t.first);
      }
    },
    hostVars: 8,
    hostBindings: function DragAndDropDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("user-select", ctx.userSelectStyle)("-ms-user-select", ctx.userSelectStyle)("-moz-user-select", ctx.userSelectStyle)("-webkit-user-select", ctx.userSelectStyle);
      }
    },
    inputs: {
      allowCopy: "allowCopy",
      dropZoneTreeViews: "dropZoneTreeViews",
      startDragAfter: "startDragAfter",
      autoScroll: "autoScroll"
    },
    features: [ɵɵProvidersFeature([DragClueService, DropHintService])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragAndDropDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewDragAndDrop]",
      providers: [DragClueService, DropHintService],
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: TreeViewComponent
    }, {
      type: DragClueService
    }, {
      type: DropHintService
    }];
  }, {
    allowCopy: [{
      type: Input
    }],
    dropZoneTreeViews: [{
      type: Input
    }],
    startDragAfter: [{
      type: Input
    }],
    autoScroll: [{
      type: Input
    }],
    dragClueTemplate: [{
      type: ContentChild,
      args: [DragClueTemplateDirective, {
        static: false
      }]
    }],
    dropHintTemplate: [{
      type: ContentChild,
      args: [DropHintTemplateDirective, {
        static: false
      }]
    }],
    userSelectStyle: [{
      type: HostBinding,
      args: ["style.user-select"]
    }, {
      type: HostBinding,
      args: ["style.-ms-user-select"]
    }, {
      type: HostBinding,
      args: ["style.-moz-user-select"]
    }, {
      type: HostBinding,
      args: ["style.-webkit-user-select"]
    }]
  });
})();
var DEFAULT_FILTER_EXPAND_SETTINGS = {
  maxAutoExpandResults: -1,
  expandMatches: false,
  expandedOnClear: "none"
};
var ExpandDirective = class _ExpandDirective {
  component;
  /**
   * @hidden
   */
  set isExpanded(value) {
    this.component.isExpanded = value;
  }
  /**
   * Defines the item key that will be stored in the `expandedKeys` collection.
   */
  expandKey;
  /**
   * Whether or not to auto-expand the nodes leading from the root node to each filter result.
   * To fine-tune this behavior, pass a [`FilterExpandSettings`]({% slug api_treeview_filterexpandsettings %}) object to this input.
   * @default false
   */
  expandOnFilter = false;
  get filterExpandSettings() {
    const settings = isBoolean(this.expandOnFilter) ? {
      enabled: this.expandOnFilter
    } : __spreadProps(__spreadValues({}, this.expandOnFilter), {
      enabled: true
    });
    return Object.assign({}, DEFAULT_FILTER_EXPAND_SETTINGS, settings);
  }
  /**
   * Fires when the `expandedKeys` collection was updated.
   */
  expandedKeysChange = new EventEmitter();
  /**
   * Defines the collection that will store the expanded keys.
   */
  expandedKeys;
  subscriptions = new Subscription();
  /**
   * Reflectes the internal `expandedKeys` state.
   */
  state = /* @__PURE__ */ new Set();
  originalExpandedKeys = /* @__PURE__ */ new Set();
  isFiltered = false;
  /**
   * Holds the last emitted `expandedKeys` collection.
   */
  lastChange;
  constructor(component) {
    this.component = component;
    this.subscriptions.add(merge(this.component.expand.pipe(map((e) => __spreadValues({
      expand: true
    }, e))), this.component.collapse.pipe(map((e) => __spreadValues({
      expand: false
    }, e)))).subscribe(this.toggleExpand.bind(this)));
    if (this.component.filterStateChange) {
      this.subscriptions.add(this.component.filterStateChange.subscribe(this.handleAutoExpand.bind(this)));
    }
    this.component.isExpanded = (dataItem, index) => this.state.has(this.itemKey({
      dataItem,
      index
    }));
  }
  ngOnChanges(changes) {
    if (isChanged("expandedKeys", changes, false) && changes["expandedKeys"].currentValue !== this.lastChange) {
      this.state = new Set(changes["expandedKeys"].currentValue);
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  /**
   * @hidden
   */
  itemKey(e) {
    if (this.expandKey) {
      if (typeof this.expandKey === "string") {
        return e.dataItem[this.expandKey];
      }
      if (typeof this.expandKey === "function") {
        return this.expandKey(e);
      }
    }
    return e.index;
  }
  toggleExpand({
    index,
    dataItem,
    expand
  }) {
    const key = this.itemKey({
      index,
      dataItem
    });
    const isExpanded2 = this.state.has(key);
    let notify = false;
    if (isExpanded2 && !expand) {
      this.state.delete(key);
      notify = true;
    } else if (!isExpanded2 && expand) {
      this.state.add(key);
      notify = true;
    }
    if (notify) {
      this.notify();
    }
  }
  handleAutoExpand({
    nodes,
    matchCount,
    term
  }) {
    if (!this.filterExpandSettings.enabled) {
      return;
    }
    const {
      maxAutoExpandResults,
      expandMatches: autoExpandMatches,
      expandedOnClear
    } = this.filterExpandSettings;
    if (!this.isFiltered) {
      this.originalExpandedKeys = new Set(this.state);
    }
    const exitingFilteredState = this.isFiltered && !term;
    const maxExceeded = maxAutoExpandResults !== -1 && matchCount > maxAutoExpandResults;
    const exitAutoExpandedState = exitingFilteredState || maxExceeded;
    if (exitAutoExpandedState) {
      switch (expandedOnClear) {
        case "initial": {
          if (!sameValues(this.state, this.originalExpandedKeys)) {
            this.state = this.originalExpandedKeys;
            this.notify();
          }
          break;
        }
        case "all": {
          this.state = new Set(nodes.reduce((acc, rootNode) => {
            this.getEveryExpandKey(acc, rootNode);
            return acc;
          }, []));
          this.notify();
          break;
        }
        case "unchanged": {
          break;
        }
        case "none":
        default: {
          if (this.state.size !== 0) {
            this.state.clear();
            this.notify();
          }
          break;
        }
      }
      this.isFiltered = false;
      return;
    }
    const indicesToExpand = new Set(nodes.reduce((acc, rootNode) => {
      this.updateExpandedNodes(acc, rootNode, autoExpandMatches);
      return acc;
    }, []));
    if (!sameValues(this.state, indicesToExpand)) {
      this.state = indicesToExpand;
      this.notify();
    }
    this.isFiltered = true;
  }
  /**
   * Fills array with the correct expand keys according to wrapper metadata.
   */
  updateExpandedNodes = (collection, node, autoExpandMatches) => {
    if (node.containsMatches || node.isMatch && autoExpandMatches && isArrayWithAtLeastOneItem(node.children)) {
      collection.push(this.itemKey({
        dataItem: node.dataItem,
        index: node.index
      }));
    }
    if (isArrayWithAtLeastOneItem(node.children)) {
      node.children.forEach((child) => {
        this.updateExpandedNodes(collection, child, autoExpandMatches);
      });
    }
  };
  /**
   * Fills array with the expand key of every node.
   */
  getEveryExpandKey = (collection, node) => {
    if (isArrayWithAtLeastOneItem(node.children)) {
      collection.push(this.itemKey({
        dataItem: node.dataItem,
        index: node.index
      }));
    }
    if (isArrayWithAtLeastOneItem(node.children)) {
      node.children.forEach((child) => {
        this.getEveryExpandKey(collection, child);
      });
    }
  };
  notify() {
    this.lastChange = Array.from(this.state);
    this.expandedKeysChange.emit(this.lastChange);
  }
  static ɵfac = function ExpandDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ExpandDirective)(ɵɵdirectiveInject(ExpandableComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ExpandDirective,
    selectors: [["", "kendoTreeViewExpandable", ""]],
    inputs: {
      isExpanded: "isExpanded",
      expandKey: [0, "expandBy", "expandKey"],
      expandOnFilter: "expandOnFilter",
      expandedKeys: "expandedKeys"
    },
    outputs: {
      expandedKeysChange: "expandedKeysChange"
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpandDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewExpandable]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ExpandableComponent
    }];
  }, {
    isExpanded: [{
      type: Input
    }],
    expandKey: [{
      type: Input,
      args: ["expandBy"]
    }],
    expandOnFilter: [{
      type: Input
    }],
    expandedKeysChange: [{
      type: Output
    }],
    expandedKeys: [{
      type: Input
    }]
  });
})();
var compose = (...args) => (data) => args.reduceRight((acc, curr) => curr(acc), data);
var copyPageSize = (treeview, source, target) => {
  if (!isPresent6(treeview.loadMoreService)) {
    return;
  }
  const sourceGroupSize = treeview.getNodePageSize(source);
  treeview.setNodePageSize(target, sourceGroupSize);
};
var incrementPageSize = (treeview, dataItem) => {
  if (!isPresent6(treeview.loadMoreService)) {
    return;
  }
  const currentPageSize = treeview.getNodePageSize(dataItem);
  treeview.setNodePageSize(dataItem, currentPageSize + 1);
};
var decrementPageSize = (treeview, dataItem) => {
  if (!isPresent6(treeview.loadMoreService)) {
    return;
  }
  const currentPageSize = treeview.getNodePageSize(dataItem);
  treeview.setNodePageSize(dataItem, currentPageSize - 1);
};
var FlatEditingService = class {
  flatBinding;
  movedItemNewIndex;
  constructor(flatBinding) {
    this.flatBinding = flatBinding;
  }
  add({
    sourceItem,
    destinationItem,
    dropPosition,
    sourceTree,
    destinationTree
  }) {
    const clonedSourceDataItem = Object.assign({}, getDataItem(sourceItem));
    if (dropPosition === DropPosition.Over) {
      expandDropTarget(destinationItem, destinationTree);
      const destinationItemId = getter(this.flatBinding.idField)(getDataItem(destinationItem));
      setter(this.flatBinding.parentIdField)(clonedSourceDataItem, destinationItemId);
      const lastChildNodeIndex = this.getLastVisibleChildNodeIndex(destinationTree, this.flatBinding.originalData, getDataItem(destinationItem));
      const targetIndex = lastChildNodeIndex + 1;
      this.flatBinding.originalData.splice(targetIndex, 0, clonedSourceDataItem);
      this.rebindData();
      const focusTarget = this.fetchChildNodes(getDataItem(destinationItem), destinationTree).indexOf(clonedSourceDataItem);
      this.movedItemNewIndex = buildTreeIndex(destinationItem.item.index, focusTarget);
    } else {
      const shiftIndex = dropPosition === DropPosition.After ? 1 : 0;
      const targetIndex = this.flatBinding.originalData.indexOf(getDataItem(destinationItem)) + shiftIndex;
      this.flatBinding.originalData.splice(targetIndex, 0, clonedSourceDataItem);
      const destinationItemParentId = getter(this.flatBinding.parentIdField)(getDataItem(destinationItem));
      setter(this.flatBinding.parentIdField)(clonedSourceDataItem, destinationItemParentId);
      this.rebindData();
      const parentIndex = destinationItem.parent ? destinationItem.parent.item.index : null;
      const parentContainer = destinationItem.parent ? this.fetchChildNodes(getDataItem(destinationItem.parent), destinationTree) : destinationTree.nodes;
      const focusTarget = parentContainer.indexOf(clonedSourceDataItem);
      this.movedItemNewIndex = buildTreeIndex(parentIndex, focusTarget);
    }
    if (sourceTree !== destinationTree) {
      this.addChildNodes(clonedSourceDataItem, sourceTree);
    }
    const updatedParent = dropPosition === DropPosition.Over ? getDataItem(destinationItem) : getDataItem(destinationItem.parent);
    incrementPageSize(destinationTree, updatedParent);
    copyPageSize(destinationTree, getDataItem(sourceItem), clonedSourceDataItem);
    if (sourceTree !== destinationTree && !destinationTree.loadOnDemand) {
      destinationTree.preloadChildNodes();
    }
    if (sourceTree !== destinationTree) {
      destinationTree.changeDetectorRef.detectChanges();
      destinationTree.focus(this.movedItemNewIndex);
    }
  }
  remove({
    sourceItem,
    sourceTree,
    destinationTree
  }) {
    const sourceDataItem = getDataItem(sourceItem);
    const sourceItemIndex = this.flatBinding.originalData.indexOf(sourceDataItem);
    this.flatBinding.originalData.splice(sourceItemIndex, 1);
    if (sourceTree !== destinationTree) {
      this.removeChildNodes(sourceDataItem, sourceTree);
    }
    this.rebindData();
    const parentChildren = sourceItem.parent ? sourceItem.parent.children : [];
    collapseEmptyParent(sourceItem.parent, parentChildren, sourceTree);
    decrementPageSize(sourceTree, getDataItem(sourceItem.parent));
    if (!sourceTree.loadOnDemand) {
      sourceTree.preloadChildNodes();
    }
    if (sourceTree === destinationTree) {
      destinationTree.changeDetectorRef.detectChanges();
      const index = updateMovedItemIndex(this.movedItemNewIndex, sourceItem.item.index);
      destinationTree.focus(index);
    }
  }
  addChildNodes(dataItem, source) {
    const itemChildren = this.fetchAllDescendantNodes(dataItem, source);
    this.flatBinding.originalData.push(...itemChildren);
  }
  removeChildNodes(dataItem, source) {
    const sourceChildren = this.fetchAllDescendantNodes(dataItem, source);
    sourceChildren.forEach((item) => {
      const index = this.flatBinding.originalData.indexOf(item);
      this.flatBinding.originalData.splice(index, 1);
    });
  }
  fetchAllDescendantNodes(node, treeview) {
    let nodes = this.fetchChildNodes(node, treeview);
    nodes.forEach((node2) => nodes = nodes.concat(this.fetchAllDescendantNodes(node2, treeview) || []));
    return nodes;
  }
  fetchChildNodes(node, treeview) {
    if (!node) {
      return [];
    }
    let nodes = [];
    treeview.children(node).pipe(take(1)).subscribe((children) => nodes = nodes.concat(children || []));
    return nodes;
  }
  getLastVisibleChildNodeIndex(treeview, data, node) {
    if (!isPresent6(treeview.loadMoreService) || !treeview.hasChildren(node)) {
      return data.length;
    }
    const visibleNodesCount = treeview.loadMoreService.getGroupSize(node);
    const visibleChildren = this.fetchChildNodes(node, treeview).slice(0, visibleNodesCount);
    const lastNode = visibleChildren[visibleChildren.length - 1];
    const lastNodeIndex = data.indexOf(lastNode);
    return lastNodeIndex;
  }
  rebindData() {
    this.flatBinding.nodes = this.flatBinding.originalData;
    this.flatBinding.updateNodes(this.flatBinding.originalData);
  }
};
var DEFAULT_FILTER_SETTINGS = {
  operator: "contains",
  ignoreCase: true,
  mode: "lenient"
};
var FilteringBase = class _FilteringBase {
  component;
  /**
   * Stores the unfiltered nodes
   */
  filterData;
  visibleNodes = /* @__PURE__ */ new Set();
  /**
   * The settings which are applied when performing a filter on the component's data.
   */
  set filterSettings(settings) {
    this._filterSettings = __spreadValues(__spreadValues({}, DEFAULT_FILTER_SETTINGS), settings);
  }
  get filterSettings() {
    return this._filterSettings;
  }
  _filterSettings = DEFAULT_FILTER_SETTINGS;
  /**
   * Applies a filter and changes the visibility of the component's nodes accordingly.
   */
  set filter(term) {
    this.handleFilterChange(term);
  }
  constructor(component) {
    this.component = component;
  }
  /**
   * @hidden
   */
  handleFilterChange(term) {
    if (!this.filterData) {
      return;
    }
    this.resetNodesVisibility(this.filterData);
    if (term) {
      filterTree(this.filterData, term, this.filterSettings, this.component.textField);
    }
    this.updateVisibleNodes(this.filterData);
    if (isPresent6(this.component.filterStateChange)) {
      this.component.filterStateChange.emit({
        nodes: this.filterData,
        matchCount: this.visibleNodes.size,
        term,
        filterSettings: this.filterSettings
      });
    }
  }
  updateVisibleNodes(items) {
    items.forEach((wrapper) => {
      if (wrapper.visible) {
        this.visibleNodes.add(wrapper.dataItem);
      }
      if (wrapper.children) {
        this.updateVisibleNodes(wrapper.children);
      }
    });
  }
  resetNodesVisibility(items) {
    this.visibleNodes.clear();
    items.forEach((wrapper) => {
      wrapper.visible = true;
      if (wrapper.children) {
        this.resetNodesVisibility(wrapper.children);
      }
    });
  }
  static ɵfac = function FilteringBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilteringBase)(ɵɵdirectiveInject(DataBoundComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilteringBase,
    inputs: {
      filterSettings: "filterSettings",
      filter: "filter"
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilteringBase, [{
    type: Directive
  }], function() {
    return [{
      type: DataBoundComponent
    }];
  }, {
    filterSettings: [{
      type: Input
    }],
    filter: [{
      type: Input
    }]
  });
})();
var findChildren = (prop, nodes, value) => nodes.filter((x) => prop(x) === value);
var indexBuilder$1 = new IndexBuilderService();
var mapToTree = (currentLevelNodes, allNodes, parentIdField, idField, parent = null, parentIndex = "") => {
  if (!isArrayWithAtLeastOneItem(currentLevelNodes)) {
    return [];
  }
  return currentLevelNodes.map((node, idx2) => {
    const index = indexBuilder$1.nodeIndex(idx2.toString(), parentIndex);
    const wrapper = {
      dataItem: node,
      index,
      parent,
      visible: true
    };
    wrapper.children = mapToTree(findChildren(getter(parentIdField), allNodes || [], getter(idField)(node)), allNodes, parentIdField, idField, wrapper, index);
    return wrapper;
  });
};
var FlatDataBindingDirective = class _FlatDataBindingDirective extends FilteringBase {
  component;
  /**
   * The nodes which will be displayed by the TreeView.
   */
  set nodes(nodes) {
    this._nodes = nodes;
  }
  get nodes() {
    return this._nodes;
  }
  _nodes;
  /**
   * Represents the parent field whose value will be matched with the parent node.
   */
  parentIdField;
  /**
   * Represents the unique field which identifies a node.
   */
  idField;
  /**
   * @hidden
   */
  loadOnDemand = true;
  /**
   * @hidden
   * A callback which determines whether a TreeView node should be rendered as hidden.
   */
  set isVisible(fn) {
    this.component.isVisible = fn;
  }
  /**
   * @hidden
   */
  originalData = [];
  constructor(component) {
    super(component);
    this.component = component;
    this.component.isVisible = (node) => this.visibleNodes.has(node);
  }
  /**
   * @hidden
   */
  ngOnInit() {
    if (isPresent6(this.parentIdField) && isPresent6(this.idField)) {
      const fetchChildren2 = (node) => findChildren(getter(this.parentIdField), this.originalData || [], getter(this.idField)(node));
      this.component.hasChildren = (node) => fetchChildren2(node).length > 0;
      this.component.children = (node) => of(fetchChildren2(node));
      this.component.editService = new FlatEditingService(this);
      this.component.filterChange.subscribe(this.handleFilterChange.bind(this));
      if (this.component.filter) {
        this.handleFilterChange(this.component.filter);
      }
      if (!this.loadOnDemand && isPresent6(this.component.preloadChildNodes)) {
        this.component.preloadChildNodes();
      }
    }
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    if (isChanged("parentIdField", changes, false)) {
      this.nodes = this.originalData;
      this.updateNodes(this.originalData);
    }
    if (isChanged("nodes", changes, false)) {
      this.updateNodes(changes["nodes"].currentValue);
    }
    if (anyChanged(["nodes", "loadOnDemand"], changes) && !this.loadOnDemand && isPresent6(this.component.preloadChildNodes)) {
      this.component.preloadChildNodes();
    }
  }
  /**
   * @hidden
   */
  updateNodes(values) {
    this.originalData = values || [];
    if (!isNullOrEmptyString(this.parentIdField)) {
      const prop = getter(this.parentIdField);
      this.component.nodes = this.originalData.filter(compose(isBlank, prop));
      this.filterData = mapToTree(this.component.nodes, this.originalData, this.parentIdField, this.idField);
      this.updateVisibleNodes(this.filterData);
    } else {
      this.component.nodes = this.originalData.slice(0);
    }
  }
  static ɵfac = function FlatDataBindingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FlatDataBindingDirective)(ɵɵdirectiveInject(DataBoundComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FlatDataBindingDirective,
    selectors: [["", "kendoTreeViewFlatDataBinding", ""]],
    inputs: {
      nodes: "nodes",
      parentIdField: "parentIdField",
      idField: "idField",
      loadOnDemand: "loadOnDemand",
      isVisible: "isVisible"
    },
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FlatDataBindingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewFlatDataBinding]",
      standalone: true
    }]
  }], function() {
    return [{
      type: DataBoundComponent
    }];
  }, {
    nodes: [{
      type: Input
    }],
    parentIdField: [{
      type: Input
    }],
    idField: [{
      type: Input
    }],
    loadOnDemand: [{
      type: Input
    }],
    isVisible: [{
      type: Input
    }]
  });
})();
var HierarchyEditingService = class {
  hierarchyBinding;
  movedItemNewIndex;
  constructor(hierarchyBinding) {
    this.hierarchyBinding = hierarchyBinding;
  }
  add({
    sourceItem,
    destinationItem,
    dropPosition,
    sourceTree,
    destinationTree
  }) {
    const clonedSourceDataItem = Object.assign({}, getDataItem(sourceItem));
    if (dropPosition === DropPosition.Over) {
      expandDropTarget(destinationItem, destinationTree);
      const destinationChildren = this.childrenFor(getDataItem(destinationItem));
      const targetIndex = isPresent6(destinationTree.loadMoreService) ? Math.min(destinationTree.loadMoreService.getGroupSize(getDataItem(destinationItem)), destinationChildren.length) : (
        // the page size might be greater than the actual children array length
        destinationChildren.length
      );
      destinationChildren.splice(targetIndex, 0, clonedSourceDataItem);
      setter(this.hierarchyBinding.childrenField)(getDataItem(destinationItem), destinationChildren);
      this.movedItemNewIndex = buildTreeIndex(destinationItem.item.index, targetIndex);
    } else {
      const destinationParentNodes = this.getParentNodes(destinationItem, destinationTree);
      const shiftIndex = dropPosition === DropPosition.After ? 1 : 0;
      const targetIndex = destinationParentNodes.indexOf(getDataItem(destinationItem)) + shiftIndex;
      destinationParentNodes.splice(targetIndex, 0, clonedSourceDataItem);
      const parentIndex = destinationItem.parent ? destinationItem.parent.item.index : null;
      this.movedItemNewIndex = buildTreeIndex(parentIndex, targetIndex);
    }
    const updatedParent = dropPosition === DropPosition.Over ? getDataItem(destinationItem) : getDataItem(destinationItem.parent);
    incrementPageSize(destinationTree, updatedParent);
    copyPageSize(destinationTree, getDataItem(sourceItem), clonedSourceDataItem);
    if (sourceTree !== destinationTree && !destinationTree.loadOnDemand) {
      destinationTree.preloadChildNodes();
    }
    if (sourceTree !== destinationTree) {
      destinationTree.changeDetectorRef.detectChanges();
      destinationTree.focus(this.movedItemNewIndex);
    }
  }
  remove({
    sourceItem,
    sourceTree,
    destinationTree
  }) {
    const sourceParentNodes = this.getParentNodes(sourceItem, sourceTree);
    const sourceItemIndex = sourceParentNodes.indexOf(getDataItem(sourceItem));
    sourceParentNodes.splice(sourceItemIndex, 1);
    collapseEmptyParent(sourceItem.parent, sourceParentNodes, sourceTree);
    decrementPageSize(sourceTree, getDataItem(sourceItem.parent));
    if (!sourceTree.loadOnDemand) {
      sourceTree.preloadChildNodes();
    }
    if (sourceTree === destinationTree) {
      destinationTree.changeDetectorRef.detectChanges();
      const index = updateMovedItemIndex(this.movedItemNewIndex, sourceItem.item.index);
      destinationTree.focus(index);
    }
  }
  getParentNodes(node, treeView) {
    return isPresent6(node.parent) ? this.childrenFor(getDataItem(node.parent)) : treeView.nodes;
  }
  childrenFor(dataItem) {
    return getter(this.hierarchyBinding.childrenField)(dataItem) || [];
  }
};
var indexBuilder = new IndexBuilderService();
var mapToWrappers = (currentLevelNodes, childrenField, parent = null, parentIndex = "") => {
  if (!isArrayWithAtLeastOneItem(currentLevelNodes)) {
    return [];
  }
  return currentLevelNodes.map((node, idx2) => {
    const index = indexBuilder.nodeIndex(idx2.toString(), parentIndex);
    const wrapper = {
      dataItem: node,
      index,
      parent,
      visible: true
    };
    wrapper.children = mapToWrappers(getter(childrenField)(node), childrenField, wrapper, index);
    return wrapper;
  });
};
var HierarchyBindingDirective = class _HierarchyBindingDirective extends FilteringBase {
  component;
  dragAndDropDirective;
  /**
   * The field name which holds the data items of the child component.
   */
  set childrenField(value) {
    if (!value) {
      throw new Error("'childrenField' cannot be empty");
    }
    this._childrenField = value;
  }
  /**
   * The field name which holds the data items of the child component.
   */
  get childrenField() {
    return this._childrenField;
  }
  /**
   * The nodes which will be displayed by the TreeView.
   */
  set nodes(nodes) {
    this._nodes = nodes;
  }
  get nodes() {
    return this._nodes;
  }
  _nodes;
  /**
   * @hidden
   * A callback which determines whether a TreeView node should be rendered as hidden.
   */
  set isVisible(fn) {
    this.component.isVisible = fn;
  }
  /**
   * @hidden
   */
  loadOnDemand = true;
  _childrenField;
  originalData = [];
  constructor(component, dragAndDropDirective) {
    super(component);
    this.component = component;
    this.dragAndDropDirective = dragAndDropDirective;
    const shouldFilter = !isPresent6(this.dragAndDropDirective);
    this.component.isVisible = shouldFilter ? (node) => this.visibleNodes.has(node) : isVisible2;
  }
  ngOnInit() {
    if (isPresent6(this.childrenField)) {
      this.component.children = (item) => of(getter(this.childrenField)(item));
      this.component.hasChildren = (item) => {
        const children = getter(this.childrenField)(item);
        return Boolean(children && children.length);
      };
      this.component.editService = new HierarchyEditingService(this);
      this.component.filterChange.subscribe(this.handleFilterChange.bind(this));
      if (this.component.filter) {
        this.handleFilterChange(this.component.filter);
      }
      if (!this.loadOnDemand && isPresent6(this.component.preloadChildNodes)) {
        this.component.preloadChildNodes();
      }
    }
  }
  ngOnChanges(changes) {
    if (isChanged("childrenField", changes, false)) {
      this.nodes = this.originalData;
      this.updateNodes(this.originalData);
    }
    if (isChanged("nodes", changes, false)) {
      this.updateNodes(changes["nodes"].currentValue);
    }
    if (anyChanged(["nodes", "loadOnDemand"], changes) && !this.loadOnDemand && isPresent6(this.component.preloadChildNodes)) {
      this.component.preloadChildNodes();
    }
  }
  /**
   * @hidden
   */
  updateNodes(values) {
    this.originalData = values || [];
    this.filterData = mapToWrappers(values, this.childrenField) || [];
    this.updateVisibleNodes(this.filterData);
  }
  static ɵfac = function HierarchyBindingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HierarchyBindingDirective)(ɵɵdirectiveInject(DataBoundComponent), ɵɵdirectiveInject(DragAndDropDirective, 9));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _HierarchyBindingDirective,
    selectors: [["", "kendoTreeViewHierarchyBinding", ""]],
    inputs: {
      childrenField: "childrenField",
      nodes: "nodes",
      isVisible: "isVisible",
      loadOnDemand: "loadOnDemand"
    },
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HierarchyBindingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewHierarchyBinding]",
      standalone: true
    }]
  }], function() {
    return [{
      type: DataBoundComponent
    }, {
      type: DragAndDropDirective,
      decorators: [{
        type: Optional
      }, {
        type: Host
      }]
    }];
  }, {
    childrenField: [{
      type: Input
    }],
    nodes: [{
      type: Input
    }],
    isVisible: [{
      type: Input
    }],
    loadOnDemand: [{
      type: Input
    }]
  });
})();
var LOAD_MORE_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/treeview/load-more-button/";
var LoadMoreDirective = class _LoadMoreDirective {
  treeview;
  /**
   * Specifies the callback that will be called when the load more button is clicked.
   * Providing a function is only required when additional nodes are fetched on demand
   * ([see example]({% slug loadmorebutton_treeview %}#toc-remote-data)).
   */
  set loadMoreNodes(loadMoreNodes) {
    if (typeof loadMoreNodes === "string") {
      return;
    }
    this.treeview.loadMoreService.loadMoreNodes = loadMoreNodes;
  }
  /**
   * Specifies the initial number of nodes that will be rendered on each level.
   * Every time the load more button is clicked, the data item page size will be incremented with this number.
   */
  pageSize;
  /**
   * Specifies the total number of root nodes.
   * Used when additional nodes are fetched on demand
   * ([see example]({% slug loadmorebutton_treeview %}#toc-remote-data)).
   */
  totalRootNodes;
  /**
   * Specifies which field holds information about the total number of child nodes of the data item.
   * Used when additional nodes are fetched on demand
   * ([see example]({% slug loadmorebutton_treeview %}#toc-remote-data)).
   */
  totalField;
  /**
   * Keeps track of the current page size of each node over expand/collapse cycles.
   */
  pageSizes = /* @__PURE__ */ new Map();
  /**
   * Used as an identifier for the root page size as the root collection of nodes is not associated with a data item.
   */
  rootLevelId = guid();
  constructor(treeview) {
    this.treeview = treeview;
    this.treeview.loadMoreService = {
      getInitialPageSize: this.getInitalPageSize.bind(this),
      getGroupSize: this.getGroupSize.bind(this),
      setGroupSize: this.setGroupSize.bind(this),
      getTotalNodesCount: this.getTotalNodesCount.bind(this)
    };
  }
  ngOnChanges() {
    this.verifySettings();
  }
  verifySettings() {
    if (!isDevMode()) {
      return;
    }
    if (!isPresent6(this.pageSize)) {
      throw new Error(`To use the TreeView \`kendoTreeViewLoadMore\` directive, you need to assign a \`pageSize\` value. See ${LOAD_MORE_DOC_LINK}.`);
    }
    const loadMoreNodes = this.treeview.loadMoreService.loadMoreNodes;
    if (isPresent6(loadMoreNodes) && typeof loadMoreNodes !== "function") {
      throw new Error(`The passed value to the \`kendoTreeViewLoadMore\` directive must be a function that retrieves additional nodes. See ${LOAD_MORE_DOC_LINK}.`);
    }
    if (isPresent6(loadMoreNodes) && !isPresent6(this.totalField)) {
      throw new Error(`When a function to fetch additional nodes is provided to the \`kendoTreeViewLoadMore\` directive, the \`totalField\` and \`totalRootNodes\` values must also be provided. See ${LOAD_MORE_DOC_LINK}.`);
    }
  }
  getGroupSize(dataItem) {
    const itemKey = dataItem || this.rootLevelId;
    return this.pageSizes.has(itemKey) ? this.pageSizes.get(itemKey) : this.pageSize;
  }
  setGroupSize(dataItem, pageSize) {
    const itemKey = dataItem || this.rootLevelId;
    const normalizedSizeValue = pageSize > 0 ? pageSize : 0;
    this.pageSizes.set(itemKey, normalizedSizeValue);
  }
  getTotalNodesCount(dataItem, loadedNodesCount) {
    if (isPresent6(dataItem) && isPresent6(this.totalField)) {
      return dataItem[this.totalField];
    } else if (!isPresent6(dataItem) && isPresent6(this.totalRootNodes)) {
      return this.totalRootNodes;
    } else {
      return loadedNodesCount;
    }
  }
  getInitalPageSize() {
    return this.pageSize;
  }
  static ɵfac = function LoadMoreDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LoadMoreDirective)(ɵɵdirectiveInject(TreeViewComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LoadMoreDirective,
    selectors: [["", "kendoTreeViewLoadMore", ""]],
    inputs: {
      loadMoreNodes: [0, "kendoTreeViewLoadMore", "loadMoreNodes"],
      pageSize: "pageSize",
      totalRootNodes: "totalRootNodes",
      totalField: "totalField"
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LoadMoreDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewLoadMore]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TreeViewComponent
    }];
  }, {
    loadMoreNodes: [{
      type: Input,
      args: ["kendoTreeViewLoadMore"]
    }],
    pageSize: [{
      type: Input
    }],
    totalRootNodes: [{
      type: Input
    }],
    totalField: [{
      type: Input
    }]
  });
})();
var CustomMessagesComponent2 = class _CustomMessagesComponent extends TreeViewMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function CustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CustomMessagesComponent,
    selectors: [["kendo-treeview-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: TreeViewMessages,
      useExisting: forwardRef(() => _CustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function CustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CustomMessagesComponent2, [{
    type: Component,
    args: [{
      providers: [{
        provide: TreeViewMessages,
        useExisting: forwardRef(() => CustomMessagesComponent2)
      }],
      selector: "kendo-treeview-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var SelectDirective = class _SelectDirective {
  treeView;
  navigationService;
  /**
   * @hidden
   */
  set isSelected(value) {
    this.treeView.isSelected = value;
  }
  /**
   * Defines the item key that will be stored in the `selectedKeys` collection.
   */
  selectKey;
  /**
   * Defines the current selection mode
   * ([see example](slug:selection_treeview#toc-modes)).
   */
  selection;
  /**
   * Defines the collection that will store the selected keys
   * ([see example](slug:selection_treeview#toc-modes)).
   */
  selectedKeys;
  /**
   * Fires when the `selectedKeys` collection was updated.
   */
  selectedKeysChange = new EventEmitter();
  get getAriaMultiselectable() {
    return this.options.mode === "multiple";
  }
  subscriptions = new Subscription();
  get options() {
    const defaultOptions = {
      enabled: true,
      mode: "single"
    };
    if (!isPresent6(this.selection) || typeof this.selection === "string") {
      return defaultOptions;
    }
    const selectionSettings = isBoolean(this.selection) ? {
      enabled: this.selection
    } : this.selection;
    return Object.assign(defaultOptions, selectionSettings);
  }
  selectActions = {
    "multiple": (e) => this.selectMultiple(e),
    "single": (e) => this.selectSingle(e)
  };
  /**
   * Reflectes the internal `selectedKeys` state.
   */
  state = /* @__PURE__ */ new Set();
  /**
   * Holds the last emitted `selectedKeys` collection.
   */
  lastChange;
  constructor(treeView, navigationService) {
    this.treeView = treeView;
    this.navigationService = navigationService;
    this.subscriptions.add(this.treeView.selectionChange.subscribe(this.select.bind(this)));
    this.treeView.isSelected = (dataItem, index) => this.state.has(this.itemKey({
      dataItem,
      index
    }));
    this.navigationService.deselectAllButCurrentItem.subscribe((node) => {
      this.selectSingle(node);
    });
  }
  ngOnChanges(changes) {
    if (isChanged("selectedKeys", changes, false) && changes["selectedKeys"].currentValue !== this.lastChange) {
      this.state = new Set(changes["selectedKeys"].currentValue);
    }
    const isSelectionBooleanTrue = typeof this.selection === "boolean" && this.selection;
    this.navigationService.selection = isSelectionBooleanTrue ? "single" : this.selection?.mode;
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  itemKey(e) {
    if (!this.selectKey) {
      return e.index;
    }
    if (typeof this.selectKey === "string") {
      return e.dataItem[this.selectKey];
    }
    if (typeof this.selectKey === "function") {
      return this.selectKey(e);
    }
  }
  select(e) {
    const {
      enabled,
      mode
    } = this.options;
    const performSelection = this.selectActions[mode] || noop5;
    if (!enabled) {
      return;
    }
    performSelection(e);
  }
  selectSingle(node) {
    const key = this.itemKey(node);
    if (!this.state.has(key)) {
      this.state.clear();
      this.state.add(key);
      this.notify();
    }
  }
  selectMultiple(node) {
    const key = this.itemKey(node);
    const isSelected2 = this.state.has(key);
    if (!isPresent6(key)) {
      return;
    }
    if (isSelected2) {
      this.state.delete(key);
    } else {
      this.state.add(key);
    }
    this.notify();
  }
  notify() {
    this.lastChange = Array.from(this.state);
    this.selectedKeysChange.emit(this.lastChange);
  }
  static ɵfac = function SelectDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SelectDirective)(ɵɵdirectiveInject(TreeViewComponent), ɵɵdirectiveInject(NavigationService2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SelectDirective,
    selectors: [["", "kendoTreeViewSelectable", ""]],
    hostVars: 1,
    hostBindings: function SelectDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-multiselectable", ctx.getAriaMultiselectable);
      }
    },
    inputs: {
      isSelected: "isSelected",
      selectKey: [0, "selectBy", "selectKey"],
      selection: [0, "kendoTreeViewSelectable", "selection"],
      selectedKeys: "selectedKeys"
    },
    outputs: {
      selectedKeysChange: "selectedKeysChange"
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewSelectable]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TreeViewComponent
    }, {
      type: NavigationService2
    }];
  }, {
    isSelected: [{
      type: Input
    }],
    selectKey: [{
      type: Input,
      args: ["selectBy"]
    }],
    selection: [{
      type: Input,
      args: ["kendoTreeViewSelectable"]
    }],
    selectedKeys: [{
      type: Input
    }],
    selectedKeysChange: [{
      type: Output
    }],
    getAriaMultiselectable: [{
      type: HostBinding,
      args: ["attr.aria-multiselectable"]
    }]
  });
})();
var KENDO_TREEVIEW = [TreeViewComponent, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, HierarchyBindingDirective, FlatDataBindingDirective, DragAndDropDirective, DragClueTemplateDirective, DropHintTemplateDirective, DragAndDropEditingDirective, LoadMoreDirective, LoadMoreButtonTemplateDirective, CustomMessagesComponent2];
var TreeViewModule = class _TreeViewModule {
  static ɵfac = function TreeViewModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TreeViewModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _TreeViewModule,
    imports: [TreeViewComponent, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, HierarchyBindingDirective, FlatDataBindingDirective, DragAndDropDirective, DragClueTemplateDirective, DropHintTemplateDirective, DragAndDropEditingDirective, LoadMoreDirective, LoadMoreButtonTemplateDirective, CustomMessagesComponent2],
    exports: [TreeViewComponent, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, HierarchyBindingDirective, FlatDataBindingDirective, DragAndDropDirective, DragClueTemplateDirective, DropHintTemplateDirective, DragAndDropEditingDirective, LoadMoreDirective, LoadMoreButtonTemplateDirective, CustomMessagesComponent2]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService],
    imports: [TreeViewComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeViewModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_TREEVIEW],
      exports: [...KENDO_TREEVIEW],
      providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-angular-dropdowns/fesm2022/progress-kendo-angular-dropdowns.mjs
var _c06 = ["kendoSearchbar", ""];
var _c111 = ["content"];
var _c211 = ["list"];
var _c311 = ["virtualContainer"];
var _c411 = (a0, a1, a2) => ({
  "height.px": a0,
  "minHeight.px": a1,
  "boxSizing": a2
});
var _c511 = (a0, a1) => ({
  templateRef: a0,
  $implicit: a1
});
var _c610 = (a0, a1) => ({
  "k-disabled": a0,
  "k-table-alt-row": a1
});
function ListComponent_div_0_1_ng_template_0_Template(rf, ctx) {
}
function ListComponent_div_0_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ListComponent_div_0_1_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction2(1, _c511, ctx_r1.fixedGroupTemplate.templateRef, ctx_r1.currentGroup));
  }
}
function ListComponent_div_0_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap(ctx_r1.listGroupStickyHeaderTextClass);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.currentGroup);
  }
}
function ListComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10);
    ɵɵtemplate(1, ListComponent_div_0_1_Template, 1, 4, null, 7)(2, ListComponent_div_0_ng_template_2_Template, 2, 3, "ng-template", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1.listGroupStickyHeaderClass);
    ɵɵproperty("ngStyle", ɵɵpureFunction3(5, _c411, ctx_r1.virtual == null ? null : ctx_r1.virtual.itemHeight, ctx_r1.virtual == null ? null : ctx_r1.virtual.itemHeight, ctx_r1.virtual ? "border-box" : "inherit"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.fixedGroupTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.fixedGroupTemplate);
  }
}
function ListComponent_5_ng_template_0_input_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "input", 16);
    ɵɵlistener("change", function ListComponent_5_ng_template_0_input_1_Template_input_change_0_listener($event) {
      ɵɵrestoreView(_r3);
      const itemIndex_r4 = ɵɵnextContext().index;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onCheckedChange($event, itemIndex_r4 + ctx_r1.startFrom));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const itemIndex_r4 = ɵɵnextContext().index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ctx_r1.checkboxClasses)("checked", ctx_r1.isChecked(itemIndex_r4));
  }
}
function ListComponent_5_ng_template_0_2_ng_template_0_Template(rf, ctx) {
}
function ListComponent_5_ng_template_0_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ListComponent_5_ng_template_0_2_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const dataItem_r5 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction2(1, _c511, ctx_r1.template.templateRef, dataItem_r5));
  }
}
function ListComponent_5_ng_template_0_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 17);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const dataItem_r5 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.getText(dataItem_r5));
  }
}
function ListComponent_5_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 14);
    ɵɵtemplate(1, ListComponent_5_ng_template_0_input_1_Template, 1, 2, "input", 15)(2, ListComponent_5_ng_template_0_2_Template, 1, 4, null, 7)(3, ListComponent_5_ng_template_0_ng_template_3_Template, 2, 1, "ng-template", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    let tmp_7_0;
    const itemIndex_r4 = ctx.index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap(ctx_r1.listItemClass);
    ɵɵstyleProp("width", (tmp_7_0 = ctx_r1.rowWidth) !== null && tmp_7_0 !== void 0 ? tmp_7_0 : null, "px");
    ɵɵproperty("checkboxes", ctx_r1.checkboxes)("height", ctx_r1.virtual == null ? null : ctx_r1.virtual.itemHeight)("index", itemIndex_r4 + ctx_r1.startFrom)("multipleSelection", ctx_r1.multipleSelection)("ngClass", ɵɵpureFunction2(15, _c610, ctx_r1.isDisabled(itemIndex_r4), ctx_r1.isAltRow(itemIndex_r4)));
    ɵɵattribute("id", ctx_r1.optionPrefix + "-" + itemIndex_r4)("tabIndex", -1)("aria-selected", ctx_r1.isItemSelected(itemIndex_r4));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.checkboxes.enabled);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.template);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.template);
  }
}
function ListComponent_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ListComponent_5_ng_template_0_Template, 4, 18, "ng-template", 13);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngForOf", ctx_r1.data);
  }
}
function ListComponent_6_ng_template_0_li_0_3_ng_template_0_Template(rf, ctx) {
}
function ListComponent_6_ng_template_0_li_0_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ListComponent_6_ng_template_0_li_0_3_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const dataItem_r6 = ɵɵnextContext(2).$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction2(1, _c511, ctx_r1.groupTemplate.templateRef, dataItem_r6.value));
  }
}
function ListComponent_6_ng_template_0_li_0_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const dataItem_r6 = ɵɵnextContext(2).$implicit;
    ɵɵtextInterpolate(dataItem_r6.value);
  }
}
function ListComponent_6_ng_template_0_li_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 20, 2)(2, "span");
    ɵɵtemplate(3, ListComponent_6_ng_template_0_li_0_3_Template, 1, 4, null, 7)(4, ListComponent_6_ng_template_0_li_0_ng_template_4_Template, 1, 1, "ng-template", 11);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    let tmp_9_0;
    const ctx_r6 = ɵɵnextContext();
    const dataItem_r6 = ctx_r6.$implicit;
    const itemIndex_r8 = ctx_r6.index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap(ctx_r1.listGroupItemClass);
    ɵɵstyleProp("width", (tmp_9_0 = ctx_r1.rowWidth) !== null && tmp_9_0 !== void 0 ? tmp_9_0 : null, "px");
    ɵɵclassProp("k-table-alt-row", ctx_r1.isAltRow(itemIndex_r8 - 1));
    ɵɵproperty("ngStyle", ɵɵpureFunction3(14, _c411, ctx_r1.virtual == null ? null : ctx_r1.virtual.itemHeight, ctx_r1.virtual == null ? null : ctx_r1.virtual.itemHeight, ctx_r1.virtual ? "border-box" : "inherit"));
    ɵɵattribute("group-index", dataItem_r6.index)("id", ctx_r1.optionPrefix + "-" + dataItem_r6.groupIndex + "-" + dataItem_r6.value.toString().split(" ").join(""))("tabIndex", -1);
    ɵɵadvance(2);
    ɵɵclassMap(ctx_r1.listGroupItemTextClass);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.groupTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.groupTemplate);
  }
}
function ListComponent_6_ng_template_0_li_1_2_ng_template_0_Template(rf, ctx) {
}
function ListComponent_6_ng_template_0_li_1_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ListComponent_6_ng_template_0_li_1_2_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const dataItem_r6 = ɵɵnextContext(2).$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction2(1, _c511, ctx_r1.template.templateRef, dataItem_r6.value));
  }
}
function ListComponent_6_ng_template_0_li_1_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 17);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const dataItem_r6 = ɵɵnextContext(2).$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.getText(dataItem_r6.value));
  }
}
function ListComponent_6_ng_template_0_li_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 21, 2);
    ɵɵtemplate(2, ListComponent_6_ng_template_0_li_1_2_Template, 1, 4, null, 7)(3, ListComponent_6_ng_template_0_li_1_ng_template_3_Template, 2, 1, "ng-template", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    let tmp_9_0;
    const ctx_r6 = ɵɵnextContext();
    const dataItem_r6 = ctx_r6.$implicit;
    const itemIndex_r8 = ctx_r6.index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap(ctx_r1.listItemClass);
    ɵɵstyleProp("width", (tmp_9_0 = ctx_r1.rowWidth) !== null && tmp_9_0 !== void 0 ? tmp_9_0 : null, "px");
    ɵɵproperty("height", ctx_r1.virtual == null ? null : ctx_r1.virtual.itemHeight)("index", dataItem_r6.offsetIndex)("multipleSelection", ctx_r1.multipleSelection)("ngClass", ɵɵpureFunction2(14, _c610, ctx_r1.isDisabled(dataItem_r6.offsetIndex), ctx_r1.isAltRow(itemIndex_r8 - 1)));
    ɵɵattribute("absolute-index", dataItem_r6.index)("id", ctx_r1.optionPrefix + "-" + (itemIndex_r8 - 1 - dataItem_r6.groupIndex))("tabIndex", -1)("aria-selected", ctx_r1.isItemSelected(dataItem_r6.offsetIndex));
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.template);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.template);
  }
}
function ListComponent_6_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ListComponent_6_ng_template_0_li_0_Template, 5, 18, "li", 18)(1, ListComponent_6_ng_template_0_li_1_Template, 4, 17, "li", 19);
  }
  if (rf & 2) {
    const dataItem_r6 = ctx.$implicit;
    ɵɵproperty("ngIf", dataItem_r6.header);
    ɵɵadvance();
    ɵɵproperty("ngIf", !dataItem_r6.header);
  }
}
function ListComponent_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ListComponent_6_ng_template_0_Template, 2, 2, "ng-template", 13);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngForOf", ctx_r1.data);
  }
}
function ListComponent_kendo_resize_sensor_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 22);
    ɵɵlistener("resize", function ListComponent_kendo_resize_sensor_7_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r9);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.listResize.emit());
    });
    ɵɵelementEnd();
  }
}
function ListComponent_div_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 23, 3)(2, "div")(3, "kendo-resize-sensor", 22);
    ɵɵlistener("resize", function ListComponent_div_8_Template_kendo_resize_sensor_resize_3_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.listResize.emit());
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵstyleProp("height", ctx_r1.scrollHeight, "px");
  }
}
var _c74 = ["actionSheetSearchBar"];
var _c84 = (a0) => ({
  duration: a0
});
function ResponsiveRendererComponent_ng_template_2_kendo_textbox_10_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon", 19);
  }
}
function ResponsiveRendererComponent_ng_template_2_kendo_textbox_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-textbox", 17, 1);
    ɵɵlistener("valueChange", function ResponsiveRendererComponent_ng_template_2_kendo_textbox_10_Template_kendo_textbox_valueChange_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onValueChange($event));
    });
    ɵɵtemplate(2, ResponsiveRendererComponent_ng_template_2_kendo_textbox_10_ng_template_2_Template, 1, 0, "ng-template", 18);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("value", ctx_r2.searchBarValue)("size", ctx_r2.size);
  }
}
function ResponsiveRendererComponent_ng_template_2_ng_container_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function ResponsiveRendererComponent_ng_template_2_div_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 20)(1, "button", 21);
    ɵɵlistener("click", function ResponsiveRendererComponent_ng_template_2_div_14_Template_button_click_1_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onCancel.emit());
    })("keydown.enter", function ResponsiveRendererComponent_ng_template_2_div_14_Template_button_keydown_enter_1_listener($event) {
      ɵɵrestoreView(_r5);
      return ɵɵresetView($event.stopImmediatePropagation());
    });
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "button", 22);
    ɵɵlistener("click", function ResponsiveRendererComponent_ng_template_2_div_14_Template_button_click_3_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onApply.emit());
    })("keydown.enter", function ResponsiveRendererComponent_ng_template_2_div_14_Template_button_keydown_enter_3_listener($event) {
      ɵɵrestoreView(_r5);
      return ɵɵresetView($event.stopImmediatePropagation());
    });
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("size", ctx_r2.size);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.messageFor("cancelButton"), " ");
    ɵɵadvance();
    ɵɵproperty("size", ctx_r2.size);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.messageFor("applyButton"), " ");
  }
}
function ResponsiveRendererComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 4)(1, "div", 5)(2, "div", 6)(3, "div", 7);
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 8);
    ɵɵtext(6);
    ɵɵelementEnd()();
    ɵɵelementStart(7, "div", 9)(8, "button", 10);
    ɵɵlistener("click", function ResponsiveRendererComponent_ng_template_2_Template_button_click_8_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleClose());
    });
    ɵɵelementEnd()()();
    ɵɵelementStart(9, "div", 11);
    ɵɵtemplate(10, ResponsiveRendererComponent_ng_template_2_kendo_textbox_10_Template, 3, 2, "kendo-textbox", 12);
    ɵɵelementEnd()();
    ɵɵelementStart(11, "div", 13)(12, "div", 14);
    ɵɵtemplate(13, ResponsiveRendererComponent_ng_template_2_ng_container_13_Template, 1, 0, "ng-container", 15);
    ɵɵelementEnd()();
    ɵɵtemplate(14, ResponsiveRendererComponent_ng_template_2_div_14_Template, 5, 4, "div", 16);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance(4);
    ɵɵtextInterpolate(ctx_r2.title);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r2.subtitle);
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r2.xIcon)("size", ctx_r2.size)("tabIndex", -1);
    ɵɵattribute("title", ctx_r2.messageFor("clearTitle"));
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r2.showTextInput);
    ɵɵadvance(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r2.sharedPopupActionSheetTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.showActionButtons);
  }
}
var _c94 = ["container"];
var _c104 = ["popupTemplate"];
var _c113 = ["optionsList"];
var _c123 = (a0) => ({
  templateRef: a0
});
function AutoCompleteComponent_span_2_ng_template_1_Template(rf, ctx) {
}
function AutoCompleteComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 14);
    ɵɵtemplate(1, AutoCompleteComponent_span_2_ng_template_1_Template, 0, 0, "ng-template", 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.prefixTemplate == null ? null : ctx_r1.prefixTemplate.templateRef);
  }
}
function AutoCompleteComponent_kendo_separator_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-separator");
  }
}
function AutoCompleteComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 16);
    ɵɵlistener("click", function AutoCompleteComponent_span_5_Template_span_click_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearValue($event));
    })("mousedown", function AutoCompleteComponent_span_5_Template_span_mousedown_0_listener($event) {
      ɵɵrestoreView(_r3);
      return ɵɵresetView($event.preventDefault());
    });
    ɵɵelement(1, "kendo-icon-wrapper", 17);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("visibility", ctx_r1.clearButtonVisiblity);
    ɵɵattribute("title", ctx_r1.messageFor("clearTitle"));
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.xIcon);
  }
}
function AutoCompleteComponent_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 18);
  }
}
function AutoCompleteComponent_kendo_separator_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-separator");
  }
}
function AutoCompleteComponent_span_8_ng_template_1_Template(rf, ctx) {
}
function AutoCompleteComponent_span_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 19);
    ɵɵtemplate(1, AutoCompleteComponent_span_8_ng_template_1_Template, 0, 0, "ng-template", 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.suffixTemplate == null ? null : ctx_r1.suffixTemplate.templateRef);
  }
}
function AutoCompleteComponent_ng_template_9_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function AutoCompleteComponent_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, AutoCompleteComponent_ng_template_9_ng_container_0_Template, 1, 0, "ng-container", 20);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const sharedPopupActionSheetTemplate_r4 = ɵɵreference(16);
    ɵɵproperty("ngTemplateOutlet", sharedPopupActionSheetTemplate_r4);
  }
}
function AutoCompleteComponent_kendo_resize_sensor_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 21);
    ɵɵlistener("resize", function AutoCompleteComponent_kendo_resize_sensor_13_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onResize());
    });
    ɵɵelementEnd();
  }
}
function AutoCompleteComponent_ng_template_15_0_ng_template_0_Template(rf, ctx) {
}
function AutoCompleteComponent_ng_template_15_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, AutoCompleteComponent_ng_template_15_0_ng_template_0_Template, 0, 0, "ng-template", 24);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c123, ctx_r1.headerTemplate.templateRef));
  }
}
function AutoCompleteComponent_ng_template_15_div_3_ng_template_1_Template(rf, ctx) {
}
function AutoCompleteComponent_ng_template_15_div_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.messageFor("noDataText"));
  }
}
function AutoCompleteComponent_ng_template_15_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 25);
    ɵɵtemplate(1, AutoCompleteComponent_ng_template_15_div_3_ng_template_1_Template, 0, 0, "ng-template", 26)(2, AutoCompleteComponent_ng_template_15_div_3_ng_template_2_Template, 2, 1, "ng-template", 27);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.noDataTemplate)("templateContext", ɵɵpureFunction1(3, _c123, ctx_r1.noDataTemplate == null ? null : ctx_r1.noDataTemplate.templateRef));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.noDataTemplate);
  }
}
function AutoCompleteComponent_ng_template_15_4_ng_template_0_Template(rf, ctx) {
}
function AutoCompleteComponent_ng_template_15_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, AutoCompleteComponent_ng_template_15_4_ng_template_0_Template, 0, 0, "ng-template", 24);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c123, ctx_r1.footerTemplate.templateRef));
  }
}
function AutoCompleteComponent_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵtemplate(0, AutoCompleteComponent_ng_template_15_0_Template, 1, 3, null, 7);
    ɵɵelementStart(1, "kendo-list", 22, 3);
    ɵɵlistener("pageChange", function AutoCompleteComponent_ng_template_15_Template_kendo_list_pageChange_1_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.pageChange($event));
    });
    ɵɵelementEnd();
    ɵɵtemplate(3, AutoCompleteComponent_ng_template_15_div_3_Template, 3, 5, "div", 23)(4, AutoCompleteComponent_ng_template_15_4_Template, 1, 3, null, 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.headerTemplate);
    ɵɵadvance();
    ɵɵproperty("size", ctx_r1.size)("rounded", ctx_r1.rounded)("id", ctx_r1.listBoxId)("optionPrefix", ctx_r1.optionPrefix)("data", ctx_r1.data)("textField", ctx_r1.valueField)("valueField", ctx_r1.valueField)("template", ctx_r1.template)("groupTemplate", ctx_r1.groupTemplate)("fixedGroupTemplate", ctx_r1.fixedGroupTemplate)("height", ctx_r1.listHeight)("show", ctx_r1.isOpen)("virtual", ctx_r1.virtual)("showStickyHeader", ctx_r1.showStickyHeader);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.data.length === 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.footerTemplate);
  }
}
var _c133 = ["select"];
var _c143 = (a0) => ({
  mousedown: a0
});
function ComboBoxComponent_span_2_ng_template_1_Template(rf, ctx) {
}
function ComboBoxComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 17);
    ɵɵtemplate(1, ComboBoxComponent_span_2_ng_template_1_Template, 0, 0, "ng-template", 18);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.prefixTemplate == null ? null : ctx_r1.prefixTemplate.templateRef);
  }
}
function ComboBoxComponent_kendo_separator_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-separator");
  }
}
function ComboBoxComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 19);
    ɵɵlistener("click", function ComboBoxComponent_span_5_Template_span_click_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearValue($event));
    });
    ɵɵelement(1, "kendo-icon-wrapper", 20);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("visibility", ctx_r1.clearButtonVisiblity);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(5, _c143, ctx_r1.preventEventDefault));
    ɵɵattribute("title", ctx_r1.messageFor("clearTitle"));
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.xIcon);
  }
}
function ComboBoxComponent_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 21);
  }
}
function ComboBoxComponent_kendo_separator_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-separator");
  }
}
function ComboBoxComponent_span_8_ng_template_1_Template(rf, ctx) {
}
function ComboBoxComponent_span_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 22);
    ɵɵtemplate(1, ComboBoxComponent_span_8_ng_template_1_Template, 0, 0, "ng-template", 18);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.suffixTemplate == null ? null : ctx_r1.suffixTemplate.templateRef);
  }
}
function ComboBoxComponent_ng_template_12_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function ComboBoxComponent_ng_template_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ComboBoxComponent_ng_template_12_ng_container_0_Template, 1, 0, "ng-container", 23);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const sharedPopupActionSheetTemplate_r4 = ɵɵreference(19);
    ɵɵproperty("ngTemplateOutlet", sharedPopupActionSheetTemplate_r4);
  }
}
function ComboBoxComponent_kendo_resize_sensor_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 24);
    ɵɵlistener("resize", function ComboBoxComponent_kendo_resize_sensor_14_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onResize());
    });
    ɵɵelementEnd();
  }
}
function ComboBoxComponent_ng_template_18_0_ng_template_0_Template(rf, ctx) {
}
function ComboBoxComponent_ng_template_18_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ComboBoxComponent_ng_template_18_0_ng_template_0_Template, 0, 0, "ng-template", 27);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c123, ctx_r1.headerTemplate.templateRef));
  }
}
function ComboBoxComponent_ng_template_18_div_3_ng_template_1_Template(rf, ctx) {
}
function ComboBoxComponent_ng_template_18_div_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.messageFor("noDataText"));
  }
}
function ComboBoxComponent_ng_template_18_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 28);
    ɵɵtemplate(1, ComboBoxComponent_ng_template_18_div_3_ng_template_1_Template, 0, 0, "ng-template", 29)(2, ComboBoxComponent_ng_template_18_div_3_ng_template_2_Template, 2, 1, "ng-template", 30);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.noDataTemplate)("templateContext", ɵɵpureFunction1(3, _c123, ctx_r1.noDataTemplate ? ctx_r1.noDataTemplate.templateRef : void 0));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.noDataTemplate);
  }
}
function ComboBoxComponent_ng_template_18_4_ng_template_0_Template(rf, ctx) {
}
function ComboBoxComponent_ng_template_18_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ComboBoxComponent_ng_template_18_4_ng_template_0_Template, 0, 0, "ng-template", 27);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c123, ctx_r1.footerTemplate.templateRef));
  }
}
function ComboBoxComponent_ng_template_18_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵtemplate(0, ComboBoxComponent_ng_template_18_0_Template, 1, 3, null, 8);
    ɵɵelementStart(1, "kendo-list", 25, 4);
    ɵɵlistener("pageChange", function ComboBoxComponent_ng_template_18_Template_kendo_list_pageChange_1_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.pageChange($event));
    });
    ɵɵelementEnd();
    ɵɵtemplate(3, ComboBoxComponent_ng_template_18_div_3_Template, 3, 5, "div", 26)(4, ComboBoxComponent_ng_template_18_4_Template, 1, 3, null, 8);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.headerTemplate);
    ɵɵadvance();
    ɵɵproperty("size", ctx_r1.size)("rounded", ctx_r1.rounded)("id", ctx_r1.listBoxId)("optionPrefix", ctx_r1.optionPrefix)("data", ctx_r1.data)("textField", ctx_r1.textField)("valueField", ctx_r1.valueField)("template", ctx_r1.template)("groupTemplate", ctx_r1.groupTemplate)("fixedGroupTemplate", ctx_r1.fixedGroupTemplate)("height", ctx_r1.listHeight)("show", ctx_r1.isOpen)("virtual", ctx_r1.virtual)("showStickyHeader", ctx_r1.showStickyHeader);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.data.length === 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.footerTemplate);
  }
}
var _c153 = (a0) => ({
  "k-disabled": a0
});
function DropDownListComponent_3_ng_template_0_Template(rf, ctx) {
}
function DropDownListComponent_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropDownListComponent_3_ng_template_0_Template, 0, 0, "ng-template", 15);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("templateContext", ɵɵpureFunction2(1, _c511, ctx_r1.valueTemplate.templateRef, ctx_r1.dataItem));
  }
}
function DropDownListComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵtextInterpolate(ctx_r1.getText());
  }
}
function DropDownListComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 16);
  }
}
function DropDownListComponent_ng_template_8_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function DropDownListComponent_ng_template_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropDownListComponent_ng_template_8_ng_container_0_Template, 1, 0, "ng-container", 17);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const sharedPopupActionSheetTemplate_r3 = ɵɵreference(15);
    ɵɵproperty("ngTemplateOutlet", sharedPopupActionSheetTemplate_r3);
  }
}
function DropDownListComponent_kendo_resize_sensor_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 18);
    ɵɵlistener("resize", function DropDownListComponent_kendo_resize_sensor_10_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onResize());
    });
    ɵɵelementEnd();
  }
}
function DropDownListComponent_ng_template_14_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 21);
    ɵɵlistener("click", function DropDownListComponent_ng_template_14_ng_template_0_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r6);
      return ɵɵresetView($event.stopImmediatePropagation());
    });
    ɵɵelementStart(1, "span", 22);
    ɵɵelement(2, "kendo-icon-wrapper", 23);
    ɵɵelementStart(3, "input", 24, 4);
    ɵɵtwoWayListener("ngModelChange", function DropDownListComponent_ng_template_14_ng_template_0_Template_input_ngModelChange_3_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r1.filterText, $event) || (ctx_r1.filterText = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("keydown", function DropDownListComponent_ng_template_14_ng_template_0_Template_input_keydown_3_listener($event) {
      ɵɵrestoreView(_r6);
      const searchInput_r7 = ɵɵreference(4);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.keydown($event, searchInput_r7));
    })("input", function DropDownListComponent_ng_template_14_ng_template_0_Template_input_input_3_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleFilter($event));
    })("focus", function DropDownListComponent_ng_template_14_ng_template_0_Template_input_focus_3_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onFilterFocus());
    })("blur", function DropDownListComponent_ng_template_14_ng_template_0_Template_input_blur_3_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.blurFilterInput());
    })("click", function DropDownListComponent_ng_template_14_ng_template_0_Template_input_click_3_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleClick());
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r1.filterInputClasses);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.searchIcon);
    ɵɵadvance();
    ɵɵproperty("filterInput", ctx_r1.isFocused && !ctx_r1.touchEnabled)("dir", ctx_r1.direction);
    ɵɵtwoWayProperty("ngModel", ctx_r1.filterText);
    ɵɵattribute("aria-controls", ctx_r1.listBoxId)("aria-label", ctx_r1.messageFor("filterInputLabel"));
  }
}
function DropDownListComponent_ng_template_14_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 25)(1, "div", 26);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ctx_r1.optionLabelSizeClass);
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction1(4, _c153, ctx_r1.isDisabledDefaultItem))("index", -1);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.getDefaultItemText(), " ");
  }
}
function DropDownListComponent_ng_template_14_ng_template_2_ng_template_2_Template(rf, ctx) {
}
function DropDownListComponent_ng_template_14_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 25)(1, "div", 26);
    ɵɵtemplate(2, DropDownListComponent_ng_template_14_ng_template_2_ng_template_2_Template, 0, 0, "ng-template", 15);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ctx_r1.optionLabelSizeClass);
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction1(4, _c153, ctx_r1.isDisabledDefaultItem))("index", -1);
    ɵɵadvance();
    ɵɵproperty("templateContext", ɵɵpureFunction2(6, _c511, ctx_r1.itemTemplate.templateRef, ctx_r1.defaultItem));
  }
}
function DropDownListComponent_ng_template_14_3_ng_template_0_Template(rf, ctx) {
}
function DropDownListComponent_ng_template_14_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropDownListComponent_ng_template_14_3_ng_template_0_Template, 0, 0, "ng-template", 15);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c123, ctx_r1.headerTemplate.templateRef));
  }
}
function DropDownListComponent_ng_template_14_div_6_ng_template_1_Template(rf, ctx) {
}
function DropDownListComponent_ng_template_14_div_6_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.messageFor("noDataText"));
  }
}
function DropDownListComponent_ng_template_14_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 27);
    ɵɵtemplate(1, DropDownListComponent_ng_template_14_div_6_ng_template_1_Template, 0, 0, "ng-template", 28)(2, DropDownListComponent_ng_template_14_div_6_ng_template_2_Template, 2, 1, "ng-template", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.noDataTemplate)("templateContext", ɵɵpureFunction1(3, _c123, ctx_r1.noDataTemplate ? ctx_r1.noDataTemplate.templateRef : void 0));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.noDataTemplate);
  }
}
function DropDownListComponent_ng_template_14_7_ng_template_0_Template(rf, ctx) {
}
function DropDownListComponent_ng_template_14_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropDownListComponent_ng_template_14_7_ng_template_0_Template, 0, 0, "ng-template", 15);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c123, ctx_r1.footerTemplate.templateRef));
  }
}
function DropDownListComponent_ng_template_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵtemplate(0, DropDownListComponent_ng_template_14_ng_template_0_Template, 5, 7, "ng-template", 9)(1, DropDownListComponent_ng_template_14_ng_template_1_Template, 3, 6, "ng-template", 9)(2, DropDownListComponent_ng_template_14_ng_template_2_Template, 3, 9, "ng-template", 9)(3, DropDownListComponent_ng_template_14_3_Template, 1, 3, null, 8);
    ɵɵelementStart(4, "kendo-list", 19, 3);
    ɵɵlistener("pageChange", function DropDownListComponent_ng_template_14_Template_kendo_list_pageChange_4_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.pageChange($event));
    });
    ɵɵelementEnd();
    ɵɵtemplate(6, DropDownListComponent_ng_template_14_div_6_Template, 3, 5, "div", 20)(7, DropDownListComponent_ng_template_14_7_Template, 1, 3, null, 8);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.filterable && !ctx_r1.isActionSheetExpanded);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.defaultItem && !ctx_r1.itemTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.defaultItem && ctx_r1.itemTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.headerTemplate);
    ɵɵadvance();
    ɵɵproperty("id", ctx_r1.listBoxId)("size", ctx_r1.size)("rounded", ctx_r1.rounded)("optionPrefix", ctx_r1.optionPrefix)("data", ctx_r1.data)("textField", ctx_r1.textField)("valueField", ctx_r1.valueField)("template", ctx_r1.itemTemplate)("groupTemplate", ctx_r1.groupTemplate)("fixedGroupTemplate", ctx_r1.fixedGroupTemplate)("height", ctx_r1.listHeight)("show", ctx_r1.isOpen)("virtual", ctx_r1.virtual)("ariaLive", ctx_r1.ariaLive)("showStickyHeader", ctx_r1.showStickyHeader);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.data.length === 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.footerTemplate);
  }
}
var _c163 = ["*"];
var _c173 = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) => ({
  "k-focus": a0,
  "k-disabled": a1,
  "k-chip-sm": a2,
  "k-chip-md": a3,
  "k-chip-lg": a4,
  "k-rounded-sm": a5,
  "k-rounded-md": a6,
  "k-rounded-lg": a7,
  "k-rounded-full": a8,
  "k-chip-solid k-chip-solid-base": a9,
  "k-chip-flat k-chip-flat-base": a10,
  "k-chip-outline k-chip-outline-base": a11
});
function TagListComponent_div_0_2_ng_template_0_Template(rf, ctx) {
}
function TagListComponent_div_0_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TagListComponent_div_0_2_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function TagListComponent_div_0_ng_template_3_1_ng_template_0_Template(rf, ctx) {
}
function TagListComponent_div_0_ng_template_3_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TagListComponent_div_0_ng_template_3_1_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const tag_r2 = ɵɵnextContext(2).$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("templateContext", ɵɵpureFunction2(1, _c511, ctx_r2.groupTemplate.templateRef, tag_r2));
  }
}
function TagListComponent_div_0_ng_template_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const tag_r2 = ɵɵnextContext(2).$implicit;
    ɵɵtextInterpolate2("", tag_r2.length, " ", tag_r2.length === 1 ? "item" : "items", " selected");
  }
}
function TagListComponent_div_0_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 9);
    ɵɵtemplate(1, TagListComponent_div_0_ng_template_3_1_Template, 1, 4, null, 10)(2, TagListComponent_div_0_ng_template_3_ng_template_2_Template, 1, 2, "ng-template", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.groupTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r2.groupTemplate);
  }
}
function TagListComponent_div_0_ng_template_5_1_ng_template_0_Template(rf, ctx) {
}
function TagListComponent_div_0_ng_template_5_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TagListComponent_div_0_ng_template_5_1_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const tag_r2 = ɵɵnextContext(2).$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("templateContext", ɵɵpureFunction2(1, _c511, ctx_r2.template.templateRef, tag_r2));
  }
}
function TagListComponent_div_0_ng_template_5_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    const tag_r2 = ctx_r3.$implicit;
    const index_r5 = ctx_r3.index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵtextInterpolate(ctx_r2.tagProp(tag_r2, ctx_r2.textField, index_r5));
  }
}
function TagListComponent_div_0_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 9);
    ɵɵtemplate(1, TagListComponent_div_0_ng_template_5_1_Template, 1, 4, null, 10)(2, TagListComponent_div_0_ng_template_5_ng_template_2_Template, 1, 1, "ng-template", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.template);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r2.template);
  }
}
function TagListComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3)(1, "span", 4);
    ɵɵtemplate(2, TagListComponent_div_0_2_Template, 1, 0, null, 5)(3, TagListComponent_div_0_ng_template_3_Template, 3, 2, "ng-template", null, 0, ɵɵtemplateRefExtractor)(5, TagListComponent_div_0_ng_template_5_Template, 3, 2, "ng-template", null, 1, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
    ɵɵelementStart(7, "span", 6)(8, "span", 7)(9, "kendo-icon-wrapper", 8);
    ɵɵlistener("mousedown", function TagListComponent_div_0_Template_kendo_icon_wrapper_mousedown_9_listener($event) {
      const ctx_r5 = ɵɵrestoreView(_r1);
      const tag_r2 = ctx_r5.$implicit;
      const index_r5 = ctx_r5.index;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.deleteTag($event, tag_r2, index_r5));
    });
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const tag_r2 = ctx.$implicit;
    const index_r5 = ctx.index;
    const groupTag_r7 = ɵɵreference(4);
    const singleTag_r8 = ɵɵreference(6);
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunctionV(9, _c173, [index_r5 === ctx_r2.focused, ctx_r2.isTagDisabled(tag_r2, index_r5), ctx_r2.size === "small", ctx_r2.size === "medium", ctx_r2.size === "large", ctx_r2.rounded === "small", ctx_r2.rounded === "medium", ctx_r2.rounded === "large", ctx_r2.rounded === "full", ctx_r2.fillMode === "solid", ctx_r2.fillMode === "flat", ctx_r2.fillMode === "outline"]));
    ɵɵattribute("id", ctx_r2.itemId(tag_r2, index_r5))("aria-selected", true)("role", "option");
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r2.isGroupTag(tag_r2))("ngIfThen", groupTag_r7)("ngIfElse", singleTag_r8);
    ɵɵadvance(6);
    ɵɵattribute("aria-hidden", index_r5 !== ctx_r2.focused);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r2.xCircleIcon);
  }
}
function MultiSelectComponent_span_2_ng_template_1_Template(rf, ctx) {
}
function MultiSelectComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 17);
    ɵɵtemplate(1, MultiSelectComponent_span_2_ng_template_1_Template, 0, 0, "ng-template", 18);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.prefixTemplate == null ? null : ctx_r1.prefixTemplate.templateRef);
  }
}
function MultiSelectComponent_kendo_separator_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-separator");
  }
}
function MultiSelectComponent_span_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 19);
    ɵɵlistener("mousedown", function MultiSelectComponent_span_7_Template_span_mousedown_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearAll($event));
    });
    ɵɵelement(1, "kendo-icon-wrapper", 20);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("visibility", ctx_r1.clearButtonVisiblity);
    ɵɵattribute("title", ctx_r1.messageFor("clearTitle"));
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.xIcon);
  }
}
function MultiSelectComponent_span_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 21);
  }
}
function MultiSelectComponent_kendo_separator_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-separator");
  }
}
function MultiSelectComponent_span_10_ng_template_1_Template(rf, ctx) {
}
function MultiSelectComponent_span_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 22);
    ɵɵtemplate(1, MultiSelectComponent_span_10_ng_template_1_Template, 0, 0, "ng-template", 18);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.suffixTemplate == null ? null : ctx_r1.suffixTemplate.templateRef);
  }
}
function MultiSelectComponent_ng_template_11_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function MultiSelectComponent_ng_template_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiSelectComponent_ng_template_11_ng_container_0_Template, 1, 0, "ng-container", 23);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const sharedPopupActionSheetTemplate_r4 = ɵɵreference(18);
    ɵɵproperty("ngTemplateOutlet", sharedPopupActionSheetTemplate_r4);
  }
}
function MultiSelectComponent_kendo_resize_sensor_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 24);
    ɵɵlistener("resize", function MultiSelectComponent_kendo_resize_sensor_13_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onResize());
    });
    ɵɵelementEnd();
  }
}
function MultiSelectComponent_ng_template_17_0_ng_template_0_Template(rf, ctx) {
}
function MultiSelectComponent_ng_template_17_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiSelectComponent_ng_template_17_0_ng_template_0_Template, 0, 0, "ng-template", 28);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c123, ctx_r1.headerTemplate.templateRef));
  }
}
function MultiSelectComponent_ng_template_17_div_1_2_ng_template_0_Template(rf, ctx) {
}
function MultiSelectComponent_ng_template_17_div_1_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiSelectComponent_ng_template_17_div_1_2_ng_template_0_Template, 0, 0, "ng-template", 28);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("templateContext", ɵɵpureFunction2(1, _c511, ctx_r1.customItemTemplate.templateRef, ctx_r1.text));
  }
}
function MultiSelectComponent_ng_template_17_div_1_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵtextInterpolate(ctx_r1.text);
  }
}
function MultiSelectComponent_ng_template_17_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 29)(1, "div", 30);
    ɵɵtemplate(2, MultiSelectComponent_ng_template_17_div_1_2_Template, 1, 4, null, 31)(3, MultiSelectComponent_ng_template_17_div_1_ng_template_3_Template, 1, 1, "ng-template", null, 4, ɵɵtemplateRefExtractor);
    ɵɵelement(5, "kendo-icon-wrapper", 32);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const default_custom_item_template_r7 = ɵɵreference(4);
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ctx_r1.customItemSizeClass);
    ɵɵadvance();
    ɵɵproperty("multipleSelection", true)("index", -1);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.customItemTemplate)("ngIfElse", default_custom_item_template_r7);
    ɵɵadvance(3);
    ɵɵproperty("svgIcon", ctx_r1.plusIcon);
  }
}
function MultiSelectComponent_ng_template_17_div_4_ng_template_1_Template(rf, ctx) {
}
function MultiSelectComponent_ng_template_17_div_4_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.messageFor("noDataText"));
  }
}
function MultiSelectComponent_ng_template_17_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 33);
    ɵɵtemplate(1, MultiSelectComponent_ng_template_17_div_4_ng_template_1_Template, 0, 0, "ng-template", 34)(2, MultiSelectComponent_ng_template_17_div_4_ng_template_2_Template, 2, 1, "ng-template", 35);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.noDataTemplate)("templateContext", ɵɵpureFunction1(3, _c123, ctx_r1.noDataTemplate ? ctx_r1.noDataTemplate.templateRef : void 0));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.noDataTemplate);
  }
}
function MultiSelectComponent_ng_template_17_5_ng_template_0_Template(rf, ctx) {
}
function MultiSelectComponent_ng_template_17_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiSelectComponent_ng_template_17_5_ng_template_0_Template, 0, 0, "ng-template", 28);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c123, ctx_r1.footerTemplate.templateRef));
  }
}
function MultiSelectComponent_ng_template_17_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵtemplate(0, MultiSelectComponent_ng_template_17_0_Template, 1, 3, null, 8)(1, MultiSelectComponent_ng_template_17_div_1_Template, 6, 6, "div", 25);
    ɵɵelementStart(2, "kendo-list", 26, 3);
    ɵɵlistener("pageChange", function MultiSelectComponent_ng_template_17_Template_kendo_list_pageChange_2_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.pageChange($event));
    });
    ɵɵelementEnd();
    ɵɵtemplate(4, MultiSelectComponent_ng_template_17_div_4_Template, 3, 5, "div", 27)(5, MultiSelectComponent_ng_template_17_5_Template, 1, 3, null, 8);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.headerTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.allowCustom && ctx_r1.text);
    ɵɵadvance();
    ɵɵproperty("size", ctx_r1.size)("rounded", ctx_r1.rounded)("id", ctx_r1.listBoxId)("optionPrefix", ctx_r1.optionPrefix)("data", ctx_r1.data)("textField", ctx_r1.textField)("valueField", ctx_r1.valueField)("template", ctx_r1.template)("groupTemplate", ctx_r1.groupTemplate)("fixedGroupTemplate", ctx_r1.fixedGroupTemplate)("height", ctx_r1.listHeight)("show", ctx_r1.isOpen)("multipleSelection", true)("virtual", ctx_r1.virtual)("checkboxes", ctx_r1.checkboxes)("isMultiselect", true)("isActionSheetExpanded", ctx_r1.isActionSheetExpanded)("showStickyHeader", ctx_r1.showStickyHeader);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.data.length === 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.footerTemplate);
  }
}
var _c182 = ["header"];
var _c192 = ["headerTable"];
var _c202 = ["columnHeader"];
var _c212 = (a0, a1, a2) => ({
  templateRef: a0,
  $implicit: a1,
  column: a2
});
var _c223 = (a0, a1, a2, a3) => ({
  templateRef: a0,
  $implicit: a1,
  dataItem: a2,
  column: a3
});
function MultiColumnComboBoxComponent_span_2_ng_template_1_Template(rf, ctx) {
}
function MultiColumnComboBoxComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 22);
    ɵɵtemplate(1, MultiColumnComboBoxComponent_span_2_ng_template_1_Template, 0, 0, "ng-template", 23);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.prefixTemplate == null ? null : ctx_r1.prefixTemplate.templateRef);
  }
}
function MultiColumnComboBoxComponent_kendo_separator_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-separator");
  }
}
function MultiColumnComboBoxComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 24);
    ɵɵlistener("click", function MultiColumnComboBoxComponent_span_5_Template_span_click_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearValue($event));
    });
    ɵɵelement(1, "kendo-icon-wrapper", 25);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("visibility", ctx_r1.clearButtonVisiblity);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(5, _c143, ctx_r1.preventEventDefault));
    ɵɵattribute("title", ctx_r1.messageFor("clearTitle"));
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.xIcon);
  }
}
function MultiColumnComboBoxComponent_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 26);
  }
}
function MultiColumnComboBoxComponent_kendo_separator_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-separator");
  }
}
function MultiColumnComboBoxComponent_span_8_ng_template_1_Template(rf, ctx) {
}
function MultiColumnComboBoxComponent_span_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 27);
    ɵɵtemplate(1, MultiColumnComboBoxComponent_span_8_ng_template_1_Template, 0, 0, "ng-template", 23);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.suffixTemplate == null ? null : ctx_r1.suffixTemplate.templateRef);
  }
}
function MultiColumnComboBoxComponent_ng_template_12_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function MultiColumnComboBoxComponent_ng_template_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiColumnComboBoxComponent_ng_template_12_ng_container_0_Template, 1, 0, "ng-container", 28);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const sharedPopupActionSheetTemplate_r4 = ɵɵreference(19);
    ɵɵproperty("ngTemplateOutlet", sharedPopupActionSheetTemplate_r4);
  }
}
function MultiColumnComboBoxComponent_kendo_resize_sensor_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 29);
    ɵɵlistener("resize", function MultiColumnComboBoxComponent_kendo_resize_sensor_14_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onResize());
    });
    ɵɵelementEnd();
  }
}
function MultiColumnComboBoxComponent_ng_template_18_0_ng_template_0_Template(rf, ctx) {
}
function MultiColumnComboBoxComponent_ng_template_18_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiColumnComboBoxComponent_ng_template_18_0_ng_template_0_Template, 0, 0, "ng-template", 39);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c123, ctx_r1.headerTemplate == null ? null : ctx_r1.headerTemplate.templateRef));
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_container_9_col_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "col");
  }
  if (rf & 2) {
    const column_r7 = ɵɵnextContext().$implicit;
    ɵɵstyleProp("width", column_r7.width, "px");
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MultiColumnComboBoxComponent_ng_template_18_ng_container_9_col_1_Template, 1, 2, "col", 40);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r7 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", !column_r7.hidden && column_r7.matchesMedia);
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_container_12_th_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r8 = ɵɵnextContext(2).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", column_r8.title || column_r8.field, " ");
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_container_12_th_1_3_ng_template_0_Template(rf, ctx) {
}
function MultiColumnComboBoxComponent_ng_template_18_ng_container_12_th_1_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiColumnComboBoxComponent_ng_template_18_ng_container_12_th_1_3_ng_template_0_Template, 0, 0, "ng-template", 39);
  }
  if (rf & 2) {
    const column_r8 = ɵɵnextContext(2).$implicit;
    ɵɵproperty("templateContext", ɵɵpureFunction3(1, _c212, column_r8.headerTemplate == null ? null : column_r8.headerTemplate.templateRef, column_r8, column_r8));
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_container_12_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 42, 9);
    ɵɵtemplate(2, MultiColumnComboBoxComponent_ng_template_18_ng_container_12_th_1_ng_container_2_Template, 2, 1, "ng-container", 13)(3, MultiColumnComboBoxComponent_ng_template_18_ng_container_12_th_1_3_Template, 1, 5, null, 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r8 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngStyle", column_r8.headerStyle)("ngClass", column_r8.headerClass);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !column_r8.headerTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r8.headerTemplate);
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_container_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MultiColumnComboBoxComponent_ng_template_18_ng_container_12_th_1_Template, 4, 4, "th", 41);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r8 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", !column_r8.hidden && column_r8.matchesMedia);
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_template_13_ng_container_0_span_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r9 = ɵɵnextContext(2).$implicit;
    const dataItem_r10 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.textFrom(dataItem_r10, column_r9.field), " ");
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_template_13_ng_container_0_span_1_2_ng_template_0_Template(rf, ctx) {
}
function MultiColumnComboBoxComponent_ng_template_18_ng_template_13_ng_container_0_span_1_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiColumnComboBoxComponent_ng_template_18_ng_template_13_ng_container_0_span_1_2_ng_template_0_Template, 0, 0, "ng-template", 39);
  }
  if (rf & 2) {
    const column_r9 = ɵɵnextContext(2).$implicit;
    const dataItem_r10 = ɵɵnextContext().$implicit;
    ɵɵproperty("templateContext", ɵɵpureFunction4(1, _c223, column_r9.cellTemplate == null ? null : column_r9.cellTemplate.templateRef, dataItem_r10, dataItem_r10, column_r9));
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_template_13_ng_container_0_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 44);
    ɵɵtemplate(1, MultiColumnComboBoxComponent_ng_template_18_ng_template_13_ng_container_0_span_1_ng_container_1_Template, 2, 1, "ng-container", 13)(2, MultiColumnComboBoxComponent_ng_template_18_ng_template_13_ng_container_0_span_1_2_Template, 1, 6, null, 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r10 = ɵɵnextContext();
    const column_r9 = ctx_r10.$implicit;
    const i_r12 = ctx_r10.index;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵstyleProp("width", ctx_r1.getColumnWidth(i_r12), "px")("max-width", ctx_r1.getColumnWidth(i_r12), "px");
    ɵɵproperty("ngClass", column_r9.class)("ngStyle", column_r9.style);
    ɵɵadvance();
    ɵɵproperty("ngIf", !column_r9.cellTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r9.cellTemplate);
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_template_13_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MultiColumnComboBoxComponent_ng_template_18_ng_template_13_ng_container_0_span_1_Template, 3, 8, "span", 43);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r9 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", !column_r9.hidden && column_r9.matchesMedia);
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_template_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiColumnComboBoxComponent_ng_template_18_ng_template_13_ng_container_0_Template, 2, 1, "ng-container", 34);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngForOf", ctx_r1.columns);
  }
}
function MultiColumnComboBoxComponent_ng_template_18_div_17_ng_template_1_Template(rf, ctx) {
}
function MultiColumnComboBoxComponent_ng_template_18_div_17_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.messageFor("noDataText"));
  }
}
function MultiColumnComboBoxComponent_ng_template_18_div_17_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 45);
    ɵɵtemplate(1, MultiColumnComboBoxComponent_ng_template_18_div_17_ng_template_1_Template, 0, 0, "ng-template", 46)(2, MultiColumnComboBoxComponent_ng_template_18_div_17_ng_template_2_Template, 2, 1, "ng-template", 47);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.noDataTemplate)("templateContext", ɵɵpureFunction1(3, _c123, ctx_r1.noDataTemplate == null ? null : ctx_r1.noDataTemplate.templateRef));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.noDataTemplate);
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_container_18_ng_template_6_Template(rf, ctx) {
}
function MultiColumnComboBoxComponent_ng_template_18_ng_container_18_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 48)(2, "table", 49)(3, "tfoot", 50)(4, "tr", 36)(5, "td", 51);
    ɵɵtemplate(6, MultiColumnComboBoxComponent_ng_template_18_ng_container_18_ng_template_6_Template, 0, 0, "ng-template", 39);
    ɵɵelementEnd()()()()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance(6);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c123, ctx_r1.footerTemplate.templateRef));
  }
}
function MultiColumnComboBoxComponent_ng_template_18_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵtemplate(0, MultiColumnComboBoxComponent_ng_template_18_0_Template, 1, 3, null, 13);
    ɵɵelementStart(1, "div", 30)(2, "div", 31, 4)(4, "div", 32, 5)(6, "table", 33, 6)(8, "colgroup");
    ɵɵtemplate(9, MultiColumnComboBoxComponent_ng_template_18_ng_container_9_Template, 2, 1, "ng-container", 34);
    ɵɵelementEnd();
    ɵɵelementStart(10, "thead", 35)(11, "tr", 36);
    ɵɵtemplate(12, MultiColumnComboBoxComponent_ng_template_18_ng_container_12_Template, 2, 1, "ng-container", 34);
    ɵɵelementEnd()()()()();
    ɵɵtemplate(13, MultiColumnComboBoxComponent_ng_template_18_ng_template_13_Template, 1, 1, "ng-template", null, 7, ɵɵtemplateRefExtractor);
    ɵɵelementStart(15, "kendo-list", 37, 8);
    ɵɵlistener("pageChange", function MultiColumnComboBoxComponent_ng_template_18_Template_kendo_list_pageChange_15_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.pageChange($event));
    })("listResize", function MultiColumnComboBoxComponent_ng_template_18_Template_kendo_list_listResize_15_listener() {
      ɵɵrestoreView(_r6);
      const header_r13 = ɵɵreference(3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.updateHeaderPadding(header_r13));
    })("popupListScroll", function MultiColumnComboBoxComponent_ng_template_18_Template_kendo_list_popupListScroll_15_listener($event) {
      ɵɵrestoreView(_r6);
      const headerWrap_r14 = ɵɵreference(5);
      return ɵɵresetView(headerWrap_r14.scrollLeft = $event.target.scrollLeft);
    });
    ɵɵelementEnd();
    ɵɵtemplate(17, MultiColumnComboBoxComponent_ng_template_18_div_17_Template, 3, 5, "div", 38)(18, MultiColumnComboBoxComponent_ng_template_18_ng_container_18_Template, 7, 3, "ng-container", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const rowTemplate_r15 = ɵɵreference(14);
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.headerTemplate);
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r1.tableSizeClass);
    ɵɵadvance(8);
    ɵɵproperty("ngForOf", ctx_r1.columns);
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ctx_r1.columns);
    ɵɵadvance(3);
    ɵɵproperty("optionPrefix", ctx_r1.optionPrefix)("data", ctx_r1.data)("textField", ctx_r1.textField)("valueField", ctx_r1.valueField)("template", ɵɵpureFunction1(20, _c123, rowTemplate_r15))("groupTemplate", ctx_r1.groupTemplate)("fixedGroupTemplate", ctx_r1.fixedGroupTemplate)("height", ctx_r1.listHeight)("show", ctx_r1.isOpen)("id", ctx_r1.listBoxId)("virtual", ctx_r1.virtual)("type", "dropdowngrid")("rowWidth", ctx_r1.rowWidth)("showStickyHeader", ctx_r1.showStickyHeader);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.data.length === 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.footerTemplate);
  }
}
var _c233 = ["treeview"];
var _c242 = ["filterInput"];
var _c252 = (a0) => ({
  blur: a0
});
function DropDownTreeComponent_span_2_1_ng_template_0_Template(rf, ctx) {
}
function DropDownTreeComponent_span_2_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropDownTreeComponent_span_2_1_ng_template_0_Template, 0, 0, "ng-template", 17);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction2(1, _c511, ctx_r1.valueTemplate.templateRef, ctx_r1.dataItem));
  }
}
function DropDownTreeComponent_span_2_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵtextInterpolate1(" ", ctx_r1.text || ctx_r1.placeholder, " ");
  }
}
function DropDownTreeComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 14);
    ɵɵtemplate(1, DropDownTreeComponent_span_2_1_Template, 1, 4, null, 15)(2, DropDownTreeComponent_span_2_ng_template_2_Template, 1, 1, "ng-template", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.valueTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.valueTemplate);
  }
}
function DropDownTreeComponent_span_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 18);
    ɵɵlistener("click", function DropDownTreeComponent_span_3_Template_span_click_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearValue($event));
    });
    ɵɵelement(1, "kendo-icon-wrapper", 19);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("visibility", ctx_r1.clearButtonVisiblity);
    ɵɵattribute("title", ctx_r1.messageFor("clearTitle"));
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.xIcon);
  }
}
function DropDownTreeComponent_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 20);
  }
}
function DropDownTreeComponent_ng_template_7_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function DropDownTreeComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropDownTreeComponent_ng_template_7_ng_container_0_Template, 1, 0, "ng-container", 21);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const sharedPopupActionSheetTemplate_r4 = ɵɵreference(13);
    ɵɵproperty("ngTemplateOutlet", sharedPopupActionSheetTemplate_r4);
  }
}
function DropDownTreeComponent_ng_template_12_span_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 25)(1, "span", 26)(2, "span", 27);
    ɵɵelement(3, "kendo-icon-wrapper", 28);
    ɵɵelementEnd();
    ɵɵelementStart(4, "input", 29, 3);
    ɵɵlistener("input", function DropDownTreeComponent_ng_template_12_span_0_Template_input_input_4_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleFilterInputChange($event.target));
    })("keydown.arrowdown", function DropDownTreeComponent_ng_template_12_span_0_Template_input_keydown_arrowdown_4_listener($event) {
      ɵɵrestoreView(_r5);
      const filterInput_r6 = ɵɵreference(5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleKeydown($event, filterInput_r6));
    })("keydown.alt.arrowup", function DropDownTreeComponent_ng_template_12_span_0_Template_input_keydown_alt_arrowup_4_listener($event) {
      ɵɵrestoreView(_r5);
      const filterInput_r6 = ɵɵreference(5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleKeydown($event, filterInput_r6));
    })("keydown.escape", function DropDownTreeComponent_ng_template_12_span_0_Template_input_keydown_escape_4_listener($event) {
      ɵɵrestoreView(_r5);
      const filterInput_r6 = ɵɵreference(5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleKeydown($event, filterInput_r6));
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r1.filterInputClasses);
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r1.searchIcon);
    ɵɵadvance();
    ɵɵproperty("filterInput", ctx_r1.filterable && !ctx_r1.touchEnabled)("value", ctx_r1.filter)("kendoEventsOutsideAngular", ɵɵpureFunction1(7, _c252, ctx_r1.handleBlur))("scope", ctx_r1);
    ɵɵattribute("aria-label", ctx_r1.messageFor("filterInputLabel"));
  }
}
function DropDownTreeComponent_ng_template_12_1_ng_template_0_Template(rf, ctx) {
}
function DropDownTreeComponent_ng_template_12_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropDownTreeComponent_ng_template_12_1_ng_template_0_Template, 0, 0, "ng-template", 17);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c123, ctx_r1.headerTemplate == null ? null : ctx_r1.headerTemplate.templateRef));
  }
}
function DropDownTreeComponent_ng_template_12_kendo_treeview_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-treeview", 30, 4);
    ɵɵtwoWayListener("selectedKeysChange", function DropDownTreeComponent_ng_template_12_kendo_treeview_2_Template_kendo_treeview_selectedKeysChange_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r1.selectedKeys, $event) || (ctx_r1.selectedKeys = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("focusout", function DropDownTreeComponent_ng_template_12_kendo_treeview_2_Template_kendo_treeview_focusout_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleBlur($event));
    })("keydown", function DropDownTreeComponent_ng_template_12_kendo_treeview_2_Template_kendo_treeview_keydown_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleKeydown($event));
    })("selectionChange", function DropDownTreeComponent_ng_template_12_kendo_treeview_2_Template_kendo_treeview_selectionChange_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onSelectionChange($event));
    })("expand", function DropDownTreeComponent_ng_template_12_kendo_treeview_2_Template_kendo_treeview_expand_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.nodeExpand.emit($event));
    })("collapse", function DropDownTreeComponent_ng_template_12_kendo_treeview_2_Template_kendo_treeview_collapse_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.nodeCollapse.emit($event));
    })("childrenLoaded", function DropDownTreeComponent_ng_template_12_kendo_treeview_2_Template_kendo_treeview_childrenLoaded_0_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onChildrenLoaded());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("max-height", ctx_r1.listHeight, "px");
    ɵɵproperty("size", ctx_r1.size)("nodes", ctx_r1.data)("animate", false);
    ɵɵtwoWayProperty("selectedKeys", ctx_r1.selectedKeys);
    ɵɵproperty("selectBy", ctx_r1.selectBy)("textField", ctx_r1.textField)("children", ctx_r1.children)("hasChildren", ctx_r1.hasChildren)("loadOnDemand", ctx_r1.loadOnDemand)("isExpanded", ctx_r1.isNodeExpanded)("isDisabled", ctx_r1.itemDisabled)("nodeTemplate", ctx_r1.nodeTemplate)("filter", ctx_r1.filter)("isVisible", ctx_r1.isNodeVisible);
    ɵɵattribute("id", ctx_r1.treeViewId);
  }
}
function DropDownTreeComponent_ng_template_12_3_ng_template_0_Template(rf, ctx) {
}
function DropDownTreeComponent_ng_template_12_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropDownTreeComponent_ng_template_12_3_ng_template_0_Template, 0, 0, "ng-template", 17);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c123, ctx_r1.footerTemplate == null ? null : ctx_r1.footerTemplate.templateRef));
  }
}
function DropDownTreeComponent_ng_template_12_div_4_ng_template_1_Template(rf, ctx) {
}
function DropDownTreeComponent_ng_template_12_div_4_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.messageFor("noDataText"));
  }
}
function DropDownTreeComponent_ng_template_12_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 31);
    ɵɵtemplate(1, DropDownTreeComponent_ng_template_12_div_4_ng_template_1_Template, 0, 0, "ng-template", 32)(2, DropDownTreeComponent_ng_template_12_div_4_ng_template_2_Template, 2, 1, "ng-template", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.noDataTemplate)("templateContext", ɵɵpureFunction1(3, _c123, ctx_r1.noDataTemplate == null ? null : ctx_r1.noDataTemplate.templateRef));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.noDataTemplate);
  }
}
function DropDownTreeComponent_ng_template_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropDownTreeComponent_ng_template_12_span_0_Template, 6, 9, "span", 22)(1, DropDownTreeComponent_ng_template_12_1_Template, 1, 3, null, 15)(2, DropDownTreeComponent_ng_template_12_kendo_treeview_2_Template, 2, 17, "kendo-treeview", 23)(3, DropDownTreeComponent_ng_template_12_3_Template, 1, 3, null, 15)(4, DropDownTreeComponent_ng_template_12_div_4_Template, 3, 5, "div", 24);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.filterable && !ctx_r1.isActionSheetExpanded);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.headerTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.data.length !== 0 && !ctx_r1.allNodesHidden);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.footerTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.data.length === 0 || ctx_r1.allNodesHidden);
  }
}
function DropDownTreeComponent_kendo_resize_sensor_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 33);
    ɵɵlistener("resize", function DropDownTreeComponent_kendo_resize_sensor_14_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onResize());
    });
    ɵɵelementEnd();
  }
}
var _c262 = ["checkAllInput"];
var _c272 = (a0) => ({
  focusout: a0
});
function MultiSelectTreeComponent_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 14);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.placeholder, " ");
  }
}
function MultiSelectTreeComponent_span_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 15);
    ɵɵlistener("click", function MultiSelectTreeComponent_span_4_Template_span_click_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearAll($event));
    });
    ɵɵelement(1, "kendo-icon-wrapper", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵattribute("title", ctx_r1.messageFor("clearTitle"));
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.xIcon);
  }
}
function MultiSelectTreeComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 17);
  }
}
function MultiSelectTreeComponent_ng_template_6_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function MultiSelectTreeComponent_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiSelectTreeComponent_ng_template_6_ng_container_0_Template, 1, 0, "ng-container", 18);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const sharedPopupActionSheetTemplate_r4 = ɵɵreference(12);
    ɵɵproperty("ngTemplateOutlet", sharedPopupActionSheetTemplate_r4);
  }
}
function MultiSelectTreeComponent_ng_template_11_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 24)(1, "span", 25)(2, "span", 26);
    ɵɵelement(3, "kendo-icon-wrapper", 27);
    ɵɵelementEnd();
    ɵɵelementStart(4, "input", 28, 4);
    ɵɵlistener("input", function MultiSelectTreeComponent_ng_template_11_div_0_Template_input_input_4_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleFilterInputChange($event.target));
    })("keydown", function MultiSelectTreeComponent_ng_template_11_div_0_Template_input_keydown_4_listener($event) {
      ɵɵrestoreView(_r6);
      const filterInput_r7 = ɵɵreference(5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleKeydown($event, filterInput_r7));
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r1.filterInputClasses);
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r1.searchIcon);
    ɵɵadvance();
    ɵɵproperty("filterInput", ctx_r1.filterable && !ctx_r1.touchEnabled)("value", ctx_r1.filter)("kendoEventsOutsideAngular", ɵɵpureFunction1(7, _c252, ctx_r1.handleBlur))("scope", ctx_r1);
    ɵɵattribute("aria-label", ctx_r1.messageFor("filterInputLabel"));
  }
}
function MultiSelectTreeComponent_ng_template_11_1_ng_template_0_Template(rf, ctx) {
}
function MultiSelectTreeComponent_ng_template_11_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiSelectTreeComponent_ng_template_11_1_ng_template_0_Template, 0, 0, "ng-template", 29);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c123, ctx_r1.headerTemplate == null ? null : ctx_r1.headerTemplate.templateRef));
  }
}
function MultiSelectTreeComponent_ng_template_11_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 30)(1, "span", 31)(2, "input", 32, 5);
    ɵɵlistener("checkedItemsChange", function MultiSelectTreeComponent_ng_template_11_div_2_Template_input_checkedItemsChange_2_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleCheckedItemsChange($event));
    })("keydown", function MultiSelectTreeComponent_ng_template_11_div_2_Template_input_keydown_2_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleKeydown($event));
    });
    ɵɵelementEnd()();
    ɵɵelementStart(4, "span", 33);
    ɵɵlistener("click", function MultiSelectTreeComponent_ng_template_11_div_2_Template_span_click_4_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.toggleCheckAll());
    })("mousedown", function MultiSelectTreeComponent_ng_template_11_div_2_Template_span_mousedown_4_listener($event) {
      ɵɵrestoreView(_r8);
      return ɵɵresetView($event.preventDefault());
    });
    ɵɵtext(5);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const treeview_r9 = ɵɵreference(4);
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("checkAll", !ctx_r1.filterable && !ctx_r1.touchEnabled)("ngClass", ctx_r1.checkAllCheckboxClasses)("treeview", treeview_r9)("checkedItems", ctx_r1.checkedItems)("valueField", ctx_r1.valueField)("lastAction", ctx_r1.lastAction)("kendoEventsOutsideAngular", ɵɵpureFunction1(9, _c252, ctx_r1.handleBlur))("scope", ctx_r1);
    ɵɵadvance(3);
    ɵɵtextInterpolate1(" ", ctx_r1.messageFor("checkAllText"), " ");
  }
}
function MultiSelectTreeComponent_ng_template_11_5_ng_template_0_Template(rf, ctx) {
}
function MultiSelectTreeComponent_ng_template_11_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiSelectTreeComponent_ng_template_11_5_ng_template_0_Template, 0, 0, "ng-template", 29);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c123, ctx_r1.footerTemplate == null ? null : ctx_r1.footerTemplate.templateRef));
  }
}
function MultiSelectTreeComponent_ng_template_11_div_6_ng_template_1_Template(rf, ctx) {
}
function MultiSelectTreeComponent_ng_template_11_div_6_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.messageFor("noDataText"));
  }
}
function MultiSelectTreeComponent_ng_template_11_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 34);
    ɵɵtemplate(1, MultiSelectTreeComponent_ng_template_11_div_6_ng_template_1_Template, 0, 0, "ng-template", 35)(2, MultiSelectTreeComponent_ng_template_11_div_6_ng_template_2_Template, 2, 1, "ng-template", 36);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.noDataTemplate)("templateContext", ɵɵpureFunction1(3, _c123, ctx_r1.noDataTemplate == null ? null : ctx_r1.noDataTemplate.templateRef));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.noDataTemplate);
  }
}
function MultiSelectTreeComponent_ng_template_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵtemplate(0, MultiSelectTreeComponent_ng_template_11_div_0_Template, 6, 9, "div", 19)(1, MultiSelectTreeComponent_ng_template_11_1_Template, 1, 3, null, 20)(2, MultiSelectTreeComponent_ng_template_11_div_2_Template, 6, 11, "div", 21);
    ɵɵelementStart(3, "kendo-treeview", 22, 3);
    ɵɵlistener("keydown", function MultiSelectTreeComponent_ng_template_11_Template_kendo_treeview_keydown_3_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleKeydown($event));
    })("nodeClick", function MultiSelectTreeComponent_ng_template_11_Template_kendo_treeview_nodeClick_3_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleNodeClick($event));
    })("expand", function MultiSelectTreeComponent_ng_template_11_Template_kendo_treeview_expand_3_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.nodeExpand.emit($event));
    })("collapse", function MultiSelectTreeComponent_ng_template_11_Template_kendo_treeview_collapse_3_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.nodeCollapse.emit($event));
    })("checkedItemsChange", function MultiSelectTreeComponent_ng_template_11_Template_kendo_treeview_checkedItemsChange_3_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleCheckedItemsChange($event));
    })("childrenLoaded", function MultiSelectTreeComponent_ng_template_11_Template_kendo_treeview_childrenLoaded_3_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onChildrenLoaded());
    });
    ɵɵelementEnd();
    ɵɵtemplate(5, MultiSelectTreeComponent_ng_template_11_5_Template, 1, 3, null, 20)(6, MultiSelectTreeComponent_ng_template_11_div_6_Template, 3, 5, "div", 23);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.filterable && !ctx_r1.isActionSheetExpanded);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.headerTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.checkAll);
    ɵɵadvance();
    ɵɵstyleProp("max-height", ctx_r1.listHeight, "px");
    ɵɵproperty("size", ctx_r1.size)("nodes", ctx_r1.data)("animate", false)("isHeterogeneous", ctx_r1.isHeterogeneous)("checkable", ctx_r1.checkableSettings)("checkedItems", ctx_r1.checkedItems)("valueField", ctx_r1.valueField)("textField", ctx_r1.textField)("children", ctx_r1.children)("hasChildren", ctx_r1.hasChildren)("isExpanded", ctx_r1.isNodeExpanded)("isDisabled", ctx_r1.itemDisabled)("nodeTemplate", ctx_r1.nodeTemplate)("loadOnDemand", ctx_r1.loadOnDemand)("filter", ctx_r1.filter)("isVisible", ctx_r1.isNodeVisible)("kendoEventsOutsideAngular", ɵɵpureFunction1(26, _c272, ctx_r1.handleBlur))("scope", ctx_r1);
    ɵɵattribute("id", ctx_r1.treeViewId);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.footerTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.data || (ctx_r1.data == null ? null : ctx_r1.data.length) === 0 || ctx_r1.allNodesHidden);
  }
}
function MultiSelectTreeComponent_kendo_resize_sensor_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 37);
    ɵɵlistener("resize", function MultiSelectTreeComponent_kendo_resize_sensor_13_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onResize());
    });
    ɵɵelementEnd();
  }
}
var packageMetadata7 = {
  name: "@progress/kendo-angular-dropdowns",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 1745303969,
  version: "18.5.2",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var isPresent7 = (value) => value !== null && value !== void 0;
var isNumber4 = (value) => !isNaN(value);
var guid2 = () => {
  let id2 = "";
  let i;
  let random;
  for (i = 0; i < 32; i++) {
    random = Math.random() * 16 | 0;
    if (i === 8 || i === 12 || i === 16 || i === 20) {
      id2 += "-";
    }
    id2 += (i === 12 ? 4 : i === 16 ? random & 3 | 8 : random).toString(16);
  }
  return id2;
};
var combineStr = (begin, end) => {
  return begin.concat(end.substr(end.toLowerCase().indexOf(begin.toLowerCase()) + begin.length));
};
var isArray3 = (value) => Array.isArray(value);
var isObject2 = (value) => isPresent7(value) && typeof value === "object";
var isEmptyString = (value) => typeof value === "string" && value.length === 0;
var resolveValuesInArray = (values, data = [], valueField) => values.map((value) => {
  return data.find((item) => getter2(item, valueField) === value);
}).filter((value) => value !== void 0);
var validateComplexValues = (values, valueField) => isArray3(values) && values.filter((item) => {
  return isObject2(item) && getter2(item, valueField) !== void 0;
});
var resolveAllValues = (value, data, valueField) => {
  const customValues = validateComplexValues(value, valueField) || [];
  const resolvedValues = resolveValuesInArray(value, data, valueField) || [];
  return resolvedValues.concat(customValues);
};
var isObjectArray = (values) => {
  return isArray3(values) && values.every((item) => isObject2(item));
};
var selectedIndices = (values, data, valueField) => {
  const extractedValues = data.map((item) => {
    return isPresent7(item) && isPresent7(getter2(item, valueField)) ? getter2(item, valueField) : item;
  });
  return values.reduce((arr, item) => {
    const value = isPresent7(item) && isPresent7(getter2(item, valueField)) ? getter2(item, valueField) : item;
    const index = extractedValues.indexOf(value);
    if (index !== -1) {
      arr.push(index);
    }
    return arr;
  }, []);
};
var getter2 = (dataItem, field) => {
  if (!isPresent7(dataItem)) {
    return null;
  }
  if (!isPresent7(field) || !isObject2(dataItem)) {
    return dataItem;
  }
  const valueFrom2 = getter(field);
  return valueFrom2(dataItem);
};
var sameCharsOnly = (word, character) => {
  for (let idx2 = 0; idx2 < word.length; idx2++) {
    if (word.charAt(idx2) !== character) {
      return false;
    }
  }
  return true;
};
var shuffleData = (data, splitIndex, defaultItem) => {
  let result = data;
  if (defaultItem) {
    result = [defaultItem].concat(result);
  }
  return result.slice(splitIndex).concat(result.slice(0, splitIndex));
};
var matchText = (text, word, ignoreCase) => {
  if (!isPresent7(text)) {
    return false;
  }
  let temp = String(text);
  if (ignoreCase) {
    temp = temp.toLowerCase();
  }
  return temp.indexOf(word) === 0;
};
var hasProps = (obj, props) => {
  if (!isPresent7(obj)) {
    return false;
  }
  return props.every((prop) => obj.hasOwnProperty(prop));
};
var isUntouched2 = (element) => element.className.includes("ng-untouched");
var noop6 = (_2) => {
};
var matches2 = (element, selector) => {
  const matcher = element.matches || element.msMatchesSelector || element.webkitMatchesSelector;
  if (!matcher) {
    return false;
  }
  return matcher.call(element, selector);
};
var closest5 = (element, selector) => {
  let parent = element;
  while (parent !== null && parent.nodeType === 1) {
    if (matches2(parent, selector)) {
      return parent;
    }
    parent = parent.parentElement || parent.parentNode;
  }
  return null;
};
var parseNumber3 = (num, defaultValue = 0) => {
  const normalizedValue = Number(num);
  return isNaN(normalizedValue) ? defaultValue : normalizedValue;
};
var inDropDown = (host, target, popupRef) => {
  return host.nativeElement.contains(target) || popupRef && popupRef.popupElement.contains(target);
};
var getHierarchicalItemLevel = (index) => {
  return (index || "").split("_").length - 1;
};
var fetchDescendentNodes = (lookup, filterExpression) => {
  if (!isPresent7(lookup) || lookup.children.length === 0) {
    return [];
  }
  let descendants = lookup.children;
  if (isPresent7(filterExpression)) {
    descendants = descendants.filter((descendent) => filterExpression(descendent.item));
  }
  descendants.forEach((child) => descendants = descendants.concat(fetchDescendentNodes(child, filterExpression)));
  return descendants;
};
var valueFrom = ({
  dataItem,
  index,
  level
}, valueField) => {
  const fields = Array.isArray(valueField) ? valueField : [valueField];
  const valueLevel = isPresent7(level) ? level : getHierarchicalItemLevel(index);
  const normalizedLevel = Math.min(valueLevel, fields.length - 1);
  const field = fields[normalizedLevel];
  return getter(field)(dataItem);
};
var getSizeClass2 = (component, size) => {
  const SIZE_CLASSES = {
    "small": `k-${component}-sm`,
    "medium": `k-${component}-md`,
    "large": `k-${component}-lg`
  };
  return SIZE_CLASSES[size];
};
var getRoundedClass = (rounded) => {
  const ROUNDED_CLASSES = {
    "small": "k-rounded-sm",
    "medium": "k-rounded-md",
    "large": "k-rounded-lg",
    "full": "k-rounded-full"
  };
  return ROUNDED_CLASSES[rounded];
};
var getFillModeClass = (component, fillMode) => {
  const FILLMODE_CLASSES = {
    "solid": `k-${component}-solid`,
    "flat": `k-${component}-flat`,
    "outline": `k-${component}-outline`
  };
  return FILLMODE_CLASSES[fillMode];
};
var filterAndMap = (arr, predicate, mapper) => arr.reduce((acc, curr) => predicate(curr) ? [...acc, mapper(curr)] : acc, []);
var isJapanese2 = (input) => {
  const japaneseRegex = /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g;
  return japaneseRegex.test(input);
};
var isLetter = (text) => {
  const isLetter2 = /[a-zA-Z]/;
  return isLetter2.test(text) && text?.length === 1;
};
var getSearchableItems = (treeViewId, element) => {
  const nodeSeletor = `kendo-treeview[id='${treeViewId}'] li.k-treeview-item`;
  const liElements = Array.from(element.querySelectorAll(nodeSeletor));
  return liElements.map((liElement) => {
    return {
      text: liElement.innerText,
      index: liElement.getAttribute("data-treeindex")
    };
  });
};
var isTruthy2 = (value) => !!value;
var updateActionSheetAdaptiveAppearance2 = (actionSheet, windowSize, renderer) => {
  const element = actionSheet["element"].nativeElement.querySelector(".k-actionsheet");
  const animationContainer = actionSheet["element"].nativeElement.querySelector(".k-child-animation-container");
  if (windowSize === "medium") {
    renderer.removeClass(element, "k-actionsheet-fullscreen");
    renderer.addClass(element, "k-actionsheet-bottom");
    renderer.addClass(element, "k-adaptive-actionsheet");
    renderer.removeStyle(animationContainer, "top");
    renderer.removeStyle(animationContainer, "height");
    renderer.setStyle(animationContainer, "bottom", "0px");
  } else if (windowSize === "small") {
    renderer.removeClass(element, "k-actionsheet-bottom");
    renderer.addClass(element, "k-actionsheet-fullscreen");
    renderer.addClass(element, "k-adaptive-actionsheet");
    renderer.setStyle(animationContainer, "bottom", "0px");
    renderer.setStyle(animationContainer, "height", "100%");
  }
};
var setListBoxAriaLabelledBy = (optionsList, element, renderer) => {
  const listBox = optionsList.wrapper.nativeElement.querySelector("kendo-list ul");
  const ariaLabel = element.nativeElement.getAttribute("aria-labelledby") || element.nativeElement.getAttribute("data-kendo-label-id");
  if (ariaLabel) {
    renderer.setAttribute(listBox, "aria-labelledby", ariaLabel);
  }
};
var setActionSheetTitle = (element, actionSheetTitle) => {
  const ariaLabel = element.nativeElement.getAttribute("aria-labelledby") || element.nativeElement.getAttribute("data-kendo-label-id");
  if (!actionSheetTitle && ariaLabel) {
    return document.getElementById(ariaLabel).innerText;
  }
  return actionSheetTitle;
};
var animationDuration2 = 300;
var SearchBarComponent = class _SearchBarComponent {
  localization;
  injector;
  input;
  ngZone;
  direction;
  tagListId;
  set readonly(readonly) {
    this._readonly = readonly;
    if (this._readonly) {
      this.renderer.setAttribute(this.input.nativeElement, "readonly", "");
    } else {
      this.renderer.removeAttribute(this.input.nativeElement, "readonly");
    }
  }
  get readonly() {
    return this._readonly;
  }
  set disabled(disabled) {
    this._disabled = disabled;
    if (this._disabled) {
      this.renderer.setAttribute(this.input.nativeElement, "disabled", "");
    } else {
      this.renderer.removeAttribute(this.input.nativeElement, "disabled");
    }
  }
  get disabled() {
    return this._disabled;
  }
  set isRequired(isRequired) {
    this._isRequired = isRequired;
    if (this._isRequired) {
      this.renderer.setAttribute(this.input.nativeElement, "required", "");
    } else {
      this.renderer.removeAttribute(this.input.nativeElement, "required");
    }
  }
  get isRequired() {
    return this._isRequired;
  }
  set isSuggestable(isSuggestable) {
    this._isSuggestable = isSuggestable;
    this.setAriaAutocomplete();
  }
  get isSuggestable() {
    return this._isSuggestable;
  }
  set isFilterable(isFilterable) {
    this._isFilterable = isFilterable;
    this.setAriaAutocomplete();
  }
  get isFilterable() {
    return this._isFilterable;
  }
  get userInput() {
    return this._userInput;
  }
  set userInput(userInput) {
    this._userInput = userInput || "";
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  suggestedText;
  /**
   * @hidden
   */
  set inputAttributes(attributes) {
    if (isObjectPresent(this.parsedAttributes)) {
      removeHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement);
    }
    this._inputAttributes = attributes;
    this.parsedAttributes = this.inputAttributes ? parseAttributes(this.inputAttributes, this.defaultAttributes) : this.inputAttributes;
    this.setInputAttributes();
  }
  get inputAttributes() {
    return this._inputAttributes;
  }
  id;
  activeDescendant;
  tabIndex;
  isLoading;
  ariaControls;
  ariaExpanded = null;
  get attrAriaInvalid() {
    return this.formControl?.invalid ? true : null;
  }
  set placeholder(text) {
    this._placeholder = text || "";
    this.setInputSize();
  }
  get placeholder() {
    return this._placeholder;
  }
  role = "combobox";
  get dir() {
    return this.direction;
  }
  valueChange = new EventEmitter();
  onBlur = new EventEmitter();
  onFocus = new EventEmitter();
  onClick = new EventEmitter();
  onNavigate = new EventEmitter();
  get value() {
    return this.input.nativeElement.value;
  }
  _isRequired;
  _readonly;
  _disabled;
  _userInput = "";
  _previousValue = "";
  _placeholder = "";
  _isSuggestable = false;
  _isFilterable = false;
  renderer;
  subs = new Subscription();
  _inputAttributes;
  parsedAttributes = {};
  get defaultAttributes() {
    return {
      id: this.id,
      disabled: this.disabled ? "" : null,
      readonly: this.readonly ? "" : null,
      placeholder: this.placeholder,
      tabIndex: this.tabIndex,
      tabindex: this.tabIndex,
      dir: this.direction,
      required: this.isRequired ? "" : null,
      "aria-haspopup": "listbox",
      "aria-expanded": this.ariaExpanded,
      "aria-controls": this.ariaControls,
      "aria-activedescendant": this.activeDescendant,
      "aria-busy": this.isLoading,
      "aria-invalid": this.formControl?.invalid
    };
  }
  get mutableAttributes() {
    return {
      autocomplete: "off",
      role: this.role,
      "aria-describedby": this.tagListId
    };
  }
  constructor(localization, renderer, injector, input, ngZone) {
    this.localization = localization;
    this.injector = injector;
    this.input = input;
    this.ngZone = ngZone;
    this.direction = localization.rtl ? "rtl" : "ltr";
    this.renderer = renderer;
    this.renderer.addClass(this.input.nativeElement, "k-input-inner");
    this.renderer.setAttribute(this.input.nativeElement, "aria-haspopup", "listbox");
    this.renderer.setAttribute(this.input.nativeElement, "autocomplete", "off");
  }
  ngOnInit() {
    this.subs.add(this.localization.changes.subscribe(({
      rtl
    }) => this.direction = rtl ? "rtl" : "ltr"));
  }
  ngOnChanges(changes) {
    if (!isDocumentAvailable()) {
      return;
    }
    let previousUserInput;
    if (this.input && (changes.userInput || changes.suggestedText)) {
      if (changes.userInput && changes.userInput.previousValue) {
        if (this._previousValue === changes.userInput.previousValue) {
          previousUserInput = this._previousValue;
        } else {
          previousUserInput = changes.userInput.currentValue || "";
        }
      } else {
        previousUserInput = this._previousValue;
      }
      const caretStart = this.input.nativeElement.selectionStart;
      const caretAtEnd = previousUserInput.length === caretStart;
      this.writeInputValue(this.suggestedText ? combineStr(this.userInput, this.suggestedText) : this.userInput);
      if (this.suggestedText) {
        this.setInputSelection(this.userInput.length, this.suggestedText.length);
      } else if (isSafari(navigator.userAgent) && !caretAtEnd) {
        this.setInputSelection(caretStart, this.userInput.length);
      } else if (caretAtEnd) {
        this.setInputSelection(this.userInput.length, this.userInput.length);
      } else {
        this.setInputSelection(caretStart, caretStart);
      }
      this._previousValue = this.userInput;
    }
  }
  ngAfterViewInit() {
    this.subs.add(this.input.nativeElement.addEventListener("input", (event) => this.handleInput(event)));
    this.subs.add(this.input.nativeElement.addEventListener("focus", (event) => this.handleFocus(event)));
    this.subs.add(this.input.nativeElement.addEventListener("blur", (event) => this.handleBlur(event)));
    this.subs.add(this.input.nativeElement.addEventListener("keydown", (event) => this.handleKeydown(event)));
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  writeInputValue(text) {
    if (isDocumentAvailable()) {
      this.renderer.setProperty(this.input.nativeElement, "value", text);
    }
  }
  setInputSelection(start, end) {
    if (isDocumentAvailable() && this.input.nativeElement === document.activeElement) {
      try {
        this.input.nativeElement.setSelectionRange(start, end);
      } catch (e) {
      }
    }
  }
  setAriaAutocomplete() {
    if (this.isFilterable) {
      this.renderer.setAttribute(this.input.nativeElement, "aria-autocomplete", "list");
    }
    if (this.isSuggestable) {
      this.renderer.setAttribute(this.input.nativeElement, "aria-autocomplete", "inline");
    }
    if (this.isFilterable && this.isSuggestable) {
      this.renderer.setAttribute(this.input.nativeElement, "aria-autocomplete", "both");
    }
    if (!this.isFilterable && !this.isSuggestable) {
      this.renderer.removeAttribute(this.input.nativeElement, "aria-autocomplete");
    }
  }
  handleInput(event) {
    const target = event.target;
    const isBrowserSafari = isSafari(navigator.userAgent);
    const value = isBrowserSafari && isJapanese2(target.value) ? event.data : target.value;
    if (value !== this.userInput) {
      this._previousValue = value;
      this.valueChange.emit(value);
    }
  }
  handleFocus(event) {
    this.onFocus.emit(event);
  }
  handleBlur(event) {
    this.onBlur.emit(event);
  }
  handleKeydown(event) {
    const keyCode = event.keyCode;
    const keys = [Keys.ArrowUp, Keys.ArrowDown, Keys.ArrowLeft, Keys.ArrowRight, Keys.Enter, Keys.Escape, Keys.Delete, Keys.Backspace, Keys.Home, Keys.End, Keys.PageDown, Keys.PageUp];
    if (keys.indexOf(keyCode) > -1) {
      this.onNavigate.emit(event);
    }
  }
  focus() {
    if (isDocumentAvailable()) {
      this.input.nativeElement.focus();
    }
  }
  blur() {
    if (isDocumentAvailable()) {
      this.input.nativeElement.blur();
    }
  }
  setInputSize() {
    const lengthOf = (x) => x ? x.length : 0;
    const input = this.input.nativeElement;
    const placeholderLength = lengthOf(this.placeholder);
    const textLength = lengthOf(this.value);
    const size = Math.max(placeholderLength, textLength, 1);
    this.renderer.setAttribute(input, "size", size.toString());
  }
  setInputAttributes() {
    const attributesToRender = Object.assign({}, this.mutableAttributes, this.parsedAttributes);
    setHTMLAttributes(attributesToRender, this.renderer, this.input.nativeElement, this.ngZone);
  }
  static ɵfac = function SearchBarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SearchBarComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SearchBarComponent,
    selectors: [["input", "kendoSearchbar", ""]],
    hostVars: 10,
    hostBindings: function SearchBarComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("id", ctx.id)("aria-activedescendant", ctx.activeDescendant)("tabindex", ctx.tabIndex)("aria-busy", ctx.isLoading)("aria-controls", ctx.ariaControls)("aria-expanded", ctx.ariaExpanded)("aria-invalid", ctx.attrAriaInvalid)("placeholder", ctx.placeholder)("role", ctx.role)("dir", ctx.dir);
      }
    },
    inputs: {
      tagListId: "tagListId",
      readonly: "readonly",
      disabled: "disabled",
      isRequired: "isRequired",
      isSuggestable: "isSuggestable",
      isFilterable: "isFilterable",
      userInput: "userInput",
      suggestedText: "suggestedText",
      inputAttributes: "inputAttributes",
      id: "id",
      activeDescendant: "activeDescendant",
      tabIndex: "tabIndex",
      isLoading: "isLoading",
      ariaControls: "ariaControls",
      ariaExpanded: "ariaExpanded",
      placeholder: "placeholder"
    },
    outputs: {
      valueChange: "valueChange",
      onBlur: "onBlur",
      onFocus: "onFocus",
      onClick: "onClick",
      onNavigate: "onNavigate"
    },
    features: [ɵɵNgOnChangesFeature],
    attrs: _c06,
    decls: 0,
    vars: 0,
    template: function SearchBarComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SearchBarComponent, [{
    type: Component,
    args: [{
      selector: "input[kendoSearchbar]",
      template: ``,
      standalone: true,
      imports: [EventsOutsideAngularDirective]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: Renderer2
    }, {
      type: Injector
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, {
    tagListId: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    isRequired: [{
      type: Input
    }],
    isSuggestable: [{
      type: Input
    }],
    isFilterable: [{
      type: Input
    }],
    userInput: [{
      type: Input
    }],
    suggestedText: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    id: [{
      type: HostBinding,
      args: ["attr.id"]
    }, {
      type: Input
    }],
    activeDescendant: [{
      type: HostBinding,
      args: ["attr.aria-activedescendant"]
    }, {
      type: Input
    }],
    tabIndex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }, {
      type: Input
    }],
    isLoading: [{
      type: HostBinding,
      args: ["attr.aria-busy"]
    }, {
      type: Input
    }],
    ariaControls: [{
      type: HostBinding,
      args: ["attr.aria-controls"]
    }, {
      type: Input
    }],
    ariaExpanded: [{
      type: HostBinding,
      args: ["attr.aria-expanded"]
    }, {
      type: Input
    }],
    attrAriaInvalid: [{
      type: HostBinding,
      args: ["attr.aria-invalid"]
    }],
    placeholder: [{
      type: HostBinding,
      args: ["attr.placeholder"]
    }, {
      type: Input
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    valueChange: [{
      type: Output
    }],
    onBlur: [{
      type: Output
    }],
    onFocus: [{
      type: Output
    }],
    onClick: [{
      type: Output
    }],
    onNavigate: [{
      type: Output
    }]
  });
})();
var ItemTemplateDirective = class _ItemTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ItemTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ItemTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ItemTemplateDirective,
    selectors: [["", "kendoDropDownListItemTemplate", ""], ["", "kendoComboBoxItemTemplate", ""], ["", "kendoAutoCompleteItemTemplate", ""], ["", "kendoMultiSelectItemTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ItemTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownListItemTemplate],[kendoComboBoxItemTemplate],[kendoAutoCompleteItemTemplate],[kendoMultiSelectItemTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var HeaderTemplateDirective = class _HeaderTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function HeaderTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _HeaderTemplateDirective,
    selectors: [["", "kendoDropDownListHeaderTemplate", ""], ["", "kendoComboBoxHeaderTemplate", ""], ["", "kendoDropDownTreeHeaderTemplate", ""], ["", "kendoMultiColumnComboBoxHeaderTemplate", ""], ["", "kendoAutoCompleteHeaderTemplate", ""], ["", "kendoMultiSelectHeaderTemplate", ""], ["", "kendoMultiSelectTreeHeaderTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownListHeaderTemplate],[kendoComboBoxHeaderTemplate],[kendoDropDownTreeHeaderTemplate],[kendoMultiColumnComboBoxHeaderTemplate],[kendoAutoCompleteHeaderTemplate],[kendoMultiSelectHeaderTemplate],[kendoMultiSelectTreeHeaderTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var FooterTemplateDirective = class _FooterTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function FooterTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FooterTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FooterTemplateDirective,
    selectors: [["", "kendoDropDownListFooterTemplate", ""], ["", "kendoComboBoxFooterTemplate", ""], ["", "kendoDropDownTreeFooterTemplate", ""], ["", "kendoMultiColumnComboBoxFooterTemplate", ""], ["", "kendoAutoCompleteFooterTemplate", ""], ["", "kendoMultiSelectFooterTemplate", ""], ["", "kendoMultiSelectTreeFooterTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownListFooterTemplate],[kendoComboBoxFooterTemplate],[kendoDropDownTreeFooterTemplate],[kendoMultiColumnComboBoxFooterTemplate],[kendoAutoCompleteFooterTemplate],[kendoMultiSelectFooterTemplate],[kendoMultiSelectTreeFooterTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var GroupTemplateDirective = class _GroupTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function GroupTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GroupTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GroupTemplateDirective,
    selectors: [["", "kendoDropDownListGroupTemplate", ""], ["", "kendoComboBoxGroupTemplate", ""], ["", "kendoMultiColumnComboBoxGroupTemplate", ""], ["", "kendoAutoCompleteGroupTemplate", ""], ["", "kendoMultiSelectGroupTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownListGroupTemplate],[kendoComboBoxGroupTemplate],[kendoMultiColumnComboBoxGroupTemplate],[kendoAutoCompleteGroupTemplate],[kendoMultiSelectGroupTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var FixedGroupTemplateDirective = class _FixedGroupTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function FixedGroupTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FixedGroupTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FixedGroupTemplateDirective,
    selectors: [["", "kendoDropDownListFixedGroupTemplate", ""], ["", "kendoComboBoxFixedGroupTemplate", ""], ["", "kendoMultiColumnComboBoxFixedGroupTemplate", ""], ["", "kendoAutoCompleteFixedGroupTemplate", ""], ["", "kendoMultiSelectFixedGroupTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FixedGroupTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownListFixedGroupTemplate],[kendoComboBoxFixedGroupTemplate],[kendoMultiColumnComboBoxFixedGroupTemplate],[kendoAutoCompleteFixedGroupTemplate],[kendoMultiSelectFixedGroupTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var DataService = class _DataService {
  grouped = false;
  groupIndices = [];
  view;
  _data;
  _flatData;
  set data(data) {
    this._data = data;
    this.grouped = this.isGrouped(data);
    if (this.grouped) {
      this.groupIndices = this.getGroupIndices(data);
      this._flatData = this.flatten(data);
    }
  }
  get data() {
    if (this.grouped) {
      return this._flatData;
    }
    return this._data;
  }
  /**
   * @hidden
   * Used to get the actual items count, i.e. excluding the header items in case of grouping.
   */
  get itemsCount() {
    if (!isPresent7(this.data) || this.data.length === 0) {
      return 0;
    }
    const items = this.grouped ? this._flatData.filter((item) => !item.header) : this.data;
    return items.length;
  }
  /**
   * @hidden
   * Used to determine if the component received grouped data.
   */
  isGrouped(data) {
    return isPresent7(data) && data.length !== 0 && isPresent7(data[0]) && hasProps(data[0], ["aggregates", "field", "items", "value"]);
  }
  /**
   * @hidden
   * Used to calculate the last item index of each group.
   */
  getGroupIndices(data) {
    const groupIndices = [];
    for (let i = 0; i <= data.length - 1; i++) {
      groupIndices[i] = (groupIndices[i - 1] || 0) + data[i].items.length;
    }
    return groupIndices;
  }
  /**
   * @hidden
   * Used to get a flat array containing all items matching certain criteria.
   */
  filter(predicate) {
    let result = [];
    if (this.isGrouped(this.data)) {
      for (let i = 0; i <= this.groupIndices.length - 1; i++) {
        const matches3 = this.data[i].items.filter(predicate);
        if (matches3) {
          result = result.concat(matches3);
        }
      }
    } else {
      result = this.data.filter(predicate);
    }
    return result;
  }
  /**
   * @hidden
   * Used to get the index of a given data item.
   */
  indexOf(item, startFrom = 0) {
    let predicate = (element) => {
      return element === item;
    };
    if (this.grouped) {
      predicate = (element) => {
        return element.value === item;
      };
    }
    return this.findIndex(predicate, startFrom);
  }
  /**
   * @hidden
   * Used to get the index of a data item based on an expression.
   */
  findIndex(predicate, startFrom = 0) {
    let index = -1;
    if (this.grouped) {
      const data = this._flatData.filter((item) => !item.header && item.offsetIndex >= startFrom);
      index = data.findIndex(predicate);
      index = data[index] ? data[index].offsetIndex : -1;
    } else {
      const data = this.data.slice(startFrom);
      const itemIndex2 = data.findIndex(predicate);
      index = itemIndex2 !== -1 ? itemIndex2 + startFrom : -1;
    }
    return index;
  }
  /**
   * @hidden
   * Used to get the closest group header prior to an item index.
   */
  closestGroup(index) {
    for (let i = index; i >= 0; i--) {
      if (this._flatData[i].header) {
        return this._flatData[i];
      }
    }
  }
  /**
   * @hidden
   * Used to get the first item matching the criteria.
   */
  find(predicate) {
    const index = this.findIndex(predicate);
    return this.itemAt(index);
  }
  /**
   * @hidden
   * Used to get the true index in a flattened data array.
   */
  flatIndex(index) {
    if (this.itemsCount === 0) {
      return -1;
    }
    if (this.grouped) {
      const match2 = this._flatData.find((item) => !item.header && item.offsetIndex === index);
      if (match2) {
        return match2.index;
      }
    } else {
      return index;
    }
    return -1;
  }
  /**
   * @hidden
   * Used to get the item at the provided index.
   */
  itemAt(index) {
    let dataItem;
    if (this.itemsCount === 0) {
      return dataItem;
    }
    if (this.grouped) {
      const match2 = this._flatData.find((item) => !item.header && item.offsetIndex === index);
      if (match2) {
        dataItem = match2.value;
      }
    } else {
      dataItem = this.data[index];
    }
    return dataItem;
  }
  /**
   * @hidden
   * Used to get the group at the provided index.
   */
  groupAt(index) {
    if (this.itemsCount === 0 || !this.isGrouped) {
      return;
    }
    return this._flatData.find((item) => item.header && item.index === index);
  }
  /**
   * @hidden
   * Used to get all group items indices.
   */
  groupItemsIndices() {
    if (this.isGrouped) {
      return filterAndMap(this.data, (item) => item.header, (mappedItem) => mappedItem.index);
    }
    return [];
  }
  /**
   * @hidden
   * Used to get the field by which the data is grouped.
   */
  groupField() {
    if (this.itemsCount === 0 || !this.isGrouped) {
      return null;
    }
    return this._data[0].field;
  }
  /**
   * @hidden
   * Used to get the group to which a dataItem belongs.
   */
  itemGroup(item) {
    if (!item || this.itemsCount === 0 || !this.isGrouped) {
      return;
    }
    const fieldName = this.groupField();
    if (fieldName) {
      return getter2(item, fieldName);
    }
  }
  flatten(data, group = void 0, offset = 0, groupIndex = 0) {
    let flat = [];
    if (isPresent7(group)) {
      flat.push({
        header: true,
        groupIndex,
        index: groupIndex + offset,
        offsetIndex: groupIndex,
        value: group
      });
    }
    for (let i = 0; i < data.length; i++) {
      let result = [];
      if (data[i].items) {
        result = this.flatten(data[i].items, data[i].value, offset, i);
        offset = offset + data[i].items.length;
      } else {
        result.push({
          header: false,
          groupIndex,
          index: groupIndex + offset + i + 1,
          offsetIndex: offset + i,
          value: data[i]
        });
      }
      flat = flat.concat(result);
    }
    return flat;
  }
  static ɵfac = function DataService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DataService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DataService,
    factory: _DataService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DataService, [{
    type: Injectable
  }], null, null);
})();
var DisabledItemsService = class _DisabledItemsService {
  dataService;
  defaultItem;
  itemDisabled = null;
  constructor(dataService) {
    this.dataService = dataService;
  }
  isIndexDisabled(index) {
    if (this.itemDisabled) {
      const item = this.dataService.itemAt(index);
      if (isPresent7(item)) {
        return this.itemDisabled({
          dataItem: item,
          index
        });
      } else if (isPresent7(this.defaultItem)) {
        return this.itemDisabled({
          dataItem: this.defaultItem,
          index: -1
        });
      }
    }
  }
  isItemDisabled(item) {
    if (this.itemDisabled) {
      const index = this.dataService.indexOf(item);
      if (index !== -1) {
        return this.itemDisabled({
          dataItem: item,
          index
        });
      } else if (isPresent7(this.defaultItem)) {
        return this.itemDisabled({
          dataItem: this.defaultItem,
          index: -1
        });
      }
    }
  }
  static ɵfac = function DisabledItemsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DisabledItemsService)(ɵɵinject(DataService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DisabledItemsService,
    factory: _DisabledItemsService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DisabledItemsService, [{
    type: Injectable
  }], function() {
    return [{
      type: DataService
    }];
  }, null);
})();
var SelectionService2 = class _SelectionService {
  disabledItemsService;
  onSelect = new EventEmitter();
  onChange = new EventEmitter();
  onFocus = new EventEmitter();
  total = 0;
  lastClickedIndex;
  selectedIndices = [];
  focusedIndex;
  constructor(disabledItemsService) {
    this.disabledItemsService = disabledItemsService;
  }
  getTotal() {
    return this.total;
  }
  isSelected(index) {
    return isPresent7(this.selectedIndices.find((current) => current === index));
  }
  isFocused(index) {
    return index === this.focused;
  }
  focus(index) {
    if (this.isFocused(index)) {
      return;
    }
    this.focused = index;
    this.onFocus.emit(index);
  }
  select(index) {
    if (this.isSelected(index)) {
      return;
    }
    this.selectedIndices = [index];
    this.focused = index;
    this.onSelect.emit({
      indices: [index],
      newSelection: isPresent7(index)
    });
  }
  add(index, preventClosingPopup) {
    if (this.isSelected(index)) {
      return;
    }
    this.selectedIndices.push(index);
    this.focused = index;
    this.onChange.emit({
      added: index,
      indices: this.selectedIndices.slice(),
      preventClosingPopup
    });
  }
  indicesToBeRemoved = [];
  indicesToBeAdded = [];
  emitMultipleAddedRemoved() {
    this.onChange.emit({
      added: this.indicesToBeAdded,
      removed: this.indicesToBeRemoved,
      indices: this.selectedIndices.slice(),
      preventClosingPopup: true,
      isMultipleSelection: true
    });
    this.indicesToBeAdded = [];
    this.indicesToBeRemoved = [];
  }
  addMultiple(indices) {
    this.indicesToBeAdded = indices.slice();
    this.selectedIndices.push(...indices);
  }
  deselect(index, preventClosingPopup) {
    if (!this.isSelected(index)) {
      return;
    }
    const position = this.selectedIndices.indexOf(index);
    this.selectedIndices.splice(position, 1);
    this.focused = index;
    if (this.selected.length === 0) {
      this.lastClickedIndex = null;
    }
    this.onChange.emit({
      indices: this.selectedIndices.slice(),
      removed: index,
      preventClosingPopup
    });
  }
  unselectMultiple(indices) {
    indices.forEach((index) => {
      const position = this.selectedIndices.indexOf(index);
      this.selectedIndices.splice(position, 1);
    });
    this.indicesToBeRemoved = indices.slice();
  }
  change(index) {
    const newSelection = isPresent7(index) && !this.isSelected(index);
    this.selectedIndices = [index];
    this.focused = index;
    this.onChange.emit({
      indices: [index],
      newSelection
    });
  }
  resetSelection(index) {
    this.selectedIndices = index instanceof Array ? index : [index];
    this.focused = this.selectedIndices[this.selectedIndices.length - 1];
  }
  get selected() {
    return this.selectedIndices.slice();
  }
  get focused() {
    return this.focusedIndex;
  }
  set focused(index) {
    if (this.focusedIndex !== index) {
      this.focusedIndex = index;
      this.onFocus.emit(index);
    }
  }
  selectFromTo(from, to) {
    const addedIndices = [];
    for (let i = from; i <= to; i++) {
      if (!this.isSelected(i) && !this.disabledItemsService.isIndexDisabled(i)) {
        addedIndices.push(i);
      }
    }
    this.addMultiple(addedIndices);
  }
  unselectFromTo(from, to) {
    const indicesToBeUnselected = [];
    for (let i = from; i >= to; i--) {
      if (this.isSelected(i) && !this.disabledItemsService.isIndexDisabled(i)) {
        indicesToBeUnselected.push(i);
      }
    }
    this.unselectMultiple(indicesToBeUnselected);
  }
  unselectNotNeededIndices(startOfSelection, endOfSelection, totalItems) {
    const indicesToBeUnselected = [];
    for (let i = 0; i < startOfSelection; i++) {
      if (this.isSelected(i)) {
        indicesToBeUnselected.push(i);
      }
    }
    for (let i = endOfSelection + 1; i < totalItems; i++) {
      if (this.isSelected(i)) {
        indicesToBeUnselected.push(i);
      }
    }
    this.unselectMultiple(indicesToBeUnselected);
  }
  static ɵfac = function SelectionService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SelectionService)(ɵɵinject(DisabledItemsService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SelectionService,
    factory: _SelectionService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectionService2, [{
    type: Injectable
  }], function() {
    return [{
      type: DisabledItemsService
    }];
  }, null);
})();
var NavigationAction;
(function(NavigationAction2) {
  NavigationAction2[NavigationAction2["Undefined"] = 0] = "Undefined";
  NavigationAction2[NavigationAction2["Open"] = 1] = "Open";
  NavigationAction2[NavigationAction2["Close"] = 2] = "Close";
  NavigationAction2[NavigationAction2["Enter"] = 3] = "Enter";
  NavigationAction2[NavigationAction2["Tab"] = 4] = "Tab";
  NavigationAction2[NavigationAction2["Esc"] = 5] = "Esc";
  NavigationAction2[NavigationAction2["Delete"] = 6] = "Delete";
  NavigationAction2[NavigationAction2["Backspace"] = 7] = "Backspace";
  NavigationAction2[NavigationAction2["Home"] = 8] = "Home";
  NavigationAction2[NavigationAction2["End"] = 9] = "End";
  NavigationAction2[NavigationAction2["Up"] = 10] = "Up";
  NavigationAction2[NavigationAction2["Down"] = 11] = "Down";
  NavigationAction2[NavigationAction2["Left"] = 12] = "Left";
  NavigationAction2[NavigationAction2["Right"] = 13] = "Right";
  NavigationAction2[NavigationAction2["PageDown"] = 14] = "PageDown";
  NavigationAction2[NavigationAction2["PageUp"] = 15] = "PageUp";
  NavigationAction2[NavigationAction2["SelectPrevious"] = 16] = "SelectPrevious";
  NavigationAction2[NavigationAction2["SelectNext"] = 17] = "SelectNext";
  NavigationAction2[NavigationAction2["SelectAll"] = 18] = "SelectAll";
  NavigationAction2[NavigationAction2["SelectAllToBeginning"] = 19] = "SelectAllToBeginning";
  NavigationAction2[NavigationAction2["SelectAllToEnd"] = 20] = "SelectAllToEnd";
})(NavigationAction || (NavigationAction = {}));
var MIN_INDEX = 0;
var NavigationEvent = class {
  index;
  originalEvent;
  /**
   * The index of the item to which the user navigated.
   */
  constructor(index, originalEvent) {
    this.index = index;
    this.originalEvent = originalEvent;
  }
};
var NavigationService3 = class _NavigationService {
  disabledItemsService;
  selectionService;
  open = new EventEmitter();
  close = new EventEmitter();
  enter = new EventEmitter();
  tab = new EventEmitter();
  esc = new EventEmitter();
  up = new EventEmitter();
  right = new EventEmitter();
  down = new EventEmitter();
  left = new EventEmitter();
  delete = new EventEmitter();
  backspace = new EventEmitter();
  home = new EventEmitter();
  end = new EventEmitter();
  pagedown = new EventEmitter();
  pageup = new EventEmitter();
  selectnext = new EventEmitter();
  selectprevious = new EventEmitter();
  selectall = new EventEmitter();
  selectalltobeginning = new EventEmitter();
  selectalltoend = new EventEmitter();
  constructor(disabledItemsService, selectionService) {
    this.disabledItemsService = disabledItemsService;
    this.selectionService = selectionService;
  }
  process(args) {
    const keyCode = args.originalEvent.keyCode;
    const altKey = args.originalEvent.altKey;
    const shiftKey = args.originalEvent.shiftKey;
    const ctrlKey = args.originalEvent.ctrlKey || args.originalEvent.metaKey;
    const openOnSpace = args.openOnSpace;
    const closeOnSpace = args.closeOnSpace;
    let index;
    let action = NavigationAction.Undefined;
    if (altKey && keyCode === Keys.ArrowDown) {
      action = NavigationAction.Open;
    } else if (openOnSpace && keyCode === Keys.Space) {
      action = NavigationAction.Open;
    } else if (altKey && keyCode === Keys.ArrowUp) {
      action = NavigationAction.Close;
    } else if (closeOnSpace && keyCode === Keys.Space) {
      action = NavigationAction.Close;
    } else if (shiftKey && keyCode === Keys.ArrowUp) {
      action = NavigationAction.SelectPrevious;
    } else if (shiftKey && keyCode === Keys.ArrowDown) {
      action = NavigationAction.SelectNext;
    } else if (ctrlKey && keyCode === Keys.KeyA) {
      action = NavigationAction.SelectAll;
    } else if (ctrlKey && shiftKey && keyCode === Keys.Home) {
      action = NavigationAction.SelectAllToBeginning;
    } else if (ctrlKey && shiftKey && keyCode === Keys.End) {
      action = NavigationAction.SelectAllToEnd;
    } else if (keyCode === Keys.Enter) {
      action = NavigationAction.Enter;
    } else if (keyCode === Keys.Escape) {
      action = NavigationAction.Esc;
    } else if (keyCode === Keys.Tab) {
      action = NavigationAction.Tab;
    } else if (keyCode === Keys.ArrowUp) {
      index = this.next({
        current: args.current,
        start: args.min,
        end: args.max,
        step: -1
      });
      action = NavigationAction.Up;
    } else if (keyCode === Keys.ArrowLeft) {
      index = this.next({
        current: args.current,
        start: args.min,
        end: args.max,
        step: -1
      });
      action = NavigationAction.Left;
    } else if (keyCode === Keys.ArrowDown) {
      index = this.next({
        current: args.current,
        start: args.min,
        end: args.max,
        step: 1
      });
      action = NavigationAction.Down;
    } else if (keyCode === Keys.ArrowRight) {
      index = this.next({
        current: args.current,
        start: args.min,
        end: args.max,
        step: 1
      });
      action = NavigationAction.Right;
    } else if (keyCode === Keys.Home) {
      index = this.isDisabled(MIN_INDEX) ? args.current : MIN_INDEX;
      action = NavigationAction.Home;
    } else if (keyCode === Keys.End) {
      index = this.isDisabled(args.max) ? args.current : args.max;
      action = NavigationAction.End;
    } else if (keyCode === Keys.Delete) {
      action = NavigationAction.Delete;
    } else if (keyCode === Keys.Backspace) {
      action = NavigationAction.Backspace;
    } else if (keyCode === Keys.PageDown) {
      action = NavigationAction.PageDown;
    } else if (keyCode === Keys.PageUp) {
      action = NavigationAction.PageUp;
    }
    const eventData = new NavigationEvent(index, args.originalEvent);
    if (action !== NavigationAction.Undefined) {
      this[NavigationAction[action].toLowerCase()].emit(eventData);
    }
    return action;
  }
  next(args) {
    const {
      current,
      start,
      end,
      step
    } = args;
    const nextIndex = !isPresent7(current) ? start : this.clampIndex(current + step, start, end);
    const firstFocusableIndex = this.firstFocusableIndex(nextIndex, start, end, step);
    if (isPresent7(firstFocusableIndex)) {
      return firstFocusableIndex;
    }
    if (this.selectionService.isSelected(current) && current >= start) {
      return current;
    }
    const inversedStep = -1 * step;
    return this.firstFocusableIndex(nextIndex, start, end, inversedStep);
  }
  clampIndex(index, min, max) {
    if (!isPresent7(index) || index < min) {
      return min;
    }
    if (index > max) {
      return max;
    }
    return index;
  }
  firstFocusableIndex(startIndex, min, max, step) {
    while (min <= startIndex && startIndex <= max) {
      if (!this.isDisabled(startIndex)) {
        return startIndex;
      }
      startIndex += step;
    }
    return void 0;
  }
  isDisabled(index) {
    if (this.disabledItemsService) {
      return this.disabledItemsService.isIndexDisabled(index);
    }
  }
  static ɵfac = function NavigationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NavigationService)(ɵɵinject(DisabledItemsService), ɵɵinject(SelectionService2));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _NavigationService,
    factory: _NavigationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationService3, [{
    type: Injectable
  }], function() {
    return [{
      type: DisabledItemsService
    }, {
      type: SelectionService2
    }];
  }, null);
})();
var NoDataTemplateDirective = class _NoDataTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function NoDataTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NoDataTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NoDataTemplateDirective,
    selectors: [["", "kendoDropDownListNoDataTemplate", ""], ["", "kendoDropDownTreeNoDataTemplate", ""], ["", "kendoComboBoxNoDataTemplate", ""], ["", "kendoMultiColumnComboBoxNoDataTemplate", ""], ["", "kendoAutoCompleteNoDataTemplate", ""], ["", "kendoMultiSelectNoDataTemplate", ""], ["", "kendoMultiSelectTreeNoDataTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoDataTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownListNoDataTemplate],[kendoDropDownTreeNoDataTemplate],[kendoComboBoxNoDataTemplate],[kendoMultiColumnComboBoxNoDataTemplate],[kendoAutoCompleteNoDataTemplate],[kendoMultiSelectNoDataTemplate],[kendoMultiSelectTreeNoDataTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var PreventableEvent5 = class {
  prevented = false;
  /**
   * Prevents the default action for a specified event.
   * In this way, the source component suppresses the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * If the event is prevented by any of its subscribers, returns `true`.
   *
   * @returns `true` if the default action was prevented. Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
};
var FilterableComponent = class {
  /**
   * Sets the data of the component.
   */
  data;
  /**
   * Explicitly enables the emitting of the `filterChange` event.
   */
  filterable;
  /**
   * Hooks to the `filter` event.
   */
  filterChange;
  /**
   * Reads the data from the components with complex data.
   */
  textField;
  /**
   * Reads the data from the components with complex data which use `valueField` instead of
   * `textField`&mdash;for example, the AutoComplete.
   */
  valueField;
};
var ListItemDirective = class _ListItemDirective {
  element;
  constructor(element) {
    this.element = element;
  }
  static ɵfac = function ListItemDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ListItemDirective)(ɵɵdirectiveInject(ElementRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ListItemDirective,
    selectors: [["li", "role", "option"], ["li", "role", "group"]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ListItemDirective, [{
    type: Directive,
    args: [{
      selector: '"li[role=option], li[role=group]"',
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, null);
})();
var SelectableDirective = class _SelectableDirective {
  index;
  checkboxes = {
    enabled: false
  };
  height;
  isMultiselect;
  multipleSelection = false;
  selectionService;
  constructor(selectionService) {
    this.selectionService = selectionService;
  }
  get focusedClassName() {
    return this.selectionService.isFocused(this.index);
  }
  get selectedClassName() {
    return !this.checkboxes.enabled && this.selectionService.isSelected(this.index);
  }
  onClick(event) {
    event.stopPropagation();
    this.selectionService.lastClickedIndex = this.index;
    if (this.checkboxes.enabled && !this.checkboxes.checkOnClick) {
      return;
    }
    if (this.multipleSelection) {
      if (this.selectionService.isSelected(this.index)) {
        this.selectionService.deselect(this.index);
      } else {
        this.selectionService.add(this.index);
      }
    } else {
      this.selectionService.change(this.index);
    }
  }
  static ɵfac = function SelectableDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SelectableDirective)(ɵɵdirectiveInject(SelectionService2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SelectableDirective,
    selectors: [["", "kendoDropDownsSelectable", ""]],
    hostVars: 9,
    hostBindings: function SelectableDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function SelectableDirective_click_HostBindingHandler($event) {
          return ctx.onClick($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("index", ctx.index);
        ɵɵstyleProp("height", ctx.height, "px")("min-height", ctx.height, "px");
        ɵɵclassProp("k-focus", ctx.focusedClassName)("k-selected", ctx.selectedClassName);
      }
    },
    inputs: {
      index: "index",
      checkboxes: "checkboxes",
      height: "height",
      isMultiselect: "isMultiselect",
      multipleSelection: "multipleSelection"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectableDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownsSelectable]",
      standalone: true
    }]
  }], function() {
    return [{
      type: SelectionService2
    }];
  }, {
    index: [{
      type: HostBinding,
      args: ["attr.index"]
    }, {
      type: Input
    }],
    checkboxes: [{
      type: Input
    }],
    height: [{
      type: HostBinding,
      args: ["style.height.px"]
    }, {
      type: HostBinding,
      args: ["style.minHeight.px"]
    }, {
      type: Input
    }],
    isMultiselect: [{
      type: Input
    }],
    multipleSelection: [{
      type: Input
    }],
    focusedClassName: [{
      type: HostBinding,
      args: ["class.k-focus"]
    }],
    selectedClassName: [{
      type: HostBinding,
      args: ["class.k-selected"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var ListComponent = class _ListComponent {
  dataService;
  wrapper;
  selectionService;
  disabledItemsService;
  cdr;
  zone;
  renderer;
  selected = [];
  focused = -1;
  textField;
  valueField;
  height;
  template;
  groupTemplate;
  fixedGroupTemplate;
  show = true;
  id;
  optionPrefix;
  multipleSelection = false;
  virtual;
  type = "list";
  checkboxes = {
    enabled: false
  };
  ariaLive;
  isMultiselect;
  isActionSheetExpanded;
  showStickyHeader;
  rowWidth;
  set data(data) {
    this._data = data[0] && data[0].header ? data.slice(0) : data;
  }
  get data() {
    return this._data;
  }
  set size(size) {
    if (this.type === "list") {
      this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass2("list", this.size));
      if (size) {
        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("list", size));
      }
      this._size = size;
    }
  }
  get size() {
    return this._size;
  }
  rounded = "medium";
  onClick = new EventEmitter();
  pageChange = new EventEmitter();
  listResize = new EventEmitter();
  popupListScroll = new EventEmitter();
  items;
  content;
  list;
  virtualContainer;
  currentGroup;
  startFrom = 0;
  lastLoaded = 0;
  lastScrollTop = 0;
  listContentClass;
  listClass;
  listItemClass;
  listVirtualClass;
  listGroupStickyHeaderClass;
  listGroupStickyHeaderTextClass;
  listGroupItemClass;
  listGroupItemTextClass;
  scrollToFocused = false;
  _data;
  scrollSubscription;
  selectSubscription;
  _size = "medium";
  get pageSize() {
    if (this.virtual.pageSize) {
      return this.virtual.pageSize;
    }
    const size = Math.round(this.height / this.virtual.itemHeight);
    return size;
  }
  get scrollHeight() {
    return this.virtual.total * this.virtual.itemHeight;
  }
  get overflowY() {
    if (isPresent7(this.virtual)) {
      const overflow = this.hasVirtualScrollbar() ? "scroll" : "hidden";
      return overflow;
    }
  }
  /**
   * @hidden
   */
  get checkboxClasses() {
    return `${this.size ? getSizeClass2("checkbox", this.size) : ""} ${this.rounded ? getRoundedClass(this.rounded) : ""}`;
  }
  /* tslint:disable:member-ordering */
  constructor(dataService, wrapper, selectionService, disabledItemsService, cdr, zone, renderer) {
    this.dataService = dataService;
    this.wrapper = wrapper;
    this.selectionService = selectionService;
    this.disabledItemsService = disabledItemsService;
    this.cdr = cdr;
    this.zone = zone;
    this.renderer = renderer;
    this.selectSubscription = merge(this.selectionService.onSelect.pipe(map((args) => args.indices[0])), this.selectionService.onFocus).pipe(
      // handle only the very last onSelect/onFocus emission
      switchMap((event) => this.zone.onStable.pipe(take(1), map(() => event)))
    ).subscribe(this.scrollToItem.bind(this));
    this.prepareClasses();
  }
  ngOnChanges(changes) {
    if (isChanged("data", changes, false)) {
      if (this.lastLoaded <= 0) {
        this.lastLoaded = this.data.length - 1;
        this.scrollToFocused = !changes["data"].isFirstChange();
      }
      this.setOverflow();
      this.zone.onStable.pipe(take(1)).subscribe(() => {
        this.setGroupAttributes();
      });
    }
    if (isChanged("virtual", changes, false)) {
      this.setOverflow();
    }
    if (isChanged("type", changes, false)) {
      this.prepareClasses();
    }
  }
  ngAfterViewInit() {
    this.setComponentClasses();
    this.zone.runOutsideAngular(() => {
      this.scrollSubscription = fromEvent(this.content.nativeElement, "scroll").pipe(auditTime(100), tap(this.prefetchData.bind(this)), tap(this.findCurrentGroup.bind(this))).subscribe(() => {
        this.lastScrollTop = this.content.nativeElement.scrollTop;
      });
    });
    this.setGroupAttributes();
    this.setOverflow();
  }
  setGroupAttributes() {
    const liItems = document.querySelectorAll("li");
    let isGroup;
    let childrenliItemsIds = [];
    let firstGroupReached = false;
    let previousGroup;
    liItems.forEach((li, idx2) => {
      isGroup = li.getAttribute("role") === "group";
      if (!isGroup && firstGroupReached) {
        this.renderer.setAttribute(li, "aria-describedby", previousGroup.getAttribute("id"));
        childrenliItemsIds.push(li.getAttribute("id"));
        if (idx2 + 1 >= liItems.length || liItems[idx2 + 1]?.getAttribute("role") === "group") {
          this.renderer.setAttribute(previousGroup, "aria-owns", childrenliItemsIds.join(" "));
          childrenliItemsIds = [];
        }
      }
      if (isGroup) {
        firstGroupReached = true;
        previousGroup = li;
      }
    });
  }
  ngAfterViewChecked() {
    if (this.virtual) {
      this.positionItems();
    }
    if (this.items && this.scrollToFocused) {
      this.scrollToFocused = false;
      const scrollTarget = this.items.length && this.selectionService.focused === -1 ? 0 : this.selectionService.focused;
      this.scrollToItem(scrollTarget);
    }
    if (this.dataService.grouped) {
      this.findCurrentGroup();
    }
  }
  ngOnDestroy() {
    this.selectSubscription.unsubscribe();
    if (this.scrollSubscription) {
      this.scrollSubscription.unsubscribe();
    }
  }
  onCheckedChange(e, index) {
    const isChecked2 = e.target["checked"];
    if (isChecked2 && !this.selectionService.isSelected(index)) {
      this.selectionService.add(index);
    }
    if (!isChecked2 && this.selectionService.isSelected(index)) {
      this.selectionService.deselect(index);
    }
  }
  prepareClasses() {
    if (this.type === "list") {
      this.listContentClass = "k-list-content";
      this.listClass = "k-list-ul";
      this.listItemClass = "k-list-item";
      this.listVirtualClass = "k-virtual-list";
      this.listGroupStickyHeaderClass = "k-list-group-sticky-header";
      this.listGroupStickyHeaderTextClass = "k-list-header-text";
      this.listGroupItemClass = "k-list-group-item";
      this.listGroupItemTextClass = "k-list-item-text";
    } else {
      this.listContentClass = "k-table-body k-table-scroller";
      this.listClass = "k-table k-table-list";
      this.listItemClass = "k-table-row";
      this.listVirtualClass = "k-virtual-table";
      this.listGroupStickyHeaderClass = "k-table-group-sticky-header";
      this.listGroupStickyHeaderTextClass = "k-table-th";
      this.listGroupItemClass = "k-table-group-row";
      this.listGroupItemTextClass = "k-table-th";
    }
  }
  isChecked(index) {
    const normalizedIndex = this.virtual ? index + this.virtual.skip : index;
    return this.selectionService.isSelected(normalizedIndex);
  }
  firstVisibleItem() {
    const content = this.content.nativeElement;
    const rect = content.getBoundingClientRect();
    const disabled = Array.prototype.slice.call(content.querySelectorAll(".k-disabled"));
    disabled.forEach((el) => this.renderer.setStyle(el, "pointer-events", "auto"));
    const item = document.elementFromPoint(rect.left + 1, rect.top + 1);
    disabled.forEach((el) => this.renderer.setStyle(el, "pointer-events", "none"));
    return closest5(item, "li");
  }
  findCurrentGroup() {
    if (!this.dataService.grouped) {
      this.currentGroup = void 0;
      return;
    }
    const item = this.firstVisibleItem();
    if (item) {
      let index;
      if (item.getAttribute("role") === "group") {
        index = parseInt(item.getAttribute("group-index"), 10);
        this.currentGroup = this.dataService.groupAt(index)?.value;
      } else {
        index = parseInt(item.getAttribute("index"), 10);
        this.currentGroup = this.dataService.itemGroup(this.dataService.itemAt(index));
      }
    } else {
      this.currentGroup = void 0;
    }
    this.cdr.detectChanges();
  }
  prefetchData() {
    if (!this.virtual) {
      return;
    }
    const visibleItems = Math.trunc(this.content.nativeElement.clientHeight / this.virtual.itemHeight);
    const offsetY = this.content.nativeElement.scrollTop;
    const start = Math.trunc(offsetY / this.virtual.itemHeight);
    const down = offsetY > this.lastScrollTop;
    const nextPage = start + visibleItems >= this.lastLoaded && this.lastLoaded < this.virtual.total - 1;
    const leftOver = this.pageSize - (this.lastLoaded - this.startFrom);
    const prevPage = this.lastLoaded - this.pageSize + visibleItems >= start - leftOver;
    if (down && nextPage) {
      this.changePage(start);
    }
    if (!down && prevPage) {
      this.changePage(start - this.pageSize + visibleItems + 1);
    }
  }
  changePage(start) {
    this.zone.run(() => {
      let end = this.pageSize + start;
      if (end > this.virtual.total) {
        start--;
        end = this.virtual.total;
      }
      if (start < 0) {
        start = 0;
      }
      this.startFrom = start;
      this.lastLoaded = end;
      this.pageChange.emit({
        skip: start,
        take: this.pageSize
      });
    });
    this.setGroupAttributes();
  }
  index(groupIndex, itemIndex2) {
    return groupIndex > 0 ? this.dataService.groupIndices[groupIndex - 1] + itemIndex2 : itemIndex2;
  }
  getText(dataItem) {
    return getter2(dataItem, this.textField);
  }
  getValue(dataItem) {
    return getter2(dataItem, this.valueField);
  }
  isDisabled(index) {
    if (isPresent7(this.virtual) && !this.dataService.grouped) {
      index += this.virtual.skip;
    }
    return this.disabledItemsService.isIndexDisabled(index);
  }
  isAltRow(index) {
    return this.type === "dropdowngrid" && index % 2 !== 0;
  }
  scrollToItem(index) {
    let flatIndex = index;
    if (this.dataService.grouped) {
      flatIndex = this.dataService.flatIndex(index);
    }
    if (this.virtual && flatIndex > -1) {
      this.scrollToIndex(flatIndex);
      return;
    }
    const items = this.items.toArray();
    if (isPresent7(items[flatIndex]) && flatIndex !== -1) {
      this.scroll(items[flatIndex].element);
    }
  }
  scrollWithOnePage(action) {
    const content = this.content.nativeElement;
    const contentOffsetHeight = content.clientHeight;
    if (action === NavigationAction.PageDown) {
      content.scrollTop += contentOffsetHeight;
    } else if (action === NavigationAction.PageUp) {
      content.scrollTop -= contentOffsetHeight;
    }
  }
  scrollToIndex(index) {
    const content = this.content.nativeElement;
    let contentScrollTop = content.scrollTop;
    const itemOffsetTop = index * this.virtual.itemHeight;
    const itemOffsetHeight = this.virtual.itemHeight;
    const contentOffsetHeight = content.clientHeight;
    const bottomDistance = itemOffsetTop + itemOffsetHeight;
    if (contentScrollTop > itemOffsetTop) {
      contentScrollTop = itemOffsetTop;
    } else if (bottomDistance > contentScrollTop + contentOffsetHeight) {
      contentScrollTop = bottomDistance - contentOffsetHeight;
    }
    content.scrollTop = contentScrollTop;
  }
  scroll(item) {
    if (!item) {
      return;
    }
    const nativeElement = item.nativeElement;
    const content = this.content.nativeElement;
    const itemOffsetTop = nativeElement.offsetTop;
    const itemOffsetHeight = nativeElement.offsetHeight;
    let contentScrollTop = content.scrollTop;
    const contentOffsetHeight = content.clientHeight;
    const bottomDistance = itemOffsetTop + itemOffsetHeight;
    if (contentScrollTop > itemOffsetTop) {
      contentScrollTop = itemOffsetTop;
    } else if (bottomDistance > contentScrollTop + contentOffsetHeight) {
      contentScrollTop = bottomDistance - contentOffsetHeight;
    }
    content.scrollTop = contentScrollTop;
  }
  /**
   * Indicates whether a scrollbar is currently rendered in the list.
   */
  hasScrollbar() {
    if (!(isPresent7(this.items) && this.items.length && isPresent7(this.list) && isPresent7(this.content))) {
      return false;
    }
    const hasVirtualScroll = isPresent7(this.virtual) && this.hasVirtualScrollbar();
    return hasVirtualScroll || this.list.nativeElement.scrollHeight > this.content.nativeElement.offsetHeight;
  }
  isItemSelected(index) {
    return this.selectionService.isSelected(index) || null;
  }
  /**
   * Sets the list's content overflow (hides/shows scrollbar)
   */
  setOverflow() {
    if (this.virtual) {
      const overflow = this.hasVirtualScrollbar() ? "scroll" : "hidden";
      this.renderer.setStyle(this.content.nativeElement, "overflow-y", overflow);
    }
  }
  /**
   * Indicates whether the scrollbar should be visible in virtual mode.
   */
  hasVirtualScrollbar() {
    const contentOffsetHeight = this.content.nativeElement.offsetHeight;
    const virtualOffsetHeight = this.virtualContainer && this.virtualContainer.nativeElement.offsetHeight;
    return this.virtualContainer && virtualOffsetHeight > contentOffsetHeight;
  }
  positionItems() {
    this.items.forEach((item, index) => {
      const offsetY = (index + this.startFrom) * this.virtual.itemHeight;
      this.renderer.setStyle(item.element.nativeElement, "transform", `translateY(${offsetY}px`);
    });
  }
  /**
   * Indicates whether the first group header from the data set is in the targeted virtual page.
   */
  firstGroupHeaderInTargetedPage(itemIndex2) {
    if (!isPresent7(this.virtual)) {
      return true;
    }
    return this.virtual.skip === 0 && this.virtual.pageSize > itemIndex2;
  }
  setComponentClasses() {
    if (this.type === "list") {
      this.renderer.addClass(this.wrapper.nativeElement, "k-list");
      if (this.size) {
        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("list", this.size));
      }
    }
    if (this.type === "dropdowngrid") {
      this.renderer.setStyle(this.wrapper.nativeElement, "overflow-y", "scroll");
    }
    if (isPresent7(this.virtual)) {
      this.renderer.addClass(this.wrapper.nativeElement, this.listVirtualClass);
    }
  }
  static ɵfac = function ListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ListComponent)(ɵɵdirectiveInject(DataService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(DisabledItemsService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ListComponent,
    selectors: [["kendo-list"]],
    viewQuery: function ListComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c111, 7);
        ɵɵviewQuery(_c211, 7);
        ɵɵviewQuery(_c311, 5);
        ɵɵviewQuery(ListItemDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.content = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.list = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.virtualContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.items = _t);
      }
    },
    inputs: {
      selected: "selected",
      focused: "focused",
      textField: "textField",
      valueField: "valueField",
      height: "height",
      template: "template",
      groupTemplate: "groupTemplate",
      fixedGroupTemplate: "fixedGroupTemplate",
      show: "show",
      id: "id",
      optionPrefix: "optionPrefix",
      multipleSelection: "multipleSelection",
      virtual: "virtual",
      type: "type",
      checkboxes: "checkboxes",
      ariaLive: "ariaLive",
      isMultiselect: "isMultiselect",
      isActionSheetExpanded: "isActionSheetExpanded",
      showStickyHeader: "showStickyHeader",
      rowWidth: "rowWidth",
      data: "data",
      size: "size",
      rounded: "rounded"
    },
    outputs: {
      onClick: "onClick",
      pageChange: "pageChange",
      listResize: "listResize",
      popupListScroll: "popupListScroll"
    },
    features: [ɵɵNgOnChangesFeature],
    decls: 9,
    vars: 15,
    consts: [["content", ""], ["list", ""], ["li", ""], ["virtualContainer", ""], [3, "class", "ngStyle", 4, "ngIf"], ["unselectable", "on", 3, "scroll"], ["role", "listbox"], [4, "ngIf"], [3, "resize", 4, "ngIf"], ["class", "k-height-container", "role", "presentation", 4, "ngIf"], [3, "ngStyle"], [3, "ngIf"], [3, "templateContext"], ["ngFor", "", 3, "ngForOf"], ["role", "option", "kendoDropDownsSelectable", "", 3, "checkboxes", "height", "index", "multipleSelection", "ngClass"], ["type", "checkbox", "class", "k-checkbox", "role", "presentation", "tabindex", "-1", "aria-hidden", "true", 3, "ngClass", "checked", "change", 4, "ngIf"], ["type", "checkbox", "role", "presentation", "tabindex", "-1", "aria-hidden", "true", 1, "k-checkbox", 3, "change", "ngClass", "checked"], [1, "k-list-item-text"], ["role", "group", 3, "class", "k-table-alt-row", "ngStyle", "width", 4, "ngIf"], ["role", "option", "kendoDropDownsSelectable", "", 3, "height", "index", "multipleSelection", "class", "ngClass", "width", 4, "ngIf"], ["role", "group", 3, "ngStyle"], ["role", "option", "kendoDropDownsSelectable", "", 3, "height", "index", "multipleSelection", "ngClass"], [3, "resize"], ["role", "presentation", 1, "k-height-container"]],
    template: function ListComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵtemplate(0, ListComponent_div_0_Template, 3, 9, "div", 4);
        ɵɵelementStart(1, "div", 5, 0);
        ɵɵlistener("scroll", function ListComponent_Template_div_scroll_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.popupListScroll.emit($event));
        });
        ɵɵelementStart(3, "ul", 6, 1);
        ɵɵtemplate(5, ListComponent_5_Template, 1, 1, null, 7)(6, ListComponent_6_Template, 1, 1, null, 7)(7, ListComponent_kendo_resize_sensor_7_Template, 1, 0, "kendo-resize-sensor", 8);
        ɵɵelementEnd();
        ɵɵtemplate(8, ListComponent_div_8_Template, 4, 2, "div", 9);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.dataService.grouped && ctx.showStickyHeader);
        ɵɵadvance();
        ɵɵclassMap(ctx.listContentClass);
        ɵɵstyleProp("max-height", ctx.height, "px");
        ɵɵadvance(2);
        ɵɵclassMap(ctx.listClass);
        ɵɵattribute("id", ctx.id)("aria-live", ctx.ariaLive)("aria-multiselectable", ctx.isMultiselect)("aria-hidden", !ctx.show);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", !ctx.dataService.grouped && ctx.show);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.dataService.grouped);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.virtual);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.virtual);
      }
    },
    dependencies: [NgIf, NgStyle, TemplateContextDirective, NgForOf, ListItemDirective, SelectableDirective, NgClass, ResizeSensorComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ListComponent, [{
    type: Component,
    args: [{
      selector: "kendo-list",
      template: `
    <div *ngIf="dataService.grouped && showStickyHeader"
        [class]="listGroupStickyHeaderClass"
        [ngStyle]="{
            'height.px': virtual?.itemHeight,
            'minHeight.px' : virtual?.itemHeight,
            'boxSizing' : virtual ? 'border-box' : 'inherit'}"
        >
        <ng-template *ngIf="fixedGroupTemplate"
            [templateContext]="{
                templateRef: fixedGroupTemplate.templateRef,
                $implicit: currentGroup
            }">
        </ng-template>
        <ng-template [ngIf]="!fixedGroupTemplate"><span [class]="listGroupStickyHeaderTextClass">{{ currentGroup }}</span></ng-template>
    </div>
    <div #content
        [class]="listContentClass"
        [style.maxHeight.px]="height"
        unselectable="on"
        (scroll)="popupListScroll.emit($event)">
    <ul #list
        role="listbox"
        [class]="listClass"
        [attr.id]="id"
        [attr.aria-live]="ariaLive"
        [attr.aria-multiselectable]="isMultiselect"
        [attr.aria-hidden]="!show">
         <ng-template *ngIf="!dataService.grouped && show" ngFor let-dataItem let-itemIndex="index" [ngForOf]="data">
            <li
                role="option"
                kendoDropDownsSelectable
                [checkboxes]="checkboxes"
                [height]="virtual?.itemHeight"
                [index]="itemIndex + startFrom"
                [multipleSelection]="multipleSelection"
                [attr.id]="optionPrefix + '-' + itemIndex"
                [attr.tabIndex]="-1"
                [attr.aria-selected]="isItemSelected(itemIndex)"
                [class]="listItemClass"
                [ngClass]="{
                    'k-disabled': isDisabled(itemIndex),
                    'k-table-alt-row': isAltRow(itemIndex)
                }"
                [style.width.px]="rowWidth ?? null"
            >
                <input
                    *ngIf="checkboxes.enabled"
                    type="checkbox"
                    class="k-checkbox"
                    role="presentation"
                    tabindex="-1"
                    aria-hidden="true"
                    [ngClass]="checkboxClasses"
                    (change)="onCheckedChange($event, itemIndex + startFrom)"
                    [checked]="isChecked(itemIndex)"
                />
                <ng-template *ngIf="template"
                    [templateContext]="{
                        templateRef: template.templateRef,
                        $implicit: dataItem
                    }">
                </ng-template>
                <ng-template [ngIf]="!template"><span class="k-list-item-text">{{ getText(dataItem) }}</span></ng-template>
            </li>
         </ng-template>
         <ng-template *ngIf="dataService.grouped" ngFor let-dataItem let-itemIndex="index" [ngForOf]="data">
            <li
                #li
                *ngIf="dataItem.header"
                role="group"
                [class]="listGroupItemClass"
                [class.k-table-alt-row]="isAltRow(itemIndex - 1)"
                [ngStyle]="{
                    'height.px': virtual?.itemHeight,
                    'minHeight.px' : virtual?.itemHeight,
                    'boxSizing' : virtual ? 'border-box' : 'inherit'}"
                [attr.group-index]="dataItem.index"
                [attr.id]="optionPrefix + '-' + dataItem.groupIndex + '-' + dataItem.value.toString().split(' ').join('')"
                [attr.tabIndex]="-1"
                [style.width.px]="rowWidth ?? null">
                    <span [class]="listGroupItemTextClass">
                        <ng-template *ngIf="groupTemplate"
                            [templateContext]="{
                                templateRef: groupTemplate.templateRef,
                                $implicit: dataItem.value
                        }">
                        </ng-template>
                        <ng-template [ngIf]="!groupTemplate">{{ dataItem.value }}</ng-template>
                    </span>
            </li>
            <li
                #li
                *ngIf="!dataItem.header"
                role="option"
                kendoDropDownsSelectable
                [height]="virtual?.itemHeight"
                [index]="dataItem.offsetIndex"
                [multipleSelection]="multipleSelection"
                [attr.absolute-index]="dataItem.index"
                [attr.id]="optionPrefix + '-' + (itemIndex - 1 - dataItem.groupIndex)"
                [attr.tabIndex]="-1"
                [attr.aria-selected]="isItemSelected(dataItem.offsetIndex)"
                [class]="listItemClass"
                [ngClass]="{
                    'k-disabled': isDisabled(dataItem.offsetIndex),
                    'k-table-alt-row': isAltRow(itemIndex - 1)
                }"
                [style.width.px]="rowWidth ?? null"
            >
                <ng-template *ngIf="template"
                    [templateContext]="{
                        templateRef: template.templateRef,
                        $implicit: dataItem.value
                    }">
                </ng-template>
                <ng-template [ngIf]="!template"><span class="k-list-item-text">{{ getText(dataItem.value) }}</span></ng-template>
            </li>
        </ng-template>
        <kendo-resize-sensor
            *ngIf="!virtual"
            (resize)="listResize.emit()"
        >
        </kendo-resize-sensor>
    </ul>
    <div *ngIf="virtual" #virtualContainer class="k-height-container" role="presentation">
        <div [style.height.px]="scrollHeight">
            <kendo-resize-sensor (resize)="listResize.emit()"></kendo-resize-sensor>
        </div>
    </div>
    </div>
  `,
      standalone: true,
      imports: [NgIf, NgStyle, TemplateContextDirective, NgForOf, ListItemDirective, SelectableDirective, NgClass, ResizeSensorComponent]
    }]
  }], function() {
    return [{
      type: DataService
    }, {
      type: ElementRef
    }, {
      type: SelectionService2
    }, {
      type: DisabledItemsService
    }, {
      type: ChangeDetectorRef
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }];
  }, {
    selected: [{
      type: Input
    }],
    focused: [{
      type: Input
    }],
    textField: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    template: [{
      type: Input
    }],
    groupTemplate: [{
      type: Input
    }],
    fixedGroupTemplate: [{
      type: Input
    }],
    show: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    optionPrefix: [{
      type: Input
    }],
    multipleSelection: [{
      type: Input
    }],
    virtual: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    checkboxes: [{
      type: Input
    }],
    ariaLive: [{
      type: Input
    }],
    isMultiselect: [{
      type: Input
    }],
    isActionSheetExpanded: [{
      type: Input
    }],
    showStickyHeader: [{
      type: Input
    }],
    rowWidth: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    onClick: [{
      type: Output
    }],
    pageChange: [{
      type: Output
    }],
    listResize: [{
      type: Output
    }],
    popupListScroll: [{
      type: Output
    }],
    items: [{
      type: ViewChildren,
      args: [ListItemDirective]
    }],
    content: [{
      type: ViewChild,
      args: ["content", {
        static: true
      }]
    }],
    list: [{
      type: ViewChild,
      args: ["list", {
        static: true
      }]
    }],
    virtualContainer: [{
      type: ViewChild,
      args: ["virtualContainer", {
        static: false
      }]
    }]
  });
})();
var DEFAULTS = {
  pageSize: 50,
  itemHeight: 28
};
var normalizeVirtualizationSettings = (settings, defaultOverrides) => {
  const defaults = Object.assign({}, DEFAULTS, defaultOverrides);
  if (settings === true) {
    return defaults;
  }
  if (!settings) {
    return null;
  }
  return __spreadValues({
    pageSize: DEFAULTS.pageSize
  }, settings);
};
var ResponsiveRendererComponent = class _ResponsiveRendererComponent {
  localization;
  title;
  showActionButtons;
  subtitle;
  size;
  showTextInput;
  sharedPopupActionSheetTemplate;
  isActionSheetExpanded;
  text;
  placeholder;
  closePopup = new EventEmitter();
  textInputChange = new EventEmitter();
  navigate = new EventEmitter();
  onExpand = new EventEmitter();
  onCollapse = new EventEmitter();
  onApply = new EventEmitter();
  onCancel = new EventEmitter();
  actionSheet;
  actionSheetSearchBar;
  constructor(localization) {
    this.localization = localization;
  }
  searchBarValue = "";
  animationDuration = animationDuration2;
  xIcon = xIcon;
  expanded = false;
  messageFor(key) {
    return this.localization.get(key);
  }
  onValueChange(value) {
    this.searchBarValue = value;
    this.textInputChange.emit(value);
  }
  onOverlayClick() {
    if (this.expanded) {
      this.handleClose();
    }
  }
  handleExpand() {
    this.onExpand.emit();
    this.expanded = true;
  }
  handleClose() {
    this.closePopup.emit();
    this.expanded = false;
  }
  static ɵfac = function ResponsiveRendererComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ResponsiveRendererComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ResponsiveRendererComponent,
    selectors: [["responsive-renderer"]],
    viewQuery: function ResponsiveRendererComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(ActionSheetComponent, 5);
        ɵɵviewQuery(_c74, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheet = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheetSearchBar = _t.first);
      }
    },
    inputs: {
      title: "title",
      showActionButtons: "showActionButtons",
      subtitle: "subtitle",
      size: "size",
      showTextInput: "showTextInput",
      sharedPopupActionSheetTemplate: "sharedPopupActionSheetTemplate",
      isActionSheetExpanded: "isActionSheetExpanded",
      text: "text",
      placeholder: "placeholder"
    },
    outputs: {
      closePopup: "closePopup",
      textInputChange: "textInputChange",
      navigate: "navigate",
      onExpand: "onExpand",
      onCollapse: "onCollapse",
      onApply: "onApply",
      onCancel: "onCancel"
    },
    decls: 3,
    vars: 4,
    consts: [["actionSheet", ""], ["actionSheetSearchBar", ""], [3, "overlayClick", "keydown", "expand", "collapse", "animation", "expanded"], ["kendoActionSheetTemplate", ""], [1, "k-text-center", "k-actionsheet-titlebar"], [1, "k-actionsheet-titlebar-group", "k-hbox"], [1, "k-actionsheet-title"], [1, "k-text-center"], [1, "k-actionsheet-subtitle", "k-text-center"], [1, "k-actionsheet-actions"], ["kendoButton", "", "icon", "x", "type", "button", "fillMode", "flat", "aria-hidden", "true", "innerCssClass", "k-button-icon", 3, "click", "svgIcon", "size", "tabIndex"], [1, "k-actionsheet-titlebar-group", "k-actionsheet-filter"], ["placeholder", "Filter", "class", "k-searchbox", "autocomplete", "off", 3, "value", "size", "valueChange", 4, "ngIf"], [1, "k-actionsheet-content", "!k-overflow-hidden"], [1, "k-list-container"], [4, "ngTemplateOutlet"], ["class", "k-actionsheet-footer k-actions k-actions-stretched", 4, "ngIf"], ["placeholder", "Filter", "autocomplete", "off", 1, "k-searchbox", 3, "valueChange", "value", "size"], ["kendoTextBoxPrefixTemplate", ""], ["name", "search"], [1, "k-actionsheet-footer", "k-actions", "k-actions-stretched"], ["kendoButton", "", "tabindex", "0", "aria-disabled", "false", "type", "button", "themeColor", "base", 3, "click", "keydown.enter", "size"], ["kendoButton", "", "tabindex", "0", "aria-disabled", "false", "type", "button", "themeColor", "primary", 3, "click", "keydown.enter", "size"]],
    template: function ResponsiveRendererComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "kendo-actionsheet", 2, 0);
        ɵɵlistener("overlayClick", function ResponsiveRendererComponent_Template_kendo_actionsheet_overlayClick_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onOverlayClick());
        })("keydown", function ResponsiveRendererComponent_Template_kendo_actionsheet_keydown_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.navigate.emit($event));
        })("expand", function ResponsiveRendererComponent_Template_kendo_actionsheet_expand_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleExpand());
        })("collapse", function ResponsiveRendererComponent_Template_kendo_actionsheet_collapse_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onCollapse.emit());
        });
        ɵɵtemplate(2, ResponsiveRendererComponent_ng_template_2_Template, 15, 9, "ng-template", 3);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("animation", ɵɵpureFunction1(2, _c84, ctx.animationDuration))("expanded", ctx.isActionSheetExpanded);
      }
    },
    dependencies: [ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, NgIf, TextBoxComponent, TextBoxPrefixTemplateDirective, IconComponent, NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResponsiveRendererComponent, [{
    type: Component,
    args: [{
      selector: "responsive-renderer",
      template: `
        <kendo-actionsheet
            #actionSheet
            [animation]="{ duration: animationDuration }"
            [expanded]="isActionSheetExpanded"
            (overlayClick)="onOverlayClick()"
            (keydown)="navigate.emit($event)"
            (expand)="handleExpand()"
            (collapse)="onCollapse.emit()"
        >
            <ng-template kendoActionSheetTemplate>
                <div class="k-text-center k-actionsheet-titlebar">
                    <div class="k-actionsheet-titlebar-group k-hbox">
                        <div class="k-actionsheet-title">
                            <div class="k-text-center">{{ title }}</div>
                            <div class="k-actionsheet-subtitle k-text-center">{{ subtitle }}</div>
                        </div>
                        <div class="k-actionsheet-actions">
                            <button
                                kendoButton
                                icon="x"
                                type="button"
                                [attr.title]="messageFor('clearTitle')"
                                [svgIcon]="xIcon"
                                fillMode="flat"
                                [size]="size"
                                [tabIndex]="-1"
                                aria-hidden="true"
                                innerCssClass="k-button-icon"
                                (click)="handleClose()"
                            ></button>
                        </div>
                    </div>
                    <div class="k-actionsheet-titlebar-group k-actionsheet-filter">
                        <kendo-textbox
                            *ngIf="showTextInput"
                            #actionSheetSearchBar
                            [value]="searchBarValue"
                            [size]="size"
                            placeholder="Filter"
                            class="k-searchbox"
                            autocomplete="off"
                            (valueChange)="onValueChange($event)"
                        >
                            <ng-template kendoTextBoxPrefixTemplate>
                                <kendo-icon name="search"></kendo-icon>
                            </ng-template>
                        </kendo-textbox>
                    </div>
                </div>
                <div class="k-actionsheet-content !k-overflow-hidden">
                    <div class="k-list-container">
                        <ng-container *ngTemplateOutlet="sharedPopupActionSheetTemplate"></ng-container>
                    </div>
                </div>

                <div *ngIf="showActionButtons" class="k-actionsheet-footer k-actions k-actions-stretched">
                    <button kendoButton 
                        tabindex="0"
                        aria-disabled="false"
                        type="button"
                        [size]="size"
                        themeColor="base"
                        (click)="onCancel.emit()"
                        (keydown.enter)="$event.stopImmediatePropagation()">
                        {{messageFor('cancelButton')}}
                    </button>
                    <button kendoButton
                        tabindex="0"
                        aria-disabled="false"
                        type="button"
                        [size]="size"
                        themeColor="primary"
                        (click)="onApply.emit()"
                        (keydown.enter)="$event.stopImmediatePropagation()">
                        {{messageFor('applyButton')}}
                    </button>
                </div>
            </ng-template>
        </kendo-actionsheet>
    `,
      standalone: true,
      imports: [ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, NgIf, TextBoxComponent, TextBoxPrefixTemplateDirective, IconComponent, NgTemplateOutlet]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, {
    title: [{
      type: Input
    }],
    showActionButtons: [{
      type: Input
    }],
    subtitle: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    showTextInput: [{
      type: Input
    }],
    sharedPopupActionSheetTemplate: [{
      type: Input
    }],
    isActionSheetExpanded: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    closePopup: [{
      type: Output
    }],
    textInputChange: [{
      type: Output
    }],
    navigate: [{
      type: Output
    }],
    onExpand: [{
      type: Output
    }],
    onCollapse: [{
      type: Output
    }],
    onApply: [{
      type: Output
    }],
    onCancel: [{
      type: Output
    }],
    actionSheet: [{
      type: ViewChild,
      args: [ActionSheetComponent]
    }],
    actionSheetSearchBar: [{
      type: ViewChild,
      args: ["actionSheetSearchBar"]
    }]
  });
})();
var SharedDropDownEventsDirective = class _SharedDropDownEventsDirective {
  ngZone;
  renderer;
  cdr;
  hostElement;
  clearButtonClicked;
  isFocused;
  isFocusedChange = new EventEmitter();
  onFocus = new EventEmitter();
  handleBlur = new EventEmitter();
  subscriptions = new Subscription();
  constructor(ngZone, renderer, cdr) {
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.cdr = cdr;
  }
  ngAfterViewInit() {
    const hostElement = this.hostElement.nativeElement;
    let cursorInsideWrapper = false;
    let tabbing = false;
    this.ngZone.runOutsideAngular(() => {
      this.subscriptions.add(this.renderer.listen(hostElement, "focusin", () => {
        this.cdr.detectChanges();
        if (!this.isFocused) {
          this.ngZone.run(() => {
            this.onFocus.emit();
            this.isFocused = true;
            this.isFocusedChange.emit(this.isFocused);
          });
        }
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "focusout", (args) => {
        if (!this.isFocused) {
          return;
        }
        if (tabbing) {
          const closestTextbox = closest(args.relatedTarget, (element) => element === hostElement);
          if (!closestTextbox) {
            this.handleBlur.emit();
          }
          tabbing = false;
        } else {
          if (!cursorInsideWrapper) {
            this.handleBlur.emit();
          }
        }
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "mouseenter", () => {
        cursorInsideWrapper = true;
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "mouseleave", () => {
        cursorInsideWrapper = false;
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "keydown", (args) => {
        if (args.keyCode === Keys.Tab) {
          tabbing = true;
        } else {
          tabbing = false;
        }
      }));
    });
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  static ɵfac = function SharedDropDownEventsDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SharedDropDownEventsDirective)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SharedDropDownEventsDirective,
    selectors: [["", "kendoDropDownSharedEvents", ""]],
    inputs: {
      hostElement: "hostElement",
      clearButtonClicked: "clearButtonClicked",
      isFocused: "isFocused"
    },
    outputs: {
      isFocusedChange: "isFocusedChange",
      onFocus: "onFocus",
      handleBlur: "handleBlur"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SharedDropDownEventsDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownSharedEvents]",
      standalone: true
    }]
  }], function() {
    return [{
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    hostElement: [{
      type: Input
    }],
    clearButtonClicked: [{
      type: Input
    }],
    isFocused: [{
      type: Input
    }],
    isFocusedChange: [{
      type: Output
    }],
    onFocus: [{
      type: Output
    }],
    handleBlur: [{
      type: Output
    }]
  });
})();
var Messages3 = class _Messages extends ComponentMessages {
  /**
   * The text displayed in the popup when there are no items.
   */
  noDataText;
  /**
   * The title of the clear button.
   */
  clearTitle;
  /**
   * The text displayed for the check-all checkbox.
   */
  checkAllText;
  /**
   * The text set as aria-label on the select button.
   */
  selectButtonText;
  /**
   * The text set as aria-label on the list filter input.
   */
  filterInputLabel;
  /**
   * The text set as aria-label on the popup containing the list of options when its role is `region`.
   */
  popupLabel;
  /**
   * The text of the Apply button in the MultiSelect action sheet.
   */
  applyButton;
  /**
   * The text of the Cancel button in the MultiSelect action sheet.
   */
  cancelButton;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMessages_BaseFactory;
    return function Messages_Factory(__ngFactoryType__) {
      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵɵgetInheritedFactory(_Messages)))(__ngFactoryType__ || _Messages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _Messages,
    inputs: {
      noDataText: "noDataText",
      clearTitle: "clearTitle",
      checkAllText: "checkAllText",
      selectButtonText: "selectButtonText",
      filterInputLabel: "filterInputLabel",
      popupLabel: "popupLabel",
      applyButton: "applyButton",
      cancelButton: "cancelButton"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Messages3, [{
    type: Directive
  }], null, {
    noDataText: [{
      type: Input
    }],
    clearTitle: [{
      type: Input
    }],
    checkAllText: [{
      type: Input
    }],
    selectButtonText: [{
      type: Input
    }],
    filterInputLabel: [{
      type: Input
    }],
    popupLabel: [{
      type: Input
    }],
    applyButton: [{
      type: Input
    }],
    cancelButton: [{
      type: Input
    }]
  });
})();
var LocalizedMessagesDirective3 = class _LocalizedMessagesDirective extends Messages3 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedMessagesDirective,
    selectors: [["", "kendoDropDownListLocalizedMessages", ""], ["", "kendoDropDownTreeLocalizedMessages", ""], ["", "kendoComboBoxLocalizedMessages", ""], ["", "kendoMultiColumnComboBoxLocalizedMessages", ""], ["", "kendoAutoCompleteLocalizedMessages", ""], ["", "kendoMultiSelectLocalizedMessages", ""], ["", "kendoMultiSelectTreeLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: Messages3,
      useExisting: forwardRef(() => _LocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedMessagesDirective3, [{
    type: Directive,
    args: [{
      providers: [{
        provide: Messages3,
        useExisting: forwardRef(() => LocalizedMessagesDirective3)
      }],
      selector: `
    [kendoDropDownListLocalizedMessages],
    [kendoDropDownTreeLocalizedMessages],
    [kendoComboBoxLocalizedMessages],
    [kendoMultiColumnComboBoxLocalizedMessages],
    [kendoAutoCompleteLocalizedMessages],
    [kendoMultiSelectLocalizedMessages],
    [kendoMultiSelectTreeLocalizedMessages]
  `,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var NO_VALUE = "";
var DEFAULT_SIZE$52 = "medium";
var DEFAULT_ROUNDED$52 = "medium";
var DEFAULT_FILL_MODE$52 = "solid";
var AUTOCOMPLETE_VALUE_ACCESSOR = {
  multi: true,
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => AutoCompleteComponent)
};
var AutoCompleteComponent = class _AutoCompleteComponent {
  localization;
  dataService;
  popupService;
  selectionService;
  navigationService;
  disabledItemsService;
  _zone;
  cdr;
  renderer;
  hostElement;
  injector;
  adaptiveService;
  /**
   * @hidden
   */
  animationDuration = animationDuration2;
  /**
   * @hidden
   */
  xIcon = xIcon;
  /**
   * @hidden
   */
  responsiveRendererComponent;
  /**
   * @hidden
   */
  get actionSheet() {
    return this.responsiveRendererComponent?.actionSheet;
  }
  /**
   * @hidden
   */
  get actionSheetSearchBar() {
    return this.responsiveRendererComponent?.actionSheetSearchBar;
  }
  get width() {
    let wrapperOffsetWidth = 0;
    if (isDocumentAvailable()) {
      wrapperOffsetWidth = this.wrapper.offsetWidth;
    }
    const width = this.popupSettings.width || wrapperOffsetWidth;
    const minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : `${wrapperOffsetWidth}px`;
    const maxWidth = isNaN(width) ? width : `${width}px`;
    return {
      min: minWidth,
      max: maxWidth
    };
  }
  get height() {
    const popupHeight = this.popupSettings.height;
    return isPresent7(popupHeight) ? `${popupHeight}px` : "auto";
  }
  get listContainerClasses() {
    const containerClasses = ["k-list-container", "k-autocomplete-popup"];
    if (this.popupSettings.popupClass) {
      containerClasses.push(this.popupSettings.popupClass);
    }
    return containerClasses;
  }
  get suggestion() {
    if (!this.text || !this.suggestedText) {
      this.suggestedText = void 0;
      return;
    }
    const hasMatch = this.suggestedText.toLowerCase().startsWith(this.text.toLowerCase());
    const shouldSuggest = this.suggest && !this.backspacePressed;
    if (shouldSuggest && hasMatch) {
      return this.suggestedText;
    }
  }
  get appendTo() {
    const {
      appendTo
    } = this.popupSettings;
    if (!appendTo || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  get clearButtonVisiblity() {
    if (touchEnabled) {
      return "visible";
    }
  }
  get ariaControls() {
    return this.isOpen ? this.listBoxId : void 0;
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.formControl);
  }
  dataItem;
  /**
   * Toggles the visibility of the popup or actionSheet.
   * If you use the `toggle` method to open or close the popup or actionSheet, the `open` and `close` events will not be fired.
   *
   * @param open - The state of the popup.
   */
  toggle(open) {
    Promise.resolve(null).then(() => {
      const shouldOpen = isPresent7(open) ? open : !this._open;
      this._toggle(shouldOpen);
    });
  }
  /**
   * Returns the current open state. Returns `true` if the popup or actionSheet is open.
   */
  get isOpen() {
    return isTruthy2(this._open || this.isActionSheetExpanded);
  }
  /**
   * @hidden
   */
  handleClick() {
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.togglePopup(true);
    }
  }
  /**
   * @hidden
   */
  togglePopup(open) {
    const isDisabled2 = this.disabled || this.readonly;
    const sameState = this.isOpen === open;
    if (isDisabled2 || sameState) {
      return;
    }
    const isDefaultPrevented2 = this.triggerPopupEvents(open);
    if (!isDefaultPrevented2) {
      this._toggle(open);
    }
  }
  get activeDescendant() {
    if (!this.isOpen || !isPresent7(this.selectionService.focused) || this.selectionService.focused === -1) {
      return null;
    }
    return this.optionPrefix + "-" + this.selectionService.focused;
  }
  /**
   * Defines whether the first match from the suggestions list will be automatically focused.
   * By default, `highlightFirst` is set to `true`.
   */
  highlightFirst = true;
  /**
   * Shows or hides the current group sticky header when using grouped data.
   * By default the sticky header is displayed ([see example]({% slug grouping_autocomplete %}#toc-sticky-header)).
   */
  showStickyHeader = true;
  /**
   * @hidden
   */
  focusableId = `k-${guid2()}`;
  /**
   * Sets the data of the AutoComplete.
   *
   * > The data has to be provided in an array-like list.
   */
  set data(data) {
    this.dataService.data = data || [];
    if (this.virtual) {
      this.virtual.skip = 0;
    }
    if (this.filterable) {
      this.selectionService.focused = this.isOpen && this.data.length && this.highlightFirst ? this.firstFocusableIndex(0) : -1;
    }
    if (this.suggest && this.dataService.itemsCount > 0) {
      this.suggestedText = getter2(this.dataService.itemAt(0), this.valueField);
    }
  }
  get data() {
    const virtual = this.virtual;
    if (virtual) {
      const start = virtual.skip || 0;
      const end = start + virtual.pageSize;
      virtual.total = this.dataService.data.length;
      return this.dataService.data.slice(start, end);
    }
    return this.dataService.data;
  }
  /**
   * Sets the value of the AutoComplete.
   */
  set value(newValue) {
    this.verifySettings(newValue);
    this._value = newValue || NO_VALUE;
    this.text = this.value;
    this.cdr.markForCheck();
  }
  get value() {
    return this._value || NO_VALUE;
  }
  /**
   * Specifies the `string` property of the data item that represents the item value.
   * If the data contains only primitive values, do not define it.
   *
   * > The `valueField` property can be set to point to a nested property value - e.g. `category.name`.
   */
  valueField;
  /**
   * The hint which is displayed when the component is empty.
   */
  placeholder = "";
  /**
   * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.
   */
  adaptiveMode = "none";
  /**
   * Sets the title of the ActionSheet that is rendered instead of the Popup when using small screen devices.
   * By default the ActionSheet title uses the text provided for the label of the AutoComplete.
   */
  title = "";
  /**
   * Sets the subtitle of the ActionSheet that is rendered instead of the Popup when using small screen devices.
   * By default the ActionSheet subtitle uses the text provided for the `placeholder` of the AutoComplete.
  */
  set subtitle(_subtitle) {
    this._subtitle = _subtitle;
  }
  get subtitle() {
    return this._subtitle || this.placeholder;
  }
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * Configures the popup of the AutoComplete.
   *
   * The available options are:
   * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
   * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.
   * - `height: Number`&mdash;Sets the height of the popup container.
   * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
   * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
   */
  set popupSettings(settings) {
    this._popupSettings = Object.assign({
      animate: true
    }, settings);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Sets the height of the options list in the popup. By default, `listHeight` is 200px.
   *
   * > The `listHeight` property affects only the list of options and not the whole popup container.
   * > To set the height of the popup container, use `popupSettings.height`.
   *
   * > When using `adaptiveMode` and the screen size is `small` or `medium` the `listHeight` property is set to null.
   */
  set listHeight(_listHeight) {
    this._listHeight = _listHeight;
  }
  get listHeight() {
    if (this.isAdaptive) {
      return;
    }
    return this._listHeight;
  }
  _listHeight = 200;
  /**
   * Sets and gets the loading state of the AutoComplete.
   */
  loading;
  /**
   * @hidden
   *
   * If set to `true`, renders a button on hovering over the component.
   * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.
   */
  clearButton = true;
  /**
   * Enables the auto-completion of the text based on the first data item.
   */
  suggest;
  /**
   * Sets the disabled state of the component. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_autocomplete#toc-managing-the-autocomplete-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Defines a Boolean function that is executed for each data item in the component
   * ([see examples]({% slug disableditems_autocomplete %})).
   * Determines whether the item will be disabled.
   */
  set itemDisabled(fn) {
    if (typeof fn !== "function") {
      throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this.disabledItemsService.itemDisabled = fn;
  }
  /**
   * Sets the read-only state of the component.
   *
   * @default false
   */
  readonly = false;
  /**
   * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Enables the [filtering]({% slug filtering_autocomplete %}) functionality.
   * If set to `true`, the component emits the `filterChange` event.
   */
  filterable = false;
  /**
   * Enables the [virtualization]({% slug virtualization_autocomplete %}) functionality.
   */
  set virtual(settings) {
    this._virtualSettings = normalizeVirtualizationSettings(settings);
  }
  get virtual() {
    return this._virtualSettings;
  }
  /**
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$52;
    this.renderer.removeClass(this.wrapper, getSizeClass2("input", this.size));
    if (size !== "none") {
      this.renderer.addClass(this.wrapper, getSizeClass2("input", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `full`
   * * `none`
   *
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED$52;
    this.renderer.removeClass(this.wrapper, getRoundedClass(this.rounded));
    if (rounded !== "none") {
      this.renderer.addClass(this.wrapper, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the fillMode of the component.
   *
   * The possible values are:
   * * `flat`
   * * `solid` (default)
   * * `outline`
   * * `none`
   *
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$52;
    this.renderer.removeClass(this.wrapper, getFillModeClass("input", this.fillMode));
    if (fillMode !== "none") {
      this.renderer.addClass(this.wrapper, getFillModeClass("input", newFillMode));
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
   */
  inputAttributes;
  /**
   * Fires each time the value is changed&mdash;
   * when the component is blurred or the value is cleared through the **Clear** button
   * ([see example](slug:events_autocomplete)).
   * When the value of the component is programmatically changed to `ngModel` or `formControl`
   * through its API or form binding, the `valueChange` event is not triggered because it
   * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the user types in the input field.
   * You can filter the source based on the passed filtration value
   * ([see example](slug:events_autocomplete)).
   */
  filterChange = new EventEmitter();
  /**
   * Fires each time the popup is about to open.
   * This event is preventable. If you cancel it, the popup will remain closed.
   */
  open = new EventEmitter();
  /**
   * Fires after the popup has been opened.
   */
  opened = new EventEmitter();
  /**
   * Fires each time the popup is about to close.
   * This event is preventable. If you cancel it, the popup will remain open.
   */
  close = new EventEmitter();
  /**
   * Fires after the popup has been closed.
   */
  closed = new EventEmitter();
  /**
   * Fires each time the user focuses the AutoComplete.
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the AutoComplete gets blurred.
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the user focuses the `input` element.
   */
  inputFocus = new EventEmitter();
  /**
   * Fires each time the `input` element gets blurred.
   */
  inputBlur = new EventEmitter();
  template;
  headerTemplate;
  footerTemplate;
  noDataTemplate;
  groupTemplate;
  fixedGroupTemplate;
  /**
   * @hidden
   */
  suffixTemplate;
  /**
   * @hidden
   */
  prefixTemplate;
  container;
  popupTemplate;
  searchbar;
  optionsList;
  widgetClasses = true;
  get isFocused() {
    return this._isFocused;
  }
  set isFocused(isFocused) {
    this.renderer[isFocused ? "addClass" : "removeClass"](this.wrapper, "k-focus");
    this._isFocused = isFocused;
  }
  get isDisabled() {
    return this.disabled;
  }
  get isLoading() {
    return this.loading;
  }
  get dir() {
    return this.direction;
  }
  text;
  listBoxId = `k-${guid2()}`;
  optionPrefix = `k-${guid2()}`;
  popupRef;
  /**
   * @hidden
   */
  windowSize = "large";
  /**
   * @hidden
   */
  get isActionSheetExpanded() {
    return this.actionSheet?.expanded;
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  onChangeCallback = noop6;
  onTouchedCallback = noop6;
  constructor(localization, dataService, popupService, selectionService, navigationService, disabledItemsService, _zone, cdr, renderer, hostElement, injector, adaptiveService) {
    this.localization = localization;
    this.dataService = dataService;
    this.popupService = popupService;
    this.selectionService = selectionService;
    this.navigationService = navigationService;
    this.disabledItemsService = disabledItemsService;
    this._zone = _zone;
    this.cdr = cdr;
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.injector = injector;
    this.adaptiveService = adaptiveService;
    validatePackage(packageMetadata7);
    this.direction = localization.rtl ? "rtl" : "ltr";
    this.wrapper = this.hostElement.nativeElement;
    this.data = [];
    this.subscribeEvents();
    this.subscribeTouchEvents();
    this.selectionService.resetSelection([-1]);
  }
  ngOnInit() {
    this.renderer.removeAttribute(this.wrapper, "tabindex");
    this.subs.add(this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
      this.cdr.detectChanges();
    }));
    this.setComponentClasses();
  }
  ngAfterViewInit() {
    this.windowSize = this.adaptiveService.size;
    this.cdr.detectChanges();
    if (this.actionSheet && isDocumentAvailable()) {
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-height", "60vh");
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-max-height", "none");
    }
  }
  ngOnDestroy() {
    this.destroyPopup();
    this.subs.unsubscribe();
    if (this.touchstartDisposeHandler) {
      this.touchstartDisposeHandler();
    }
  }
  ngOnChanges(changes) {
    const virtual = this.virtual;
    const requestInitialData = virtual && changes["data"] && changes["data"].isFirstChange();
    if (requestInitialData) {
      this.pageChange({
        skip: 0,
        take: virtual.pageSize
      });
    }
  }
  /**
   * Resets the value of the AutoComplete.
   * If you use the `reset` method to clear the value of the component,
   * the model will not update automatically and the `valueChange` event will not be fired.
   */
  reset() {
    this.value = NO_VALUE;
  }
  /**
   * @hidden
   */
  messageFor(key) {
    return this.localization.get(key);
  }
  /**
   * @hidden
   */
  onAdaptiveTextBoxChange(text) {
    this.search(text);
  }
  /**
   * @hidden
   */
  clearValue(event) {
    event.stopImmediatePropagation();
    this.focus();
    this.change(NO_VALUE);
    if (this.filterable) {
      this.filterChange.emit("");
    }
    this.selectionService.resetSelection([]);
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value;
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onChangeCallback = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.cdr.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * Focuses a specific item of the AutoComplete based on a provided index.
   * If null or invalid index is provided the focus will be removed.
   */
  focusItemAt(index) {
    const isInRange = index >= 0 && index < this.data.length;
    if (isPresent7(index) && isInRange && !this.disabledItemsService.isIndexDisabled(index)) {
      this.selectionService.focus(index);
    } else {
      this.selectionService.focus(-1);
    }
  }
  /**
   * Focuses the AutoComplete.
   */
  focus() {
    if (!this.disabled) {
      this.searchbar.focus();
    }
  }
  /**
   * Blurs the AutoComplete.
   */
  blur() {
    if (!this.disabled) {
      this.searchbar.blur();
    }
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (this.isAdaptiveModeEnabled && this.windowSize !== currentWindowSize) {
      if (this.isOpen) {
        this.togglePopup(false);
      }
      this.windowSize = currentWindowSize;
      this.cdr.detectChanges();
    }
    if (this._open && !this.isActionSheetExpanded) {
      const popupWrapper = this.popupRef.popupElement;
      const {
        min,
        max
      } = this.width;
      popupWrapper.style.minWidth = min;
      popupWrapper.style.width = max;
    }
  }
  emitChange(value) {
    this.onChangeCallback(value);
    this.valueChange.emit(value);
  }
  verifySettings(newValue) {
    if (!isDevMode()) {
      return;
    }
    if (isPresent7(newValue) && typeof newValue !== "string") {
      throw new Error("Expected value of type string. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/autocomplete/value-binding/");
    }
  }
  search(text, startFrom = 0) {
    const index = this.findIndex(text, startFrom);
    if (this.disabledItemsService.isIndexDisabled(index)) {
      if (index + 1 < this.dataService.itemsCount) {
        this.search(text, index + 1);
      } else {
        this.selectionService.focus(-1);
      }
    } else {
      this.selectionService.focus(index);
      if (this.suggest) {
        this.suggestedText = getter2(this.dataService.itemAt(index), this.valueField);
      }
    }
  }
  navigate(index) {
    if (!this.isOpen) {
      return;
    }
    this.selectionService.focus(index);
  }
  /**
   * @hidden
   */
  handleNavigate(event) {
    const focused = isNaN(this.selectionService.focused) ? this.firstFocusableIndex(0) : this.selectionService.focused;
    if (this.disabled || this.readonly || isNaN(focused)) {
      return;
    }
    const action = this.navigationService.process({
      current: focused,
      max: this.dataService.itemsCount - 1,
      min: 0,
      originalEvent: event
    });
    if (action !== NavigationAction.Undefined && action !== NavigationAction.Backspace && action !== NavigationAction.Delete && action !== NavigationAction.Home && action !== NavigationAction.End && action !== NavigationAction.Left && action !== NavigationAction.Right && action !== NavigationAction.PageDown && action !== NavigationAction.PageUp && (action === NavigationAction.Enter && this.isOpen || action !== NavigationAction.Enter)) {
      event.preventDefault();
    }
    if (action === NavigationAction.Tab && this.isActionSheetExpanded) {
      event.stopImmediatePropagation();
      this.togglePopup(false);
    }
  }
  handleEnter(event) {
    const focused = this.selectionService.focused;
    let value;
    if (this.isOpen) {
      event.originalEvent.preventDefault();
    }
    if (focused >= 0) {
      value = getter2(this.dataService.itemAt(focused), this.valueField);
    } else {
      const match2 = this.suggest && this.suggestedText && this.data.length && getter2(this.dataService.itemAt(0), this.valueField).toLowerCase() === this.searchbar.value.toLowerCase();
      if (this.isOpen && match2) {
        value = this.suggestedText;
      } else {
        value = this.searchbar.value;
      }
    }
    if (this.isActionSheetExpanded && focused >= 0) {
      this.togglePopup(false);
    }
    this.change(value);
  }
  handleEscape() {
    if (this.isOpen) {
      this.togglePopup(false);
    } else {
      this.value = "";
    }
    this.selectionService.focused = -1;
    this.suggestedText = null;
  }
  /**
   * @hidden
   */
  searchBarChange(text) {
    const currentTextLength = isPresent7(this.text) ? this.text.length : 0;
    this.backspacePressed = text.length < currentTextLength ? true : false;
    this.text = text;
    this.togglePopup(text.length > 0);
    if (!this.highlightFirst) {
      this.selectionService.focused = -1;
    }
    if (this.filterable) {
      this.filterChange.emit(text);
    } else if (this.highlightFirst) {
      this.search(text);
    }
  }
  /**
   * @hidden
   */
  onFilterChange(text) {
    if (this.filterable) {
      this.filterChange.emit(text);
    } else if (this.highlightFirst) {
      this.search(text);
    }
  }
  /**
   * @hidden
   */
  handleInputFocus() {
    this.handleFocus();
    if (hasObservers(this.inputFocus)) {
      this._zone.run(() => {
        this.inputFocus.emit();
      });
    }
  }
  /**
   * @hidden
   */
  handleFocus() {
    this._zone.run(() => {
      if (!this.isFocused && hasObservers(this.onFocus)) {
        this.onFocus.emit();
      }
      this.isFocused = true;
    });
  }
  /**
   * @hidden
   */
  handleBlur() {
    if (!this.isActionSheetExpanded) {
      this.isFocused = false;
      const valueHasChanged = this.value !== this.text;
      const runInZone = hasObservers(this.onBlur) || hasObservers(this.close) || isUntouched2(this.wrapper) || valueHasChanged;
      if (runInZone) {
        this._zone.run(() => {
          if (valueHasChanged) {
            this.change(this.searchbar.value);
          }
          this.onBlur.emit();
          this.onTouchedCallback();
          this.togglePopup(false);
        });
      } else {
        this.togglePopup(false);
      }
    }
  }
  /**
   * @hidden
   */
  handleInputBlur() {
    if (!this.isActionSheetExpanded) {
      const focused = this.filterable ? this.selectionService.focused : -1;
      this.searchbar.input.nativeElement.scrollLeft = 0;
      let dataItem;
      let text;
      if (focused !== -1) {
        dataItem = this.dataService.itemAt(focused);
        text = getter2(dataItem, this.valueField) || "";
      } else {
        text = this.searchbar.value;
      }
      const exactMatch = text === this.searchbar.value;
      const insensitiveMatch = text.toLowerCase() === this.searchbar.value.toLowerCase();
      if (!exactMatch && insensitiveMatch) {
        this.selectionService.resetSelection([]);
      }
      const valueHasChanged = this.value !== this.text;
      const runInZone = hasObservers(this.inputBlur) || hasObservers(this.close) || isUntouched2(this.wrapper) || valueHasChanged || this.formControl?.updateOn === "blur";
      if (runInZone) {
        this._zone.run(() => {
          if (valueHasChanged) {
            this.change(this.searchbar.value);
          }
          this.inputBlur.emit();
          this.onTouchedCallback();
          this.togglePopup(false);
        });
      } else {
        this.togglePopup(false);
      }
    }
  }
  /**
   * @hidden
   */
  pageChange(event) {
    const virtual = this.virtual;
    virtual.skip = event.skip;
  }
  change(value) {
    this.togglePopup(false);
    this.valueChangeSubject.next(value);
  }
  popupMouseDownHandler = (event) => event.preventDefault();
  _popupSettings = {
    animate: true
  };
  _virtualSettings;
  _open = false;
  _value = "";
  suggestedText;
  backspacePressed;
  subs = new Subscription();
  valueChangeSubject = new Subject();
  touchstartDisposeHandler;
  _subtitle;
  wrapper;
  _isFocused = false;
  direction;
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  subscribeEvents() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.subs.add(this.valueChangeSubject.subscribe((value) => {
      const hasChange = this.value !== value;
      const index = this.findIndex(value);
      this.selectionService.focused = index;
      this.value = value;
      this.text = value;
      if (hasChange) {
        this.emitChange(value);
      }
    }));
    this.subs.add(this.selectionService.onChange.subscribe(this.handleItemChange.bind(this)));
    this.subs.add(this.selectionService.onFocus.subscribe(this.handleItemFocus.bind(this)));
    this.subs.add(merge(this.navigationService.up, this.navigationService.down).subscribe((event) => this.navigate(event.index)));
    this.subs.add(this.navigationService.close.subscribe(() => this.togglePopup(false)));
    this.subs.add(this.navigationService.open.subscribe(() => this.togglePopup(true)));
    this.subs.add(this.navigationService.enter.subscribe(this.handleEnter.bind(this)));
    this.subs.add(this.navigationService.esc.subscribe(this.handleEscape.bind(this)));
    this.subs.add(merge(this.navigationService.pagedown, this.navigationService.pageup).subscribe((event) => {
      if (this.isOpen) {
        event.originalEvent.preventDefault();
        this.optionsList.scrollWithOnePage(NavigationAction[event.originalEvent.code]);
      }
    }));
  }
  findIndex(value, startFrom = 0) {
    let index;
    if (value && value.length && this.dataService.itemsCount) {
      index = this.dataService.findIndex(this.findIndexPredicate(value), startFrom);
    } else {
      index = -1;
    }
    return index;
  }
  subscribeTouchEvents() {
    if (!isDocumentAvailable() || !touchEnabled) {
      return;
    }
    this._zone.runOutsideAngular(() => (
      // Roll up AutoComplete on iOS when tapped outside
      this.touchstartDisposeHandler = this.renderer.listen(document, "touchstart", (e) => {
        const target = e.target;
        if (this.isFocused && !inDropDown(this.hostElement, target, this.popupRef)) {
          this._zone.run(() => this.blur());
        }
      })
    ));
  }
  handleItemChange(event) {
    const index = event.indices.length ? event.indices[0] : void 0;
    this.selectionService.resetSelection([-1]);
    if (!isPresent7(index)) {
      return;
    }
    const text = getter2(this.dataService.itemAt(index), this.valueField);
    this.change(text);
  }
  handleItemFocus(_event) {
    const focused = this.selectionService.focused;
    const shouldSuggest = Boolean(this.suggest && this.data && this.data.length && focused >= 0);
    if (shouldSuggest) {
      this.suggestedText = getter2(this.dataService.itemAt(focused), this.valueField);
    }
  }
  createPopup() {
    if (this.virtual) {
      this.virtual.skip = 0;
    }
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.openActionSheet();
      return;
    }
    const horizontalAlign = this.direction === "rtl" ? "right" : "left";
    const anchorPosition = {
      horizontal: horizontalAlign,
      vertical: "bottom"
    };
    const popupPosition = {
      horizontal: horizontalAlign,
      vertical: "top"
    };
    const appendToComponent = typeof this.popupSettings.appendTo === "string" && this.popupSettings.appendTo === "component";
    this.popupRef = this.popupService.open({
      anchor: this.wrapper,
      animate: this.popupSettings.animate,
      appendTo: this.appendTo,
      content: this.popupTemplate,
      popupClass: this.listContainerClasses,
      positionMode: appendToComponent ? "fixed" : "absolute",
      popupAlign: popupPosition,
      anchorAlign: anchorPosition
    });
    const popupWrapper = this.popupRef.popupElement;
    const {
      min,
      max
    } = this.width;
    popupWrapper.addEventListener("mousedown", this.popupMouseDownHandler);
    popupWrapper.style.minWidth = min;
    popupWrapper.style.width = max;
    popupWrapper.style.height = this.height;
    popupWrapper.setAttribute("dir", this.direction);
    if (!this.appendTo) {
      this.renderer.setAttribute(popupWrapper, "role", "region");
      this.renderer.setAttribute(popupWrapper, "aria-label", this.messageFor("popupLabel"));
    }
    this.subs.add(this.popupRef.popupOpen.subscribe(() => {
      this.cdr.detectChanges();
      setListBoxAriaLabelledBy(this.optionsList, this.searchbar.input, this.renderer);
      this.optionsList.scrollToItem(this.selectionService.focused);
      this.selectionService.focus(this.selectionService.focused);
      this.opened.emit();
    }));
    this.subs.add(this.popupRef.popupClose.subscribe(() => {
      this.closed.emit();
    }));
    this.subs.add(this.popupRef.popupAnchorViewportLeave.subscribe(() => this.togglePopup(false)));
  }
  destroyPopup() {
    if (this.popupRef) {
      this.popupRef.popupElement.removeEventListener("mousedown", this.popupMouseDownHandler);
      this.popupRef.close();
      this.popupRef = null;
    }
  }
  _toggle(open) {
    this._open = open;
    this.destroyPopup();
    if (this.isActionSheetExpanded) {
      this.closeActionSheet();
    }
    if (this._open) {
      this.createPopup();
    }
  }
  triggerPopupEvents(open) {
    const eventArgs = new PreventableEvent5();
    if (open) {
      this.open.emit(eventArgs);
    } else {
      this.close.emit(eventArgs);
    }
    return eventArgs.isDefaultPrevented();
  }
  firstFocusableIndex(index) {
    const maxIndex = this.data.length - 1;
    if (this.disabledItemsService.isIndexDisabled(index)) {
      return index < maxIndex ? this.firstFocusableIndex(index + 1) : void 0;
    } else {
      return index;
    }
  }
  findIndexPredicate(text) {
    if (this.dataService.grouped) {
      return (item) => {
        let itemText = getter2(item.value, this.valueField);
        itemText = !isPresent7(itemText) ? "" : itemText.toString().toLowerCase();
        return itemText.startsWith(text.toLowerCase());
      };
    } else {
      return (item) => {
        let itemText = getter2(item, this.valueField);
        itemText = !isPresent7(itemText) ? "" : itemText.toString().toLowerCase();
        return itemText.startsWith(text.toLowerCase());
      };
    }
  }
  setComponentClasses() {
    if (this.size !== "none") {
      this.renderer.addClass(this.wrapper, getSizeClass2("input", this.size));
    }
    if (this.rounded !== "none") {
      this.renderer.addClass(this.wrapper, getRoundedClass(this.rounded));
    }
    if (this.fillMode !== "none") {
      this.renderer.addClass(this.wrapper, getFillModeClass("input", this.fillMode));
    }
  }
  closeActionSheet() {
    this.actionSheet.toggle(false);
    this.filterable && this.filterChange.emit("");
    this.searchbar.input.nativeElement.focus();
    this.responsiveRendererComponent.searchBarValue = "";
    this.closed.emit();
  }
  openActionSheet() {
    this.actionSheet.toggle(true);
    this.cdr.detectChanges();
    setListBoxAriaLabelledBy(this.optionsList, this.searchbar.input, this.renderer);
    this.title = setActionSheetTitle(this.searchbar.input, this.title);
    updateActionSheetAdaptiveAppearance2(this.actionSheet, this.windowSize, this.renderer);
    this.cdr.detectChanges();
    this.opened.emit();
    this.optionsList.scrollToItem(this.selectionService.focused);
    this.selectionService.focus(this.selectionService.focused);
    this.actionSheetSearchBar.focus();
  }
  static ɵfac = function AutoCompleteComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AutoCompleteComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(DataService), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(NavigationService3), ɵɵdirectiveInject(DisabledItemsService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AutoCompleteComponent,
    selectors: [["kendo-autocomplete"]],
    contentQueries: function AutoCompleteComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, GroupTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FixedGroupTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, SuffixTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, PrefixTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fixedGroupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.suffixTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.prefixTemplate = _t.first);
      }
    },
    viewQuery: function AutoCompleteComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(ResponsiveRendererComponent, 5);
        ɵɵviewQuery(_c94, 7, ViewContainerRef);
        ɵɵviewQuery(_c104, 7);
        ɵɵviewQuery(SearchBarComponent, 7);
        ɵɵviewQuery(_c113, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.responsiveRendererComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.searchbar = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.optionsList = _t.first);
      }
    },
    hostVars: 11,
    hostBindings: function AutoCompleteComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.dir);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-autocomplete", ctx.widgetClasses)("k-input", ctx.widgetClasses)("k-disabled", ctx.isDisabled)("k-loading", ctx.isLoading);
      }
    },
    inputs: {
      highlightFirst: "highlightFirst",
      showStickyHeader: "showStickyHeader",
      focusableId: "focusableId",
      data: "data",
      value: "value",
      valueField: "valueField",
      placeholder: "placeholder",
      adaptiveMode: "adaptiveMode",
      title: "title",
      subtitle: "subtitle",
      popupSettings: "popupSettings",
      listHeight: "listHeight",
      loading: "loading",
      clearButton: "clearButton",
      suggest: "suggest",
      disabled: "disabled",
      itemDisabled: "itemDisabled",
      readonly: "readonly",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      filterable: "filterable",
      virtual: "virtual",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      inputAttributes: "inputAttributes"
    },
    outputs: {
      valueChange: "valueChange",
      filterChange: "filterChange",
      open: "open",
      opened: "opened",
      close: "close",
      closed: "closed",
      onFocus: "focus",
      onBlur: "blur",
      inputFocus: "inputFocus",
      inputBlur: "inputBlur"
    },
    exportAs: ["kendoAutoComplete"],
    features: [ɵɵProvidersFeature([AUTOCOMPLETE_VALUE_ACCESSOR, DataService, SelectionService2, NavigationService3, DisabledItemsService, LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.autocomplete"
    }, {
      provide: FilterableComponent,
      useExisting: forwardRef(() => _AutoCompleteComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _AutoCompleteComponent)
    }]), ɵɵNgOnChangesFeature],
    decls: 17,
    vars: 30,
    consts: () => {
      let i18n_0;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_0 = goog.getMsg("NO DATA FOUND");
        i18n_0 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_0;
      } else {
        i18n_0 = $localize`:kendo.autocomplete.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;
      }
      let i18n_1;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_1 = goog.getMsg("clear");
        i18n_1 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_1;
      } else {
        i18n_1 = $localize`:kendo.autocomplete.clearTitle|The title of the clear button:clear`;
      }
      let i18n_2;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_2 = goog.getMsg("Options list");
        i18n_2 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_2;
      } else {
        i18n_2 = $localize`:kendo.autocomplete.popupLabel|The label of the popup element that contains the list of options when its role is 'region':Options list`;
      }
      return [["popupTemplate", ""], ["container", ""], ["sharedPopupActionSheetTemplate", ""], ["optionsList", ""], ["kendoAutoCompleteLocalizedMessages", "", "noDataText", i18n_0, "clearTitle", i18n_1, "popupLabel", i18n_2], ["kendoDropDownSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused"], ["class", "k-input-prefix k-input-prefix-horizontal", 4, "ngIf"], [4, "ngIf"], ["kendoSearchbar", "", 3, "onNavigate", "valueChange", "onBlur", "onFocus", "click", "ariaExpanded", "isSuggestable", "isFilterable", "isLoading", "ariaControls", "id", "activeDescendant", "userInput", "suggestedText", "disabled", "readonly", "tabIndex", "isRequired", "placeholder", "inputAttributes"], ["class", "k-clear-value", "role", "button", "tabindex", "-1", 3, "visibility", "click", "mousedown", 4, "ngIf"], ["class", "k-icon k-i-loading k-input-loading-icon", 4, "ngIf"], ["class", "k-input-suffix k-input-suffix-horizontal", 4, "ngIf"], [3, "resize", 4, "ngIf"], [3, "closePopup", "textInputChange", "navigate", "sharedPopupActionSheetTemplate", "isActionSheetExpanded", "title", "showTextInput", "subtitle", "placeholder"], [1, "k-input-prefix", "k-input-prefix-horizontal"], [3, "ngTemplateOutlet"], ["role", "button", "tabindex", "-1", 1, "k-clear-value", 3, "click", "mousedown"], ["name", "x", 3, "svgIcon"], [1, "k-icon", "k-i-loading", "k-input-loading-icon"], [1, "k-input-suffix", "k-input-suffix-horizontal"], [4, "ngTemplateOutlet"], [3, "resize"], [3, "pageChange", "size", "rounded", "id", "optionPrefix", "data", "textField", "valueField", "template", "groupTemplate", "fixedGroupTemplate", "height", "show", "virtual", "showStickyHeader"], ["class", "k-no-data", 4, "ngIf"], [3, "templateContext"], [1, "k-no-data"], [3, "ngIf", "templateContext"], [3, "ngIf"]];
    },
    template: function AutoCompleteComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 4);
        ɵɵelementContainerStart(1, 5);
        ɵɵtwoWayListener("isFocusedChange", function AutoCompleteComponent_Template_ng_container_isFocusedChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.isFocused, $event) || (ctx.isFocused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function AutoCompleteComponent_Template_ng_container_handleBlur_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function AutoCompleteComponent_Template_ng_container_onFocus_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵtemplate(2, AutoCompleteComponent_span_2_Template, 2, 1, "span", 6)(3, AutoCompleteComponent_kendo_separator_3_Template, 1, 0, "kendo-separator", 7);
        ɵɵelementStart(4, "input", 8);
        ɵɵlistener("onNavigate", function AutoCompleteComponent_Template_input_onNavigate_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleNavigate($event));
        })("valueChange", function AutoCompleteComponent_Template_input_valueChange_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.searchBarChange($event));
        })("onBlur", function AutoCompleteComponent_Template_input_onBlur_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputBlur());
        })("onFocus", function AutoCompleteComponent_Template_input_onFocus_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputFocus());
        })("click", function AutoCompleteComponent_Template_input_click_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleClick());
        });
        ɵɵelementEnd();
        ɵɵtemplate(5, AutoCompleteComponent_span_5_Template, 2, 4, "span", 9)(6, AutoCompleteComponent_span_6_Template, 1, 0, "span", 10)(7, AutoCompleteComponent_kendo_separator_7_Template, 1, 0, "kendo-separator", 7)(8, AutoCompleteComponent_span_8_Template, 2, 1, "span", 11);
        ɵɵelementContainerEnd();
        ɵɵtemplate(9, AutoCompleteComponent_ng_template_9_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        ɵɵelementContainer(11, null, 1);
        ɵɵtemplate(13, AutoCompleteComponent_kendo_resize_sensor_13_Template, 1, 0, "kendo-resize-sensor", 12);
        ɵɵelementStart(14, "responsive-renderer", 13);
        ɵɵlistener("closePopup", function AutoCompleteComponent_Template_responsive_renderer_closePopup_14_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.togglePopup(false));
        })("textInputChange", function AutoCompleteComponent_Template_responsive_renderer_textInputChange_14_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onFilterChange($event));
        })("navigate", function AutoCompleteComponent_Template_responsive_renderer_navigate_14_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleNavigate($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(15, AutoCompleteComponent_ng_template_15_Template, 5, 17, "ng-template", null, 2, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const sharedPopupActionSheetTemplate_r4 = ɵɵreference(16);
        ɵɵadvance();
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.isFocused);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate && ctx.prefixTemplate.showSeparator);
        ɵɵadvance();
        ɵɵproperty("ariaExpanded", ctx.isOpen)("isSuggestable", ctx.suggest)("isFilterable", ctx.filterable)("isLoading", ctx.isLoading)("ariaControls", ctx.ariaControls)("id", ctx.focusableId)("activeDescendant", ctx.activeDescendant)("userInput", ctx.text)("suggestedText", ctx.suggestion)("disabled", ctx.disabled)("readonly", ctx.readonly || ctx.isAdaptive)("tabIndex", ctx.tabIndex)("isRequired", ctx.isControlRequired)("placeholder", ctx.placeholder)("inputAttributes", ctx.inputAttributes);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.loading && !ctx.readonly && ctx.clearButton && (ctx.text == null ? null : ctx.text.length));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.loading);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffixTemplate && ctx.suffixTemplate.showSeparator);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffixTemplate);
        ɵɵadvance(5);
        ɵɵproperty("ngIf", ctx.isOpen || ctx.isAdaptiveModeEnabled);
        ɵɵadvance();
        ɵɵproperty("sharedPopupActionSheetTemplate", sharedPopupActionSheetTemplate_r4)("isActionSheetExpanded", ctx.isActionSheetExpanded)("title", ctx.title)("showTextInput", true)("subtitle", ctx.subtitle)("placeholder", ctx.placeholder);
      }
    },
    dependencies: [LocalizedMessagesDirective3, SharedDropDownEventsDirective, NgIf, NgTemplateOutlet, SeparatorComponent, SearchBarComponent, IconWrapperComponent, ResizeSensorComponent, ResponsiveRendererComponent, TemplateContextDirective, ListComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AutoCompleteComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoAutoComplete",
      providers: [AUTOCOMPLETE_VALUE_ACCESSOR, DataService, SelectionService2, NavigationService3, DisabledItemsService, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.autocomplete"
      }, {
        provide: FilterableComponent,
        useExisting: forwardRef(() => AutoCompleteComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => AutoCompleteComponent)
      }],
      selector: "kendo-autocomplete",
      template: `
        <ng-container kendoAutoCompleteLocalizedMessages
            i18n-noDataText="kendo.autocomplete.noDataText|The text displayed in the popup when there are no items"
            noDataText="NO DATA FOUND"

            i18n-clearTitle="kendo.autocomplete.clearTitle|The title of the clear button"
            clearTitle="clear"

            i18n-popupLabel="kendo.autocomplete.popupLabel|The label of the popup element that contains the list of options when its role is 'region'"
            popupLabel="Options list"
        >
        </ng-container>

        <ng-container
            kendoDropDownSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="isFocused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
        >
            <span *ngIf="prefixTemplate" class="k-input-prefix k-input-prefix-horizontal">
                <ng-template [ngTemplateOutlet]="prefixTemplate?.templateRef">
                </ng-template>
            </span>
            <kendo-separator *ngIf="prefixTemplate && prefixTemplate.showSeparator"></kendo-separator>
            <input
                kendoSearchbar
                [ariaExpanded]="isOpen"
                [isSuggestable]="suggest"
                [isFilterable]="filterable"
                [isLoading]="isLoading"
                [ariaControls]="ariaControls"
                [id]="focusableId"
                [activeDescendant]="activeDescendant"
                [userInput]="text"
                [suggestedText]="suggestion"
                [disabled]="disabled"
                [readonly]="readonly || this.isAdaptive"
                [tabIndex]="tabIndex"
                [isRequired]="isControlRequired"
                [placeholder]="placeholder"
                [inputAttributes]="inputAttributes"
                (onNavigate)="handleNavigate($event)"
                (valueChange)="searchBarChange($event)"
                (onBlur)="handleInputBlur()"
                (onFocus)="handleInputFocus()"
                (click)="handleClick()"
            />
            <span
                *ngIf="!loading && !readonly && (clearButton && text?.length)"
                class="k-clear-value"
                [style.visibility]="clearButtonVisiblity"
                [attr.title]="messageFor('clearTitle')"
                role="button"
                tabindex="-1"
                (click)="clearValue($event)"
                (mousedown)="$event.preventDefault()"
            >
                <kendo-icon-wrapper
                    name="x"
                    [svgIcon]="xIcon"
                >
                </kendo-icon-wrapper>
            </span>
            <span *ngIf="loading" class="k-icon k-i-loading k-input-loading-icon"></span>
            <kendo-separator *ngIf="suffixTemplate && suffixTemplate.showSeparator"></kendo-separator>
            <span *ngIf="suffixTemplate" class="k-input-suffix k-input-suffix-horizontal">
                <ng-template [ngTemplateOutlet]="suffixTemplate?.templateRef">
                </ng-template>
            </span>
        </ng-container>

        <ng-template #popupTemplate>
            <ng-container *ngTemplateOutlet="sharedPopupActionSheetTemplate"></ng-container>
        </ng-template>
        <ng-container #container></ng-container>
        <kendo-resize-sensor *ngIf="isOpen || isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>

        <!--adaptive rendering-->
        <responsive-renderer
            [sharedPopupActionSheetTemplate]="sharedPopupActionSheetTemplate"
            [isActionSheetExpanded]="isActionSheetExpanded"
            [title]="title"
            [showTextInput]="true"
            [subtitle]="subtitle"
            (closePopup)="togglePopup(false)"
            (textInputChange)="onFilterChange($event)"
            (navigate)="handleNavigate($event)"
            [placeholder]="placeholder"
            >
        </responsive-renderer>

        <ng-template #sharedPopupActionSheetTemplate>
            <!--header template-->
            <ng-template *ngIf="headerTemplate"
                [templateContext]="{
                    templateRef: headerTemplate.templateRef
                }">
            </ng-template>
            <!--list-->
            <kendo-list
                #optionsList
                [size]="size"
                [rounded]="rounded"
                [id]="listBoxId"
                [optionPrefix]="optionPrefix"
                [data]="data"
                [textField]="valueField"
                [valueField]="valueField"
                [template]="template"
                [groupTemplate]="groupTemplate"
                [fixedGroupTemplate]="fixedGroupTemplate"
                [height]="listHeight"
                [show]="isOpen"
                [virtual]="virtual"
                [showStickyHeader]="showStickyHeader"
                (pageChange)="pageChange($event)"
            >
            </kendo-list>
            <!--no-data template-->
            <div class="k-no-data" *ngIf="data.length === 0">
                <ng-template [ngIf]="noDataTemplate"
                    [templateContext]="{
                        templateRef: noDataTemplate?.templateRef
                    }">
                </ng-template>
                <ng-template [ngIf]="!noDataTemplate">
                    <div>{{ messageFor('noDataText') }}</div>
                </ng-template>
            </div>
            <!--footer template-->
            <ng-template *ngIf="footerTemplate"
                [templateContext]="{
                    templateRef: footerTemplate.templateRef
                }">
            </ng-template>
        </ng-template>
  `,
      standalone: true,
      imports: [LocalizedMessagesDirective3, SharedDropDownEventsDirective, NgIf, NgTemplateOutlet, SeparatorComponent, SearchBarComponent, IconWrapperComponent, ResizeSensorComponent, ResponsiveRendererComponent, TemplateContextDirective, ListComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: DataService
    }, {
      type: PopupService
    }, {
      type: SelectionService2
    }, {
      type: NavigationService3
    }, {
      type: DisabledItemsService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: Injector
    }, {
      type: AdaptiveService
    }];
  }, {
    responsiveRendererComponent: [{
      type: ViewChild,
      args: [ResponsiveRendererComponent]
    }],
    highlightFirst: [{
      type: Input
    }],
    showStickyHeader: [{
      type: Input
    }],
    focusableId: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    subtitle: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    listHeight: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    suggest: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    itemDisabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input,
      args: ["tabIndex"]
    }],
    filterable: [{
      type: Input
    }],
    virtual: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    filterChange: [{
      type: Output
    }],
    open: [{
      type: Output
    }],
    opened: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    closed: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    inputFocus: [{
      type: Output
    }],
    inputBlur: [{
      type: Output
    }],
    template: [{
      type: ContentChild,
      args: [ItemTemplateDirective, {
        static: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective, {
        static: false
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective, {
        static: false
      }]
    }],
    noDataTemplate: [{
      type: ContentChild,
      args: [NoDataTemplateDirective, {
        static: false
      }]
    }],
    groupTemplate: [{
      type: ContentChild,
      args: [GroupTemplateDirective, {
        static: false
      }]
    }],
    fixedGroupTemplate: [{
      type: ContentChild,
      args: [FixedGroupTemplateDirective, {
        static: false
      }]
    }],
    suffixTemplate: [{
      type: ContentChild,
      args: [SuffixTemplateDirective]
    }],
    prefixTemplate: [{
      type: ContentChild,
      args: [PrefixTemplateDirective]
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        static: true
      }]
    }],
    searchbar: [{
      type: ViewChild,
      args: [SearchBarComponent, {
        static: true
      }]
    }],
    optionsList: [{
      type: ViewChild,
      args: ["optionsList", {
        static: false
      }]
    }],
    widgetClasses: [{
      type: HostBinding,
      args: ["class.k-autocomplete"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    isDisabled: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    isLoading: [{
      type: HostBinding,
      args: ["class.k-loading"]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }]
  });
})();
var MultiselectMessages = {
  "array": "Expected values of array type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/value-binding",
  "object": "Expected values of Object type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/value-binding/#toc-object-values",
  "primitive": "Expected values of primitive type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/value-binding/#toc-primitive-values",
  "textAndValue": "Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/data-binding/#toc-arrays-of-complex-data"
};
var MultiSelectTreeMessages = {
  "array": "Expected values of array type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselecttree/value-binding",
  "primitive": "Expected values of primitive type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselecttree/value-binding/#toc-primitive-values",
  "object": "Expected values of type Object. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselecttree/value-binding/#toc-object-values",
  "dataItems": "Expected dataItems of type Object[] to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/api/MultiSelectTreeComponent/#toc-dataitems",
  "dataItemsLength": "Expected dataItems length to match the number of provided values. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/api/MultiSelectTreeComponent/#toc-dataitems",
  "textAndValue": "Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselecttree/value-binding",
  "valueDepth": "Expected valueDepth of type number[] to be set. See https://www.telerik.com/kendo-angular-ui-develop/components/dropdowns/api/MultiSelectTreeComponent/#toc-valuedepth",
  "valueDepthLength": "Expected valueDepth length to match the number of provided values. See https://www.telerik.com/kendo-angular-ui-develop/components/dropdowns/api/MultiSelectTreeComponent/#toc-valuedepth"
};
var ComboBoxMessages = {
  "object": "Expected value of type Object. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/combobox/value-binding/#toc-object-values",
  "primitive": "Expected value of primitive type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/combobox/value-binding/#toc-primitive-values",
  "textAndValue": "Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/combobox/data-binding/#toc-arrays-of-complex-data",
  "noItemHeight": "Expected virtual.itemHeight of type number."
};
var MultiColumnComboBoxMessages = {
  "data": "Provided data must consist only of objects. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multicolumncombobox/data-binding/",
  "textAndValue": "Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multicolumncombobox/data-binding/#toc-fields-configuration"
};
var DropDownListMessages = {
  "defaultItem": "defaultItem and data items must be of same type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/api/DropDownListComponent/#toc-defaultitem",
  "object": "Expected value of type Object. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdownlist/value-binding/#toc-object-values",
  "primitive": "Expected value of primitive type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdownlist/value-binding/#toc-primitive-values",
  "textAndValue": "Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdownlist/data-binding/#toc-arrays-of-complex-data"
};
var DropDownTreeMessages = {
  "primitive": "Expected value of primitive type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdowntree/value-binding/#toc-primitive-values",
  "object": "Expected value of type Object. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdowntree/value-binding/#toc-object-values",
  "dataItem": "Expected dataItem of type Object to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/api/DropDownTreeComponent/#toc-dataitem",
  "textAndValue": "Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdowntree/value-binding",
  "valueDepth": "Expected valueDepth to be set. See https://www.telerik.com/kendo-angular-ui-develop/components/dropdowns/api/DropDownTreeComponent/#toc-valuedepth"
};
var COMBOBOX_VALUE_ACCESSOR = {
  multi: true,
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => ComboBoxComponent)
};
var DEFAULT_SIZE$42 = "medium";
var DEFAULT_ROUNDED$42 = "medium";
var DEFAULT_FILL_MODE$42 = "solid";
var ComboBoxComponent = class _ComboBoxComponent extends MultiTabStop {
  wrapper;
  localization;
  popupService;
  selectionService;
  navigationService;
  disabledItemsService;
  dataService;
  zone;
  cdr;
  renderer;
  injector;
  hostElement;
  adaptiveService;
  /**
   * @hidden
   */
  icon;
  /**
   * @hidden
   */
  svgIcon;
  /**
   * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
   */
  inputAttributes;
  /**
   * @hidden
   */
  animationDuration = animationDuration2;
  /**
   * @hidden
   */
  xIcon = xIcon;
  /**
   * @hidden
   */
  responsiveRendererComponent;
  /**
   * @hidden
   */
  get actionSheet() {
    return this.responsiveRendererComponent?.actionSheet;
  }
  /**
   * @hidden
   */
  get actionSheetSearchBar() {
    return this.responsiveRendererComponent?.actionSheetSearchBar;
  }
  /**
   * @hidden
   */
  caretAltDownIcon = caretAltDownIcon;
  set text(text) {
    this._text = isPresent7(text) ? text.toString() : "";
  }
  get text() {
    return this._text;
  }
  /**
   * @hidden
   */
  get ariaControls() {
    return this.isOpen ? this.listBoxId : void 0;
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.formControl);
  }
  /**
   * @hidden
   */
  togglePopup(open) {
    const isDisabled2 = this.disabled || this.readonly;
    const sameState = this.isOpen === open;
    if (isDisabled2 || sameState) {
      return;
    }
    const isDefaultPrevented2 = this.triggerPopupEvents(open);
    if (!isDefaultPrevented2) {
      this._toggle(open);
    }
  }
  get activeDescendant() {
    if (!this.isOpen || !isPresent7(this.selectionService.focused) || this.selectionService.focused === -1) {
      return null;
    }
    return this.optionPrefix + "-" + this.selectionService.focused;
  }
  get appendTo() {
    const {
      appendTo
    } = this.popupSettings;
    if (!appendTo || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  dataItem;
  selected = [];
  /**
   * Shows or hides the current group sticky header when using grouped data.
   * By default the sticky header is displayed ([see example]({% slug grouping_autocomplete %}#toc-sticky-header)).
   */
  showStickyHeader = true;
  /**
   * @hidden
   */
  focusableId = `k-${guid2()}`;
  /**
   * Specifies whether the ComboBox allows user-defined values that are not present in the dataset
   * ([more information and examples]({% slug custom_values_combobox %})).
   * Defaults to `false`.
   *
   * The feature is not available when using adaptive mode.
   */
  allowCustom = false;
  /**
   * Sets the data of the ComboBox.
   *
   * > The data has to be provided in an array-like list.
   */
  set data(data) {
    this.dataService.data = data || [];
    if (this.virtual) {
      this.virtual.skip = 0;
    }
    this.setState();
    if (this._filtering) {
      const queryAndDataPresent = this.text.length > 0 && this.dataService.itemsCount > 0;
      const index = queryAndDataPresent ? this.firstFocusableIndex(0) : -1;
      this.selectionService.focused = index;
    }
    if (this.suggest && this.dataService.itemsCount && this.text) {
      this.suggestedText = getter2(this.dataService.itemAt(0), this.textField);
    }
  }
  get data() {
    const virtual = this.virtual;
    if (virtual) {
      const start = virtual.skip || 0;
      const end = start + virtual.pageSize;
      virtual.total = this.dataService.data.length;
      return this.dataService.data.slice(start, end);
    }
    return this.dataService.data;
  }
  /**
   * Sets the value of the ComboBox.
   * It can either be of the primitive (string, numbers) or of the complex (objects) type.
   * To define the type, use the `valuePrimitive` option.
   *
   * > All selected values which are not present in the dataset are considered custom values.
   * > When the `Enter` key is pressed or the component loses focus, custom values get dismissed unless `allowCustom` is set to `true`.
   */
  set value(newValue) {
    this._value = newValue;
    this.setState();
    this.cdr.markForCheck();
  }
  get value() {
    return this._value;
  }
  /**
   * Sets the data item field that represents the item text.
   * If the data contains only primitive values, do not define it.
   *
   * > The `textField` property can be set to point to a nested property value - e.g. `category.name`.
   */
  textField;
  /**
   * Sets the data item field that represents the item value.
   * If the data contains only primitive values, do not define it.
   *
   * > The `valueField` property can be set to point to a nested property value - e.g. `category.id`.
   */
  valueField;
  /**
   * Specifies the type of the selected value.
   * If set to `true`, the selected value has to be of the primitive type
   * ([more information and example]({% slug valuebinding_combobox %}#toc-primitive-values-from-object-fields)).
   */
  set valuePrimitive(isPrimitive) {
    this._valuePrimitive = isPrimitive;
  }
  get valuePrimitive() {
    if (!isPresent7(this._valuePrimitive)) {
      return !isPresent7(this.valueField);
    }
    return this._valuePrimitive;
  }
  /**
   * A user-defined callback which returns normalized custom values.
   * Typically used when the data items are different from type `string`.
   * @param { Any } value - The custom value defined by the user.
   * @returns { Any }
   *
   * @example
   * ```ts
   * import { map } from 'rxjs/operators';
   *
   * _@Component({
   * selector: 'my-app',
   * template: `
   *   <kendo-combobox
   *       [allowCustom]="true"
   *       [data]="listItems"
   *       textField="text"
   *       valueField="value"
   *       [valueNormalizer]="valueNormalizer"
   *       (valueChange)="onValueChange($event)"
   *   >
   *   </kendo-combobox>
   * `
   * })
   *
   * class AppComponent {
   *   public listItems: Array<{ text: string, value: number }> = [
   *       { text: "Small", value: 1 },
   *       { text: "Medium", value: 2 },
   *       { text: "Large", value: 3 }
   *   ];
   *
   *   public onValueChange(value) {
   *       console.log("valueChange : ", value);
   *   }
   *
   *   public valueNormalizer = (text$: Observable<string>) => text$.pipe(map((text: string) => {
   *      return { ProductID: null, ProductName: text };
   *   }));
   *
   * }
   * ```
   */
  valueNormalizer = (text) => text.pipe(map((userInput) => userInput));
  /**
   * The hint that is displayed when the component is empty.
   *
   */
  placeholder = "";
  /**
   * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.
   */
  adaptiveMode = "none";
  /**
   * Sets the title of the ActionSheet that is rendered instead of the Popup when using small screen devices.
   * By default the ActionSheet title uses the text provided for the label of the AutoComplete.
   */
  title = "";
  /**
   * Sets the subtitle of the ActionSheet that is rendered instead of the Popup when using small screen devices.
   * By default the ActionSheet subtitle uses the text provided for the `placeholder` of the AutoComplete.
  */
  set subtitle(_subtitle) {
    this._subtitle = _subtitle;
  }
  get subtitle() {
    return this._subtitle || this.placeholder;
  }
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * Configures the popup of the ComboBox.
   *
   * The available options are:
   * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
   * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.
   * - `height: Number`&mdash;Sets the height of the popup container.
   * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
   * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
   */
  set popupSettings(settings) {
    this._popupSettings = Object.assign({
      animate: true
    }, settings);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Sets the height of the options list in the popup. By default, `listHeight` is 200px.
   *
   * > The `listHeight` property affects only the list of options and not the whole popup container.
   * > To set the height of the popup container, use `popupSettings.height`.
   *
   * > When using `adaptiveMode` and the screen size is `small` or `medium` the `listHeight` property is set to null.
   */
  set listHeight(_listHeight) {
    this._listHeight = _listHeight;
  }
  get listHeight() {
    if (this.isAdaptive) {
      return;
    }
    return this._listHeight;
  }
  _listHeight = 200;
  /**
   * Sets and gets the loading state of the ComboBox.
   */
  loading;
  /**
   * Enables the auto-completion of the text based on the first data item.
   */
  suggest = false;
  /**
   * If set to `true`, renders a button on hovering over the component.
   * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.
   */
  clearButton = true;
  /**
   * Sets the disabled state of the component. To learn how to disable the component in reactive forms, refer to the articles on [ComboBox Forms Support](slug:formssupport_combobox#toc-managing-the-combobox-disabled-state-in-reactive-forms) and [MultiColumnComboBox Forms Support](slug:formssupport_multicolumncombobox#toc-managing-the-multicolumncombobox-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Defines a Boolean function that is executed for each data item in the component
   * ([see examples]({% slug disableditems_combobox %})). Determines whether the item will be disabled.
   */
  set itemDisabled(fn) {
    if (typeof fn !== "function") {
      throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this.disabledItemsService.itemDisabled = fn;
  }
  /**
   * Sets the read-only state of the component.
   *
   * @default false
   */
  readonly = false;
  /**
   * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Enables the [filtering]({% slug filtering_combobox %}) functionality.
   * If set to `true`, the component emits the `filterChange` event.
   */
  filterable = false;
  /**
   * Enables the [virtualization]({% slug virtualization_combobox %}) functionality.
   */
  set virtual(settings) {
    this._virtualSettings = normalizeVirtualizationSettings(settings, {
      itemHeight: this.defaultVirtualItemHeight,
      pageSize: this.defaultVirtualPageSize
    });
  }
  get virtual() {
    return this._virtualSettings;
  }
  /**
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$42;
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass2("input", this.size));
    if (size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("input", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `full`
   * * `none`
   *
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED$42;
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    if (rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the fillMode of the component.
   *
   * The possible values are:
   * * `flat`
   * * `solid` (default)
   * * `outline`
   * * `none`
   *
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$42;
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    if (fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", newFillMode));
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Fires each time the value is changed&mdash;
   * when the component is blurred or the value is cleared through the **Clear** button
   * ([see example](slug:events_combobox)).
   * When the value of the component is programmatically changed to `ngModel` or `formControl`
   * through its API or form binding, the `valueChange` event is not triggered because it
   * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time an item selection is changed
   * ([see example](slug:events_combobox)).
   */
  selectionChange = new EventEmitter();
  /**
   * Fires each time the user types in the input field.
   * You can filter the source based on the passed filtration value
   * ([see example](slug:events_combobox)).
   */
  filterChange = new EventEmitter();
  /**
   * Fires each time the popup is about to open.
   * This event is preventable. If you cancel it, the popup will remain closed.
   */
  open = new EventEmitter();
  /**
   * Fires after the popup has been opened.
   */
  opened = new EventEmitter();
  /**
   * Fires each time the popup is about to close.
   * This event is preventable. If you cancel it, the popup will remain open.
   */
  close = new EventEmitter();
  /**
   * Fires after the popup has been closed.
   */
  closed = new EventEmitter();
  /**
   * Fires each time the user focuses the ComboBox.
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the ComboBox gets blurred.
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the user focuses the `input` element.
   */
  inputFocus = new EventEmitter();
  /**
   * Fires each time the `input` element gets blurred.
   */
  inputBlur = new EventEmitter();
  /**
   * @hidden
   */
  escape = new EventEmitter();
  template;
  headerTemplate;
  footerTemplate;
  noDataTemplate;
  groupTemplate;
  fixedGroupTemplate;
  /**
   * @hidden
   */
  suffixTemplate;
  /**
   * @hidden
   */
  prefixTemplate;
  container;
  popupTemplate;
  searchbar;
  optionsList;
  select;
  widgetClasses = true;
  get isDisabled() {
    return this.disabled;
  }
  get isLoading() {
    return this.loading;
  }
  get dir() {
    return this.direction;
  }
  _isFocused = false;
  get isFocused() {
    return this._isFocused;
  }
  set isFocused(value) {
    this.renderer[value ? "addClass" : "removeClass"](this.wrapper.nativeElement, "k-focus");
    this._isFocused = value;
  }
  get clearButtonVisiblity() {
    if (touchEnabled) {
      return "visible";
    }
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  /**
   * @hidden
   */
  windowSize = "large";
  /**
   * @hidden
   */
  get isActionSheetExpanded() {
    return this.actionSheet?.expanded;
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  listBoxId = `k-${guid2()}`;
  optionPrefix = `k-${guid2()}`;
  popupRef;
  get popupWidth() {
    let wrapperOffsetWidth = 0;
    if (isDocumentAvailable()) {
      wrapperOffsetWidth = this.wrapper.nativeElement.offsetWidth;
    }
    const width = this.popupSettings.width || wrapperOffsetWidth;
    const minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : `${wrapperOffsetWidth}px`;
    const maxWidth = isNaN(width) ? width : `${width}px`;
    return {
      min: minWidth,
      max: maxWidth
    };
  }
  get popupHeight() {
    const popupHeight = this.popupSettings.height;
    return isPresent7(popupHeight) ? `${popupHeight}px` : "auto";
  }
  onChangeCallback = (_2) => {
  };
  onTouchedCallback = (_2) => {
  };
  /**
   * Used for the default virtualization settings config.
   */
  defaultVirtualItemHeight = 28;
  /**
   * Used for the default virtualization settings config.
   */
  defaultVirtualPageSize = 50;
  valueSubscription;
  _filtering = false;
  _text = "";
  filterText = "";
  _open = false;
  _value;
  _valuePrimitive;
  _previousDataItem;
  suggestedText;
  backspacePressed;
  _popupSettings = {
    animate: true
  };
  _virtualSettings;
  _subtitle;
  popupMouseDownHandler = (event) => event.preventDefault();
  customValueSubject = new Subject();
  valueSubject = new Subject();
  clearValueSubject = new Subject();
  direction;
  subs = new Subscription();
  touchstartDisposeHandler;
  selectClickDisposeHandler;
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  constructor(wrapper, localization, popupService, selectionService, navigationService, disabledItemsService, dataService, zone, cdr, renderer, injector, hostElement, adaptiveService) {
    super();
    this.wrapper = wrapper;
    this.localization = localization;
    this.popupService = popupService;
    this.selectionService = selectionService;
    this.navigationService = navigationService;
    this.disabledItemsService = disabledItemsService;
    this.dataService = dataService;
    this.zone = zone;
    this.cdr = cdr;
    this.renderer = renderer;
    this.injector = injector;
    this.hostElement = hostElement;
    this.adaptiveService = adaptiveService;
    validatePackage(packageMetadata7);
    this.direction = localization.rtl ? "rtl" : "ltr";
    this.data = [];
  }
  ngOnInit() {
    this.renderer.removeAttribute(this.wrapper.nativeElement, "tabindex");
    this.attachStreams();
    this.createValueStream();
    this.subscribeTouchEvents();
    this.attachSelectClickHandler();
    this.setComponentClasses();
  }
  ngAfterViewInit() {
    this.windowSize = this.adaptiveService.size;
    this.cdr.detectChanges();
    if (this.actionSheet && isDocumentAvailable()) {
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-height", "60vh");
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-max-height", "none");
    }
  }
  createValueStream() {
    const valueStream = this.valueSubject.pipe(filter((candidate) => {
      const current = getter2(this.value, this.valueField);
      const newValue = getter2(candidate, this.valueField);
      let newText = getter2(candidate, this.textField);
      if (!isPresent7(this.value) && !isPresent7(newValue)) {
        return false;
      }
      if (isPresent7(newText)) {
        newText = newText.toString();
      }
      if (current === newValue && this.text === newText) {
        this.clearFilter();
        return false;
      } else {
        return true;
      }
    }), map((candidate) => {
      const newValue = getter2(candidate, this.valueField);
      const newText = getter2(candidate, this.textField);
      return {
        dataItem: candidate,
        text: newText,
        value: this.valuePrimitive ? newValue : candidate
      };
    }));
    const customValueStreams = partition(() => this.allowCustom)(this.customValueSubject.pipe(throttleTime(300)));
    const allowCustomValueStream = customValueStreams[0].pipe(tap(() => {
      this.loading = true;
      this.disabled = true;
      this.cdr.detectChanges();
    }), filter(() => {
      const hasChange = this.text !== getter2(this.value, this.valueField);
      this.loading = hasChange;
      this.disabled = hasChange;
      if (!hasChange) {
        this.clearFilter();
      }
      return hasChange;
    }), this.valueNormalizer, map((normalizedValue) => {
      return {
        custom: true,
        dataItem: normalizedValue,
        text: this.text,
        value: normalizedValue
      };
    }));
    const disableCustomValueStream = customValueStreams[1].pipe(map(() => {
      return {
        custom: true,
        dataItem: void 0,
        text: void 0,
        value: void 0
      };
    }));
    const clearValueStream = this.clearValueSubject.pipe(map(() => ({
      dataItem: void 0,
      text: void 0,
      value: void 0
    })));
    if (this.valueSubscription) {
      this.valueSubscription.unsubscribe();
    }
    const merged = merge(valueStream, allowCustomValueStream, disableCustomValueStream, clearValueStream);
    this.valueSubscription = merged.pipe(catchError(() => {
      const selectionChanged = getter2(this.dataItem, this.valueField) !== void 0;
      this.dataItem = void 0;
      this.value = void 0;
      this.text = void 0;
      this.loading = false;
      this.disabled = false;
      if (selectionChanged) {
        this.selectionChange.emit(void 0);
      }
      this.emitValueChange();
      this.createValueStream();
      return of(null);
    })).subscribe((state2) => {
      const selectionChanged = getter2(this.dataItem, this.valueField) !== getter2(state2.dataItem, this.valueField);
      this.dataItem = state2.dataItem;
      this.value = state2.value;
      this.text = state2.text;
      this.loading = false;
      this.disabled = false;
      this.clearFilter();
      if (state2.custom) {
        this.selectionService.focused = -1;
      }
      if (selectionChanged) {
        const selectionArgs = state2.custom ? void 0 : this.dataItem;
        this.selectionChange.emit(selectionArgs);
      }
      this.emitValueChange();
    });
  }
  attachStreams() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.subs.add(this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
      this.cdr.detectChanges();
    }));
    this.subs.add(merge(this.navigationService.up, this.navigationService.down, this.navigationService.home, this.navigationService.end).pipe(filter((event) => isPresent7(event.index))).subscribe((event) => this.navigate(event.index)));
    this.subs.add(this.navigationService.open.subscribe(this.handleNavigationOpen.bind(this)));
    this.subs.add(this.navigationService.close.subscribe(() => this.togglePopup(false)));
    this.subs.add(merge(this.navigationService.pagedown, this.navigationService.pageup).subscribe((event) => {
      if (this.isOpen) {
        event.originalEvent.preventDefault();
        this.optionsList.scrollWithOnePage(NavigationAction[event.originalEvent.code]);
      }
    }));
    this.subs.add(this.navigationService.esc.subscribe(this.handleEscape.bind(this)));
    this.subs.add(this.navigationService.enter.pipe(tap((event) => {
      if (this.isOpen) {
        event.originalEvent.preventDefault();
      }
    })).subscribe(this.handleEnter.bind(this)));
    this.subs.add(merge(this.selectionService.onChange, this.selectionService.onSelect.pipe(filter(() => !this.isOpen))).pipe(tap(() => {
      this._filtering = false;
      this.togglePopup(false);
    }), map((event) => this.dataService.itemAt(event.indices[0]))).subscribe((dataItem) => {
      this.change(dataItem);
    }));
    this.subs.add(this.selectionService.onSelect.pipe(filter(() => this.isOpen), tap(() => this._filtering = false), map((event) => this.dataService.itemAt(event.indices[0]))).subscribe((dataItem) => {
      const selectionChanged = getter2(dataItem, this.valueField) !== getter2(this.dataItem, this.valueField);
      this.updateState({
        dataItem
      });
      if (selectionChanged) {
        this.selectionChange.emit(dataItem);
      }
    }));
  }
  ngOnDestroy() {
    this.destroyPopup();
    this.subs.unsubscribe();
    if (isPresent7(this.valueSubscription)) {
      this.valueSubscription.unsubscribe();
    }
    if (this.touchstartDisposeHandler) {
      this.touchstartDisposeHandler();
    }
    if (this.selectClickDisposeHandler) {
      this.selectClickDisposeHandler();
    }
  }
  ngOnChanges(changes) {
    const virtual = this.virtual;
    const requestInitialData = virtual && changes["data"] && changes["data"].isFirstChange();
    if (requestInitialData) {
      this.pageChange({
        skip: 0,
        take: virtual.pageSize
      });
    }
    if (isChanged("valueNormalizer", changes)) {
      this.createValueStream();
    }
    if (anyChanged(["textField", "valueField", "valuePrimitive"], changes, false)) {
      this.setState();
    }
  }
  ngAfterContentChecked() {
    this.verifySettings();
  }
  /**
   * Focuses a specific item of the ComboBox based on a provided index.
   * If null or invalid index is provided the focus will be removed.
   */
  focusItemAt(index) {
    const isInRange = index >= 0 && index < this.data.length;
    if (isPresent7(index) && isInRange && !this.disabledItemsService.isIndexDisabled(index)) {
      this.selectionService.focus(index);
    } else {
      this.selectionService.focus(-1);
    }
  }
  /**
   * Focuses the ComboBox.
   */
  focus() {
    if (!this.disabled) {
      this.searchbar.focus();
    }
  }
  /**
   * Blurs the ComboBox.
   */
  blur() {
    if (!this.disabled) {
      this.searchbar.blur();
    }
  }
  /**
   * Toggles the visibility of the popup or actionSheet. If you use the `toggle` method to open or close the popup or actionSheet,
   * the `open` and `close` events will not be fired.
   *
   * @param open - The state of the popup.
   */
  toggle(open) {
    Promise.resolve(null).then(() => {
      const shouldOpen = isPresent7(open) ? open : !this._open;
      this._toggle(shouldOpen);
      this.cdr.markForCheck();
    });
  }
  /**
   * Returns the current open state. Returns `true` if the popup or actionSheet is open.
   */
  get isOpen() {
    return isTruthy2(this._open || this.isActionSheetExpanded);
  }
  /**
   * @hidden
   */
  handleClick() {
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.togglePopup(true);
    }
  }
  /**
   * Resets the value of the ComboBox.
   * If you use the `reset` method to clear the value of the component,
   * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.
   */
  reset() {
    this.value = void 0;
    this.clearState();
    this.resetSelection();
  }
  /**
   * @hidden
   *
   * Used by the TextBoxContainer to determine if the floating label
   * should be rendered in the input when the component is not focused.
   */
  isEmpty() {
    const textEmpty = !isPresent7(this.text) || isEmptyString(this.text);
    const valueEmpty = !isPresent7(this.value) || isEmptyString(this.value);
    return textEmpty && valueEmpty;
  }
  /**
   * @hidden
   */
  messageFor(key) {
    return this.localization.get(key);
  }
  /**
   * @hidden
   */
  clearValue(event) {
    event?.stopImmediatePropagation();
    if (event) {
      this.focus();
    }
    this._previousDataItem = void 0;
    this.selectionService.resetSelection([]);
    this.clearValueSubject.next();
    this._filtering = false;
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value === null ? void 0 : value;
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onChangeCallback = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.cdr.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * @hidden
   */
  get selectButtonClasses() {
    return `${this.size ? getSizeClass2("button", this.size) : ""} ${this.fillMode ? "k-button-" + this.fillMode : ""} ${this.fillMode ? "k-button-" + this.fillMode + "-base" : ""}
        `;
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (this.isAdaptiveModeEnabled && this.windowSize !== currentWindowSize) {
      if (this.isOpen) {
        this.togglePopup(false);
      }
      this.windowSize = currentWindowSize;
      this.cdr.detectChanges();
    }
    if (this.isOpen && !this.isActionSheetExpanded) {
      const popupWrapper = this.popupRef.popupElement;
      const {
        min,
        max
      } = this.popupWidth;
      popupWrapper.style.minWidth = min;
      popupWrapper.style.width = max;
    }
  }
  verifySettings() {
    if (!isDevMode()) {
      return;
    }
    if (this.valuePrimitive === true && isPresent7(this.value) && typeof this.value === "object") {
      throw new Error(ComboBoxMessages.primitive);
    }
    if (this.valuePrimitive === false && isPresent7(this.value) && typeof this.value !== "object") {
      throw new Error(ComboBoxMessages.object);
    }
    const valueOrText = !isPresent7(this.valueField) !== !isPresent7(this.textField);
    if (valueOrText) {
      throw new Error(ComboBoxMessages.textAndValue);
    }
    if (this.virtual && isNaN(this.virtual.itemHeight)) {
      throw new Error(ComboBoxMessages.noItemHeight);
    }
  }
  setState() {
    if (this._filtering) {
      return;
    }
    const value = this.value;
    const valueField = this.valueField;
    const resolved = this.findDataItem({
      valueField,
      value
    });
    if (isPresent7(resolved.index) && resolved.index !== -1) {
      this.updateState({
        dataItem: resolved.dataItem,
        confirm: true
      });
      this.resetSelection(resolved.index);
    } else if (isPresent7(value) && this.allowCustom) {
      this.updateState({
        dataItem: value
      });
      this.resetSelection(-1);
    } else if (this._previousDataItem && this.value) {
      this.updateState({
        dataItem: this._previousDataItem
      });
      this.resetSelection();
    } else {
      this.clearState();
      this.resetSelection(-1);
    }
  }
  updateState({
    dataItem,
    confirm = false
  }) {
    this.dataItem = dataItem;
    this.text = getter2(dataItem, this.textField);
    if (confirm) {
      this._previousDataItem = dataItem;
    }
  }
  clearState() {
    this.text = void 0;
    this.dataItem = void 0;
  }
  resetSelection(index) {
    const clear2 = !isPresent7(index) || index < 0;
    this.selectionService.resetSelection(clear2 ? [] : [index]);
    this.selectionService.focused = index;
  }
  firstFocusableIndex(index) {
    const maxIndex = this.data.length - 1;
    if (this.disabledItemsService.isIndexDisabled(index)) {
      return index < maxIndex ? this.firstFocusableIndex(index + 1) : void 0;
    } else {
      return index;
    }
  }
  findIndexPredicate(text) {
    if (this.dataService.grouped) {
      return (item) => {
        let itemText = getter2(item.value, this.textField);
        itemText = !isPresent7(itemText) ? "" : itemText.toString().toLowerCase();
        return itemText.startsWith(text.toLowerCase());
      };
    } else {
      return (item) => {
        let itemText = getter2(item, this.textField);
        itemText = !isPresent7(itemText) ? "" : itemText.toString().toLowerCase();
        return itemText.startsWith(text.toLowerCase());
      };
    }
  }
  findDataItem({
    valueField,
    value
  }) {
    const result = {
      dataItem: null,
      index: -1
    };
    const comparer = (element) => {
      const dataItem = this.dataService.grouped ? element.value : element;
      return getter2(dataItem, valueField) === getter2(value, valueField);
    };
    const index = this.dataService.findIndex(comparer);
    result.dataItem = this.dataService.itemAt(index);
    result.index = index;
    return result;
  }
  search(text, startFrom = 0) {
    const index = this.findIndex(text, startFrom);
    if (this.disabledItemsService.isIndexDisabled(index)) {
      if (index + 1 < this.dataService.itemsCount) {
        this.search(text, index + 1);
      } else {
        this.selectionService.focus(-1);
      }
    } else {
      this.selectionService.focus(index);
      if (this.suggest) {
        this.suggestedText = getter2(this.dataService.itemAt(index), this.textField);
      }
    }
  }
  /**
   * @hidden
   */
  onAdaptiveTextBoxChange(text) {
    if (this.filterable && this.filterText !== text) {
      this.filterText = text;
      this.filterChange.emit(text);
    } else {
      this.search(text);
    }
  }
  /**
   * @hidden
   */
  getSuggestion() {
    const hasSelected = !!this.selectionService.selected.length;
    const shouldSuggest = this.suggest && !this.backspacePressed && this.suggestedText && this.text;
    if (!hasSelected && shouldSuggest && this.suggestedText.toLowerCase().startsWith(this.text.toLowerCase())) {
      return this.suggestedText;
    } else {
      this.suggestedText = void 0;
    }
  }
  navigate(index) {
    if (this.dataService.itemsCount === 0) {
      return;
    }
    this.text = getter2(this.dataService.itemAt(index), this.textField);
    this.selectionService.select(index);
  }
  /**
   * @hidden
   */
  handleNavigate(event) {
    const hasSelected = isPresent7(this.selectionService.selected[0]);
    const focused = isNaN(this.selectionService.focused) ? this.firstFocusableIndex(0) : this.selectionService.focused;
    let offset = 0;
    if (this.disabled || this.readonly) {
      return;
    }
    if (event.keyCode === Keys.Home || event.keyCode === Keys.End) {
      return;
    }
    if (!hasSelected) {
      if (event.keyCode === Keys.ArrowDown) {
        offset = -1;
      } else if (event.keyCode === Keys.ArrowUp) {
        offset = 1;
      }
    }
    const action = this.navigationService.process({
      current: offset + focused,
      max: this.dataService.itemsCount - 1,
      min: 0,
      originalEvent: event
    });
    if (action !== NavigationAction.Undefined && action !== NavigationAction.Left && action !== NavigationAction.Right && action !== NavigationAction.Backspace && action !== NavigationAction.Delete && action !== NavigationAction.PageDown && action !== NavigationAction.PageUp && (action === NavigationAction.Enter && this.isOpen || action !== NavigationAction.Enter)) {
      event.preventDefault();
    }
    if (action === NavigationAction.Tab && this.isActionSheetExpanded) {
      event.stopImmediatePropagation();
      this.togglePopup(false);
    }
  }
  handleEnter() {
    const text = this.text;
    const focused = this.selectionService.focused;
    const hasFocused = isPresent7(focused) && focused !== -1;
    const previousText = getter2(this._previousDataItem, this.textField) || "";
    const focusedItemText = getter2(this.dataService.itemAt(focused), this.textField);
    const textHasChanged = text !== previousText;
    this.togglePopup(false);
    this._filtering = false;
    if (this.allowCustom && textHasChanged) {
      if (text === focusedItemText || this.useSuggestion()) {
        this.selectionService.change(focused);
      } else {
        this.change(text, true);
      }
    }
    if (!this.allowCustom) {
      if (hasFocused) {
        this.selectionService.change(focused);
      } else if (textHasChanged) {
        this.change(text, true);
      }
    }
  }
  /**
   * @hidden
   */
  handleFocus() {
    this.zone.run(() => {
      if (!this.isFocused && hasObservers(this.onFocus)) {
        this.onFocus.emit();
      }
      this.isFocused = true;
    });
  }
  /**
   * @hidden
   */
  handleBlur() {
    if (!this.isActionSheetExpanded) {
      this._filtering = false;
      this.searchbar.input.nativeElement.scrollLeft = 0;
      this.isFocused = false;
      const unresolvedSelection = getter2(this.dataItem, this.valueField) !== getter2(this.value, this.valueField);
      const currentText = this.searchbar.value;
      const textHasChanged = currentText !== (getter2(this.dataItem, this.textField) || "");
      const valueHasChanged = unresolvedSelection || textHasChanged;
      const runInZone = valueHasChanged || hasObservers(this.onBlur) || hasObservers(this.close) || isUntouched2(this.wrapper.nativeElement);
      if (runInZone) {
        this.zone.run(() => {
          if (valueHasChanged) {
            const lowerCaseMatch = isPresent7(this.focusedItemText) && this.focusedItemText.toLowerCase() === currentText.toLowerCase();
            if (lowerCaseMatch || unresolvedSelection) {
              this.selectionService.change(this.selectionService.focused);
            } else {
              this.change(currentText, true);
            }
          }
          this.onBlur.emit();
          this.onTouchedCallback();
          this.togglePopup(false);
        });
      } else {
        this.togglePopup(false);
      }
    }
  }
  /**
   * @hidden
   */
  handleInputBlur() {
    if (!this.isActionSheetExpanded) {
      this._filtering = false;
      this.searchbar.input.nativeElement.scrollLeft = 0;
      const unresolvedSelection = getter2(this.dataItem, this.valueField) !== getter2(this.value, this.valueField);
      const currentText = this.searchbar.value;
      const textHasChanged = currentText !== (getter2(this.dataItem, this.textField) || "");
      const valueHasChanged = unresolvedSelection || textHasChanged;
      const runInZone = valueHasChanged || hasObservers(this.onBlur) || hasObservers(this.close) || isUntouched2(this.wrapper.nativeElement) || this.formControl?.updateOn === "blur";
      if (runInZone) {
        this.zone.run(() => {
          if (valueHasChanged) {
            const lowerCaseMatch = isPresent7(this.focusedItemText) && this.focusedItemText.toLowerCase() === currentText.toLowerCase();
            if (lowerCaseMatch || unresolvedSelection) {
              this.selectionService.change(this.selectionService.focused);
            } else {
              this.change(currentText, true);
            }
          }
          this.inputBlur.emit();
          this.onTouchedCallback();
          this.togglePopup(false);
        });
      } else {
        this.togglePopup(false);
      }
    }
  }
  /**
   * @hidden
   */
  handleEscape() {
    this.isOpen ? this.togglePopup(false) : this.clearValue();
    const hasSelected = this.selectionService.selected.length > 0;
    if (!hasSelected) {
      this.suggestedText = null;
      this.selectionService.focused = -1;
    }
    hasObservers(this.escape) && this.escape.emit();
  }
  /**
   * @hidden
   */
  handleNavigationOpen() {
    this.restoreItemFocus();
    this.togglePopup(true);
  }
  /**
   * @hidden
   */
  searchBarChange(text) {
    const currentTextLength = this.text ? this.text.length : 0;
    this.backspacePressed = text.length < currentTextLength ? true : false;
    this.text = text;
    this.selectionService.resetSelection([]);
    this.togglePopup(true);
    this._filtering = true;
    if (this.filterable && this.filterText !== text) {
      this.filterText = text;
      this.filterChange.emit(text);
    } else {
      this.search(text);
    }
  }
  /**
   * @hidden
   */
  handleInputFocus() {
    this.handleFocus();
    if (hasObservers(this.inputFocus)) {
      this.zone.run(() => this.inputFocus.emit());
    }
  }
  /**
   * @hidden
   */
  pageChange(event) {
    const virtual = this.virtual;
    virtual.skip = event.skip;
  }
  change(candidate, isCustom = false) {
    if (isCustom) {
      this.customValueSubject.next(candidate);
    } else {
      this.valueSubject.next(candidate);
      if (this.isActionSheetExpanded) {
        this.togglePopup(false);
      }
    }
  }
  emitValueChange() {
    this.onChangeCallback(this.value);
    this.valueChange.emit(this.value);
    this._previousDataItem = this.dataItem;
  }
  /**
   * @hidden
   */
  selectClick() {
    if (!touchEnabled) {
      this.searchbar.focus();
      this.isFocused = true;
    }
    if (!this.isOpen) {
      this.restoreItemFocus();
    }
    this.togglePopup(!this.isOpen);
  }
  get listContainerClasses() {
    return ["k-list-container", "k-combobox-popup"].concat(this.popupSettings.popupClass || []);
  }
  /**
   * @hidden
   */
  preventEventDefault(event) {
    event.preventDefault();
  }
  get focusedItemText() {
    const focused = this.selectionService.focused;
    if (!isPresent7(focused) || focused === -1) {
      return null;
    }
    const itemText = getter2(this.dataService.itemAt(focused), this.textField);
    return !isPresent7(itemText) ? "" : itemText.toString();
  }
  /**
   * Focuses the first match when there's text in the input field, but no focused item.
   */
  restoreItemFocus() {
    const hasFocus = isPresent7(this.selectionService.focused) && this.selectionService.focused > -1;
    if (!hasFocus && this.text && this.dataService.itemsCount) {
      if (this.filterable) {
        this.selectionService.focused = this.firstFocusableIndex(0);
      } else {
        this.search(this.text);
      }
    }
  }
  useSuggestion() {
    if (!(this.suggest && isPresent7(this.searchbar.value))) {
      return false;
    }
    const focusedDataItem = this.dataService.itemAt(this.selectionService.focused);
    const focusedItemText = getter2(focusedDataItem, this.textField);
    if (!isPresent7(focusedItemText)) {
      return false;
    }
    return this.searchbar.value.toLowerCase() === focusedItemText.toLowerCase();
  }
  destroyPopup() {
    if (this.popupRef) {
      this.popupRef.popupElement.removeEventListener("mousedown", this.popupMouseDownHandler);
      this.popupRef.close();
      this.popupRef = null;
    }
  }
  createPopup() {
    if (this.virtual) {
      this.virtual.skip = 0;
    }
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.openActionSheet();
      return;
    }
    const horizontalAlign = this.direction === "rtl" ? "right" : "left";
    const anchorPosition = {
      horizontal: horizontalAlign,
      vertical: "bottom"
    };
    const popupPosition = {
      horizontal: horizontalAlign,
      vertical: "top"
    };
    const appendToComponent = typeof this.popupSettings.appendTo === "string" && this.popupSettings.appendTo === "component";
    this.popupRef = this.popupService.open({
      anchor: this.wrapper,
      animate: this.popupSettings.animate,
      appendTo: this.appendTo,
      content: this.popupTemplate,
      popupClass: this.listContainerClasses,
      positionMode: appendToComponent ? "fixed" : "absolute",
      anchorAlign: anchorPosition,
      popupAlign: popupPosition
    });
    const popupWrapper = this.popupRef.popupElement;
    const {
      min,
      max
    } = this.popupWidth;
    popupWrapper.addEventListener("mousedown", this.popupMouseDownHandler);
    popupWrapper.style.minWidth = min;
    popupWrapper.style.width = max;
    popupWrapper.style.height = this.popupHeight;
    popupWrapper.setAttribute("dir", this.direction);
    if (!this.appendTo) {
      this.renderer.setAttribute(popupWrapper, "role", "region");
      this.renderer.setAttribute(popupWrapper, "aria-label", this.messageFor("popupLabel"));
    }
    this.popupRef.popupOpen.subscribe(() => {
      this.cdr.detectChanges();
      setListBoxAriaLabelledBy(this.optionsList, this.searchbar.input, this.renderer);
      this.optionsList.scrollToItem(this.selectionService.focused);
      this.selectionService.focus(this.selectionService.focused);
      this.opened.emit();
    });
    this.popupRef.popupClose.subscribe(() => {
      this.closed.emit();
    });
    this.popupRef.popupAnchorViewportLeave.subscribe(() => this.togglePopup(false));
  }
  _toggle(open) {
    this._open = open;
    this.destroyPopup();
    if (this.isActionSheetExpanded) {
      this.closeActionSheet();
    }
    if (this._open) {
      this.windowSize = this.adaptiveService.size;
      this.createPopup();
    }
  }
  triggerPopupEvents(open) {
    const eventArgs = new PreventableEvent5();
    if (open) {
      this.open.emit(eventArgs);
    } else {
      this.close.emit(eventArgs);
    }
    return eventArgs.isDefaultPrevented();
  }
  clearFilter() {
    if (!(this.filterable && this.filterText)) {
      return;
    }
    this.filterText = "";
    this.filterChange.emit(this.filterText);
  }
  subscribeTouchEvents() {
    if (!isDocumentAvailable() || !touchEnabled) {
      return;
    }
    this.zone.runOutsideAngular(() => (
      // Roll up ComboBox on iOS when tapped outside
      this.touchstartDisposeHandler = this.renderer.listen(document, "touchstart", (e) => {
        const target = e.target;
        const isInDropDown = inDropDown(this.wrapper, target, this.popupRef);
        if (this.isFocused && !isInDropDown) {
          this.zone.run(() => this.blur());
        } else if (this.isOpen && !isInDropDown) {
          this.zone.run(() => this.togglePopup(false));
        }
      })
    ));
  }
  attachSelectClickHandler() {
    const selectElement = this.select.nativeElement;
    const event = pointers ? "pointerdown" : "click";
    this.selectClickDisposeHandler = this.renderer.listen(selectElement, event, this.selectClick.bind(this));
  }
  setComponentClasses() {
    if (this.size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("input", this.size));
    }
    if (this.rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    }
  }
  findIndex(value, startFrom = 0) {
    let index;
    if (value && value.length && this.dataService.itemsCount) {
      index = this.dataService.findIndex(this.findIndexPredicate(value), startFrom);
    } else {
      index = -1;
    }
    return index;
  }
  closeActionSheet() {
    this.actionSheet.toggle(false);
    this.searchbar.input.nativeElement.focus();
    this.responsiveRendererComponent.searchBarValue = "";
    this.closed.emit();
  }
  openActionSheet() {
    this.windowSize = this.adaptiveService.size;
    this.actionSheet.toggle(true);
    this.cdr.detectChanges();
    setListBoxAriaLabelledBy(this.optionsList, this.searchbar.input, this.renderer);
    this.title = setActionSheetTitle(this.searchbar.input, this.title);
    updateActionSheetAdaptiveAppearance2(this.actionSheet, this.windowSize, this.renderer);
    this.cdr.detectChanges();
    this.opened.emit();
    this.optionsList.scrollToItem(this.selectionService.focused);
    this.selectionService.focus(this.selectionService.focused);
    this.actionSheetSearchBar.focus();
  }
  static ɵfac = function ComboBoxComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ComboBoxComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(NavigationService3), ɵɵdirectiveInject(DisabledItemsService), ɵɵdirectiveInject(DataService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ComboBoxComponent,
    selectors: [["kendo-combobox"]],
    contentQueries: function ComboBoxComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, GroupTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FixedGroupTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, SuffixTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, PrefixTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fixedGroupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.suffixTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.prefixTemplate = _t.first);
      }
    },
    viewQuery: function ComboBoxComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(ResponsiveRendererComponent, 5);
        ɵɵviewQuery(_c94, 7, ViewContainerRef);
        ɵɵviewQuery(_c104, 7);
        ɵɵviewQuery(SearchBarComponent, 7);
        ɵɵviewQuery(_c113, 5);
        ɵɵviewQuery(_c133, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.responsiveRendererComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.searchbar = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.optionsList = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.select = _t.first);
      }
    },
    hostVars: 11,
    hostBindings: function ComboBoxComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.dir);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-combobox", ctx.widgetClasses)("k-input", ctx.widgetClasses)("k-disabled", ctx.isDisabled)("k-loading", ctx.isLoading);
      }
    },
    inputs: {
      icon: "icon",
      svgIcon: "svgIcon",
      inputAttributes: "inputAttributes",
      showStickyHeader: "showStickyHeader",
      focusableId: "focusableId",
      allowCustom: "allowCustom",
      data: "data",
      value: "value",
      textField: "textField",
      valueField: "valueField",
      valuePrimitive: "valuePrimitive",
      valueNormalizer: "valueNormalizer",
      placeholder: "placeholder",
      adaptiveMode: "adaptiveMode",
      title: "title",
      subtitle: "subtitle",
      popupSettings: "popupSettings",
      listHeight: "listHeight",
      loading: "loading",
      suggest: "suggest",
      clearButton: "clearButton",
      disabled: "disabled",
      itemDisabled: "itemDisabled",
      readonly: "readonly",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      filterable: "filterable",
      virtual: "virtual",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode"
    },
    outputs: {
      valueChange: "valueChange",
      selectionChange: "selectionChange",
      filterChange: "filterChange",
      open: "open",
      opened: "opened",
      close: "close",
      closed: "closed",
      onFocus: "focus",
      onBlur: "blur",
      inputFocus: "inputFocus",
      inputBlur: "inputBlur",
      escape: "escape"
    },
    exportAs: ["kendoComboBox"],
    features: [ɵɵProvidersFeature([COMBOBOX_VALUE_ACCESSOR, DataService, SelectionService2, NavigationService3, DisabledItemsService, LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.combobox"
    }, {
      provide: FilterableComponent,
      useExisting: forwardRef(() => _ComboBoxComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _ComboBoxComponent)
    }, {
      provide: MultiTabStop,
      useExisting: forwardRef(() => _ComboBoxComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 20,
    vars: 38,
    consts: () => {
      let i18n_3;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_3 = goog.getMsg("NO DATA FOUND");
        i18n_3 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_3;
      } else {
        i18n_3 = $localize`:kendo.combobox.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;
      }
      let i18n_4;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_4 = goog.getMsg("clear");
        i18n_4 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_4;
      } else {
        i18n_4 = $localize`:kendo.combobox.clearTitle|The title of the clear button:clear`;
      }
      let i18n_5;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_5 = goog.getMsg("Select");
        i18n_5 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_5;
      } else {
        i18n_5 = $localize`:kendo.combobox.selectButtonText|The text set as aria-label on the select button:Select`;
      }
      let i18n_6;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_6 = goog.getMsg("Options list");
        i18n_6 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_6;
      } else {
        i18n_6 = $localize`:kendo.combobox.popupLabel|The label of the popup element that contains the list of options when its role is 'region':Options list`;
      }
      return [["select", ""], ["popupTemplate", ""], ["container", ""], ["sharedPopupActionSheetTemplate", ""], ["optionsList", ""], ["kendoComboBoxLocalizedMessages", "", "noDataText", i18n_3, "clearTitle", i18n_4, "selectButtonText", i18n_5, "popupLabel", i18n_6], ["kendoDropDownSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused"], ["class", "k-input-prefix k-input-prefix-horizontal", 4, "ngIf"], [4, "ngIf"], ["kendoSearchbar", "", 3, "onNavigate", "valueChange", "onBlur", "onFocus", "click", "ariaExpanded", "ariaControls", "id", "isLoading", "isSuggestable", "isFilterable", "activeDescendant", "userInput", "suggestedText", "disabled", "readonly", "tabIndex", "isRequired", "placeholder", "inputAttributes"], ["class", "k-clear-value", "aria-hidden", "true", 3, "visibility", "kendoEventsOutsideAngular", "click", 4, "ngIf"], ["class", "k-i-loading k-input-loading-icon k-icon", 4, "ngIf"], ["class", "k-input-suffix k-input-suffix-horizontal", 4, "ngIf"], ["tabindex", "-1", "unselectable", "on", "type", "button", 1, "k-input-button", "k-button", "k-icon-button", 3, "keydown.enter", "ngClass", "kendoEventsOutsideAngular"], ["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [3, "resize", 4, "ngIf"], [3, "closePopup", "textInputChange", "navigate", "sharedPopupActionSheetTemplate", "isActionSheetExpanded", "title", "showTextInput", "subtitle", "placeholder"], [1, "k-input-prefix", "k-input-prefix-horizontal"], [3, "ngTemplateOutlet"], ["aria-hidden", "true", 1, "k-clear-value", 3, "click", "kendoEventsOutsideAngular"], ["name", "x", 3, "svgIcon"], [1, "k-i-loading", "k-input-loading-icon", "k-icon"], [1, "k-input-suffix", "k-input-suffix-horizontal"], [4, "ngTemplateOutlet"], [3, "resize"], [3, "pageChange", "size", "rounded", "id", "optionPrefix", "data", "textField", "valueField", "template", "groupTemplate", "fixedGroupTemplate", "height", "show", "virtual", "showStickyHeader"], ["class", "k-no-data", 4, "ngIf"], [3, "templateContext"], [1, "k-no-data"], [3, "ngIf", "templateContext"], [3, "ngIf"]];
    },
    template: function ComboBoxComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 5);
        ɵɵelementContainerStart(1, 6);
        ɵɵtwoWayListener("isFocusedChange", function ComboBoxComponent_Template_ng_container_isFocusedChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.isFocused, $event) || (ctx.isFocused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function ComboBoxComponent_Template_ng_container_handleBlur_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function ComboBoxComponent_Template_ng_container_onFocus_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵtemplate(2, ComboBoxComponent_span_2_Template, 2, 1, "span", 7)(3, ComboBoxComponent_kendo_separator_3_Template, 1, 0, "kendo-separator", 8);
        ɵɵelementStart(4, "input", 9);
        ɵɵlistener("onNavigate", function ComboBoxComponent_Template_input_onNavigate_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleNavigate($event));
        })("valueChange", function ComboBoxComponent_Template_input_valueChange_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.searchBarChange($event));
        })("onBlur", function ComboBoxComponent_Template_input_onBlur_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputBlur());
        })("onFocus", function ComboBoxComponent_Template_input_onFocus_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputFocus());
        })("click", function ComboBoxComponent_Template_input_click_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleClick());
        });
        ɵɵelementEnd();
        ɵɵtemplate(5, ComboBoxComponent_span_5_Template, 2, 7, "span", 10)(6, ComboBoxComponent_span_6_Template, 1, 0, "span", 11)(7, ComboBoxComponent_kendo_separator_7_Template, 1, 0, "kendo-separator", 8)(8, ComboBoxComponent_span_8_Template, 2, 1, "span", 12);
        ɵɵelementStart(9, "button", 13, 0);
        ɵɵlistener("keydown.enter", function ComboBoxComponent_Template_button_keydown_enter_9_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView($event.stopImmediatePropagation());
        });
        ɵɵelement(11, "kendo-icon-wrapper", 14);
        ɵɵelementEnd();
        ɵɵelementContainerEnd();
        ɵɵtemplate(12, ComboBoxComponent_ng_template_12_Template, 1, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor)(14, ComboBoxComponent_kendo_resize_sensor_14_Template, 1, 0, "kendo-resize-sensor", 15);
        ɵɵelementContainer(15, null, 2);
        ɵɵelementStart(17, "responsive-renderer", 16);
        ɵɵlistener("closePopup", function ComboBoxComponent_Template_responsive_renderer_closePopup_17_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.togglePopup(false));
        })("textInputChange", function ComboBoxComponent_Template_responsive_renderer_textInputChange_17_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onAdaptiveTextBoxChange($event));
        })("navigate", function ComboBoxComponent_Template_responsive_renderer_navigate_17_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleNavigate($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(18, ComboBoxComponent_ng_template_18_Template, 5, 17, "ng-template", null, 3, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const sharedPopupActionSheetTemplate_r4 = ɵɵreference(19);
        ɵɵadvance();
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.isFocused);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate && ctx.prefixTemplate.showSeparator);
        ɵɵadvance();
        ɵɵproperty("ariaExpanded", ctx.isOpen)("ariaControls", ctx.ariaControls)("id", ctx.focusableId)("isLoading", ctx.loading)("isSuggestable", ctx.suggest)("isFilterable", ctx.filterable)("activeDescendant", ctx.activeDescendant)("userInput", ctx.text)("suggestedText", ctx.getSuggestion())("disabled", ctx.disabled)("readonly", ctx.readonly || ctx.isAdaptive)("tabIndex", ctx.tabIndex)("isRequired", ctx.isControlRequired)("placeholder", ctx.placeholder)("inputAttributes", ctx.inputAttributes);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.clearButton && !ctx.loading && !ctx.disabled && !ctx.readonly && (ctx.text == null ? null : ctx.text.length));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.loading);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffixTemplate && ctx.suffixTemplate.showSeparator);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffixTemplate);
        ɵɵadvance();
        ɵɵproperty("ngClass", ctx.selectButtonClasses)("kendoEventsOutsideAngular", ɵɵpureFunction1(36, _c143, ctx.preventEventDefault));
        ɵɵattribute("aria-label", ctx.messageFor("selectButtonText"))("disabled", ctx.disabled ? "" : null);
        ɵɵadvance(2);
        ɵɵproperty("name", ctx.icon || "caret-alt-down")("svgIcon", ctx.svgIcon || ctx.caretAltDownIcon);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.isOpen || ctx.isAdaptiveModeEnabled);
        ɵɵadvance(3);
        ɵɵproperty("sharedPopupActionSheetTemplate", sharedPopupActionSheetTemplate_r4)("isActionSheetExpanded", ctx.isActionSheetExpanded)("title", ctx.title)("showTextInput", true)("subtitle", ctx.subtitle)("placeholder", ctx.placeholder);
      }
    },
    dependencies: [LocalizedMessagesDirective3, SharedDropDownEventsDirective, NgIf, NgTemplateOutlet, SeparatorComponent, SearchBarComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgClass, ResizeSensorComponent, ResponsiveRendererComponent, TemplateContextDirective, ListComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ComboBoxComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoComboBox",
      providers: [COMBOBOX_VALUE_ACCESSOR, DataService, SelectionService2, NavigationService3, DisabledItemsService, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.combobox"
      }, {
        provide: FilterableComponent,
        useExisting: forwardRef(() => ComboBoxComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => ComboBoxComponent)
      }, {
        provide: MultiTabStop,
        useExisting: forwardRef(() => ComboBoxComponent)
      }],
      selector: "kendo-combobox",
      template: `
        <ng-container kendoComboBoxLocalizedMessages
            i18n-noDataText="kendo.combobox.noDataText|The text displayed in the popup when there are no items"
            noDataText="NO DATA FOUND"

            i18n-clearTitle="kendo.combobox.clearTitle|The title of the clear button"
            clearTitle="clear"

            i18n-selectButtonText="kendo.combobox.selectButtonText|The text set as aria-label on the select button"
            selectButtonText="Select"

            i18n-popupLabel="kendo.combobox.popupLabel|The label of the popup element that contains the list of options when its role is 'region'"
            popupLabel="Options list"
        >
        </ng-container>

        <ng-container
            kendoDropDownSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="isFocused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
        >
            <span *ngIf="prefixTemplate" class="k-input-prefix k-input-prefix-horizontal">
                <ng-template [ngTemplateOutlet]="prefixTemplate?.templateRef">
                </ng-template>
            </span>
            <kendo-separator *ngIf="prefixTemplate && prefixTemplate.showSeparator"></kendo-separator>
            <input 
                kendoSearchbar
                [ariaExpanded]="isOpen"
                [ariaControls]="ariaControls"
                [id]="focusableId"
                [isLoading]="loading"
                [isSuggestable]="suggest"
                [isFilterable]="filterable"
                [activeDescendant]="activeDescendant"
                [userInput]="text"
                [suggestedText]="getSuggestion()"
                [disabled]="disabled"
                [readonly]="readonly || isAdaptive"
                [tabIndex]="tabIndex"
                [isRequired]="isControlRequired"
                [placeholder]="placeholder"
                [inputAttributes]="inputAttributes"
                (onNavigate)="handleNavigate($event)"
                (valueChange)="searchBarChange($event)"
                (onBlur)="handleInputBlur()"
                (onFocus)="handleInputFocus()"
                (click)="handleClick()"
            />
            <span
                *ngIf="clearButton && !loading && !disabled && !readonly && text?.length"
                class="k-clear-value"
                [style.visibility]="clearButtonVisiblity"
                aria-hidden="true"
                [attr.title]="messageFor('clearTitle')"
                (click)="clearValue($event)"
                [kendoEventsOutsideAngular]="{
                    mousedown: preventEventDefault
                }"
            >
                <kendo-icon-wrapper
                    name="x"
                    [svgIcon]="xIcon"
                >
                </kendo-icon-wrapper>
            </span>
            <span *ngIf="loading" class="k-i-loading k-input-loading-icon k-icon"></span>
            <kendo-separator *ngIf="suffixTemplate && suffixTemplate.showSeparator"></kendo-separator>
            <span *ngIf="suffixTemplate" class="k-input-suffix k-input-suffix-horizontal">
                <ng-template [ngTemplateOutlet]="suffixTemplate?.templateRef">
                </ng-template>
            </span>
            <button
                #select
                tabindex="-1"
                unselectable="on"
                type="button"
                class="k-input-button k-button k-icon-button"
                [ngClass]="selectButtonClasses"
                [attr.aria-label]="messageFor('selectButtonText')"
                [attr.disabled]="disabled ? '' : null"
                (keydown.enter)="$event.stopImmediatePropagation();"
                [kendoEventsOutsideAngular]="{
                    mousedown: preventEventDefault
                }"
            >
                <kendo-icon-wrapper
                    [name]="icon || 'caret-alt-down'"
                    innerCssClass="k-button-icon"
                    [svgIcon]="svgIcon || caretAltDownIcon"
                >
                </kendo-icon-wrapper>
            </button>
        </ng-container>

        <ng-template #popupTemplate>
            <ng-container *ngTemplateOutlet="sharedPopupActionSheetTemplate"></ng-container>
        </ng-template>
        <kendo-resize-sensor *ngIf="isOpen || isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>
        <ng-container #container></ng-container>

        <!--adaptive rendering-->
        <responsive-renderer
            [sharedPopupActionSheetTemplate]="sharedPopupActionSheetTemplate"
            [isActionSheetExpanded]="isActionSheetExpanded"
            [title]="title"
            [showTextInput]="true"
            [subtitle]="subtitle"
            (closePopup)="togglePopup(false)"
            (textInputChange)="onAdaptiveTextBoxChange($event)"
            (navigate)="handleNavigate($event)"
            [placeholder]="placeholder"
            >
        </responsive-renderer>
        <ng-template #sharedPopupActionSheetTemplate>
            <!--header template-->
            <ng-template *ngIf="headerTemplate"
                [templateContext]="{
                    templateRef: headerTemplate.templateRef
                }">
            </ng-template>
            <!--list-->
            <kendo-list
                #optionsList
                [size]="size"
                [rounded]="rounded"
                [id]="listBoxId"
                [optionPrefix]="optionPrefix"
                [data]="data"
                [textField]="textField"
                [valueField]="valueField"
                [template]="template"
                [groupTemplate]="groupTemplate"
                [fixedGroupTemplate]="fixedGroupTemplate"
                [height]="listHeight"
                [show]="isOpen"
                [virtual]="virtual"
                [showStickyHeader]="showStickyHeader"
                (pageChange)="pageChange($event)"
            >
            </kendo-list>
            <!--no-data template-->
            <div class="k-no-data" *ngIf="data.length === 0">
                <ng-template [ngIf]="noDataTemplate"
                    [templateContext]="{
                        templateRef: noDataTemplate ? noDataTemplate.templateRef : undefined
                    }">
                </ng-template>
                <ng-template [ngIf]="!noDataTemplate">
                    <div>{{ messageFor('noDataText') }}</div>
                </ng-template>
            </div>
            <!--footer template-->
            <ng-template *ngIf="footerTemplate"
                [templateContext]="{
                    templateRef: footerTemplate.templateRef
                }">
            </ng-template>
        </ng-template>
  `,
      standalone: true,
      imports: [LocalizedMessagesDirective3, SharedDropDownEventsDirective, NgIf, NgTemplateOutlet, SeparatorComponent, SearchBarComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgClass, ResizeSensorComponent, ResponsiveRendererComponent, TemplateContextDirective, ListComponent]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: LocalizationService
    }, {
      type: PopupService
    }, {
      type: SelectionService2
    }, {
      type: NavigationService3
    }, {
      type: DisabledItemsService
    }, {
      type: DataService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }, {
      type: Injector
    }, {
      type: ElementRef
    }, {
      type: AdaptiveService
    }];
  }, {
    icon: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    responsiveRendererComponent: [{
      type: ViewChild,
      args: [ResponsiveRendererComponent]
    }],
    showStickyHeader: [{
      type: Input
    }],
    focusableId: [{
      type: Input
    }],
    allowCustom: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    textField: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    valuePrimitive: [{
      type: Input
    }],
    valueNormalizer: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    subtitle: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    listHeight: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    suggest: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    itemDisabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input,
      args: ["tabIndex"]
    }],
    filterable: [{
      type: Input
    }],
    virtual: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    selectionChange: [{
      type: Output
    }],
    filterChange: [{
      type: Output
    }],
    open: [{
      type: Output
    }],
    opened: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    closed: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    inputFocus: [{
      type: Output
    }],
    inputBlur: [{
      type: Output
    }],
    escape: [{
      type: Output
    }],
    template: [{
      type: ContentChild,
      args: [ItemTemplateDirective, {
        static: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective, {
        static: false
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective, {
        static: false
      }]
    }],
    noDataTemplate: [{
      type: ContentChild,
      args: [NoDataTemplateDirective, {
        static: false
      }]
    }],
    groupTemplate: [{
      type: ContentChild,
      args: [GroupTemplateDirective, {
        static: false
      }]
    }],
    fixedGroupTemplate: [{
      type: ContentChild,
      args: [FixedGroupTemplateDirective, {
        static: false
      }]
    }],
    suffixTemplate: [{
      type: ContentChild,
      args: [SuffixTemplateDirective]
    }],
    prefixTemplate: [{
      type: ContentChild,
      args: [PrefixTemplateDirective]
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        static: true
      }]
    }],
    searchbar: [{
      type: ViewChild,
      args: [SearchBarComponent, {
        static: true
      }]
    }],
    optionsList: [{
      type: ViewChild,
      args: ["optionsList", {
        static: false
      }]
    }],
    select: [{
      type: ViewChild,
      args: ["select", {
        static: true
      }]
    }],
    widgetClasses: [{
      type: HostBinding,
      args: ["class.k-combobox"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    isDisabled: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    isLoading: [{
      type: HostBinding,
      args: ["class.k-loading"]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }]
  });
})();
var ValueTemplateDirective = class _ValueTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ValueTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ValueTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ValueTemplateDirective,
    selectors: [["", "kendoDropDownListValueTemplate", ""], ["", "kendoDropDownTreeValueTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ValueTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownListValueTemplate],[kendoDropDownTreeValueTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var FilterInputDirective = class _FilterInputDirective {
  element;
  zone;
  focused;
  constructor(element, zone) {
    this.element = element;
    this.zone = zone;
  }
  ngOnChanges() {
    if (this.focused) {
      this.nextTick(() => this.element.nativeElement.focus());
    }
  }
  nextTick(fn) {
    this.zone.runOutsideAngular(() => setTimeout(fn));
  }
  static ɵfac = function FilterInputDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterInputDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterInputDirective,
    selectors: [["", "filterInput", ""]],
    inputs: {
      focused: [0, "filterInput", "focused"]
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterInputDirective, [{
    type: Directive,
    args: [{
      selector: "[filterInput]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, {
    focused: [{
      type: Input,
      args: ["filterInput"]
    }]
  });
})();
var DROPDOWNLIST_VALUE_ACCESSOR = {
  multi: true,
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => DropDownListComponent)
};
var DEFAULT_SIZE$32 = "medium";
var DEFAULT_ROUNDED$32 = "medium";
var DEFAULT_FILL_MODE$32 = "solid";
var DropDownListComponent = class _DropDownListComponent {
  wrapper;
  localization;
  popupService;
  selectionService;
  navigationService;
  disabledItemsService;
  dataService;
  _zone;
  renderer;
  cdr;
  injector;
  adaptiveService;
  /**
   * @hidden
   */
  touchEnabled = touchEnabled;
  /**
   * @hidden
   */
  animationDuration = animationDuration2;
  /**
   * @hidden
   */
  xIcon = xIcon;
  /**
   * @hidden
   */
  searchIcon = searchIcon;
  /**
   * @hidden
   */
  caretAltDownSVGIcon = caretAltDownIcon;
  /**
   * @hidden
   */
  customIconClass;
  /**
   * @hidden
   */
  responsiveRendererComponent;
  /**
   * @hidden
   */
  get actionSheet() {
    return this.responsiveRendererComponent?.actionSheet;
  }
  /**
   * @hidden
   */
  get actionSheetSearchBar() {
    return this.responsiveRendererComponent?.actionSheetSearchBar;
  }
  get width() {
    const wrapperWidth = isDocumentAvailable() ? this.wrapper.nativeElement.offsetWidth : 0;
    const width = this.popupSettings.width || wrapperWidth;
    const minWidth = isNaN(wrapperWidth) ? wrapperWidth : `${wrapperWidth}px`;
    const maxWidth = isNaN(width) ? width : `${width}px`;
    return {
      min: minWidth,
      max: maxWidth
    };
  }
  get height() {
    const popupHeight = this.popupSettings.height;
    return isPresent7(popupHeight) ? `${popupHeight}px` : "auto";
  }
  get widgetTabIndex() {
    if (this.disabled) {
      return void 0;
    }
    const providedTabIndex = Number(this.tabIndex);
    const defaultTabIndex = 0;
    return !isNaN(providedTabIndex) ? providedTabIndex : defaultTabIndex;
  }
  get ariaActivedescendant() {
    if (!isPresent7(this.dataItem) || !this.isOpen) {
      return;
    }
    return this.optionPrefix + "-" + this.selectionService.focused;
  }
  get appendTo() {
    const {
      appendTo
    } = this.popupSettings;
    if (!appendTo || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  /**
   * @hidden
   */
  onFilterChange(text) {
    if (this.filterable) {
      this.filterChange.emit(text);
    }
  }
  /**
   * @hidden
   */
  get ariaLive() {
    return this.filterable ? "polite" : "off";
  }
  /**
   * Shows or hides the current group sticky header when using grouped data.
   * By default the sticky header is displayed ([see example]({% slug grouping_autocomplete %}#toc-sticky-header)).
   */
  showStickyHeader = true;
  /**
   * @hidden
   */
  icon;
  /**
   * @hidden
   */
  svgIcon;
  /**
   * Sets and gets the loading state of the DropDownList.
   */
  loading;
  /**
   * Sets the data of the DropDownList.
   *
   * > The data has to be provided in an array-like list.
   */
  set data(data) {
    this.dataService.data = data || [];
    if (this.virtual) {
      this.virtual.skip = 0;
    }
    this.setState();
  }
  get data() {
    const virtual = this.virtual;
    if (virtual) {
      const start = virtual.skip || 0;
      const end = start + virtual.pageSize;
      virtual.total = this.dataService.data.length;
      return this.dataService.data.slice(start, end);
    }
    return this.dataService.data;
  }
  /**
   * Sets the value of the DropDownList.
   * It can either be of the primitive (string, numbers) or of the complex (objects) type.
   * To define the type, use the `valuePrimitive` option.
   *
   * > All selected values which are not present in the source are ignored.
   */
  set value(newValue) {
    if (!isPresent7(newValue)) {
      this._previousDataItem = void 0;
    }
    this._value = newValue;
    this.setState();
    this.cdr.markForCheck();
  }
  get value() {
    return this._value;
  }
  /**
   * Sets the data item field that represents the item text.
   * If the data contains only primitive values, do not define it.
   *
   * > The `textField` property can be set to point to a nested property value - e.g. `category.name`.
   */
  textField;
  /**
   * Sets the data item field that represents the item value.
   * If the data contains only primitive values, do not define it.
   *
   * > The `valueField` property can be set to point to a nested property value - e.g. `category.id`.
   */
  valueField;
  /**
   * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.
   */
  adaptiveMode = "none";
  /**
   * Sets the title of the ActionSheet that is rendered instead of the Popup when using small screen devices.
   * By default the ActionSheet title uses the text provided for the label of the AutoComplete.
   */
  title = "";
  /**
   * Sets the subtitle of the ActionSheet that is rendered instead of the Popup when using small screen devices.
   * By default the ActionSheet subtitle uses the text provided for the `placeholder` of the AutoComplete.
  */
  subtitle = "";
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
  * @hidden
  */
  windowSize = "large";
  /**
   * @hidden
   */
  get isActionSheetExpanded() {
    return this.actionSheet?.expanded;
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  /**
   * Configures the popup of the DropDownList.
   *
   * The available options are:
   * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
   * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.
   * - `height: Number`&mdash;Sets the height of the popup container.
   * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
   * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
   */
  set popupSettings(settings) {
    this._popupSettings = Object.assign({
      animate: true
    }, settings);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Sets the height of the options list in the popup. By default, `listHeight` is 200px.
   *
   * > The `listHeight` property affects only the list of options and not the whole popup container.
   * > To set the height of the popup container, use `popupSettings.height`.
   *
   * > When using `adaptiveMode` and the screen size is `small` or `medium` the `listHeight` property is set to null.
   */
  set listHeight(_listHeight) {
    this._listHeight = _listHeight;
  }
  get listHeight() {
    if (this.isAdaptive) {
      return;
    }
    return this._listHeight;
  }
  _listHeight = 200;
  /**
   * Sets the text of the default empty item. The type of the defined value has to match the data type.
   */
  defaultItem;
  /**
   * Sets the disabled state of the component. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_ddl#toc-managing-the-dropdownlist-disabled-state-in-reactive-forms).
   */
  disabled;
  /**
   * Defines a Boolean function that is executed for each data item in the component
   * ([see examples]({% slug disableditems_ddl %})). Determines whether the item will be disabled.
   */
  set itemDisabled(fn) {
    if (typeof fn !== "function") {
      throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this.disabledItemsService.itemDisabled = fn;
  }
  /**
   * Sets the read-only state of the component.
   *
   * @default false
   */
  readonly = false;
  /**
   * Enables the [filtering]({% slug filtering_ddl %}) functionality of the DropDownList.
   */
  filterable = false;
  /**
   * Enables the [virtualization]({% slug virtualization_ddl %}) functionality.
   */
  set virtual(settings) {
    this._virtualSettings = normalizeVirtualizationSettings(settings);
  }
  get virtual() {
    return this._virtualSettings;
  }
  /**
   * Enables a case-insensitive search. When filtration is disabled, use this option.
   */
  ignoreCase = true;
  /**
   * Sets the delay before an item search is performed. When filtration is disabled, use this option.
   */
  delay = 500;
  /**
   * Specifies the type of the selected value
   * ([more information and example]({% slug valuebinding_ddl %}#toc-primitive-values-from-object-fields)).
   * If set to `true`, the selected value has to be of a primitive value.
   */
  set valuePrimitive(isPrimitive) {
    this._valuePrimitive = isPrimitive;
  }
  get valuePrimitive() {
    if (!isPresent7(this._valuePrimitive)) {
      return !isPresent7(this.valueField);
    }
    return this._valuePrimitive;
  }
  /**
   * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$32;
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass2("picker", this.size));
    if (size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("picker", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `full`
   * * `none`
   *
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED$32;
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    if (rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = rounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the fillMode of the component.
   *
   * The possible values are:
   * * `flat`
   * * `solid` (default)
   * * `outline`
   * * `none`
   *
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$32;
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("picker", this.fillMode));
    if (fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("picker", newFillMode));
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Toggles the left and right arrow keys navigation functionality.
   * @hidden
   */
  leftRightArrowsNavigation = true;
  /**
   * Fires each time the value is changed ([see example](slug:events_ddl)).
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the user types in the input field
   * ([see example](slug:events_ddl)).
   * You can filter the source based on the passed filtration value.
   * When the value of the component is programmatically changed to `ngModel` or `formControl`
   * through its API or form binding, the `valueChange` event is not triggered because it
   * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
   */
  filterChange = new EventEmitter();
  /**
   * Fires each time the item selection is changed
   * ([see example](slug:events_ddl)).
   */
  selectionChange = new EventEmitter();
  /**
   * Fires each time the popup is about to open
   * ([see example]({% slug openstate_ddl %}#toc-preventing-opening-and-closing)).
   * This event is preventable. If you cancel it, the popup will remain closed.
   */
  open = new EventEmitter();
  /**
   * Fires after the popup has been opened.
   */
  opened = new EventEmitter();
  /**
   * Fires each time the popup is about to close
   * ([see example]({% slug openstate_ddl %}#toc-preventing-opening-and-closing)).
   * This event is preventable. If you cancel it, the popup will remain open.
   */
  close = new EventEmitter();
  /**
   * Fires after the popup has been closed.
   */
  closed = new EventEmitter();
  /**
   * Fires each time the user focuses the DropDownList.
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the DropDownList gets blurred.
   */
  onBlur = new EventEmitter();
  itemTemplate;
  groupTemplate;
  fixedGroupTemplate;
  valueTemplate;
  headerTemplate;
  footerTemplate;
  noDataTemplate;
  container;
  popupTemplate;
  optionsList;
  /**
   * @hidden
   */
  blurComponent(event) {
    if (event.target !== this.wrapper.nativeElement) {
      return;
    }
    event.stopImmediatePropagation();
    this.hostElementBlurred.emit();
  }
  /**
   * @hidden
   */
  blurFilterInput() {
    this.filterBlurred.emit();
  }
  /**
   * @hidden
   */
  focusComponent(event) {
    if (event.target !== this.wrapper.nativeElement) {
      return;
    }
    event.stopImmediatePropagation();
    this.hostElementFocused.emit();
    if (!this.isFocused) {
      this.isFocused = true;
      if (hasObservers(this.onFocus)) {
        this._zone.run(() => {
          this.onFocus.emit();
        });
      }
    }
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (this.isAdaptiveModeEnabled && this.windowSize !== currentWindowSize) {
      if (this.isOpen) {
        this.togglePopup(false);
      }
      this.windowSize = currentWindowSize;
    }
    if (this.isOpen && !this.isActionSheetExpanded) {
      const popupWrapper = this.popupRef.popupElement;
      const {
        min,
        max
      } = this.width;
      popupWrapper.style.minWidth = min;
      popupWrapper.style.width = max;
    }
  }
  hostClasses = true;
  get isDisabledClass() {
    return this.disabled || null;
  }
  get isLoading() {
    return this.loading;
  }
  /**
   * @hidden
   */
  focusableId = `k-${guid2()}`;
  get dir() {
    return this.direction;
  }
  get hostTabIndex() {
    return this.widgetTabIndex;
  }
  get readonlyClass() {
    return this.readonly;
  }
  get readonlyAttr() {
    return this.readonly ? "" : null;
  }
  get isBusy() {
    return this.isLoading;
  }
  role = "combobox";
  haspopup = "listbox";
  get hostAriaInvalid() {
    return this.formControl?.invalid ? true : null;
  }
  /**
   * @hidden
   */
  keydown(event, input) {
    if (input) {
      event.stopPropagation();
    }
    const firstIndex = isPresent7(this.defaultItem) ? -1 : 0;
    const focused = isNaN(this.selectionService.focused) ? this.firstFocusableIndex(firstIndex) : this.selectionService.focused;
    let offset = 0;
    if (this.disabled || this.readonly) {
      return;
    }
    const isHomeEnd = event.keyCode === Keys.Home || event.keyCode === Keys.End;
    const isFilterFocused = this.filterable && this.isFocused && this.isOpen;
    if (isFilterFocused && isHomeEnd) {
      return;
    }
    const hasSelected = isPresent7(this.selectionService.selected[0]);
    const focusedItemNotSelected = isPresent7(this.selectionService.focused) && !this.selectionService.isSelected(this.selectionService.focused);
    if (!hasSelected || focusedItemNotSelected) {
      if (event.keyCode === Keys.ArrowDown || event.keyCode === Keys.ArrowRight && this.leftRightArrowsNavigation) {
        offset = -1;
      } else if (event.keyCode === Keys.ArrowUp || event.keyCode === Keys.ArrowLeft && this.leftRightArrowsNavigation) {
        offset = 1;
      }
    }
    const eventData = event;
    const action = this.navigationService.process({
      current: focused + offset,
      max: this.dataService.itemsCount - 1,
      min: this.defaultItem ? -1 : 0,
      originalEvent: eventData,
      openOnSpace: !this.isOpen,
      closeOnSpace: this.isOpen && !input && !(event.target instanceof HTMLInputElement)
    });
    const leftRightKeys = action === NavigationAction.Left || action === NavigationAction.Right && this.leftRightArrowsNavigation;
    if (action !== NavigationAction.Undefined && action !== NavigationAction.Tab && action !== NavigationAction.Backspace && action !== NavigationAction.Delete && action !== NavigationAction.PageDown && action !== NavigationAction.PageUp && action !== NavigationAction.SelectAll && !(leftRightKeys && this.filterable) && action !== NavigationAction.Enter) {
      eventData.preventDefault();
    }
    if (action === NavigationAction.Tab && this.isActionSheetExpanded) {
      this.togglePopup(false);
    }
  }
  /**
   * @hidden
   */
  keypress(event) {
    if (this.disabled || this.readonly || this.filterable) {
      return;
    }
    this.onKeyPress(event);
  }
  /**
   * @hidden
   */
  click() {
    if (!this.isActionSheetExpanded) {
      this.focus();
      this.togglePopup(!this.isOpen);
    }
  }
  groupIndices = [];
  optionPrefix = `k-${guid2()}`;
  valueLabelId;
  filterText = "";
  listBoxId = `k-${guid2()}`;
  subs = new Subscription();
  _isFocused = false;
  set isFocused(isFocused) {
    this.renderer[isFocused ? "addClass" : "removeClass"](this.wrapper.nativeElement, "k-focus");
    this._isFocused = isFocused;
  }
  get isFocused() {
    return this._isFocused;
  }
  direction;
  dataItem;
  popupRef;
  onTouchedCallback = (_2) => {
  };
  onChangeCallback = (_2) => {
  };
  popupMouseDownHandler;
  word = "";
  last = "";
  typingTimeout;
  filterFocused = new EventEmitter();
  filterBlurred = new EventEmitter();
  hostElementFocused = new EventEmitter();
  hostElementBlurred = new EventEmitter();
  touchstartDisposeHandler;
  _value;
  _open = false;
  _previousDataItem;
  _valuePrimitive;
  text;
  _popupSettings = {
    animate: true
  };
  _virtualSettings;
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  constructor(wrapper, localization, popupService, selectionService, navigationService, disabledItemsService, dataService, _zone, renderer, cdr, injector, adaptiveService) {
    this.wrapper = wrapper;
    this.localization = localization;
    this.popupService = popupService;
    this.selectionService = selectionService;
    this.navigationService = navigationService;
    this.disabledItemsService = disabledItemsService;
    this.dataService = dataService;
    this._zone = _zone;
    this.renderer = renderer;
    this.cdr = cdr;
    this.injector = injector;
    this.adaptiveService = adaptiveService;
    validatePackage(packageMetadata7);
    this.direction = localization.rtl ? "rtl" : "ltr";
    this.data = [];
    this.subscribeEvents();
    this.subscribeTouchEvents();
    this.subscribeFocusEvents();
    this.popupMouseDownHandler = this.onMouseDown.bind(this);
  }
  ngOnInit() {
    this.renderer.removeAttribute(this.wrapper.nativeElement, "tabindex");
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-expanded", "false");
    if (this.ariaActivedescendant) {
      this.renderer.setAttribute(this.wrapper.nativeElement, "aria-activedescendant", this.ariaActivedescendant);
    }
    this.subs.add(this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
      this.cdr.detectChanges();
    }));
    this.assignAriaDescribedBy();
    this.setComponentClasses();
  }
  ngAfterViewInit() {
    this.windowSize = this.adaptiveService.size;
    if (this.actionSheet && isDocumentAvailable()) {
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-height", "60vh");
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-max-height", "none");
    }
  }
  /**
   * @hidden
   * Used by the TextBoxContainer to determine if the component is empty.
   */
  isEmpty() {
    const value = this.value;
    return !(value === 0 || value === false || value || this.defaultItem);
  }
  /**
   * @hidden
   */
  onFilterFocus() {
    this.filterFocused.emit();
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    this.destroyPopup();
    this.subs.unsubscribe();
    this.unSubscribeFocusEvents();
    if (this.touchstartDisposeHandler) {
      this.touchstartDisposeHandler();
    }
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    const virtual = this.virtual;
    const requestInitialData = virtual && changes["data"] && changes["data"].isFirstChange();
    if (requestInitialData) {
      this.pageChange({
        skip: 0,
        take: virtual.pageSize
      });
    }
    if (isChanged("defaultItem", changes, false)) {
      this.disabledItemsService.defaultItem = this.defaultItem;
    }
    if (anyChanged(["textField", "valueField", "valuePrimitive", "defaultItem", "itemDisabled"], changes, false)) {
      this.setState();
    }
  }
  /**
   * @hidden
   */
  ngAfterContentChecked() {
    this.verifySettings();
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  /**
   * Focuses a specific item of the DropDownList based on a provided index.
   * If there is a default item it is positioned at index -1.
   * If null or invalid index is provided the focus will be removed.
   */
  focusItemAt(index) {
    const minIndex = isPresent7(this.defaultItem) ? -1 : 0;
    const isInRange = minIndex <= index && index < this.data.length;
    if (isPresent7(index) && isInRange && !this.disabledItemsService.isIndexDisabled(index)) {
      this.selectionService.focus(index);
    } else {
      this.selectionService.focus(null);
    }
  }
  /**
   * Focuses the DropDownList.
   */
  focus() {
    if (!this.disabled) {
      this.wrapper.nativeElement.focus();
    }
  }
  /**
   * Blurs the DropDownList.
   */
  blur() {
    if (!this.disabled) {
      this.wrapper.nativeElement.blur();
      this.cdr.detectChanges();
    }
  }
  /**
   * Toggles the visibility of the popup or actionSheet
   * ([see example]({% slug openstate_ddl %}#toc-setting-the-initially-opened-component)).
   * If you use the `toggle` method to open or close the popup, the `open` and `close` events will not be fired.
   *
   * @param open - The state of the popup.
   */
  toggle(open) {
    Promise.resolve(null).then(() => {
      const shouldOpen = isPresent7(open) ? open : !this._open;
      this._toggle(shouldOpen);
    });
  }
  _toggle(open) {
    this._open = open;
    this.destroyPopup();
    if (this.isActionSheetExpanded) {
      this.closeActionSheet();
    }
    if (this._open) {
      this.createPopup();
    }
  }
  triggerPopupEvents(open) {
    const eventArgs = new PreventableEvent5();
    if (open) {
      this.open.emit(eventArgs);
    } else {
      this.close.emit(eventArgs);
    }
    return eventArgs.isDefaultPrevented();
  }
  /**
   * @hidden
   */
  togglePopup(open) {
    const isDisabled2 = this.disabled || this.readonly;
    const sameState = this.isOpen === open;
    if (isDisabled2 || sameState) {
      return;
    }
    const isDefaultPrevented2 = this.triggerPopupEvents(open);
    if (!isDefaultPrevented2) {
      if (!open && this.filterable && this.isFocused) {
        this.focus();
      }
      this._toggle(open);
    }
  }
  /**
   * Returns the current open state. Returns `true` if the popup or actionSheet is open.
   */
  get isOpen() {
    return isTruthy2(this._open || this.isActionSheetExpanded);
  }
  /**
   * Resets the value of the DropDownList.
   * If you use the `reset` method to clear the value of the component,
   * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.
   */
  reset() {
    this.value = void 0;
  }
  /**
   * @hidden
   */
  messageFor(key) {
    return this.localization.get(key);
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value === null ? void 0 : value;
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onChangeCallback = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.cdr.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * @hidden
   */
  get selectButtonClasses() {
    return `${this.size ? getSizeClass2("button", this.size) : ""} ${this.fillMode ? "k-button-" + this.fillMode : ""} ${this.fillMode ? "k-button-" + this.fillMode + "-base" : ""}`;
  }
  /**
   * @hidden
   */
  get filterInputClasses() {
    return `${this.size ? getSizeClass2("input", this.size) : ""} ${this.fillMode ? "k-input-" + this.fillMode : ""} ${this.rounded ? getRoundedClass(this.rounded) : ""}`;
  }
  /**
   * @hidden
   */
  get optionLabelSizeClass() {
    return `${this.size ? getSizeClass2("list", this.size) : ""}`;
  }
  /**
   * @hidden
   */
  get listContainerClasses() {
    const containerClasses = ["k-list-container", "k-dropdownlist-popup"];
    if (this.popupSettings.popupClass) {
      containerClasses.push(this.popupSettings.popupClass);
    }
    return containerClasses;
  }
  /**
   * @hidden
   */
  get isDisabledDefaultItem() {
    return this.disabledItemsService.isItemDisabled(this.defaultItem);
  }
  /**
   * @hidden
   */
  getText() {
    return this.text;
  }
  /**
   * @hidden
   */
  getDefaultItemText() {
    return getter2(this.defaultItem, this.textField);
  }
  createPopup() {
    if (this.virtual) {
      this.virtual.skip = 0;
    }
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.openActionSheet();
      return;
    }
    const horizontalAlign = this.direction === "rtl" ? "right" : "left";
    const anchorPosition = {
      horizontal: horizontalAlign,
      vertical: "bottom"
    };
    const popupPosition = {
      horizontal: horizontalAlign,
      vertical: "top"
    };
    const appendToComponent = typeof this.popupSettings.appendTo === "string" && this.popupSettings.appendTo === "component";
    this.popupRef = this.popupService.open({
      anchor: this.wrapper,
      anchorAlign: anchorPosition,
      animate: this.popupSettings.animate,
      appendTo: this.appendTo,
      content: this.popupTemplate,
      popupAlign: popupPosition,
      popupClass: this.listContainerClasses,
      positionMode: appendToComponent ? "fixed" : "absolute"
    });
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-expanded", "true");
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-controls", this.listBoxId);
    const popupWrapper = this.popupRef.popupElement;
    const {
      min,
      max
    } = this.width;
    popupWrapper.addEventListener("mousedown", this.popupMouseDownHandler);
    popupWrapper.style.minWidth = min;
    popupWrapper.style.width = max;
    popupWrapper.style.height = this.height;
    popupWrapper.setAttribute("dir", this.direction);
    if (!this.appendTo) {
      this.renderer.setAttribute(popupWrapper, "role", "region");
      this.renderer.setAttribute(popupWrapper, "aria-label", this.messageFor("popupLabel"));
    }
    const listBox = popupWrapper.querySelector("ul.k-list-ul");
    const ariaLabel = this.wrapper.nativeElement.getAttribute("aria-labelledby");
    if (ariaLabel) {
      listBox.setAttribute("aria-labelledby", ariaLabel);
    }
    this.subs.add(this.popupRef.popupOpen.subscribe(() => {
      this.cdr.detectChanges();
      setListBoxAriaLabelledBy(this.optionsList, this.wrapper, this.renderer);
      this.setAriaactivedescendant();
      this.optionsList.scrollToItem(this.selectionService.focused);
      this.selectionService.focus(this.selectionService.focused);
      this.opened.emit();
    }));
    this.subs.add(this.popupRef.popupClose.subscribe(() => {
      this.closed.emit();
    }));
    if (!this.filterable) {
      this.subs.add(this.popupRef.popupAnchorViewportLeave.subscribe(() => this.togglePopup(false)));
    }
  }
  destroyPopup() {
    if (this.popupRef) {
      this.renderer.setAttribute(this.wrapper.nativeElement, "aria-expanded", "false");
      this.renderer.removeAttribute(this.wrapper.nativeElement, "aria-controls");
      this.renderer.removeAttribute(this.wrapper.nativeElement, "aria-activedescendant");
      this.popupRef.popupElement.removeEventListener("mousedown", this.popupMouseDownHandler);
      this.popupRef.close();
      this.popupRef = null;
    }
  }
  updateState({
    dataItem,
    confirm = false
  }) {
    this.dataItem = dataItem;
    this.text = getter2(dataItem, this.textField);
    if (confirm) {
      this._previousDataItem = dataItem;
    }
  }
  clearState() {
    this.text = void 0;
    this.dataItem = void 0;
  }
  resetSelection(index) {
    const clear2 = !isPresent7(index);
    this.selectionService.resetSelection(clear2 ? [] : [index]);
    this.selectionService.focused = clear2 ? this.firstFocusableIndex(0) : index;
  }
  onSelectionChange({
    dataItem
  }) {
    this.updateState({
      dataItem
    });
    this.selectionChange.emit(dataItem);
    this.assignAriaDescribedBy();
    this.setAriaactivedescendant();
  }
  subscribeEvents() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.subs.add(this.selectionService.onSelect.pipe(filter(() => this.isOpen), map(this.itemFromEvent.bind(this))).subscribe(this.onSelectionChange.bind(this)));
    this.subs.add(merge(this.selectionService.onSelect.pipe(filter(() => !this.isOpen)), this.selectionService.onChange).pipe(map(this.itemFromEvent.bind(this)), tap(() => this.togglePopup(false))).subscribe(({
      dataItem,
      value: newValue,
      newSelection
    }) => {
      if (newSelection) {
        this.onSelectionChange({
          dataItem
        });
      }
      const shouldUsePrevious = !isPresent7(dataItem) && this._previousDataItem;
      const shouldUseNewValue = newValue !== getter2(this.value, this.valueField);
      if (shouldUsePrevious) {
        this.updateState({
          dataItem: this._previousDataItem
        });
        this.resetSelection();
      } else if (shouldUseNewValue) {
        this.value = this.valuePrimitive ? newValue : dataItem;
        this._previousDataItem = dataItem;
        this.emitChange(this.value);
      }
      this.clearFilter();
    }));
    this.subs.add(merge(this.navigationService.up, this.navigationService.down, this.navigationService.left.pipe(filter(() => this.leftRightArrowsNavigation), skipWhile(() => this.filterable)), this.navigationService.right.pipe(filter(() => this.leftRightArrowsNavigation), skipWhile(() => this.filterable)), this.navigationService.home, this.navigationService.end).pipe(filter((event) => !isNaN(event.index))).subscribe((event) => this.selectionService.select(event.index)));
    this.subs.add(merge(this.navigationService.pagedown, this.navigationService.pageup).subscribe((event) => {
      if (this.isOpen) {
        event.originalEvent.preventDefault();
        this.optionsList.scrollWithOnePage(NavigationAction[event.originalEvent.code]);
      }
    }));
    this.subs.add(this.navigationService.open.subscribe(() => this.togglePopup(true)));
    this.subs.add(this.navigationService.close.subscribe(() => {
      this.togglePopup(false);
      this.focus();
    }));
    this.subs.add(this.navigationService.enter.pipe(tap((event) => event.originalEvent.preventDefault())).subscribe(this.handleEnter.bind(this)));
    this.subs.add(this.navigationService.esc.subscribe(this.handleEscape.bind(this)));
    this.subs.add(this.filterBlurred.pipe(concatMap(() => interval(10).pipe(take(1), takeUntil(this.hostElementFocused)))).subscribe(() => {
      this.hostElementBlurred.emit();
    }));
    this._zone.runOutsideAngular(() => {
      this.subs.add(merge(this.hostElementBlurred.pipe(concatMap(() => interval(10).pipe(take(1), takeUntil(this.filterFocused)))), this.navigationService.tab).pipe(tap((event) => event instanceof NavigationEvent && this.focus()), filter(() => this.isFocused)).subscribe(() => this.componentBlur()));
    });
  }
  setAriaactivedescendant() {
    if (this.ariaActivedescendant) {
      this.renderer.setAttribute(this.wrapper.nativeElement, "aria-activedescendant", this.ariaActivedescendant);
      const searchInput = this.popupRef?.popupElement.querySelector('input[role="searchbox"]') || this.actionSheetSearchBar?.input.nativeElement;
      if (searchInput) {
        this.renderer.setAttribute(searchInput, "aria-activedescendant", this.ariaActivedescendant);
      }
    }
  }
  subscribeTouchEvents() {
    if (!isDocumentAvailable() || !this.touchEnabled) {
      return;
    }
    this._zone.runOutsideAngular(() => (
      // Roll up DropDownList on iOS when tapped outside
      this.touchstartDisposeHandler = this.renderer.listen(document, "touchstart", (e) => {
        const target = e.target;
        if (this.isFocused && !inDropDown(this.wrapper, target, this.popupRef)) {
          this._zone.run(() => {
            if (this.filterFocused) {
              this.togglePopup(false);
            }
            this.blur();
          });
        }
      })
    ));
  }
  subscribeFocusEvents() {
    if (isDocumentAvailable()) {
      this.focusComponent = this.focusComponent.bind(this);
      this.blurComponent = this.blurComponent.bind(this);
      this._zone.runOutsideAngular(() => {
        const useCapture = true;
        document.addEventListener("focus", this.focusComponent, useCapture);
        document.addEventListener("blur", this.blurComponent, useCapture);
      });
    }
  }
  unSubscribeFocusEvents() {
    if (isDocumentAvailable()) {
      const useCapture = true;
      document.removeEventListener("focus", this.focusComponent, useCapture);
      document.removeEventListener("blur", this.blurComponent, useCapture);
    }
  }
  itemFromEvent(event) {
    const index = event.indices[0];
    let dataItem = this.dataService.itemAt(index);
    dataItem = isPresent7(dataItem) ? dataItem : this.currentOrDefault(index);
    const value = getter2(dataItem, this.valueField);
    const newSelection = event.newSelection;
    return {
      dataItem,
      index,
      newSelection,
      value
    };
  }
  currentOrDefault(selectedIndex) {
    const defaultItemIndex = -1;
    if (isPresent7(this.dataItem) && selectedIndex !== defaultItemIndex) {
      return this.dataItem;
    } else {
      return this.defaultItem;
    }
  }
  firstFocusableIndex(index) {
    const maxIndex = this.dataService.itemsCount - 1;
    if (this.disabledItemsService.isIndexDisabled(index)) {
      return index < maxIndex ? this.firstFocusableIndex(index + 1) : void 0;
    } else {
      return index;
    }
  }
  handleEnter() {
    if (this.isOpen) {
      this.selectionService.change(this.selectionService.focused);
      this.focus();
    } else {
      this.togglePopup(true);
    }
  }
  handleEscape() {
    if (isPresent7(this.selectionService.selected[0])) {
      this.selectionService.change(this.selectionService.selected[0]);
    } else {
      this.togglePopup(false);
      this.clearFilter();
    }
    this.focus();
  }
  clearFilter() {
    if (!(this.filterable && this.filterText)) {
      return;
    }
    this.filterText = "";
    this.cdr.markForCheck();
    this.filterChange.emit(this.filterText);
  }
  verifySettings() {
    if (!isDevMode()) {
      return;
    }
    if (this.defaultItem && this.valueField && typeof this.defaultItem !== "object") {
      throw new Error(DropDownListMessages.defaultItem);
    }
    if (this.valuePrimitive === true && isPresent7(this.value) && typeof this.value === "object") {
      throw new Error(DropDownListMessages.primitive);
    }
    if (this.valuePrimitive === false && isPresent7(this.value) && typeof this.value !== "object") {
      throw new Error(DropDownListMessages.object);
    }
    const valueOrText = !isPresent7(this.valueField) !== !isPresent7(this.textField);
    if (valueOrText) {
      throw new Error(DropDownListMessages.textAndValue);
    }
  }
  componentBlur() {
    if (!this.isActionSheetExpanded) {
      this.isFocused = false;
      const selectionPresent = isPresent7(this.selectionService.selected[0]);
      const valueHasChanged = selectionPresent && getter2(this.value, this.valueField) !== getter2(this.dataService.itemAt(this.selectionService.selected[0]), this.valueField);
      if (valueHasChanged || hasObservers(this.close) || hasObservers(this.onBlur) || hasObservers(this.filterChange) || isUntouched2(this.wrapper.nativeElement) || this.formControl?.updateOn === "blur") {
        this._zone.run(() => {
          if (valueHasChanged) {
            this.selectionService.change(this.selectionService.selected[0]);
          }
          this.togglePopup(false);
          this.clearFilter();
          this.onBlur.emit();
          this.onTouchedCallback();
        });
      } else {
        this.togglePopup(false);
        this.cdr.markForCheck();
      }
    }
  }
  /**
   * @hidden
   */
  onMouseDown(event) {
    const tagName = event.target.tagName.toLowerCase();
    if (tagName !== "input") {
      event.preventDefault();
    }
  }
  onKeyPress(event) {
    if (event.which === 0 || event.keyCode === Keys.Enter) {
      return;
    }
    let character = String.fromCharCode(event.charCode || event.keyCode);
    if (this.ignoreCase) {
      character = character.toLowerCase();
    }
    if (character === " ") {
      event.preventDefault();
    }
    this.word += character;
    this.last = character;
    this.search();
  }
  search() {
    clearTimeout(this.typingTimeout);
    if (!this.filterable) {
      this.typingTimeout = setTimeout(() => {
        this.word = "";
      }, this.delay);
      this.selectNext();
    }
  }
  selectNext() {
    let data = this.dataService.filter((item) => isPresent7(item) && !item.header && !this.disabledItemsService.isItemDisabled(item)).map((item) => {
      if (this.dataService.grouped) {
        return {
          item: item.value,
          itemIndex: item.offsetIndex
        };
      }
      return {
        item,
        itemIndex: this.dataService.indexOf(item)
      };
    });
    const isInLoop = sameCharsOnly(this.word, this.last);
    let dataLength = data.length;
    const hasSelected = !isNaN(this.selectionService.selected[0]);
    let startIndex = !hasSelected ? 0 : this.selectionService.selected[0];
    let text, index, defaultItem;
    if (this.defaultItem && !this.disabledItemsService.isItemDisabled(this.defaultItem)) {
      defaultItem = {
        item: this.defaultItem,
        itemIndex: -1
      };
      dataLength += 1;
      startIndex += 1;
    }
    startIndex += isInLoop && hasSelected ? 1 : 0;
    data = shuffleData(data, startIndex, defaultItem);
    index = 0;
    for (; index < dataLength; index++) {
      text = getter2(data[index].item, this.textField);
      const loopMatch = Boolean(isInLoop && matchText(text, this.last, this.ignoreCase));
      const nextMatch = Boolean(matchText(text, this.word, this.ignoreCase));
      if (loopMatch || nextMatch) {
        index = data[index].itemIndex;
        break;
      }
    }
    if (index !== dataLength) {
      this.navigate(index);
    }
  }
  emitChange(value) {
    this.onChangeCallback(value);
    this.valueChange.emit(value);
  }
  navigate(index) {
    this.selectionService.select(index);
  }
  findDataItem({
    valueField,
    value
  }) {
    const result = {
      dataItem: null,
      index: -1
    };
    const prop = (dataItem) => getter2(dataItem, valueField);
    let comparer;
    if (this.dataService.grouped) {
      comparer = (element) => {
        return prop(element.value) === prop(value);
      };
    } else {
      comparer = (element) => {
        return prop(element) === prop(value);
      };
    }
    const index = this.dataService.findIndex(comparer);
    result.dataItem = this.dataService.itemAt(index);
    result.index = index;
    return result;
  }
  setState() {
    const value = this.value;
    const valueField = this.valueField;
    const textField = this.textField;
    const primitive = this.valuePrimitive;
    if (this.defaultItem) {
      const defaultValue = getter2(this.defaultItem, valueField);
      const currentValue = getter2(value, valueField);
      if (!isPresent7(value) || currentValue === defaultValue) {
        this.updateState({
          dataItem: this.defaultItem,
          confirm: true
        });
        this.resetSelection(-1);
        if (this.filterable && this.filterText && this.dataService.itemsCount) {
          this.selectionService.focused = this.firstFocusableIndex(0);
        }
        return;
      }
    }
    const resolved = this.findDataItem({
      valueField,
      value
    });
    const ofSameType = !(primitive && textField);
    if (resolved.dataItem) {
      this.updateState({
        dataItem: resolved.dataItem,
        confirm: true
      });
      this.resetSelection(resolved.index);
    } else if (isPresent7(value) && ofSameType) {
      this.updateState({
        dataItem: value
      });
      this.resetSelection();
    } else if (this._previousDataItem) {
      this.updateState({
        dataItem: this._previousDataItem
      });
      this.resetSelection();
    } else {
      this.clearState();
      this.resetSelection();
    }
  }
  /**
   * @hidden
   */
  handleFilter(event) {
    this.filterChange.emit(event.target.value);
  }
  /**
   * @hidden
   */
  handleClick() {
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.togglePopup(true);
    }
  }
  /**
   * @hidden
   */
  pageChange(event) {
    const virtual = this.virtual;
    virtual.skip = event.skip;
  }
  assignAriaDescribedBy() {
    const currentValue = this.wrapper.nativeElement.getAttribute("aria-describedby") || "";
    const trimmed = currentValue.replace(this.valueLabelId, "").trim();
    this.valueLabelId = `k-${guid2()}`;
    const newValue = `${this.valueLabelId} ${trimmed}`.trim();
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-describedby", newValue);
  }
  setComponentClasses() {
    if (this.size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("picker", this.size));
    }
    if (this.rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("picker", this.fillMode));
    }
  }
  closeActionSheet() {
    this.actionSheet.toggle(false);
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-expanded", "false");
    this.renderer.removeAttribute(this.wrapper.nativeElement, "aria-controls");
    if (this.filterable) {
      this.responsiveRendererComponent.searchBarValue = "";
      this.filterChange.emit("");
    }
    this.closed.emit();
  }
  openActionSheet() {
    this.windowSize = this.adaptiveService.size;
    this.actionSheet.toggle(true);
    this.cdr.detectChanges();
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-expanded", "true");
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-controls", this.listBoxId);
    setListBoxAriaLabelledBy(this.optionsList, this.wrapper, this.renderer);
    this.setAriaactivedescendant();
    this.title = setActionSheetTitle(this.wrapper, this.title);
    updateActionSheetAdaptiveAppearance2(this.actionSheet, this.windowSize, this.renderer);
    this.cdr.detectChanges();
    this.opened.emit();
    this.optionsList.scrollToItem(this.selectionService.focused);
    this.selectionService.focus(this.selectionService.focused);
    if (this.filterable) {
      this.actionSheetSearchBar.focus();
    }
  }
  static ɵfac = function DropDownListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropDownListComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(NavigationService3), ɵɵdirectiveInject(DisabledItemsService), ɵɵdirectiveInject(DataService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DropDownListComponent,
    selectors: [["kendo-dropdownlist"]],
    contentQueries: function DropDownListComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, GroupTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FixedGroupTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, ValueTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fixedGroupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.valueTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);
      }
    },
    viewQuery: function DropDownListComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(ResponsiveRendererComponent, 5);
        ɵɵviewQuery(_c94, 7, ViewContainerRef);
        ɵɵviewQuery(_c104, 7);
        ɵɵviewQuery(_c113, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.responsiveRendererComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.optionsList = _t.first);
      }
    },
    hostVars: 19,
    hostBindings: function DropDownListComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown", function DropDownListComponent_keydown_HostBindingHandler($event) {
          return ctx.keydown($event);
        })("keypress", function DropDownListComponent_keypress_HostBindingHandler($event) {
          return ctx.keypress($event);
        })("click", function DropDownListComponent_click_HostBindingHandler() {
          return ctx.click();
        });
      }
      if (rf & 2) {
        ɵɵattribute("aria-disabled", ctx.isDisabledClass)("id", ctx.focusableId)("dir", ctx.dir)("tabindex", ctx.hostTabIndex)("readonly", ctx.readonlyAttr)("aria-busy", ctx.isBusy)("role", ctx.role)("aria-haspopup", ctx.haspopup)("aria-invalid", ctx.hostAriaInvalid);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-dropdownlist", ctx.hostClasses)("k-picker", ctx.hostClasses)("k-disabled", ctx.isDisabledClass)("k-loading", ctx.isLoading);
      }
    },
    inputs: {
      customIconClass: "customIconClass",
      showStickyHeader: "showStickyHeader",
      icon: "icon",
      svgIcon: "svgIcon",
      loading: "loading",
      data: "data",
      value: "value",
      textField: "textField",
      valueField: "valueField",
      adaptiveMode: "adaptiveMode",
      title: "title",
      subtitle: "subtitle",
      popupSettings: "popupSettings",
      listHeight: "listHeight",
      defaultItem: "defaultItem",
      disabled: "disabled",
      itemDisabled: "itemDisabled",
      readonly: "readonly",
      filterable: "filterable",
      virtual: "virtual",
      ignoreCase: "ignoreCase",
      delay: "delay",
      valuePrimitive: "valuePrimitive",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      leftRightArrowsNavigation: "leftRightArrowsNavigation",
      focusableId: [0, "id", "focusableId"]
    },
    outputs: {
      valueChange: "valueChange",
      filterChange: "filterChange",
      selectionChange: "selectionChange",
      open: "open",
      opened: "opened",
      close: "close",
      closed: "closed",
      onFocus: "focus",
      onBlur: "blur"
    },
    exportAs: ["kendoDropDownList"],
    features: [ɵɵProvidersFeature([DROPDOWNLIST_VALUE_ACCESSOR, DataService, SelectionService2, NavigationService3, DisabledItemsService, LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.dropdownlist"
    }, {
      provide: FilterableComponent,
      useExisting: forwardRef(() => _DropDownListComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _DropDownListComponent)
    }]), ɵɵNgOnChangesFeature],
    decls: 16,
    vars: 19,
    consts: () => {
      let i18n_7;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_7 = goog.getMsg("NO DATA FOUND");
        i18n_7 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_7;
      } else {
        i18n_7 = $localize`:kendo.dropdownlist.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;
      }
      let i18n_8;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_8 = goog.getMsg("Select");
        i18n_8 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_8;
      } else {
        i18n_8 = $localize`:kendo.dropdownlist.selectButtonText|The text set as aria-label on the select button:Select`;
      }
      let i18n_9;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_9 = goog.getMsg("Filter");
        i18n_9 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_9;
      } else {
        i18n_9 = $localize`:kendo.dropdownlist.filterInputLabel|The text set as aria-label on the filter input:Filter`;
      }
      let i18n_10;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_10 = goog.getMsg("Options list");
        i18n_10 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_10;
      } else {
        i18n_10 = $localize`:kendo.dropdownlist.popupLabel|The label of the popup element that contains the list of options when its role is 'region':Options list`;
      }
      return [["popupTemplate", ""], ["container", ""], ["sharedPopupActionSheetTemplate", ""], ["optionsList", ""], ["searchInput", ""], ["kendoDropDownListLocalizedMessages", "", "noDataText", i18n_7, "selectButtonText", i18n_8, "filterInputLabel", i18n_9, "popupLabel", i18n_10], ["unselectable", "on", 1, "k-input-inner", 3, "click", "id"], [1, "k-input-value-text"], [4, "ngIf"], [3, "ngIf"], ["class", "k-i-loading k-input-loading-icon k-icon", 4, "ngIf"], ["tabindex", "-1", "unselectable", "on", "type", "button", 1, "k-input-button", "k-button", "k-icon-button", 3, "ngClass", "kendoEventsOutsideAngular"], ["unselectable", "on", "innerCssClass", "k-button-icon", 3, "name", "customFontClass", "svgIcon"], [3, "resize", 4, "ngIf"], [3, "closePopup", "textInputChange", "sharedPopupActionSheetTemplate", "isActionSheetExpanded", "title", "showTextInput", "subtitle"], [3, "templateContext"], [1, "k-i-loading", "k-input-loading-icon", "k-icon"], [4, "ngTemplateOutlet"], [3, "resize"], [3, "pageChange", "id", "size", "rounded", "optionPrefix", "data", "textField", "valueField", "template", "groupTemplate", "fixedGroupTemplate", "height", "show", "virtual", "ariaLive", "showStickyHeader"], ["class", "k-no-data", 4, "ngIf"], [1, "k-list-filter", 3, "click"], [1, "k-searchbox", "k-input", 3, "ngClass"], ["innerCssClass", "k-input-icon", "name", "search", 1, "k-icon", 3, "svgIcon"], ["role", "searchbox", "aria-autocomplete", "list", "aria-haspopup", "listbox", "tabindex", "-1", 1, "k-input-inner", 3, "ngModelChange", "keydown", "input", "focus", "blur", "click", "filterInput", "dir", "ngModel"], [1, "k-list", 3, "ngClass"], ["kendoDropDownsSelectable", "", 1, "k-list-optionlabel", 3, "ngClass", "index"], [1, "k-no-data"], [3, "ngIf", "templateContext"]];
    },
    template: function DropDownListComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 5);
        ɵɵelementStart(1, "span", 6);
        ɵɵlistener("click", function DropDownListComponent_Template_span_click_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView($event.preventDefault());
        });
        ɵɵelementStart(2, "span", 7);
        ɵɵtemplate(3, DropDownListComponent_3_Template, 1, 4, null, 8)(4, DropDownListComponent_ng_template_4_Template, 1, 1, "ng-template", 9);
        ɵɵelementEnd()();
        ɵɵtemplate(5, DropDownListComponent_span_5_Template, 1, 0, "span", 10);
        ɵɵelementStart(6, "button", 11);
        ɵɵelement(7, "kendo-icon-wrapper", 12);
        ɵɵelementEnd();
        ɵɵtemplate(8, DropDownListComponent_ng_template_8_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor)(10, DropDownListComponent_kendo_resize_sensor_10_Template, 1, 0, "kendo-resize-sensor", 13);
        ɵɵelementContainer(11, null, 1);
        ɵɵelementStart(13, "responsive-renderer", 14);
        ɵɵlistener("closePopup", function DropDownListComponent_Template_responsive_renderer_closePopup_13_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.togglePopup(false));
        })("textInputChange", function DropDownListComponent_Template_responsive_renderer_textInputChange_13_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onFilterChange($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(14, DropDownListComponent_ng_template_14_Template, 8, 21, "ng-template", null, 2, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const sharedPopupActionSheetTemplate_r3 = ɵɵreference(15);
        ɵɵadvance();
        ɵɵproperty("id", ctx.valueLabelId);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.valueTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.valueTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.loading);
        ɵɵadvance();
        ɵɵproperty("ngClass", ctx.selectButtonClasses)("kendoEventsOutsideAngular", ɵɵpureFunction1(17, _c143, ctx.onMouseDown));
        ɵɵattribute("aria-label", ctx.messageFor("selectButtonText"))("disabled", ctx.disabled ? "" : null);
        ɵɵadvance();
        ɵɵproperty("name", ctx.icon || "caret-alt-down")("customFontClass", ctx.customIconClass)("svgIcon", ctx.svgIcon || ctx.caretAltDownSVGIcon);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.isOpen || ctx.isAdaptiveModeEnabled);
        ɵɵadvance(3);
        ɵɵproperty("sharedPopupActionSheetTemplate", sharedPopupActionSheetTemplate_r3)("isActionSheetExpanded", ctx.isActionSheetExpanded)("title", ctx.title)("showTextInput", ctx.filterable)("subtitle", ctx.subtitle);
      }
    },
    dependencies: [LocalizedMessagesDirective3, NgIf, TemplateContextDirective, NgClass, EventsOutsideAngularDirective, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent, ResponsiveRendererComponent, ReactiveFormsModule, DefaultValueAccessor, NgControlStatus, FilterInputDirective, FormsModule, NgModel, SelectableDirective, ListComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropDownListComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoDropDownList",
      providers: [DROPDOWNLIST_VALUE_ACCESSOR, DataService, SelectionService2, NavigationService3, DisabledItemsService, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.dropdownlist"
      }, {
        provide: FilterableComponent,
        useExisting: forwardRef(() => DropDownListComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => DropDownListComponent)
      }],
      selector: "kendo-dropdownlist",
      template: `
        <ng-container kendoDropDownListLocalizedMessages
            i18n-noDataText="kendo.dropdownlist.noDataText|The text displayed in the popup when there are no items"
            noDataText="NO DATA FOUND"

            i18n-selectButtonText="kendo.dropdownlist.selectButtonText|The text set as aria-label on the select button"
            selectButtonText="Select"

            i18n-filterInputLabel="kendo.dropdownlist.filterInputLabel|The text set as aria-label on the filter input"
            filterInputLabel="Filter"

            i18n-popupLabel="kendo.dropdownlist.popupLabel|The label of the popup element that contains the list of options when its role is 'region'"
            popupLabel="Options list"
        >
        </ng-container>
        <span class="k-input-inner" unselectable="on" [id]="valueLabelId" (click)="$event.preventDefault()">
            <span class="k-input-value-text">
                <ng-template *ngIf="valueTemplate"
                    [templateContext]="{
                        templateRef: valueTemplate.templateRef,
                        $implicit: dataItem
                    }">
                </ng-template>
                <ng-template [ngIf]="!valueTemplate">{{ getText() }}</ng-template>
            </span>
        </span>
        <span *ngIf="loading" class="k-i-loading k-input-loading-icon k-icon"></span>
        <button
            tabindex="-1"
            unselectable="on"
            type="button"
            class="k-input-button k-button k-icon-button"
            [ngClass]="selectButtonClasses"
            [attr.aria-label]="messageFor('selectButtonText')"
            [attr.disabled]="disabled ? '' : null"
            [kendoEventsOutsideAngular]="{
                mousedown: onMouseDown
            }"
        >
            <kendo-icon-wrapper
                unselectable="on"
                [name]="icon || 'caret-alt-down'"
                innerCssClass="k-button-icon"
                [customFontClass]="customIconClass"
                [svgIcon]="svgIcon || caretAltDownSVGIcon"
            >
            </kendo-icon-wrapper>
        </button>
        <ng-template #popupTemplate>
            <ng-container *ngTemplateOutlet="sharedPopupActionSheetTemplate"></ng-container>
        </ng-template>
        <kendo-resize-sensor *ngIf="isOpen || isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>
        <ng-container #container></ng-container>

        <!--adaptive rendering-->
        <responsive-renderer
            [sharedPopupActionSheetTemplate]="sharedPopupActionSheetTemplate"
            [isActionSheetExpanded]="isActionSheetExpanded"
            [title]="title"
            [showTextInput]="filterable"
            [subtitle]="subtitle"
            (closePopup)="togglePopup(false)"
            (textInputChange)="onFilterChange($event)"
            >
        </responsive-renderer>

        <ng-template #sharedPopupActionSheetTemplate>
            <!--filterable-->
            <ng-template [ngIf]="filterable && !isActionSheetExpanded">
                <div class="k-list-filter" (click)="$event.stopImmediatePropagation()">
                    <span
                        class="k-searchbox k-input"
                        [ngClass]="filterInputClasses">
                        <kendo-icon-wrapper
                            class="k-icon"
                            innerCssClass="k-input-icon"
                            name="search"
                            [svgIcon]="searchIcon">
                        </kendo-icon-wrapper>
                        <input
                            #searchInput
                            role="searchbox"
                            aria-autocomplete="list"
                            aria-haspopup="listbox"
                            [attr.aria-controls]="listBoxId"
                            tabindex="-1"
                            [filterInput]="isFocused && !touchEnabled"
                            [attr.aria-label]="messageFor('filterInputLabel')"
                            [dir]="direction"
                            [(ngModel)]="filterText"
                            class="k-input-inner"
                            (keydown)="keydown($event, searchInput)"
                            (input)="handleFilter($event)"
                            (focus)="onFilterFocus()"
                            (blur)="blurFilterInput()"
                            (click)="handleClick()" />
                    </span>
                </div>
            </ng-template>
            <!--default item-->
            <ng-template [ngIf]="defaultItem && !itemTemplate">
                <div
                    class="k-list"
                    [ngClass]="optionLabelSizeClass"
                >
                    <div class="k-list-optionlabel" [ngClass]="{ 'k-disabled': isDisabledDefaultItem }" kendoDropDownsSelectable [index]="-1">
                        {{ getDefaultItemText() }}
                    </div>
                </div>
            </ng-template>
            <ng-template [ngIf]="defaultItem && itemTemplate">
                <div
                    class="k-list"
                    [ngClass]="optionLabelSizeClass"
                >
                    <div class="k-list-optionlabel" [ngClass]="{ 'k-disabled': isDisabledDefaultItem }" kendoDropDownsSelectable [index]="-1">
                        <ng-template
                            [templateContext]="{
                                templateRef: itemTemplate.templateRef,
                                $implicit: defaultItem
                            }">
                        </ng-template>
                    </div>
                </div>
            </ng-template>
            <!--header template-->
            <ng-template *ngIf="headerTemplate"
                [templateContext]="{
                    templateRef: headerTemplate.templateRef
                }">
            </ng-template>
            <!--list-->           
            <kendo-list
                #optionsList
                [id]="listBoxId"
                [size]="size"
                [rounded]="rounded"
                [optionPrefix]="optionPrefix"
                [data]="data"
                [textField]="textField"
                [valueField]="valueField"
                [template]="itemTemplate"
                [groupTemplate]="groupTemplate"
                [fixedGroupTemplate]="fixedGroupTemplate"
                [height]="listHeight"
                [show]="isOpen"
                [virtual]="virtual"
                [ariaLive]="ariaLive"
                [showStickyHeader]="showStickyHeader"
                (pageChange)="pageChange($event)">
            </kendo-list>
            <!--no-data template-->
            <div class="k-no-data" *ngIf="data.length === 0">
                <ng-template [ngIf]="noDataTemplate"
                    [templateContext]="{
                        templateRef: noDataTemplate ? noDataTemplate.templateRef : undefined
                    }">
                </ng-template>
                <ng-template [ngIf]="!noDataTemplate">
                    <div>{{ messageFor('noDataText') }}</div>
                </ng-template>
            </div>
            <!--footer template-->
            <ng-template *ngIf="footerTemplate"
                [templateContext]="{
                    templateRef: footerTemplate.templateRef
                }">
            </ng-template>
        </ng-template>
  `,
      standalone: true,
      imports: [LocalizedMessagesDirective3, NgIf, TemplateContextDirective, NgClass, EventsOutsideAngularDirective, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent, ResponsiveRendererComponent, ReactiveFormsModule, FilterInputDirective, FormsModule, SelectableDirective, ListComponent]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: LocalizationService
    }, {
      type: PopupService
    }, {
      type: SelectionService2
    }, {
      type: NavigationService3
    }, {
      type: DisabledItemsService
    }, {
      type: DataService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }, {
      type: Injector
    }, {
      type: AdaptiveService
    }];
  }, {
    customIconClass: [{
      type: Input
    }],
    responsiveRendererComponent: [{
      type: ViewChild,
      args: [ResponsiveRendererComponent]
    }],
    showStickyHeader: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    textField: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    subtitle: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    listHeight: [{
      type: Input
    }],
    defaultItem: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    itemDisabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    filterable: [{
      type: Input
    }],
    virtual: [{
      type: Input
    }],
    ignoreCase: [{
      type: Input
    }],
    delay: [{
      type: Input
    }],
    valuePrimitive: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input,
      args: ["tabIndex"]
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    leftRightArrowsNavigation: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    filterChange: [{
      type: Output
    }],
    selectionChange: [{
      type: Output
    }],
    open: [{
      type: Output
    }],
    opened: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    closed: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    itemTemplate: [{
      type: ContentChild,
      args: [ItemTemplateDirective, {
        static: false
      }]
    }],
    groupTemplate: [{
      type: ContentChild,
      args: [GroupTemplateDirective, {
        static: false
      }]
    }],
    fixedGroupTemplate: [{
      type: ContentChild,
      args: [FixedGroupTemplateDirective, {
        static: false
      }]
    }],
    valueTemplate: [{
      type: ContentChild,
      args: [ValueTemplateDirective, {
        static: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective, {
        static: false
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective, {
        static: false
      }]
    }],
    noDataTemplate: [{
      type: ContentChild,
      args: [NoDataTemplateDirective, {
        static: false
      }]
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        static: true
      }]
    }],
    optionsList: [{
      type: ViewChild,
      args: ["optionsList", {
        static: false
      }]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-dropdownlist"]
    }, {
      type: HostBinding,
      args: ["class.k-picker"]
    }],
    isDisabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }, {
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    isLoading: [{
      type: HostBinding,
      args: ["class.k-loading"]
    }],
    focusableId: [{
      type: Input,
      args: ["id"]
    }, {
      type: HostBinding,
      args: ["attr.id"]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    hostTabIndex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    readonlyClass: [{
      type: HostBinding,
      args: ["attr.readonly"]
    }],
    readonlyAttr: [{
      type: HostBinding,
      args: ["attr.readonly"]
    }],
    isBusy: [{
      type: HostBinding,
      args: ["attr.aria-busy"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    haspopup: [{
      type: HostBinding,
      args: ["attr.aria-haspopup"]
    }],
    hostAriaInvalid: [{
      type: HostBinding,
      args: ["attr.aria-invalid"]
    }],
    keydown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }],
    keypress: [{
      type: HostListener,
      args: ["keypress", ["$event"]]
    }],
    click: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var CustomItemTemplateDirective = class _CustomItemTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function CustomItemTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CustomItemTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CustomItemTemplateDirective,
    selectors: [["", "kendoMultiSelectCustomItemTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CustomItemTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMultiSelectCustomItemTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var TagTemplateDirective = class _TagTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function TagTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TagTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TagTemplateDirective,
    selectors: [["", "kendoMultiSelectTagTemplate", ""], ["", "kendoMultiSelectTreeTagTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TagTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMultiSelectTagTemplate],[kendoMultiSelectTreeTagTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var GroupTagTemplateDirective = class _GroupTagTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function GroupTagTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GroupTagTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GroupTagTemplateDirective,
    selectors: [["", "kendoMultiSelectGroupTagTemplate", ""], ["", "kendoMultiSelectTreeGroupTagTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupTagTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMultiSelectGroupTagTemplate],[kendoMultiSelectTreeGroupTagTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var RemoveTagEvent = class extends PreventableEvent5 {
  /**
   * The data item or an array of data items that will be removed.
   */
  dataItem;
  /**
   * Constructs the event arguments for the `remove` event.
   * @param dataItem - The data item or an array of data items that will be removed.
   */
  constructor(dataItem) {
    super();
    this.dataItem = dataItem;
  }
};
var normalizeCheckboxesSettings = (settings) => {
  if (isObject2(settings)) {
    const defaultSettings = {
      enabled: true,
      checkOnClick: true
    };
    return Object.assign({}, defaultSettings, settings);
  }
  return {
    enabled: Boolean(settings),
    checkOnClick: true
  };
};
var TagListComponent = class _TagListComponent {
  renderer;
  hostElement;
  /**
   * @hidden
   */
  xCircleIcon = xCircleIcon;
  tags;
  textField;
  valueField;
  valueDepth;
  focused;
  template;
  groupTemplate;
  disabled;
  tagPrefix;
  id;
  set size(size) {
    this.renderer.removeClass(this.hostElement.nativeElement, getSizeClass2("chip-list", this.size));
    if (size) {
      this.renderer.addClass(this.hostElement.nativeElement, getSizeClass2("chip-list", size));
    }
    this._size = size;
  }
  get size() {
    return this._size;
  }
  rounded = "medium";
  fillMode = "solid";
  /**
   * A collection with the disabled tags' indices.
   */
  disabledIndices = /* @__PURE__ */ new Set();
  removeTag = new EventEmitter();
  hostClass = true;
  get hostId() {
    return this.id;
  }
  taglistRole = "listbox";
  multiselectable = true;
  _size = "medium";
  constructor(renderer, hostElement) {
    this.renderer = renderer;
    this.hostElement = hostElement;
  }
  tagProp(tag, prop, index) {
    const propField = prop && this.getPropField(tag, prop, index);
    return getter2(tag, propField);
  }
  isTagDisabled(tag, positionIndex) {
    if (this.isGroupTag(tag)) {
      return tag.every((_tag, index) => this.disabledIndices.has(index + positionIndex));
    }
    return this.disabledIndices.has(positionIndex);
  }
  deleteTag(event, tag, index) {
    event.preventDefault();
    event.stopImmediatePropagation();
    if (!this.disabled && event.which === 1) {
      this.removeTag.emit({
        tag,
        index
      });
    }
  }
  itemId(tag, index) {
    if (tag) {
      return this.tagPrefix + "-" + index;
    }
  }
  isGroupTag(tag) {
    return tag instanceof Array;
  }
  tagAriaHidden(index) {
    return isPresent7(this.focused) && this.focused !== index;
  }
  getPropField(tag, prop, index) {
    const fieldsCount = prop.length - 1;
    if (typeof prop === "string") {
      return prop;
    } else if (this.valueDepth) {
      const depth = this.valueDepth[index];
      return fieldsCount < depth ? prop[fieldsCount] : prop[depth];
    } else {
      return prop.find((item) => item in tag);
    }
  }
  static ɵfac = function TagListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TagListComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TagListComponent,
    selectors: [["kendo-taglist"]],
    hostVars: 5,
    hostBindings: function TagListComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("id", ctx.hostId)("role", ctx.taglistRole)("aria-multiselectable", ctx.multiselectable);
        ɵɵclassProp("k-chip-list", ctx.hostClass);
      }
    },
    inputs: {
      tags: "tags",
      textField: "textField",
      valueField: "valueField",
      valueDepth: "valueDepth",
      focused: "focused",
      template: "template",
      groupTemplate: "groupTemplate",
      disabled: "disabled",
      tagPrefix: "tagPrefix",
      id: "id",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      disabledIndices: "disabledIndices"
    },
    outputs: {
      removeTag: "removeTag"
    },
    ngContentSelectors: _c163,
    decls: 2,
    vars: 1,
    consts: [["groupTag", ""], ["singleTag", ""], ["class", "k-chip", 3, "ngClass", 4, "ngFor", "ngForOf"], [1, "k-chip", 3, "ngClass"], [1, "k-chip-content"], [4, "ngIf", "ngIfThen", "ngIfElse"], [1, "k-chip-actions"], ["aria-label", "delete", 1, "k-chip-action", "k-chip-remove-action"], ["name", "x-circle", 3, "mousedown", "svgIcon"], [1, "k-chip-label", "k-text-ellipsis"], [4, "ngIf"], [3, "ngIf"], [3, "templateContext"]],
    template: function TagListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, TagListComponent_div_0_Template, 10, 22, "div", 2);
        ɵɵprojection(1);
      }
      if (rf & 2) {
        ɵɵproperty("ngForOf", ctx.tags);
      }
    },
    dependencies: [NgForOf, NgClass, NgIf, TemplateContextDirective, IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TagListComponent, [{
    type: Component,
    args: [{
      selector: "kendo-taglist",
      template: `
        <div
            *ngFor="let tag of tags; let index = index;"
            [attr.id]="itemId(tag, index)"
            [attr.aria-selected]="true"
            [attr.role]="'option'"
            class="k-chip"
            [ngClass]="{
                'k-focus': index === focused,
                'k-disabled': isTagDisabled(tag, index),
                'k-chip-sm': size === 'small',
                'k-chip-md': size === 'medium',
                'k-chip-lg': size === 'large',
                'k-rounded-sm': rounded === 'small',
                'k-rounded-md': rounded === 'medium',
                'k-rounded-lg': rounded === 'large',
                'k-rounded-full': rounded === 'full',
                'k-chip-solid k-chip-solid-base': fillMode === 'solid',
                'k-chip-flat k-chip-flat-base': fillMode === 'flat',
                'k-chip-outline k-chip-outline-base': fillMode === 'outline'
            }"
        >
            <span class="k-chip-content">
                <ng-template *ngIf="isGroupTag(tag); then groupTag else singleTag"></ng-template>
                <ng-template #groupTag>
                    <span class="k-chip-label k-text-ellipsis">
                        <ng-template *ngIf="groupTemplate"
                            [templateContext]="{
                            templateRef: groupTemplate.templateRef,
                            $implicit: tag
                        }">
                        </ng-template>
                        <ng-template [ngIf]="!groupTemplate">{{ tag.length }} {{ tag.length === 1 ? 'item' : 'items' }} selected</ng-template>
                    </span>
                </ng-template>
                <ng-template #singleTag>
                    <span class="k-chip-label k-text-ellipsis">
                        <ng-template *ngIf="template"
                            [templateContext]="{
                            templateRef: template.templateRef,
                            $implicit: tag
                        }">
                        </ng-template>
                        <ng-template [ngIf]="!template">{{ tagProp(tag, textField, index) }}</ng-template>
                    </span>
                </ng-template>
            </span>
            <span class="k-chip-actions">
                <span aria-label="delete" [attr.aria-hidden]="index !== focused" class="k-chip-action k-chip-remove-action">
                    <kendo-icon-wrapper
                        (mousedown)="deleteTag($event, tag, index)"
                        name="x-circle"
                        [svgIcon]="xCircleIcon"
                    >
                    </kendo-icon-wrapper>
                </span>
            </span>
        </div>
        <ng-content></ng-content>
  `,
      standalone: true,
      imports: [NgForOf, NgClass, NgIf, TemplateContextDirective, IconWrapperComponent]
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, {
    tags: [{
      type: Input
    }],
    textField: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    valueDepth: [{
      type: Input
    }],
    focused: [{
      type: Input
    }],
    template: [{
      type: Input
    }],
    groupTemplate: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    tagPrefix: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    disabledIndices: [{
      type: Input
    }],
    removeTag: [{
      type: Output
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-chip-list"]
    }],
    hostId: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    taglistRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    multiselectable: [{
      type: HostBinding,
      args: ["attr.aria-multiselectable"]
    }]
  });
})();
var MULTISELECT_VALUE_ACCESSOR = {
  multi: true,
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => MultiSelectComponent)
};
var DEFAULT_SIZE$22 = "medium";
var DEFAULT_ROUNDED$22 = "medium";
var DEFAULT_FILL_MODE$22 = "solid";
var MultiSelectComponent = class _MultiSelectComponent {
  wrapper;
  localization;
  popupService;
  dataService;
  selectionService;
  navigationService;
  disabledItemsService;
  cdr;
  differs;
  renderer;
  _zone;
  injector;
  hostElement;
  adaptiveService;
  /**
   * @hidden
   */
  animationDuration = animationDuration2;
  /**
   * @hidden
   */
  xIcon = xIcon;
  /**
   * @hidden
   */
  plusIcon = plusIcon;
  listBoxId = `k-${guid2()}`;
  tagListId = `k-${guid2()}`;
  tagPrefix = "tag-" + guid2();
  optionPrefix = "option-" + guid2();
  popupRef;
  text;
  tags;
  focusedTagIndex = void 0;
  /**
   * @hidden
   */
  responsiveRendererComponent;
  /**
   * @hidden
   */
  get actionSheet() {
    return this.responsiveRendererComponent?.actionSheet;
  }
  /**
   * @hidden
   */
  get actionSheetSearchBar() {
    return this.responsiveRendererComponent?.actionSheetSearchBar;
  }
  /**
   * @hidden
   */
  get ariaControls() {
    return this.isOpen ? this.listBoxId : void 0;
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.formControl);
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  /**
   * Focuses a specific item of the MultiSelect based on a provided index.
   * If there is a custom item it is positioned at index -1.
   * If null or invalid index is provided the focus will be removed.
   */
  focusItemAt(index) {
    const minIndex = this.allowCustom ? -1 : 0;
    const isInRange = minIndex <= 0 && index < this.data.length;
    if (isPresent7(index) && isInRange && !this.disabledItemsService.isIndexDisabled(index)) {
      this.selectionService.focus(index);
    } else {
      this.selectionService.focus(null);
    }
  }
  /**
   * Focuses the MultiSelect.
   */
  focus() {
    if (!this.disabled) {
      this.searchbar.focus();
    }
  }
  /**
   * @hidden
   */
  handleInputFocus() {
    this.handleFocus();
    if (hasObservers(this.inputFocus)) {
      this._zone.run(() => {
        this.inputFocus.emit();
      });
    }
  }
  /**
   * @hidden
   */
  onAdaptiveTextBoxChange(text) {
    if (this.filterable) {
      this.filterChange.emit(text);
      return;
    }
    this.searchTextAndFocus(text);
  }
  /**
   * Blurs the MultiSelect.
   */
  blur() {
    if (!this.disabled) {
      this.searchbar.blur();
    }
  }
  /**
   * @hidden
   */
  handleFocus() {
    this._zone.run(() => {
      if (!this.isFocused && hasObservers(this.onFocus)) {
        this.onFocus.emit();
      }
      this.isFocused = true;
    });
  }
  /**
   * @hidden
   */
  handleBlur() {
    if (!this.isActionSheetExpanded) {
      if (!this.isFocused) {
        return;
      }
      this.isFocused = false;
      if (hasObservers(this.onBlur) || hasObservers(this.filterChange) || hasObservers(this.close) || isUntouched2(this.wrapper.nativeElement)) {
        this._zone.run(() => {
          this.closePopup();
          if (!(this.isOpen && this.allowCustom)) {
            this.clearFilter();
          }
          this.onBlur.emit();
          this.onTouchedCallback();
        });
      } else {
        if (!this.allowCustom) {
          this.clearFilter();
        }
        this.closePopup();
      }
    }
  }
  /**
   * @hidden
   */
  handleInputBlur() {
    if (!this.isActionSheetExpanded) {
      if (!this.isFocused) {
        return;
      }
      if (hasObservers(this.inputBlur) || hasObservers(this.filterChange) || hasObservers(this.close) || isUntouched2(this.wrapper.nativeElement) || this.formControl?.updateOn === "blur") {
        this._zone.run(() => {
          this.closePopup();
          if (!(this.isOpen && this.allowCustom)) {
            this.clearFilter();
          }
          this.inputBlur.emit();
          this.onTouchedCallback();
        });
      } else {
        if (!this.allowCustom) {
          this.clearFilter();
        }
        this.closePopup();
      }
    }
  }
  /**
   * @hidden
   */
  onPointerDown(event) {
    event.preventDefault();
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (this.isAdaptiveModeEnabled && this.windowSize !== currentWindowSize) {
      if (this.isOpen) {
        this.togglePopup(false);
      }
      this.windowSize = currentWindowSize;
      this.cdr.detectChanges();
    }
    if (this.isOpen && !this.isActionSheetExpanded) {
      const popupWrapper = this.popupRef.popupElement;
      const {
        min,
        max
      } = this.width;
      popupWrapper.style.minWidth = min;
      popupWrapper.style.width = max;
    }
  }
  get appendTo() {
    const {
      appendTo
    } = this.popupSettings;
    if (!appendTo || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  /**
   * Shows or hides the current group sticky header when using grouped data.
   * By default the sticky header is displayed ([see example]({% slug grouping_autocomplete %}#toc-sticky-header)).
   */
  showStickyHeader = true;
  /**
   * @hidden
   */
  focusableId = `k-${guid2()}`;
  /**
   * Determines whether to close the options list of the MultiSelect after the item selection is finished
   * ([see example]({% slug openstate_multiselect %}#toc-keeping-the-options-list-open-while-on-focus)).
   * @default true
   */
  autoClose = true;
  /**
   * Sets and gets the loading state of the MultiSelect.
   */
  loading;
  /**
   * Sets the data of the MultiSelect.
   *
   * > The data has to be provided in an array-like list of items.
   */
  set data(data) {
    this.dataService.data = data || [];
    if (this.virtual) {
      this.virtual.skip = 0;
    }
    if (this.initialized) {
      this.setState(this.value);
    }
  }
  get data() {
    const virtual = this.virtual;
    if (virtual) {
      const start = virtual.skip || 0;
      const end = start + virtual.pageSize;
      virtual.total = this.dataService.data.length;
      return this.dataService.data.slice(start, end);
    }
    return this.dataService.data;
  }
  /**
   * Sets the value of the MultiSelect. It can be either of the primitive (string, numbers) or of the complex (objects) type.
   * To define the type, use the `valuePrimitive` option.
   *
   * > All selected values which are not present in the source are ignored.
   */
  set value(values) {
    this._value = values ? values : [];
    if (!this.differ && this.value) {
      this.differ = this.differs.find(this.value).create();
    }
    this.valueChangeDetected = true;
    if (this.initialized) {
      this.setState(this.value);
    }
  }
  get value() {
    return this._value;
  }
  /**
   * Sets the data item field that represents the item value.
   * If the data contains only primitive values, do not define it.
   *
   * > The `valueField` property can be set to point to a nested property value - e.g. `category.id`.
   */
  valueField;
  /**
   * Sets the data item field that represents the item text.
   * If the data contains only primitive values, do not define it.
   *
   * > The `textField` property can be set to point to a nested property value - e.g. `category.name`.
   */
  textField;
  /**
   * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$22;
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass2("input", this.size));
    if (size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("input", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `full`
   * * `none`
   *
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED$22;
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    if (rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the fillMode of the component.
   *
   * The possible values are:
   * * `flat`
   * * `solid` (default)
   * * `outline`
   * * `none`
   *
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$22;
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    if (fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", newFillMode));
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * The hint which is displayed when the component is empty.
   * When the values are selected, it disappears.
   */
  set placeholder(text) {
    this._placeholder = text || "";
  }
  get placeholder() {
    return this.selectedDataItems.length ? "" : this._placeholder;
  }
  /**
   * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.
   */
  adaptiveMode = "none";
  /**
   * Sets the title of the ActionSheet that is rendered instead of the Popup when using small screen devices.
   * By default the ActionSheet title uses the text provided for the label of the AutoComplete.
   */
  title = "";
  /**
   * Sets the subtitle of the ActionSheet that is rendered instead of the Popup when using small screen devices.
   * By default the ActionSheet subtitle uses the text provided for the `placeholder` of the AutoComplete.
  */
  set subtitle(_subtitle) {
    this._subtitle = _subtitle;
  }
  get subtitle() {
    return this._subtitle || this.placeholder;
  }
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * Sets the disabled state of the component. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_multiselect#toc-managing-the-multiselect-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Defines a Boolean function that is executed for each data item in the component
   * ([see examples]({% slug disableditems_multiselect %})). Determines whether the item will be disabled.
   */
  set itemDisabled(fn) {
    if (typeof fn !== "function") {
      throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this.disabledItemsService.itemDisabled = fn;
  }
  /**
   * Specifies whether checkboxes will be rendered before each item in the popup list.
   */
  set checkboxes(settings) {
    this._checkboxes = normalizeCheckboxesSettings(settings);
  }
  get checkboxes() {
    return this._checkboxes;
  }
  /**
   * Sets the read-only state of the component.
   *
   * @default false
   */
  readonly = false;
  /**
   * Enables the [filtering]({% slug filtering_multiselect %}) functionality of the MultiSelect.
   */
  filterable = false;
  /**
   * Enables the [virtualization]({% slug virtualization_multiselect %}) functionality.
   */
  set virtual(settings) {
    this._virtualSettings = normalizeVirtualizationSettings(settings);
  }
  get virtual() {
    return this._virtualSettings;
  }
  /**
   * Configures the popup of the MultiSelect.
   *
   * The available options are:
   * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
   * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.
   * - `height: Number`&mdash;Sets the height of the popup container.
   * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
   * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
   */
  set popupSettings(settings) {
    this._popupSettings = Object.assign({
      animate: true
    }, settings);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Sets the height of the options list in the popup. By default, `listHeight` is 200px.
   *
   * > The `listHeight` property affects only the list of options and not the whole popup container.
   * > To set the height of the popup container, use `popupSettings.height`.
   *
   * > When using `adaptiveMode` and the screen size is `small` or `medium` the `listHeight` property is set to null.
   */
  set listHeight(_listHeight) {
    this._listHeight = _listHeight;
  }
  get listHeight() {
    if (this.isAdaptive) {
      return;
    }
    return this._listHeight;
  }
  _listHeight = 200;
  /**
   * Specifies the type of the selected value.
   * If set to `true`, the selected value has to be of the primitive type
   * ([more information and example]({% slug valuebinding_multiselect %}#toc-primitive-values-from-object-fields)).
   */
  set valuePrimitive(isPrimitive) {
    this._valuePrimitive = isPrimitive;
  }
  get valuePrimitive() {
    if (!isPresent7(this._valuePrimitive)) {
      return !isPresent7(this.valueField);
    }
    return this._valuePrimitive;
  }
  /**
   * If set to `true`, renders a button on hovering over the component.
   * Clicking this button resets the value of the component to an empty array and triggers the `change` event.
   */
  clearButton = true;
  /**
   * A user-defined callback function which receives an array of selected data items and maps them to an array of tags
   * ([see examples]({% slug summarytagmode_multiselect %}#toc-rendering-of-tags)).
   *
   * @param { Any[] } dataItems - The selected data items from the list.
   * @returns { Any[] } - The tags that will be rendered by the component.
   */
  tagMapper = (tags) => tags || [];
  /**
   * Specifies whether the MultiSelect allows user-defined values that are not present in the dataset
   * ([more information and examples]({% slug custom_values_multiselect %})).
   * Defaults to `false`.
   *
   * The feature is not available when using adaptive mode.
   */
  allowCustom = false;
  /**
   * A user-defined callback function which returns normalized custom values.
   * Typically used when the data items are different from type `string`.
   *
   * @param { Any } value - The custom value that is defined by the user.
   * @returns { Any }
   *
   * @example
   * ```ts
   * import { map } from 'rxjs/operators';
   *
   * _@Component({
   * selector: 'my-app',
   * template: `
   *   <kendo-multiselect
   *       [allowCustom]="true"
   *       [data]="listItems"
   *       textField="text"
   *       valueField="value"
   *       [valueNormalizer]="valueNormalizer"
   *       (valueChange)="onValueChange($event)"
   *   >
   *   </kendo-multiselect>
   * `
   * })
   *
   * class AppComponent {
   *   public listItems: Array<{ text: string, value: number }> = [
   *       { text: "Small", value: 1 },
   *       { text: "Medium", value: 2 },
   *       { text: "Large", value: 3 }
   *   ];
   *
   *   public onValueChange(value) {
   *       console.log("valueChange : ", value);
   *   }
   *
   *   public valueNormalizer = (text$: Observable<string>) => text$.pipe(map((text: string) => {
   *      return {
   *         value: Math.floor(Math.random() * (1000 - 100) + 1000), //generate unique valueField
   *         text: text };
   *   }));
   *
   * }
   * ```
   */
  valueNormalizer = (text) => text.pipe(map((userInput) => {
    const comparer = (item) => typeof item === "string" && userInput.toLowerCase() === item.toLowerCase();
    const matchingValue = this.value.find(comparer);
    if (matchingValue) {
      return matchingValue;
    }
    const matchingItem = this.dataService.find(comparer);
    return matchingItem ? matchingItem : userInput;
  }));
  /**
   * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
   */
  inputAttributes;
  /**
   * Fires each time the user types in the input field.
   * You can filter the source based on the passed filtration value.
   */
  filterChange = new EventEmitter();
  /**
   * Fires each time the value is changed&mdash;
   * when the component is blurred or the value is cleared through the **Clear** button
   * ([see example](slug:events_multiselect)).
   * When the value of the component is programmatically changed to `ngModel` or `formControl`
   * through its API or form binding, the `valueChange` event is not triggered because it
   * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the popup is about to open
   * ([see example]({% slug openstate_multiselect %}#toc-preventing-opening-and-closing)).
   * This event is preventable. If you cancel it, the popup will remain closed.
   */
  open = new EventEmitter();
  /**
   * Fires after the popup has been opened.
   */
  opened = new EventEmitter();
  /**
   * Fires each time the popup is about to close
   * ([see example]({% slug openstate_multiselect %}#toc-preventing-opening-and-closing)).
   * This event is preventable. If you cancel it, the popup will remain open.
   */
  close = new EventEmitter();
  /**
   * Fires after the popup has been closed.
   */
  closed = new EventEmitter();
  /**
   * Fires each time the user focuses the MultiSelect.
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the MultiSelect gets blurred.
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the user focuses the `input` element.
   */
  inputFocus = new EventEmitter();
  /**
   * Fires each time the `input` element gets blurred.
   */
  inputBlur = new EventEmitter();
  /**
   * Fires each time a tag is about to be removed([see examples]({% slug summarytagmode_multiselecttree %}#toc-notifying-on-removing-group-tags)).
   * This event is preventable. If you cancel it, the tag will not be removed.
   */
  removeTag = new EventEmitter();
  container;
  searchbar;
  tagList;
  popupTemplate;
  optionsList;
  template;
  customItemTemplate;
  groupTemplate;
  fixedGroupTemplate;
  headerTemplate;
  footerTemplate;
  tagTemplate;
  groupTagTemplate;
  noDataTemplate;
  /**
   * @hidden
   */
  suffixTemplate;
  /**
   * @hidden
   */
  prefixTemplate;
  hostClasses = true;
  get dir() {
    return this.direction;
  }
  get disabledClass() {
    return this.disabled;
  }
  get isLoading() {
    return this.loading;
  }
  /**
   * @hidden
   */
  windowSize = "large";
  /**
   * @hidden
   */
  get isActionSheetExpanded() {
    return this.actionSheet?.expanded;
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  disabledIndices;
  initialized = false;
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  _subtitle;
  _valueHolder = [];
  constructor(wrapper, localization, popupService, dataService, selectionService, navigationService, disabledItemsService, cdr, differs, renderer, _zone, injector, hostElement, adaptiveService) {
    this.wrapper = wrapper;
    this.localization = localization;
    this.popupService = popupService;
    this.dataService = dataService;
    this.selectionService = selectionService;
    this.navigationService = navigationService;
    this.disabledItemsService = disabledItemsService;
    this.cdr = cdr;
    this.differs = differs;
    this.renderer = renderer;
    this._zone = _zone;
    this.injector = injector;
    this.hostElement = hostElement;
    this.adaptiveService = adaptiveService;
    validatePackage(packageMetadata7);
    this.popupPointerDownHandler = this.onPointerDown.bind(this);
    this.data = [];
    this.direction = this.localization.rtl ? "rtl" : "ltr";
    this.subscribeEvents();
    this.subscribeTouchEvents();
  }
  get listContainerClasses() {
    const containerClasses = ["k-list-container", "k-multiselect-popup"];
    if (this.popupSettings.popupClass) {
      containerClasses.push(this.popupSettings.popupClass);
    }
    return containerClasses;
  }
  /**
   * @hidden
   */
  get customItemSizeClass() {
    return `${this.size ? getSizeClass2("list", this.size) : ""}`;
  }
  get width() {
    let wrapperOffsetWidth = 0;
    if (isDocumentAvailable()) {
      wrapperOffsetWidth = this.wrapper.nativeElement.offsetWidth;
    }
    const width = this.popupSettings.width || wrapperOffsetWidth;
    const minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : `${wrapperOffsetWidth}px`;
    const maxWidth = isNaN(width) ? width : `${width}px`;
    return {
      min: minWidth,
      max: maxWidth
    };
  }
  get height() {
    const popupHeight = this.popupSettings.height;
    return isPresent7(popupHeight) ? `${popupHeight}px` : "auto";
  }
  get activeDescendant() {
    const focusedTagIndex = this.focusedTagIndex;
    const focusedListIndex = this.selectionService.focused;
    let prefix;
    let focusedIndex;
    if (isPresent7(focusedTagIndex) && !this.isOpen) {
      focusedIndex = focusedTagIndex;
      prefix = this.tagPrefix;
    } else if (isPresent7(focusedListIndex) && focusedListIndex !== -1 && this.isOpen) {
      focusedIndex = focusedListIndex;
      prefix = this.optionPrefix;
    } else {
      return null;
    }
    return prefix + "-" + focusedIndex;
  }
  get clearButtonVisiblity() {
    if (touchEnabled) {
      return "visible";
    }
  }
  /**
   * @hidden
   */
  applyValue() {
    this.value = this._valueHolder;
    this._valueHolder = [];
    this.emitValueChange();
    this.togglePopup(false);
  }
  /**
   * @hidden
   */
  cancelValue() {
    this._valueHolder = [];
    this.togglePopup(false);
  }
  /**
   * @hidden
   */
  verifySettings() {
    if (!isDevMode() || this.value.length === 0) {
      return;
    }
    if (!isArray3(this.value)) {
      throw new Error(MultiselectMessages.array);
    }
    if (this.valuePrimitive === true && isObjectArray(this.value)) {
      throw new Error(MultiselectMessages.primitive);
    }
    if (this.valuePrimitive === false && !isObjectArray(this.value)) {
      throw new Error(MultiselectMessages.object);
    }
    const valueOrText = !isPresent7(this.valueField) !== !isPresent7(this.textField);
    if (valueOrText) {
      throw new Error(MultiselectMessages.textAndValue);
    }
  }
  /**
   * @hidden
   */
  change(event) {
    if (event.isMultipleSelection) {
      if (isPresent7(event.added) && event.added.length > 0) {
        event.added.forEach((itemIndex2) => {
          const dataItem = this.dataService.itemAt(itemIndex2);
          const newItem = this.valuePrimitive && isPresent7(dataItem) && isPresent7(getter2(dataItem, this.valueField)) ? getter2(dataItem, this.valueField) : dataItem;
          if (newItem) {
            if (!this.isAdaptive || !this.isActionSheetExpanded) {
              this.value = [...this.value, newItem];
            } else {
              this._valueHolder = [...this._valueHolder, newItem];
            }
          }
        });
      }
      if (isPresent7(event.removed) && event.removed.length > 0) {
        event.removed.forEach((itemIndex2) => {
          const dataItem = this.dataService.itemAt(itemIndex2);
          const filter2 = (item) => getter2(item, this.valueField) !== getter2(dataItem, this.valueField);
          if (!this.isAdaptive || !this.isActionSheetExpanded) {
            this.value = this.value.filter(filter2);
          } else {
            this._valueHolder = this._valueHolder.filter(filter2);
          }
        });
        this.cdr.detectChanges();
      }
    } else {
      const isCustomItem = (isPresent7(event.added) || isPresent7(event.removed)) && (event.added === -1 || event.removed === -1);
      if (isCustomItem) {
        this.addCustomValue(this.text);
        return;
      }
      if (isPresent7(event.added)) {
        const dataItem = this.dataService.itemAt(event.added);
        const newItem = this.valuePrimitive && isPresent7(dataItem) && isPresent7(getter2(dataItem, this.valueField)) ? getter2(dataItem, this.valueField) : dataItem;
        if (!this.isAdaptive || !this.isActionSheetExpanded) {
          this.value = [...this.value, newItem];
        } else {
          this._valueHolder = [...this._valueHolder, newItem];
        }
      }
      if (isPresent7(event.removed)) {
        const dataItem = this.dataService.itemAt(event.removed);
        const filter2 = (item) => getter2(item, this.valueField) !== getter2(dataItem, this.valueField);
        if (!this.isAdaptive || !this.isActionSheetExpanded) {
          this.value = this.value.filter(filter2);
        } else {
          this._valueHolder = this._valueHolder.filter(filter2);
        }
        this.selectionService.focused = event.removed;
        this.cdr.detectChanges();
      }
    }
    if (!this.isAdaptive || !this.isActionSheetExpanded) {
      this.emitValueChange();
    }
  }
  /**
   * @hidden
   */
  setState(value) {
    let data = this.dataService.data;
    if (this.dataService.grouped) {
      data = data.filter((item) => !item.header).map((item) => item.value);
    }
    const selection = selectedIndices(this.value, data, this.valueField);
    this.selectionService.resetSelection(selection);
    if (this.disabledItemsService.isIndexDisabled(this.selectionService.focused)) {
      this.selectionService.focused = this.firstFocusableIndex(0);
    }
    if (this.isOpen && this.selectionService.focused === void 0) {
      if (this.dataService.itemsCount > 0) {
        this.selectionService.focused = this.firstFocusableIndex(0);
      } else if (this.allowCustom) {
        this.selectionService.focused = -1;
      }
    }
    if (this.valuePrimitive && !this.valueField) {
      this.selectedDataItems = value.slice();
    }
    if (isObjectArray(value) || this.valuePrimitive && this.valueField) {
      this.selectedDataItems = resolveAllValues(value, data, this.valueField);
    }
    if (this.selectedDataItems.length < value.length) {
      this.selectedDataItems = value.map((current) => {
        const dataItem = this.selectedDataItems.find((item) => getter2(item, this.valueField) === getter2(current, this.valueField));
        return isPresent7(dataItem) ? dataItem : this.resolveDataItemFromTags(current);
      }).filter((dataItem) => isPresent7(dataItem));
    }
    this.tags = this.tagMapper(this.selectedDataItems.slice(0));
    this.disabledIndices = this.disabledItemsMapper();
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  handleFilter(text) {
    this.text = text;
    if (text && !this.isOpen) {
      this.openPopup();
    }
    if (this.filterable) {
      this.filterChange.emit(text);
    } else {
      this.searchTextAndFocus(text);
    }
    this.searchbar.setInputSize();
  }
  /**
   * @hidden
   */
  pageChange(event) {
    const virtual = this.virtual;
    virtual.skip = event.skip;
  }
  /**
   * @hidden
   */
  clearFilter() {
    if (this.filterable && this.text) {
      this.filterChange.emit("");
    }
    this.text = "";
    this.searchbar.input.nativeElement.value = "";
    this.searchbar.setInputSize();
  }
  /**
   * @hidden
   */
  handleNavigate(event) {
    const navigateInput = this.text && event.keyCode !== Keys.ArrowDown && event.keyCode !== Keys.ArrowUp;
    const selectValue = this.text && event.keyCode === Keys.Enter || event.keyCode === Keys.Escape;
    const deleteTag = !this.text && event.keyCode === Keys.Backspace && this.tags.length > 0;
    if (event.keyCode === Keys.Backspace && this.isActionSheetExpanded) {
      return;
    }
    if (deleteTag) {
      this.handleBackspace();
      return;
    }
    if (this.disabled || navigateInput && !selectValue) {
      return;
    }
    const eventData = event;
    const focused = isNaN(this.selectionService.focused) ? -1 : this.selectionService.focused;
    const action = this.navigationService.process({
      current: focused,
      max: this.dataService.itemsCount - 1,
      min: this.allowCustom && this.text ? -1 : 0,
      open: this.isOpen,
      originalEvent: eventData
    });
    if (action !== NavigationAction.Undefined && (action === NavigationAction.Enter && this.isOpen || action !== NavigationAction.Enter) && !this.isActionSheetExpanded && action === NavigationAction.Tab) {
      event.preventDefault();
    }
  }
  /**
   * @hidden
   */
  handleRemoveTag({
    tag
  }) {
    const eventArgs = new RemoveTagEvent(tag);
    if (this.disabled || this.readonly) {
      return;
    }
    this.focus();
    this.removeTag.emit(eventArgs);
    if (eventArgs.isDefaultPrevented()) {
      return;
    }
    if (tag instanceof Array) {
      this.removeGroupTag(tag);
    } else {
      this.removeSingleTag(tag);
    }
    this.cdr.detectChanges();
  }
  /**
   * @hidden
   */
  clearAll(event) {
    event?.stopImmediatePropagation();
    event?.preventDefault();
    this.focus();
    this.clearFilter();
    this.selectionService.lastClickedIndex = null;
    const selected = this.selectionService.selected;
    this.value = this.value.filter((_item, index) => this.disabledItemsService.isIndexDisabled(selected[index]));
    this.emitValueChange();
  }
  /**
   * @hidden
   */
  addCustomValue(text) {
    this.customValueSubject.next(text);
  }
  ngAfterContentChecked() {
    this.verifySettings();
  }
  ngDoCheck() {
    const valueChanges = this.differ && this.differ.diff(this.value);
    if (valueChanges && !this.valueChangeDetected) {
      this.setState(this.value);
    }
    this.valueChangeDetected = false;
  }
  ngOnInit() {
    this.renderer.removeAttribute(this.wrapper.nativeElement, "tabindex");
    this.createCustomValueStream();
    this.subs.add(this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
      this.cdr.markForCheck();
    }));
    this.setState(this.value);
    this.setComponentClasses();
    this.initialized = true;
  }
  ngOnChanges(changes) {
    const virtual = this.virtual;
    const requestInitialData = virtual && changes.data && changes.data.isFirstChange();
    if (requestInitialData) {
      this.pageChange({
        skip: 0,
        take: virtual.pageSize
      });
    }
    if (isChanged("valueNormalizer", changes)) {
      this.createCustomValueStream();
    }
    if (anyChanged(["textField", "valueField", "valuePrimitive"], changes)) {
      this.setState(this.value);
    }
  }
  ngAfterViewInit() {
    this.windowSize = this.adaptiveService.size;
    this.cdr.detectChanges();
    this.searchbar.setInputSize();
    this.subs.add(this.renderer.listen(this.wrapper.nativeElement, "mousedown", this.handleMousedown.bind(this)));
    this.subs.add(this.renderer.listen(this.wrapper.nativeElement, "keydown", this.handleKeydown.bind(this)));
    if (this.actionSheet && isDocumentAvailable()) {
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-height", "60vh");
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-max-height", "none");
    }
    this._zone.onStable.pipe(take(1)).subscribe(() => {
      const ariaLabel = this.searchbar.input.nativeElement.getAttribute("aria-labelledby") || this.searchbar.input.nativeElement.getAttribute("data-kendo-label-id");
      if (ariaLabel) {
        this.renderer.setAttribute(this.tagList.hostElement.nativeElement, "aria-labelledby", ariaLabel);
      }
    });
  }
  ngOnDestroy() {
    this._toggle(false);
    this.unsubscribeEvents();
  }
  /**
   * Toggles the visibility of the popup or actionSheet
   * ([see example]({% slug openstate_multiselect %}#toc-setting-the-initially-opened-component)).
   * If you use the `toggle` method to open or close the popup or actionSheet, the respective `open` and `close` events will not be fired.
   *
   * @param open - The state of the popup.
   */
  toggle(open) {
    Promise.resolve(null).then(() => {
      const shouldOpen = isPresent7(open) ? open : !this._open;
      this._toggle(shouldOpen);
      this.cdr.markForCheck();
    });
  }
  /**
   * Returns the current open state. Returns `true` if the popup or actionSheet is open.
   */
  get isOpen() {
    return isTruthy2(this._open || this.isActionSheetExpanded);
  }
  /**
   * Resets the value of the MultiSelect.
   * If you use the `reset` method to clear the value of the component,
   * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.
   */
  reset() {
    this.text = "";
    this.value = [];
  }
  /**
   * @hidden
   */
  messageFor(key) {
    return this.localization.get(key);
  }
  // NG MODEL BINDINGS
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value || [];
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onChangeCallback = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.cdr.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * @hidden
   */
  onTagMapperChange() {
    this.tags = this.tagMapper(this.selectedDataItems.slice(0));
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  handleClick() {
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.togglePopup(true);
    }
  }
  onChangeCallback = (_2) => {
  };
  onTouchedCallback = (_2) => {
  };
  _placeholder = "";
  _open = false;
  _value = [];
  _popupSettings = {
    animate: true
  };
  _virtualSettings;
  _valuePrimitive;
  _checkboxes = {
    enabled: false
  };
  _isFocused = false;
  set isFocused(isFocused) {
    this.renderer[isFocused ? "addClass" : "removeClass"](this.wrapper.nativeElement, "k-focus");
    this._isFocused = isFocused;
  }
  get isFocused() {
    return this._isFocused;
  }
  selectedDataItems = [];
  popupPointerDownHandler;
  isOpenPrevented = false;
  customValueSubject = new Subject();
  customValueSubscription;
  subs = new Subscription();
  touchstartDisposeHandler;
  direction;
  differ;
  valueChangeDetected;
  subscribeEvents() {
    if (!isDocumentAvailable()) {
      return;
    }
    const isOpen = () => this.isOpen;
    const isClosed = () => !this.isOpen;
    const isTagFocused = () => !this.isOpen && this.focusedTagIndex !== void 0;
    [this.selectionService.onChange.subscribe(this.handleItemChange.bind(this)), this.navigationService.esc.subscribe(this.closePopup.bind(this)), this.navigationService.enter.pipe(filter(isOpen)).subscribe(this.handleEnter.bind(this)), this.navigationService.open.subscribe(this.openPopup.bind(this)), this.navigationService.close.subscribe(this.handleClose.bind(this)), this.navigationService.up.pipe(filter(isOpen)).subscribe((event) => this.handleUp(event.index)), this.navigationService.home.pipe(filter(() => isClosed)).subscribe(this.handleHome.bind(this)), this.navigationService.end.pipe(filter(() => isClosed)).subscribe(this.handleEnd.bind(this)), this.navigationService.backspace.pipe(filter(isTagFocused)).subscribe(this.handleBackspace.bind(this)), this.navigationService.delete.pipe(filter(isTagFocused)).subscribe(this.handleDelete.bind(this)), this.navigationService.left.subscribe(this.direction === "rtl" ? this.handleRightKey.bind(this) : this.handleLeftKey.bind(this)), this.navigationService.right.subscribe(this.direction === "rtl" ? this.handleLeftKey.bind(this) : this.handleRightKey.bind(this)), this.navigationService.down.subscribe((event) => this.handleDownKey(event.index)), this.navigationService.selectprevious.pipe(filter(isOpen)).subscribe((event) => this.handleSelectUpDown(event)), this.navigationService.selectnext.pipe(filter(isOpen)).subscribe((event) => this.handleSelectUpDown(event)), this.navigationService.selectalltobeginning.pipe(filter(isOpen)).subscribe(() => this.handleSelectAllToBeginning()), this.navigationService.selectalltoend.pipe(filter(isOpen)).subscribe(() => this.handleSelectAllToEnd()), merge(this.navigationService.pagedown, this.navigationService.pageup).subscribe((event) => {
      if (this.isOpen) {
        event.originalEvent.preventDefault();
        this.optionsList.scrollWithOnePage(NavigationAction[event.originalEvent.code]);
      }
    })].forEach((s) => this.subs.add(s));
  }
  subscribeTouchEvents() {
    if (!isDocumentAvailable() || !touchEnabled) {
      return;
    }
    this._zone.runOutsideAngular(() => (
      // Roll up MultiSelect on iOS when tapped outside
      this.touchstartDisposeHandler = this.renderer.listen(document, "touchstart", (e) => {
        const target = e.target;
        if ((this.isFocused || this.isOpen) && !inDropDown(this.wrapper, target, this.popupRef)) {
          this._zone.run(() => {
            this.blur();
            if (this.isOpen) {
              this.togglePopup(false);
            }
          });
        }
      })
    ));
  }
  unsubscribeEvents() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.subs.unsubscribe();
    if (this.customValueSubscription) {
      this.customValueSubscription.unsubscribe();
    }
    if (this.touchstartDisposeHandler) {
      this.touchstartDisposeHandler();
    }
  }
  removeGroupTag(dataItems) {
    let data = this.dataService.data;
    if (this.dataService.grouped) {
      data = data.filter((item) => !item.header).map((item) => item.value);
    }
    const dataItemValues = new Set(dataItems.map((item) => getter2(item, this.valueField)));
    this.value = this.value.filter((value) => {
      const index = selectedIndices([value], data, this.valueField)[0];
      const isDataItemDisabled = this.disabledItemsService.isIndexDisabled(index);
      return !dataItemValues.has(getter2(value, this.valueField)) || isDataItemDisabled;
    });
    this.emitValueChange();
  }
  removeSingleTag(dataItem) {
    let data = this.dataService.data;
    if (this.dataService.grouped) {
      data = data.filter((item) => !item.header).map((item) => item.value);
    }
    const index = selectedIndices([dataItem], data, this.valueField)[0];
    if (this.disabledItemsService.isIndexDisabled(index)) {
      return;
    }
    if (isNumber4(index)) {
      this.selectionService.deselect(index);
      this.selectionService.focused = index;
      this.togglePopup(false);
    } else {
      const filter2 = (item) => getter2(item, this.valueField) !== getter2(dataItem, this.valueField);
      this.value = this.value.filter(filter2);
      this.emitValueChange();
    }
  }
  /**
   * @hidden
   *
   * Determines which of the provided tags should be disabled and stores their position indices
   */
  disabledItemsMapper() {
    const {
      selected
    } = this.selectionService;
    return new Set(this.selectedDataItems.reduce((indices, _item, index) => {
      if (this.disabledItemsService.isIndexDisabled(selected[index])) {
        indices.push(index);
      }
      return indices;
    }, []));
  }
  createCustomValueStream() {
    if (this.customValueSubscription) {
      this.customValueSubscription.unsubscribe();
    }
    this.customValueSubscription = this.customValueSubject.pipe(tap(() => {
      this.loading = true;
      this.disabled = true;
      this.cdr.detectChanges();
    }), this.valueNormalizer, catchError(() => {
      this.loading = false;
      this.disabled = false;
      if (this.autoClose) {
        this.togglePopup(false);
      }
      if (this.autoClose || !this.filterable) {
        this.clearFilter();
      }
      this.nextTick(() => {
        this.searchbar.focus();
      });
      this.createCustomValueStream();
      return of(null);
    })).subscribe((normalizedValue) => {
      this.loading = false;
      this.disabled = false;
      if (isPresent7(normalizedValue)) {
        const newValue = this.valuePrimitive ? getter2(normalizedValue, this.valueField) : normalizedValue;
        const itemIndex2 = this.dataService.indexOf(newValue);
        const customItem = itemIndex2 === -1;
        if (this.value.indexOf(newValue) === -1) {
          this.tags = this.tagMapper([...this.selectedDataItems, normalizedValue]);
          if (!customItem) {
            this.selectionService.add(itemIndex2);
          } else {
            this.value = [...this.value, newValue];
          }
        } else {
          if (!customItem && this.selectionService.isSelected(itemIndex2)) {
            this.selectionService.deselect(itemIndex2);
            this.selectionService.focused = itemIndex2;
          } else {
            this.value = this.value.filter((item) => getter2(item, this.valueField) !== newValue);
          }
        }
        this.emitValueChange();
      }
      if (this.autoClose) {
        this.togglePopup(false);
      }
      if (this.autoClose || !this.filterable) {
        this.clearFilter();
      }
      this.nextTick(() => {
        this.searchbar.focus();
      });
    });
  }
  handleItemChange(event) {
    this.change(event);
    if (this.autoClose && !event.preventClosingPopup && !this.isActionSheetExpanded) {
      this.togglePopup(false);
    }
    if (this.autoClose || !this.filterable) {
      this.clearFilter();
    }
  }
  handleMousedown(event) {
    if (event.target.closest(".k-input-prefix") || event.target.closest(".k-input-suffix")) {
      return;
    }
    if (!this.isActionSheetExpanded) {
      const inputElement = this.searchbar.input.nativeElement;
      if (event.button === 0) {
        if (this.isFocused && (this.isOpen || this.isOpenPrevented) && event.target === inputElement) {
          return;
        }
        if (!touchEnabled || touchEnabled && event.target.tagName !== "SPAN") {
          this.searchbar.focus();
        }
        if (this.popupRef && this.popupRef.popupElement.contains(event.target)) {
          return;
        }
        event.preventDefault();
        this.togglePopup(!this.isOpen);
      }
    }
  }
  handleKeydown(event) {
    if (this.isFocused && this.isOpen && (event.ctrlKey || event.metaKey) && event.keyCode === Keys.KeyA) {
      event.preventDefault();
      this.handleSelectAll();
    }
  }
  handleEnter(event) {
    const service = this.selectionService;
    const focusedIndex = this.selectionService.focused;
    this.selectionService.lastClickedIndex = focusedIndex;
    if (this.isOpen) {
      event.originalEvent.preventDefault();
    }
    if (focusedIndex === -1) {
      if (this.allowCustom && this.text) {
        this.addCustomValue(this.text);
      }
      return;
    }
    if (service.isSelected(focusedIndex)) {
      service.deselect(focusedIndex);
      service.focused = focusedIndex;
    } else {
      service.add(focusedIndex);
    }
    if (this.autoClose && !this.isActionSheetExpanded) {
      this.togglePopup(false);
    }
    if (this.autoClose || !this.filterable) {
      this.clearFilter();
    }
  }
  handleClose() {
    this.closePopup();
    this.searchbar.focus();
  }
  handleEnd() {
    this.focusedTagIndex = this.tags.length - 1;
  }
  handleHome() {
    this.focusedTagIndex = 0;
  }
  sortSelectionAscending() {
    return this.selectionService.selected.sort((a, b) => a - b);
  }
  handleSelectAll() {
    const selectedItemsCount = this.selectionService.selected.length;
    const dataItemsCount = this.dataService.data.length;
    const dataItemsWithoutHeadersCount = this.dataService.data.filter((i) => !i.header).length;
    if (!this.dataService.grouped && selectedItemsCount === dataItemsCount || this.dataService.grouped && selectedItemsCount === dataItemsWithoutHeadersCount) {
      this.clearAll();
    } else {
      this.selectionService.selectFromTo(0, dataItemsCount - 1);
      this.selectionService.emitMultipleAddedRemoved();
    }
  }
  handleSelectAllToBeginning() {
    const selectedItemsCount = this.selectionService.selected.length;
    const dataItemsCount = this.dataService.data.length;
    const focusedItem = this.selectionService.focused;
    const largestIndex = this.sortSelectionAscending()[selectedItemsCount - 1];
    if (selectedItemsCount !== dataItemsCount) {
      this.selectionService.unselectFromTo(largestIndex, focusedItem + 1);
      this.selectionService.selectFromTo(0, focusedItem);
    }
    this.nextTick(() => this.selectionService.focus(0));
    this.selectionService.emitMultipleAddedRemoved();
  }
  handleSelectAllToEnd() {
    const selectedItemsCount = this.selectionService.selected.length;
    const dataItemsCount = this.dataService.data.length;
    const focusedItem = this.selectionService.focused;
    if (selectedItemsCount !== dataItemsCount) {
      this.selectionService.unselectFromTo(focusedItem - 1, 0);
      this.selectionService.selectFromTo(focusedItem, dataItemsCount - 1);
    }
    if (this.dataService.grouped) {
      const lastItemIndex = this.dataService.groupIndices[this.dataService.groupIndices.length - 1] - 1;
      this.nextTick(() => this.selectionService.focus(lastItemIndex));
    } else {
      this.nextTick(() => this.selectionService.focus(dataItemsCount - 1));
    }
    this.selectionService.emitMultipleAddedRemoved();
  }
  handleSelectUpDown(event) {
    const focusedIndex = this.selectionService.focused;
    if (!isPresent7(focusedIndex)) {
      return;
    }
    let indexToSelect;
    if (event.originalEvent.key === "ArrowUp") {
      indexToSelect = focusedIndex > 0 ? focusedIndex - 1 : focusedIndex;
    } else {
      indexToSelect = focusedIndex < this.dataService.data.length - 1 ? focusedIndex + 1 : focusedIndex;
    }
    if (!isPresent7(this.selectionService.lastClickedIndex)) {
      this.selectionService.lastClickedIndex = focusedIndex;
    }
    this.selectRangeFromTo(indexToSelect);
  }
  /**
   * Selects all items between the focused item and the last clicked item (index). Also removes all other selected items.
   */
  selectRangeFromTo(indexToSelect) {
    const lastClickedIndex = this.selectionService.lastClickedIndex;
    if (lastClickedIndex > indexToSelect) {
      this.selectionService.unselectNotNeededIndices(indexToSelect, lastClickedIndex, this.dataService.data.length);
      this.selectionService.selectFromTo(indexToSelect, this.selectionService.lastClickedIndex);
      this.selectionService.emitMultipleAddedRemoved();
    } else {
      this.selectionService.unselectNotNeededIndices(lastClickedIndex, indexToSelect, this.dataService.data.length);
      this.selectionService.selectFromTo(lastClickedIndex, indexToSelect);
      this.selectionService.emitMultipleAddedRemoved();
    }
    this.nextTick(() => this.selectionService.focus(indexToSelect));
  }
  handleUp(index) {
    this.selectionService.focused = index;
  }
  handleBackspace() {
    if (this.focusedTagIndex !== void 0) {
      this.handleDelete();
    } else {
      this.handleRemoveTag({
        tag: this.tags[this.tags.length - 1]
      });
      this.searchbar.focus();
    }
  }
  handleDelete() {
    this.handleRemoveTag({
      tag: this.tags[this.focusedTagIndex]
    });
    if (this.focusedTagIndex === this.tags.length) {
      this.focusedTagIndex = void 0;
    }
  }
  handleLeftKey() {
    if (this.focusedTagIndex === void 0 || this.focusedTagIndex < 0) {
      this.focusedTagIndex = this.tags.length - 1;
    } else if (this.focusedTagIndex !== 0) {
      this.focusedTagIndex--;
    }
  }
  handleDownKey(index) {
    if (this.isOpen) {
      this.selectionService.focused = index || this.firstFocusableIndex(0);
    } else {
      this.openPopup();
    }
  }
  handleRightKey() {
    const last2 = this.tags.length - 1;
    if (this.focusedTagIndex === last2) {
      this.focusedTagIndex = void 0;
    } else if (this.focusedTagIndex < last2) {
      this.focusedTagIndex++;
    }
  }
  findIndex(text, startsFrom = 0) {
    let itemText;
    text = text.toLowerCase();
    const index = this.dataService.findIndex((item) => {
      if (this.dataService.grouped) {
        itemText = getter2(item.value, this.textField);
      } else {
        itemText = getter2(item, this.textField);
      }
      itemText = !isPresent7(itemText) ? "" : itemText.toString().toLowerCase();
      return text && itemText.startsWith(text);
    }, startsFrom);
    if (this.disabledItemsService.isIndexDisabled(index)) {
      return index + 1 > this.dataService.itemsCount ? -1 : this.findIndex(text, index + 1);
    } else {
      return index;
    }
  }
  searchTextAndFocus(text) {
    const index = this.findIndex(text);
    this.selectionService.focused = index;
  }
  closePopup() {
    this.togglePopup(false);
    this.focusedTagIndex = void 0;
  }
  openPopup() {
    this.togglePopup(true);
    this.focusedTagIndex = void 0;
  }
  /**
   * @hidden
   */
  togglePopup(open) {
    const isDisabled2 = this.disabled || this.readonly;
    const sameState = this.isOpen === open;
    if (isDisabled2 || sameState) {
      return;
    }
    const isDefaultPrevented2 = this.triggerPopupEvents(open);
    if (open) {
      this.isOpenPrevented = isDefaultPrevented2;
    }
    if (!isDefaultPrevented2) {
      this._toggle(open);
    }
  }
  triggerPopupEvents(open) {
    const eventArgs = new PreventableEvent5();
    if (open) {
      this.open.emit(eventArgs);
    } else {
      this.close.emit(eventArgs);
    }
    return eventArgs.isDefaultPrevented();
  }
  _toggle(open) {
    this._open = open;
    this.destroyPopup();
    if (this.isActionSheetExpanded) {
      this.closeActionSheet();
      this.focus();
    }
    if (this._open) {
      this.createPopup();
    }
  }
  destroyPopup() {
    if (this.popupRef) {
      this.popupRef.popupElement.removeEventListener("pointerdown", this.popupPointerDownHandler);
      this.popupRef.close();
      this.popupRef = null;
    }
  }
  createPopup() {
    if (this.virtual) {
      this.virtual.skip = 0;
    }
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.openActionSheet();
      return;
    }
    const horizontalAlign = this.direction === "rtl" ? "right" : "left";
    const anchorPosition = {
      horizontal: horizontalAlign,
      vertical: "bottom"
    };
    const popupPosition = {
      horizontal: horizontalAlign,
      vertical: "top"
    };
    const appendToComponent = typeof this.popupSettings.appendTo === "string" && this.popupSettings.appendTo === "component";
    this.popupRef = this.popupService.open({
      anchor: this.wrapper,
      anchorAlign: anchorPosition,
      animate: this.popupSettings.animate,
      appendTo: this.appendTo,
      content: this.popupTemplate,
      popupAlign: popupPosition,
      popupClass: this.listContainerClasses,
      positionMode: appendToComponent ? "fixed" : "absolute"
    });
    const popupWrapper = this.popupRef.popupElement;
    const {
      min,
      max
    } = this.width;
    if (!this.appendTo) {
      this.renderer.setAttribute(popupWrapper, "role", "region");
      this.renderer.setAttribute(popupWrapper, "aria-label", this.messageFor("popupLabel"));
    }
    popupWrapper.addEventListener("pointerdown", this.popupPointerDownHandler);
    popupWrapper.style.minWidth = min;
    popupWrapper.style.width = max;
    popupWrapper.style.height = this.height;
    popupWrapper.setAttribute("dir", this.direction);
    this.popupRef.popupOpen.subscribe(() => {
      this.cdr.detectChanges();
      setListBoxAriaLabelledBy(this.optionsList, this.searchbar.input, this.renderer);
      this.optionsList.scrollToItem(this.selectionService.focused);
      this.selectionService.focus(this.selectionService.focused);
      this.opened.emit();
    });
    this.popupRef.popupClose.subscribe(() => {
      this.closed.emit();
    });
    this.popupRef.popupAnchorViewportLeave.subscribe(() => {
      this.togglePopup(false);
    });
  }
  emitValueChange() {
    this.onChangeCallback(this.value);
    this.valueChange.emit(this.value);
  }
  resolveDataItemFromTags(value) {
    if (!(this.tags && this.tags.length && isPresent7(value))) {
      return void 0;
    }
    const tags = this.tags.reduce((acc, tag) => {
      const items = isArray3(tag) ? tag : [tag];
      acc.push(...items);
      return acc;
    }, []);
    return tags.find((tag) => getter2(tag, this.valueField) === getter2(value, this.valueField));
  }
  firstFocusableIndex(index) {
    const maxIndex = this.dataService.itemsCount;
    if (this.disabledItemsService.isIndexDisabled(index)) {
      const nextIndex = index + 1;
      return nextIndex < maxIndex ? this.firstFocusableIndex(nextIndex) : void 0;
    } else {
      return index;
    }
  }
  nextTick(f) {
    this._zone.runOutsideAngular(() => {
      setTimeout(() => this._zone.run(f));
    });
  }
  setComponentClasses() {
    if (this.size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("input", this.size));
    }
    if (this.rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    }
  }
  closeActionSheet() {
    this.actionSheet.toggle(false);
    this.filterable && this.filterChange.emit("");
    this.responsiveRendererComponent.searchBarValue = "";
    this.closed.emit();
  }
  openActionSheet() {
    this.windowSize = this.adaptiveService.size;
    this.actionSheet.toggle(true);
    this._valueHolder = [...this.value];
    this.cdr.detectChanges();
    setListBoxAriaLabelledBy(this.optionsList, this.searchbar.input, this.renderer);
    this.title = setActionSheetTitle(this.searchbar.input, this.title);
    updateActionSheetAdaptiveAppearance2(this.actionSheet, this.windowSize, this.renderer);
    this.cdr.detectChanges();
    this.opened.emit();
    this.optionsList.scrollToItem(this.selectionService.focused);
    this.selectionService.focus(this.selectionService.focused);
    this.actionSheetSearchBar.focus();
  }
  static ɵfac = function MultiSelectComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiSelectComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(DataService), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(NavigationService3), ɵɵdirectiveInject(DisabledItemsService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(KeyValueDiffers), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MultiSelectComponent,
    selectors: [["kendo-multiselect"]],
    contentQueries: function MultiSelectComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, CustomItemTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, GroupTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FixedGroupTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, TagTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, GroupTagTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, SuffixTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, PrefixTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.customItemTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fixedGroupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tagTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupTagTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.suffixTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.prefixTemplate = _t.first);
      }
    },
    viewQuery: function MultiSelectComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(ResponsiveRendererComponent, 5);
        ɵɵviewQuery(_c94, 7, ViewContainerRef);
        ɵɵviewQuery(SearchBarComponent, 7);
        ɵɵviewQuery(TagListComponent, 7);
        ɵɵviewQuery(_c104, 7);
        ɵɵviewQuery(_c113, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.responsiveRendererComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.searchbar = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tagList = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.optionsList = _t.first);
      }
    },
    hostVars: 11,
    hostBindings: function MultiSelectComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.dir);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-multiselect", ctx.hostClasses)("k-input", ctx.hostClasses)("k-disabled", ctx.disabledClass)("k-loading", ctx.isLoading);
      }
    },
    inputs: {
      showStickyHeader: "showStickyHeader",
      focusableId: "focusableId",
      autoClose: "autoClose",
      loading: "loading",
      data: "data",
      value: "value",
      valueField: "valueField",
      textField: "textField",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      placeholder: "placeholder",
      adaptiveMode: "adaptiveMode",
      title: "title",
      subtitle: "subtitle",
      disabled: "disabled",
      itemDisabled: "itemDisabled",
      checkboxes: "checkboxes",
      readonly: "readonly",
      filterable: "filterable",
      virtual: "virtual",
      popupSettings: "popupSettings",
      listHeight: "listHeight",
      valuePrimitive: "valuePrimitive",
      clearButton: "clearButton",
      tagMapper: "tagMapper",
      allowCustom: "allowCustom",
      valueNormalizer: "valueNormalizer",
      inputAttributes: "inputAttributes"
    },
    outputs: {
      filterChange: "filterChange",
      valueChange: "valueChange",
      open: "open",
      opened: "opened",
      close: "close",
      closed: "closed",
      onFocus: "focus",
      onBlur: "blur",
      inputFocus: "inputFocus",
      inputBlur: "inputBlur",
      removeTag: "removeTag"
    },
    exportAs: ["kendoMultiSelect"],
    features: [ɵɵProvidersFeature([MULTISELECT_VALUE_ACCESSOR, DataService, SelectionService2, NavigationService3, DisabledItemsService, LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.multiselect"
    }, {
      provide: FilterableComponent,
      useExisting: forwardRef(() => _MultiSelectComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _MultiSelectComponent)
    }]), ɵɵNgOnChangesFeature],
    decls: 19,
    vars: 43,
    consts: () => {
      let i18n_11;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_11 = goog.getMsg("NO DATA FOUND");
        i18n_11 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_11;
      } else {
        i18n_11 = $localize`:kendo.multiselect.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;
      }
      let i18n_12;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_12 = goog.getMsg("clear");
        i18n_12 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_12;
      } else {
        i18n_12 = $localize`:kendo.multiselect.clearTitle|The title of the clear button:clear`;
      }
      let i18n_13;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_13 = goog.getMsg("Options list");
        i18n_13 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_13;
      } else {
        i18n_13 = $localize`:kendo.multiselect.popupLabel|The label of the popup element that contains the list of options when its role is 'region':Options list`;
      }
      let i18n_14;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_14 = goog.getMsg("Apply");
        i18n_14 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_14;
      } else {
        i18n_14 = $localize`:kendo.multiselect.applyButton|The text of the Apply button in the action sheet:Apply`;
      }
      let i18n_15;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_15 = goog.getMsg("Cancel");
        i18n_15 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_15;
      } else {
        i18n_15 = $localize`:kendo.multiselect.cancelButton|The text of the Cancel button in the action sheet:Cancel`;
      }
      return [["popupTemplate", ""], ["container", ""], ["sharedPopupActionSheetTemplate", ""], ["optionsList", ""], ["default_custom_item_template", ""], ["kendoMultiSelectLocalizedMessages", "", "noDataText", i18n_11, "clearTitle", i18n_12, "popupLabel", i18n_13, "applyButton", i18n_14, "cancelButton", i18n_15], ["kendoDropDownSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused"], ["class", "k-input-prefix k-input-prefix-horizontal", 4, "ngIf"], [4, "ngIf"], [1, "k-input-values"], [3, "removeTag", "size", "rounded", "fillMode", "id", "tags", "textField", "valueField", "focused", "disabled", "template", "groupTemplate", "tagPrefix", "disabledIndices"], ["kendoSearchbar", "", 3, "onNavigate", "valueChange", "onBlur", "onFocus", "click", "ariaControls", "ariaExpanded", "id", "tagListId", "isLoading", "isFilterable", "activeDescendant", "userInput", "disabled", "readonly", "tabIndex", "isRequired", "placeholder", "inputAttributes"], ["class", "k-clear-value", "role", "button", "tabindex", "-1", 3, "visibility", "mousedown", 4, "ngIf"], ["class", "k-icon k-i-loading k-input-loading-icon", 4, "ngIf"], ["class", "k-input-suffix k-input-suffix-horizontal", 4, "ngIf"], [3, "resize", 4, "ngIf"], [3, "closePopup", "textInputChange", "navigate", "onApply", "onCancel", "sharedPopupActionSheetTemplate", "isActionSheetExpanded", "title", "showTextInput", "showActionButtons", "subtitle", "placeholder"], [1, "k-input-prefix", "k-input-prefix-horizontal"], [3, "ngTemplateOutlet"], ["role", "button", "tabindex", "-1", 1, "k-clear-value", 3, "mousedown"], ["name", "x", 1, "k-icon", 3, "svgIcon"], [1, "k-icon", "k-i-loading", "k-input-loading-icon"], [1, "k-input-suffix", "k-input-suffix-horizontal"], [4, "ngTemplateOutlet"], [3, "resize"], ["class", "k-list", 3, "ngClass", 4, "ngIf"], [3, "pageChange", "size", "rounded", "id", "optionPrefix", "data", "textField", "valueField", "template", "groupTemplate", "fixedGroupTemplate", "height", "show", "multipleSelection", "virtual", "checkboxes", "isMultiselect", "isActionSheetExpanded", "showStickyHeader"], ["class", "k-no-data", 4, "ngIf"], [3, "templateContext"], [1, "k-list", 3, "ngClass"], ["kendoDropDownsSelectable", "", 1, "k-list-item", "k-custom-item", 3, "multipleSelection", "index"], [4, "ngIf", "ngIfElse"], ["name", "plus", 1, "k-icon", 3, "svgIcon"], [1, "k-no-data"], [3, "ngIf", "templateContext"], [3, "ngIf"]];
    },
    template: function MultiSelectComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 5);
        ɵɵelementContainerStart(1, 6);
        ɵɵtwoWayListener("isFocusedChange", function MultiSelectComponent_Template_ng_container_isFocusedChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.isFocused, $event) || (ctx.isFocused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function MultiSelectComponent_Template_ng_container_handleBlur_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function MultiSelectComponent_Template_ng_container_onFocus_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵtemplate(2, MultiSelectComponent_span_2_Template, 2, 1, "span", 7)(3, MultiSelectComponent_kendo_separator_3_Template, 1, 0, "kendo-separator", 8);
        ɵɵelementStart(4, "div", 9)(5, "kendo-taglist", 10);
        ɵɵlistener("removeTag", function MultiSelectComponent_Template_kendo_taglist_removeTag_5_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleRemoveTag($event));
        });
        ɵɵelementEnd();
        ɵɵelementStart(6, "input", 11);
        ɵɵlistener("onNavigate", function MultiSelectComponent_Template_input_onNavigate_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleNavigate($event));
        })("valueChange", function MultiSelectComponent_Template_input_valueChange_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFilter($event));
        })("onBlur", function MultiSelectComponent_Template_input_onBlur_6_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputBlur());
        })("onFocus", function MultiSelectComponent_Template_input_onFocus_6_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputFocus());
        })("click", function MultiSelectComponent_Template_input_click_6_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleClick());
        });
        ɵɵelementEnd()();
        ɵɵtemplate(7, MultiSelectComponent_span_7_Template, 2, 4, "span", 12)(8, MultiSelectComponent_span_8_Template, 1, 0, "span", 13)(9, MultiSelectComponent_kendo_separator_9_Template, 1, 0, "kendo-separator", 8)(10, MultiSelectComponent_span_10_Template, 2, 1, "span", 14);
        ɵɵelementContainerEnd();
        ɵɵtemplate(11, MultiSelectComponent_ng_template_11_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor)(13, MultiSelectComponent_kendo_resize_sensor_13_Template, 1, 0, "kendo-resize-sensor", 15);
        ɵɵelementContainer(14, null, 1);
        ɵɵelementStart(16, "responsive-renderer", 16);
        ɵɵlistener("closePopup", function MultiSelectComponent_Template_responsive_renderer_closePopup_16_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.togglePopup(false));
        })("textInputChange", function MultiSelectComponent_Template_responsive_renderer_textInputChange_16_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onAdaptiveTextBoxChange($event));
        })("navigate", function MultiSelectComponent_Template_responsive_renderer_navigate_16_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleNavigate($event));
        })("onApply", function MultiSelectComponent_Template_responsive_renderer_onApply_16_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.applyValue());
        })("onCancel", function MultiSelectComponent_Template_responsive_renderer_onCancel_16_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.cancelValue());
        });
        ɵɵelementEnd();
        ɵɵtemplate(17, MultiSelectComponent_ng_template_17_Template, 6, 22, "ng-template", null, 2, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const sharedPopupActionSheetTemplate_r4 = ɵɵreference(18);
        ɵɵadvance();
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.isFocused);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate && ctx.prefixTemplate.showSeparator);
        ɵɵadvance(2);
        ɵɵproperty("size", ctx.size)("rounded", ctx.rounded)("fillMode", ctx.fillMode)("id", ctx.tagListId)("tags", ctx.tags)("textField", ctx.textField)("valueField", ctx.valueField)("focused", ctx.focusedTagIndex)("disabled", ctx.disabled)("template", ctx.tagTemplate)("groupTemplate", ctx.groupTagTemplate)("tagPrefix", ctx.tagPrefix)("disabledIndices", ctx.disabledIndices);
        ɵɵadvance();
        ɵɵproperty("ariaControls", ctx.ariaControls)("ariaExpanded", ctx.isOpen)("id", ctx.focusableId)("tagListId", ctx.tagListId)("isLoading", ctx.loading)("isFilterable", ctx.filterable)("activeDescendant", ctx.activeDescendant)("userInput", ctx.text)("disabled", ctx.disabled)("readonly", ctx.readonly || ctx.isAdaptive)("tabIndex", ctx.tabIndex)("isRequired", ctx.isControlRequired)("placeholder", ctx.placeholder)("inputAttributes", ctx.inputAttributes);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.loading && !ctx.readonly && ctx.clearButton && ((ctx.tags == null ? null : ctx.tags.length) || (ctx.text == null ? null : ctx.text.length)));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.loading);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffixTemplate && ctx.suffixTemplate.showSeparator);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffixTemplate);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.isOpen || ctx.isAdaptiveModeEnabled);
        ɵɵadvance(3);
        ɵɵproperty("sharedPopupActionSheetTemplate", sharedPopupActionSheetTemplate_r4)("isActionSheetExpanded", ctx.isActionSheetExpanded)("title", ctx.title)("showTextInput", true)("showActionButtons", true)("subtitle", ctx.subtitle)("placeholder", ctx.placeholder);
      }
    },
    dependencies: [LocalizedMessagesDirective3, SharedDropDownEventsDirective, NgIf, NgTemplateOutlet, SeparatorComponent, TagListComponent, SearchBarComponent, IconWrapperComponent, ResizeSensorComponent, ResponsiveRendererComponent, TemplateContextDirective, NgClass, SelectableDirective, ListComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiSelectComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoMultiSelect",
      providers: [MULTISELECT_VALUE_ACCESSOR, DataService, SelectionService2, NavigationService3, DisabledItemsService, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.multiselect"
      }, {
        provide: FilterableComponent,
        useExisting: forwardRef(() => MultiSelectComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => MultiSelectComponent)
      }],
      selector: "kendo-multiselect",
      template: `
        <ng-container kendoMultiSelectLocalizedMessages
            i18n-noDataText="kendo.multiselect.noDataText|The text displayed in the popup when there are no items"
            noDataText="NO DATA FOUND"

            i18n-clearTitle="kendo.multiselect.clearTitle|The title of the clear button"
            clearTitle="clear"

            i18n-popupLabel="kendo.multiselect.popupLabel|The label of the popup element that contains the list of options when its role is 'region'"
            popupLabel="Options list"

            i18n-applyButton="kendo.multiselect.applyButton|The text of the Apply button in the action sheet"
            applyButton="Apply"

            i18n-cancelButton="kendo.multiselect.cancelButton|The text of the Cancel button in the action sheet"
            cancelButton="Cancel"
        >
        </ng-container>

        <ng-container
            kendoDropDownSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="isFocused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
        >
            <span *ngIf="prefixTemplate" class="k-input-prefix k-input-prefix-horizontal">
                <ng-template [ngTemplateOutlet]="prefixTemplate?.templateRef">
                </ng-template>
            </span>
            <kendo-separator *ngIf="prefixTemplate && prefixTemplate.showSeparator"></kendo-separator>
            <div class="k-input-values">
                <kendo-taglist
                    [size]="size"
                    [rounded]="rounded"
                    [fillMode]="fillMode"
                    [id]="tagListId"
                    [tags]="tags"
                    [textField]="textField"
                    [valueField]="valueField"
                    [focused]="focusedTagIndex"
                    [disabled]="disabled"
                    [template]="tagTemplate"
                    [groupTemplate]="groupTagTemplate"
                    [tagPrefix]="tagPrefix"
                    [disabledIndices]="disabledIndices"
                    (removeTag)="handleRemoveTag($event)"
                >
                </kendo-taglist>
                <input
                    kendoSearchbar
                    [ariaControls]="ariaControls"
                    [ariaExpanded]="isOpen"
                    [id]="focusableId"
                    [tagListId]="tagListId"
                    [isLoading]="loading"
                    [isFilterable]="filterable"
                    [activeDescendant]="activeDescendant"
                    [userInput]="text"
                    [disabled]="disabled"
                    [readonly]="readonly || this.isAdaptive"
                    [tabIndex]="tabIndex"
                    [isRequired]="isControlRequired"
                    [placeholder]="placeholder"
                    [inputAttributes]="inputAttributes"
                    (onNavigate)="handleNavigate($event)"
                    (valueChange)="handleFilter($event)"
                    (onBlur)="handleInputBlur()"
                    (onFocus)="handleInputFocus()"
                    (click)="handleClick()"
                />
            </div>

            <span
                *ngIf="!loading && !readonly && clearButton && (tags?.length || text?.length)"
                class="k-clear-value"
                [style.visibility]="clearButtonVisiblity"
                [attr.title]="messageFor('clearTitle')"
                role="button"
                tabindex="-1"
                (mousedown)="clearAll($event)"
            >
                <kendo-icon-wrapper
                    class="k-icon"
                    name="x"
                    [svgIcon]="xIcon"
                >
                </kendo-icon-wrapper>
            </span>
            <span
                *ngIf="loading"
                class="k-icon k-i-loading k-input-loading-icon"
            >
            </span>
            <kendo-separator *ngIf="suffixTemplate && suffixTemplate.showSeparator"></kendo-separator>
            <span *ngIf="suffixTemplate" class="k-input-suffix k-input-suffix-horizontal">
                <ng-template [ngTemplateOutlet]="suffixTemplate?.templateRef">
                </ng-template>
            </span>
        </ng-container>

        <ng-template #popupTemplate>
            <ng-container *ngTemplateOutlet="sharedPopupActionSheetTemplate"></ng-container>
        </ng-template>
        <kendo-resize-sensor *ngIf="isOpen || isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>
        <ng-container #container></ng-container>

        <!--adaptive rendering-->
        <responsive-renderer
            [sharedPopupActionSheetTemplate]="sharedPopupActionSheetTemplate"
            [isActionSheetExpanded]="isActionSheetExpanded"
            [title]="title"
            [showTextInput]="true"
            [showActionButtons]="true"
            [subtitle]="subtitle"
            (closePopup)="togglePopup(false)"
            (textInputChange)="onAdaptiveTextBoxChange($event)"
            [placeholder]="placeholder"
            (navigate)="handleNavigate($event)"
            (onApply)="applyValue()"
            (onCancel)="cancelValue()"
            >
        </responsive-renderer>

        <ng-template #sharedPopupActionSheetTemplate>
            <!--header template-->
            <ng-template *ngIf="headerTemplate"
                [templateContext]="{
                    templateRef: headerTemplate.templateRef
                }">
            </ng-template>
            <!--custom item template-->
            <div
                *ngIf="allowCustom && text"
                class="k-list"
                [ngClass]="customItemSizeClass"
            >
                <div class="k-list-item k-custom-item" kendoDropDownsSelectable [multipleSelection]="true" [index]="-1">
                    <ng-template *ngIf="customItemTemplate;else default_custom_item_template"
                        [templateContext]="{
                            templateRef: customItemTemplate.templateRef,
                            $implicit: text
                        }">
                    </ng-template>
                    <ng-template #default_custom_item_template>{{ text }}</ng-template>
                    <kendo-icon-wrapper
                        class="k-icon"
                        name="plus"
                        [svgIcon]="plusIcon"
                    >
                    </kendo-icon-wrapper>
                </div>
            </div>
            <!--list-->
            <kendo-list
                #optionsList
                [size]="size"
                [rounded]="rounded"
                [id]="listBoxId"
                [optionPrefix]="optionPrefix"
                [data]="data"
                [textField]="textField"
                [valueField]="valueField"
                [template]="template"
                [groupTemplate]="groupTemplate"
                [fixedGroupTemplate]="fixedGroupTemplate"
                [height]="listHeight"
                [show]="isOpen"
                [multipleSelection]="true"
                [virtual]="virtual"
                (pageChange)="pageChange($event)"
                [checkboxes]="checkboxes"
                [isMultiselect]="true"
                [isActionSheetExpanded]="isActionSheetExpanded"
                [showStickyHeader]="showStickyHeader"
            >
            </kendo-list>
            <!--no data template-->
            <div class="k-no-data" *ngIf="data.length === 0">
                <ng-template [ngIf]="noDataTemplate"
                    [templateContext]="{
                        templateRef: noDataTemplate ? noDataTemplate.templateRef : undefined
                    }">
                </ng-template>
                <ng-template [ngIf]="!noDataTemplate">
                    <div>{{ messageFor('noDataText') }}</div>
                </ng-template>
            </div>
            <!--footer template-->
            <ng-template *ngIf="footerTemplate"
                [templateContext]="{
                    templateRef: footerTemplate.templateRef
                }">
            </ng-template>
        </ng-template>
  `,
      standalone: true,
      imports: [LocalizedMessagesDirective3, SharedDropDownEventsDirective, NgIf, NgTemplateOutlet, SeparatorComponent, TagListComponent, SearchBarComponent, IconWrapperComponent, ResizeSensorComponent, ResponsiveRendererComponent, TemplateContextDirective, NgClass, SelectableDirective, ListComponent]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: LocalizationService
    }, {
      type: PopupService
    }, {
      type: DataService
    }, {
      type: SelectionService2
    }, {
      type: NavigationService3
    }, {
      type: DisabledItemsService
    }, {
      type: ChangeDetectorRef
    }, {
      type: KeyValueDiffers
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: Injector
    }, {
      type: ElementRef
    }, {
      type: AdaptiveService
    }];
  }, {
    responsiveRendererComponent: [{
      type: ViewChild,
      args: [ResponsiveRendererComponent]
    }],
    showStickyHeader: [{
      type: Input
    }],
    focusableId: [{
      type: Input
    }],
    autoClose: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    textField: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input,
      args: ["tabIndex"]
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    subtitle: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    itemDisabled: [{
      type: Input
    }],
    checkboxes: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    filterable: [{
      type: Input
    }],
    virtual: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    listHeight: [{
      type: Input
    }],
    valuePrimitive: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    tagMapper: [{
      type: Input
    }],
    allowCustom: [{
      type: Input
    }],
    valueNormalizer: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    filterChange: [{
      type: Output
    }],
    valueChange: [{
      type: Output
    }],
    open: [{
      type: Output
    }],
    opened: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    closed: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    inputFocus: [{
      type: Output
    }],
    inputBlur: [{
      type: Output
    }],
    removeTag: [{
      type: Output
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    searchbar: [{
      type: ViewChild,
      args: [SearchBarComponent, {
        static: true
      }]
    }],
    tagList: [{
      type: ViewChild,
      args: [TagListComponent, {
        static: true
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        static: true
      }]
    }],
    optionsList: [{
      type: ViewChild,
      args: ["optionsList", {
        static: false
      }]
    }],
    template: [{
      type: ContentChild,
      args: [ItemTemplateDirective, {
        static: false
      }]
    }],
    customItemTemplate: [{
      type: ContentChild,
      args: [CustomItemTemplateDirective, {
        static: false
      }]
    }],
    groupTemplate: [{
      type: ContentChild,
      args: [GroupTemplateDirective, {
        static: false
      }]
    }],
    fixedGroupTemplate: [{
      type: ContentChild,
      args: [FixedGroupTemplateDirective, {
        static: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective, {
        static: false
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective, {
        static: false
      }]
    }],
    tagTemplate: [{
      type: ContentChild,
      args: [TagTemplateDirective, {
        static: false
      }]
    }],
    groupTagTemplate: [{
      type: ContentChild,
      args: [GroupTagTemplateDirective, {
        static: false
      }]
    }],
    noDataTemplate: [{
      type: ContentChild,
      args: [NoDataTemplateDirective, {
        static: false
      }]
    }],
    suffixTemplate: [{
      type: ContentChild,
      args: [SuffixTemplateDirective]
    }],
    prefixTemplate: [{
      type: ContentChild,
      args: [PrefixTemplateDirective]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-multiselect"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    isLoading: [{
      type: HostBinding,
      args: ["class.k-loading"]
    }]
  });
})();
var ColumnCellTemplateDirective = class _ColumnCellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ColumnCellTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ColumnCellTemplateDirective,
    selectors: [["", "kendoMultiColumnComboBoxColumnCellTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMultiColumnComboBoxColumnCellTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var ColumnHeaderTemplateDirective = class _ColumnHeaderTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ColumnHeaderTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnHeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ColumnHeaderTemplateDirective,
    selectors: [["", "kendoMultiColumnComboBoxColumnHeaderTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnHeaderTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMultiColumnComboBoxColumnHeaderTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var ComboBoxColumnComponent = class _ComboBoxColumnComponent {
  /**
   * @hidden
   */
  cellTemplate;
  /**
   * @hidden
   */
  headerTemplate;
  /**
   * The field to which the column is bound.
   *
   * > The `field` property can be set to point to a nested property value - e.g. `category.name`.
   */
  field;
  /**
   * The title of the column.
   */
  title;
  /**
   * The width of the column (in pixels).
   */
  width;
  /**
   * Sets the visibility of the column.
   *
   * @default false
   */
  hidden = false;
  /**
   * Sets the custom styles for the table cells (excluding the header ones) of the column.
   * Under the hood, to apply the property, the style option uses the NgStyle directive.
   */
  style;
  /**
   * Sets the custom styles for the header cell of the column.
   * Under the hood, to apply the property, the headerStyle option uses the NgStyle directive.
   */
  headerStyle;
  /**
   * Sets the custom CSS classes to the column cells.
   * Under the hood, to apply the property, the class option uses the NgClass directive.
   */
  class;
  /**
   * Sets the custom CSS classes to the column header cell.
   * Under the hood, to apply the property, the headerClass option uses the NgClass directive.
   */
  headerClass;
  /**
   * Sets the condition that needs to be satisfied for a column to remain visible.
   * If you set the [`hidden`]({% slug api_dropdowns_comboboxcolumncomponent %}#toc-hidden) property, the behavior of `media` is overridden.
   */
  media;
  /**
   * @hidden
   */
  matchesMedia = true;
  static ɵfac = function ComboBoxColumnComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ComboBoxColumnComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ComboBoxColumnComponent,
    selectors: [["kendo-combobox-column"]],
    contentQueries: function ComboBoxColumnComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ColumnCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, ColumnHeaderTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
      }
    },
    inputs: {
      field: "field",
      title: "title",
      width: "width",
      hidden: "hidden",
      style: "style",
      headerStyle: "headerStyle",
      class: "class",
      headerClass: "headerClass",
      media: "media"
    },
    decls: 0,
    vars: 0,
    template: function ComboBoxColumnComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ComboBoxColumnComponent, [{
    type: Component,
    args: [{
      selector: "kendo-combobox-column",
      template: "",
      standalone: true
    }]
  }], null, {
    cellTemplate: [{
      type: ContentChild,
      args: [ColumnCellTemplateDirective, {
        static: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [ColumnHeaderTemplateDirective, {
        static: false
      }]
    }],
    field: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    hidden: [{
      type: Input
    }],
    style: [{
      type: Input
    }],
    headerStyle: [{
      type: Input
    }],
    class: [{
      type: Input
    }],
    headerClass: [{
      type: Input
    }],
    media: [{
      type: Input
    }]
  });
})();
var SCROLLBAR_WIDTH;
var scrollbarWidth = () => {
  if (isNaN(SCROLLBAR_WIDTH)) {
    const div = document.createElement("div");
    div.style.cssText = "overflow: scroll; overflow-x: hidden; zoom: 1; clear: both; display: block;";
    div.innerHTML = "&nbsp;";
    document.body.appendChild(div);
    SCROLLBAR_WIDTH = div.offsetWidth - div.scrollWidth;
    document.body.removeChild(div);
  }
  return SCROLLBAR_WIDTH;
};
var allColumnsWidthsSet = (columns) => {
  if (!isPresent7(columns) || columns.length === 0) {
    return false;
  }
  return columns.toArray().every((column) => !isNaN(column.width) && column.width > 0);
};
var getRowWidthFromColumnsMeta = (columns) => {
  if (!allColumnsWidthsSet(columns)) {
    return null;
  }
  const bordersWidth = 2;
  const initialRowWidht = scrollbarWidth() + bordersWidth;
  return columns.reduce((totalWidth, column) => {
    if (!column.hidden && column.matchesMedia) {
      totalWidth += parseInt(column.width, 10);
    }
    return totalWidth;
  }, initialRowWidht);
};
var MultiColumnComboBoxComponent = class _MultiColumnComboBoxComponent extends ComboBoxComponent {
  hostElement;
  /**
   * @hidden
   */
  animationDuration = animationDuration2;
  /**
   * @hidden
   */
  hostClasses = true;
  /**
   * @hidden
   */
  get isDisabled() {
    return this.disabled;
  }
  /**
   * A query list of all declared columns.
   */
  columns;
  /**
   * @hidden
   */
  set header(header) {
    this.updateHeaderPadding(header && header.nativeElement);
  }
  /**
   * @hidden
   */
  set headerTable(headerTable) {
    this._headerTable = headerTable;
    if (this.headerTable) {
      this.zone.onStable.pipe(take(1)).subscribe(() => {
        this.rowWidth = this.calculateRowWidth();
      });
    }
  }
  get headerTable() {
    return this._headerTable;
  }
  /**
   * @hidden
   */
  set headerColumns(columns) {
    this.zone.onStable.pipe(take(1)).subscribe(() => {
      this.headerColumnWidths = columns.map((column) => column.nativeElement.offsetWidth);
    });
  }
  /**
   * @hidden
   */
  rowWidth;
  /**
   * @hidden
   */
  headerColumnWidths = [];
  /**
   * @hidden
   */
  totalColumnsWidth;
  get popupWidth() {
    const wrapperOffsetWidth = this.wrapper.nativeElement.offsetWidth;
    const min = `${wrapperOffsetWidth}px`;
    const width = this.popupSettings.width || getRowWidthFromColumnsMeta(this.columns) || wrapperOffsetWidth;
    const max = isNaN(width) ? width : `${width}px`;
    return {
      min,
      max
    };
  }
  _headerTable;
  removeWindowResizeListener = noop6;
  columnsChangeSubscription = new Subscription();
  /**
   * @hidden
   */
  get tableSizeClass() {
    return `${this.size ? getSizeClass2("table", this.size) : ""}`;
  }
  /**
   * @hidden
   */
  get listContainerClasses() {
    return ["k-popup", "k-dropdowngrid-popup"].concat(this.popupSettings.popupClass || []);
  }
  constructor(localization, popupService, selectionService, navigationService, disabledItemsService, dataService, zone, changeDetector, renderer, wrapper, injector, hostElement, adaptiveService) {
    super(wrapper, localization, popupService, selectionService, navigationService, disabledItemsService, dataService, zone, changeDetector, renderer, injector, hostElement, adaptiveService);
    this.hostElement = hostElement;
    this.defaultVirtualItemHeight = 36;
    this.defaultVirtualPageSize = 30;
  }
  ngAfterViewInit() {
    this.updateColumnsMediaState();
    this.addWindowResizeListener();
    this.windowSize = this.adaptiveService.size;
    this.rowWidth = this.calculateRowWidth();
    this.totalColumnsWidth = this.columns.reduce((total, currentColumn) => total + currentColumn.width, 0);
    this.columnsChangeSubscription = this.columns.changes.subscribe(() => {
      this.rowWidth = this.calculateRowWidth();
      this.totalColumnsWidth = this.columns.reduce((total, currentColumn) => total + currentColumn.width, 0);
    });
    this.cdr.detectChanges();
    if (this.actionSheet && isDocumentAvailable()) {
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-height", "60vh");
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-max-height", "none");
    }
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.removeWindowResizeListener();
    if (this.columnsChangeSubscription) {
      this.columnsChangeSubscription.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  textFrom(dataItem, field) {
    return getter2(dataItem, field);
  }
  /**
   * @hidden
   *
   * Adds or removes a padding value at the end of the header container equal to the size of the scrollbar.
   * As when the items container has a scrollbar, the column headers and the cells are misaligned.
   * When the container has a scrollbar, the padding style is added, and when there is none - it is removed.
   */
  updateHeaderPadding(header) {
    if (!isPresent7(header)) {
      return;
    }
    const headerPaddingPosition = this.localization.rtl ? "padding-left" : "padding-right";
    if (this.optionsList.hasScrollbar() && scrollbarWidth() > 0) {
      this.renderer.setStyle(header, headerPaddingPosition, `${scrollbarWidth()}px`);
    } else {
      this.renderer.removeStyle(header, headerPaddingPosition);
    }
  }
  /**
   *
   * @hidden
   */
  getColumnWidth(index) {
    if (!this.virtual) {
      return this.columns.get(index).width;
    }
    return this.headerColumnWidths[index];
  }
  verifySettings() {
    if (!isDevMode()) {
      return;
    }
    if (isPresent7(this.data) && this.data.length > 0 && this.data.some((item) => !isObject2(item))) {
      throw new Error(MultiColumnComboBoxMessages.data);
    }
    if (!isPresent7(this.valueField) || !isPresent7(this.textField)) {
      throw new Error(MultiColumnComboBoxMessages.textAndValue);
    }
    super.verifySettings();
  }
  addWindowResizeListener() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.zone.runOutsideAngular(() => this.removeWindowResizeListener = this.renderer.listen(window, "resize", this.updateColumnsMediaState.bind(this)));
  }
  updateColumnsMediaState() {
    if (!(isPresent7(this.columns) && isDocumentAvailable()) || this.isActionSheetExpanded) {
      return;
    }
    this.columns.forEach((column) => {
      const matchesMedia = !column.media || window.matchMedia(column.media).matches;
      if (column.matchesMedia !== matchesMedia) {
        column.matchesMedia = matchesMedia;
        if (this.isOpen) {
          this.zone.run(() => this.popupRef.popupElement.style.width = this.popupWidth.max);
        }
      }
    });
  }
  calculateRowWidth() {
    if (this.isActionSheetExpanded || !this.virtual) {
      return;
    }
    return this.headerTable?.nativeElement.offsetWidth;
  }
  static ɵfac = function MultiColumnComboBoxComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiColumnComboBoxComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(NavigationService3), ɵɵdirectiveInject(DisabledItemsService), ɵɵdirectiveInject(DataService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MultiColumnComboBoxComponent,
    selectors: [["kendo-multicolumncombobox"]],
    contentQueries: function MultiColumnComboBoxComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ComboBoxColumnComponent, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columns = _t);
      }
    },
    viewQuery: function MultiColumnComboBoxComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c182, 5);
        ɵɵviewQuery(_c192, 5);
        ɵɵviewQuery(_c202, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.header = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTable = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerColumns = _t);
      }
    },
    hostVars: 4,
    hostBindings: function MultiColumnComboBoxComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-dropdowngrid", ctx.hostClasses)("k-disabled", ctx.isDisabled);
      }
    },
    features: [ɵɵProvidersFeature([SelectionService2, DataService, NavigationService3, DisabledItemsService, LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.multicolumncombobox"
    }, {
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _MultiColumnComboBoxComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _MultiColumnComboBoxComponent)
    }, {
      provide: FilterableComponent,
      useExisting: forwardRef(() => _MultiColumnComboBoxComponent)
    }, {
      provide: MultiTabStop,
      useExisting: forwardRef(() => _MultiColumnComboBoxComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 20,
    vars: 38,
    consts: () => {
      let i18n_16;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_16 = goog.getMsg("NO DATA FOUND");
        i18n_16 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_16;
      } else {
        i18n_16 = $localize`:kendo.multicolumncombobox.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;
      }
      let i18n_17;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_17 = goog.getMsg("clear");
        i18n_17 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_17;
      } else {
        i18n_17 = $localize`:kendo.multicolumncombobox.clearTitle|The title of the clear button:clear`;
      }
      let i18n_18;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_18 = goog.getMsg("Select");
        i18n_18 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_18;
      } else {
        i18n_18 = $localize`:kendo.multicolumncombobox.selectButtonText|The title of the select button:Select`;
      }
      let i18n_19;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_19 = goog.getMsg("Options list");
        i18n_19 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_19;
      } else {
        i18n_19 = $localize`:kendo.multicolumncombobox.popupLabel|The label of the popup element that contains the list of options
                when its role is 'region':Options list`;
      }
      return [["select", ""], ["popupTemplate", ""], ["container", ""], ["sharedPopupActionSheetTemplate", ""], ["header", ""], ["headerWrap", ""], ["headerTable", ""], ["rowTemplate", ""], ["optionsList", ""], ["columnHeader", ""], ["kendoMultiColumnComboBoxLocalizedMessages", "", "noDataText", i18n_16, "clearTitle", i18n_17, "selectButtonText", i18n_18, "popupLabel", i18n_19], ["kendoDropDownSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused"], ["class", "k-input-prefix k-input-prefix-horizontal", 4, "ngIf"], [4, "ngIf"], ["kendoSearchbar", "", 3, "onNavigate", "valueChange", "onBlur", "onFocus", "click", "ariaControls", "ariaExpanded", "id", "isLoading", "isSuggestable", "isFilterable", "activeDescendant", "userInput", "suggestedText", "disabled", "readonly", "tabIndex", "isRequired", "placeholder", "inputAttributes"], ["class", "k-clear-value", "aria-hidden", "true", 3, "visibility", "kendoEventsOutsideAngular", "click", 4, "ngIf"], ["class", "k-i-loading k-input-loading-icon k-icon", 4, "ngIf"], ["class", "k-input-suffix k-input-suffix-horizontal", 4, "ngIf"], ["tabindex", "-1", "aria-hidden", "true", "unselectable", "on", "type", "button", 1, "k-input-button", "k-button", "k-icon-button", 3, "ngClass", "kendoEventsOutsideAngular"], ["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [3, "resize", 4, "ngIf"], [3, "closePopup", "textInputChange", "navigate", "sharedPopupActionSheetTemplate", "isActionSheetExpanded", "title", "showTextInput", "subtitle", "placeholder"], [1, "k-input-prefix", "k-input-prefix-horizontal"], [3, "ngTemplateOutlet"], ["aria-hidden", "true", 1, "k-clear-value", 3, "click", "kendoEventsOutsideAngular"], ["name", "x", 3, "svgIcon"], [1, "k-i-loading", "k-input-loading-icon", "k-icon"], [1, "k-input-suffix", "k-input-suffix-horizontal"], [4, "ngTemplateOutlet"], [3, "resize"], [1, "k-data-table", 3, "ngClass"], [1, "k-table-header"], [1, "k-table-header-wrap"], ["role", "presentation", 1, "k-table"], [4, "ngFor", "ngForOf"], [1, "k-table-thead"], [1, "k-table-row"], [3, "pageChange", "listResize", "popupListScroll", "optionPrefix", "data", "textField", "valueField", "template", "groupTemplate", "fixedGroupTemplate", "height", "show", "id", "virtual", "type", "rowWidth", "showStickyHeader"], ["class", "k-no-data", 4, "ngIf"], [3, "templateContext"], [3, "width", 4, "ngIf"], ["class", "k-table-th", 3, "ngStyle", "ngClass", 4, "ngIf"], [1, "k-table-th", 3, "ngStyle", "ngClass"], ["class", "k-table-td", 3, "ngClass", "width", "max-width", "ngStyle", 4, "ngIf"], [1, "k-table-td", 3, "ngClass", "ngStyle"], [1, "k-no-data"], [3, "ngIf", "templateContext"], [3, "ngIf"], [1, "k-table-footer"], [1, "k-table"], [1, "k-table-tfoot"], [1, "k-table-td"]];
    },
    template: function MultiColumnComboBoxComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 10);
        ɵɵelementContainerStart(1, 11);
        ɵɵtwoWayListener("isFocusedChange", function MultiColumnComboBoxComponent_Template_ng_container_isFocusedChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.isFocused, $event) || (ctx.isFocused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function MultiColumnComboBoxComponent_Template_ng_container_handleBlur_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function MultiColumnComboBoxComponent_Template_ng_container_onFocus_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵtemplate(2, MultiColumnComboBoxComponent_span_2_Template, 2, 1, "span", 12)(3, MultiColumnComboBoxComponent_kendo_separator_3_Template, 1, 0, "kendo-separator", 13);
        ɵɵelementStart(4, "input", 14);
        ɵɵlistener("onNavigate", function MultiColumnComboBoxComponent_Template_input_onNavigate_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleNavigate($event));
        })("valueChange", function MultiColumnComboBoxComponent_Template_input_valueChange_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.searchBarChange($event));
        })("onBlur", function MultiColumnComboBoxComponent_Template_input_onBlur_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputBlur());
        })("onFocus", function MultiColumnComboBoxComponent_Template_input_onFocus_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputFocus());
        })("click", function MultiColumnComboBoxComponent_Template_input_click_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleClick());
        });
        ɵɵelementEnd();
        ɵɵtemplate(5, MultiColumnComboBoxComponent_span_5_Template, 2, 7, "span", 15)(6, MultiColumnComboBoxComponent_span_6_Template, 1, 0, "span", 16)(7, MultiColumnComboBoxComponent_kendo_separator_7_Template, 1, 0, "kendo-separator", 13)(8, MultiColumnComboBoxComponent_span_8_Template, 2, 1, "span", 17);
        ɵɵelementStart(9, "button", 18, 0);
        ɵɵelement(11, "kendo-icon-wrapper", 19);
        ɵɵelementEnd();
        ɵɵelementContainerEnd();
        ɵɵtemplate(12, MultiColumnComboBoxComponent_ng_template_12_Template, 1, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor)(14, MultiColumnComboBoxComponent_kendo_resize_sensor_14_Template, 1, 0, "kendo-resize-sensor", 20);
        ɵɵelementContainer(15, null, 2);
        ɵɵelementStart(17, "responsive-renderer", 21);
        ɵɵlistener("closePopup", function MultiColumnComboBoxComponent_Template_responsive_renderer_closePopup_17_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.togglePopup(false));
        })("textInputChange", function MultiColumnComboBoxComponent_Template_responsive_renderer_textInputChange_17_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onAdaptiveTextBoxChange($event));
        })("navigate", function MultiColumnComboBoxComponent_Template_responsive_renderer_navigate_17_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleNavigate($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(18, MultiColumnComboBoxComponent_ng_template_18_Template, 19, 22, "ng-template", null, 3, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const sharedPopupActionSheetTemplate_r4 = ɵɵreference(19);
        ɵɵadvance();
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.isFocused);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate && ctx.prefixTemplate.showSeparator);
        ɵɵadvance();
        ɵɵproperty("ariaControls", ctx.ariaControls)("ariaExpanded", ctx.isOpen)("id", ctx.focusableId)("isLoading", ctx.loading)("isSuggestable", ctx.suggest)("isFilterable", ctx.filterable)("activeDescendant", ctx.activeDescendant)("userInput", ctx.text)("suggestedText", ctx.getSuggestion())("disabled", ctx.disabled)("readonly", ctx.readonly)("tabIndex", ctx.tabIndex)("isRequired", ctx.isControlRequired)("placeholder", ctx.placeholder)("inputAttributes", ctx.inputAttributes);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.clearButton && !ctx.loading && !ctx.disabled && (!ctx.readonly || ctx.readonly && ctx.isAdaptiveModeEnabled && ctx.windowSize !== "large") && (ctx.text == null ? null : ctx.text.length));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.loading);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffixTemplate && ctx.suffixTemplate.showSeparator);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffixTemplate);
        ɵɵadvance();
        ɵɵproperty("ngClass", ctx.selectButtonClasses)("kendoEventsOutsideAngular", ɵɵpureFunction1(36, _c143, ctx.preventEventDefault));
        ɵɵattribute("aria-label", ctx.messageFor("selectButtonText"))("disabled", ctx.disabled ? "" : null);
        ɵɵadvance(2);
        ɵɵproperty("name", ctx.icon || "caret-alt-down")("svgIcon", ctx.svgIcon || ctx.caretAltDownIcon);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.isOpen || ctx.isAdaptiveModeEnabled);
        ɵɵadvance(3);
        ɵɵproperty("sharedPopupActionSheetTemplate", sharedPopupActionSheetTemplate_r4)("isActionSheetExpanded", ctx.isActionSheetExpanded)("title", ctx.title)("showTextInput", true)("subtitle", ctx.subtitle)("placeholder", ctx.placeholder);
      }
    },
    dependencies: [LocalizedMessagesDirective3, SharedDropDownEventsDirective, NgIf, NgTemplateOutlet, SeparatorComponent, SearchBarComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgClass, ResizeSensorComponent, ResponsiveRendererComponent, TemplateContextDirective, NgForOf, NgStyle, ListComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiColumnComboBoxComponent, [{
    type: Component,
    args: [{
      providers: [SelectionService2, DataService, NavigationService3, DisabledItemsService, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.multicolumncombobox"
      }, {
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => MultiColumnComboBoxComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => MultiColumnComboBoxComponent)
      }, {
        provide: FilterableComponent,
        useExisting: forwardRef(() => MultiColumnComboBoxComponent)
      }, {
        provide: MultiTabStop,
        useExisting: forwardRef(() => MultiColumnComboBoxComponent)
      }],
      selector: "kendo-multicolumncombobox",
      template: `
        <ng-container
            kendoMultiColumnComboBoxLocalizedMessages
            i18n-noDataText="
                kendo.multicolumncombobox.noDataText|The text displayed in the popup when there are no items
            "
            noDataText="NO DATA FOUND"
            i18n-clearTitle="kendo.multicolumncombobox.clearTitle|The title of the clear button"
            clearTitle="clear"
            i18n-selectButtonText="kendo.multicolumncombobox.selectButtonText|The title of the select button"
            selectButtonText="Select"
            i18n-popupLabel="
                kendo.multicolumncombobox.popupLabel|The label of the popup element that contains the list of options
                when its role is 'region'
            "
            popupLabel="Options list"
        ></ng-container>

        <ng-container
            kendoDropDownSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="isFocused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
        >
            <span *ngIf="prefixTemplate" class="k-input-prefix k-input-prefix-horizontal">
                <ng-template [ngTemplateOutlet]="prefixTemplate?.templateRef">
                </ng-template>
            </span>
            <kendo-separator *ngIf="prefixTemplate && prefixTemplate.showSeparator"></kendo-separator>
            <input 
                kendoSearchbar
                [ariaControls]="ariaControls"
                [ariaExpanded]="isOpen"
                [id]="focusableId"
                [isLoading]="loading"
                [isSuggestable]="suggest"
                [isFilterable]="filterable"
                [activeDescendant]="activeDescendant"
                [userInput]="text"
                [suggestedText]="getSuggestion()"
                [disabled]="disabled"
                [readonly]="readonly"
                [tabIndex]="tabIndex"
                [isRequired]="isControlRequired"
                [placeholder]="placeholder"
                [inputAttributes]="inputAttributes"
                (onNavigate)="handleNavigate($event)"
                (valueChange)="searchBarChange($event)"
                (onBlur)="handleInputBlur()"
                (onFocus)="handleInputFocus()"
                (click)="handleClick()"
            />
            <span
                *ngIf="clearButton && !loading && !disabled && (!readonly || readonly && isAdaptiveModeEnabled && windowSize !== 'large')  && text?.length"
                class="k-clear-value"
                [style.visibility]="clearButtonVisiblity"
                aria-hidden="true"
                [attr.title]="messageFor('clearTitle')"
                (click)="clearValue($event)"
                [kendoEventsOutsideAngular]="{
                    mousedown: preventEventDefault
                }"
            >
                <kendo-icon-wrapper name="x" [svgIcon]="xIcon"> </kendo-icon-wrapper>
            </span>

            <span *ngIf="loading" class="k-i-loading k-input-loading-icon k-icon"></span>
            <kendo-separator *ngIf="suffixTemplate && suffixTemplate.showSeparator"></kendo-separator>
            <span *ngIf="suffixTemplate" class="k-input-suffix k-input-suffix-horizontal">
                <ng-template [ngTemplateOutlet]="suffixTemplate?.templateRef">
                </ng-template>
            </span>
            <button
                #select
                tabindex="-1"
                aria-hidden="true"
                unselectable="on"
                type="button"
                class="k-input-button k-button k-icon-button"
                [ngClass]="selectButtonClasses"
                [attr.aria-label]="messageFor('selectButtonText')"
                [attr.disabled]="disabled ? '' : null"
                [kendoEventsOutsideAngular]="{
                    mousedown: preventEventDefault
                }"
            >
                <kendo-icon-wrapper
                    [name]="icon || 'caret-alt-down'"
                    innerCssClass="k-button-icon"
                    [svgIcon]="svgIcon || caretAltDownIcon"
                >
                </kendo-icon-wrapper>
            </button>
        </ng-container>

        <ng-template #popupTemplate>
            <!--popup/actionsheet content-->
            <ng-container *ngTemplateOutlet="sharedPopupActionSheetTemplate"></ng-container>
        </ng-template>

        <kendo-resize-sensor *ngIf="isOpen || isAdaptiveModeEnabled" (resize)="onResize()"> </kendo-resize-sensor>

        <!-- when the popupSettings.appendTo value is set to 'component', this container is used -->
        <ng-container #container></ng-container>

        <!--adaptive rendering-->
        <responsive-renderer
            [sharedPopupActionSheetTemplate]="sharedPopupActionSheetTemplate"
            [isActionSheetExpanded]="isActionSheetExpanded"
            [title]="title"
            [showTextInput]="true"
            [subtitle]="subtitle"
            (closePopup)="togglePopup(false)"
            (textInputChange)="onAdaptiveTextBoxChange($event)"
            (navigate)="handleNavigate($event)"
            [placeholder]="placeholder"
            >
        </responsive-renderer>

        <ng-template #sharedPopupActionSheetTemplate>
            <!--user-defined header template -->
            <ng-template
                *ngIf="headerTemplate"
                [templateContext]="{
                    templateRef: headerTemplate?.templateRef
                }"
            >
            </ng-template>
            <!--data table-->
            <div class="k-data-table" [ngClass]="tableSizeClass">
                <!--grid header-->
                <div #header class="k-table-header">
                    <div #headerWrap class="k-table-header-wrap">
                        <table #headerTable class="k-table" role="presentation">
                            <colgroup>
                                <ng-container *ngFor="let column of columns">
                                    <col *ngIf="!column.hidden && column.matchesMedia" [style.width.px]="column.width" />
                                </ng-container>
                            </colgroup>
                            <thead class="k-table-thead">
                                <tr class="k-table-row">
                                    <ng-container *ngFor="let column of columns">
                                        <th
                                            #columnHeader
                                            *ngIf="!column.hidden && column.matchesMedia"
                                            class="k-table-th"
                                            [ngStyle]="column.headerStyle"
                                            [ngClass]="column.headerClass"
                                        >
                                            <ng-container *ngIf="!column.headerTemplate">
                                                {{ column.title || column.field }}
                                            </ng-container>
                                            <ng-template
                                                *ngIf="column.headerTemplate"
                                                [templateContext]="{
                                                    templateRef: column.headerTemplate?.templateRef,
                                                    $implicit: column,
                                                    column: column
                                                }"
                                            >
                                            </ng-template>
                                        </th>
                                    </ng-container>
                                </tr>
                            </thead>
                        </table>
                    </div>
                </div>
                <!-- item template -->
                <ng-template #rowTemplate let-dataItem>
                    <ng-container *ngFor="let column of columns; let i = index">
                        <span
                            *ngIf="!column.hidden && column.matchesMedia"
                            class="k-table-td"
                            [ngClass]="column.class"
                            [style.width.px]="getColumnWidth(i)"
                            [style.max-width.px]="getColumnWidth(i)"
                            [ngStyle]="column.style"
                        >
                            <ng-container *ngIf="!column.cellTemplate">
                                {{ textFrom(dataItem, column.field) }}
                            </ng-container>
                            <ng-template
                                *ngIf="column.cellTemplate"
                                [templateContext]="{
                                    templateRef: column.cellTemplate?.templateRef,
                                    $implicit: dataItem,
                                    dataItem: dataItem,
                                    column: column
                                }"
                            >
                            </ng-template>
                        </span>
                    </ng-container>
                </ng-template>
                <kendo-list
                    #optionsList
                    [optionPrefix]="optionPrefix"
                    [data]="data"
                    [textField]="textField"
                    [valueField]="valueField"
                    [template]="{ templateRef: rowTemplate }"
                    [groupTemplate]="groupTemplate"
                    [fixedGroupTemplate]="fixedGroupTemplate"
                    [height]="listHeight"
                    [show]="isOpen"
                    [id]="listBoxId"
                    [virtual]="virtual"
                    [type]="'dropdowngrid'"
                    [rowWidth]="rowWidth"
                    [showStickyHeader]="showStickyHeader"
                    (pageChange)="pageChange($event)"
                    (listResize)="updateHeaderPadding(header)"
                    (popupListScroll)="headerWrap.scrollLeft = $event.target.scrollLeft;"
                >
                </kendo-list>

                <!--no-data template-->
                <div class="k-no-data" *ngIf="data.length === 0">
                    <ng-template
                        [ngIf]="noDataTemplate"
                        [templateContext]="{
                            templateRef: noDataTemplate?.templateRef
                        }"
                    >
                    </ng-template>
                    <ng-template [ngIf]="!noDataTemplate">
                        <div>{{ messageFor('noDataText') }}</div>
                    </ng-template>
                </div>

                <!--user-defined footer template-->
                <ng-container *ngIf="footerTemplate">
                    <div class="k-table-footer">
                        <table class="k-table">
                            <tfoot class="k-table-tfoot">
                                <tr class="k-table-row">
                                    <td class="k-table-td">
                                        <ng-template
                                            [templateContext]="{
                                                templateRef: footerTemplate.templateRef
                                            }"
                                        >
                                        </ng-template>
                                    </td>
                                </tr>
                            </tfoot>
                        </table>
                    </div>
                </ng-container>
            </div>
        </ng-template>
    `,
      standalone: true,
      imports: [LocalizedMessagesDirective3, SharedDropDownEventsDirective, NgIf, NgTemplateOutlet, SeparatorComponent, SearchBarComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgClass, ResizeSensorComponent, ResponsiveRendererComponent, TemplateContextDirective, NgForOf, NgStyle, ListComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: PopupService
    }, {
      type: SelectionService2
    }, {
      type: NavigationService3
    }, {
      type: DisabledItemsService
    }, {
      type: DataService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: Injector
    }, {
      type: ElementRef
    }, {
      type: AdaptiveService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-dropdowngrid"]
    }],
    isDisabled: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    columns: [{
      type: ContentChildren,
      args: [ComboBoxColumnComponent]
    }],
    header: [{
      type: ViewChild,
      args: ["header", {
        static: false
      }]
    }],
    headerTable: [{
      type: ViewChild,
      args: ["headerTable", {
        static: false
      }]
    }],
    headerColumns: [{
      type: ViewChildren,
      args: ["columnHeader"]
    }]
  });
})();
var NodeTemplateDirective2 = class _NodeTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function NodeTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NodeTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NodeTemplateDirective,
    selectors: [["", "kendoDropDownTreeNodeTemplate", ""], ["", "kendoMultiSelectTreeNodeTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NodeTemplateDirective2, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownTreeNodeTemplate], [kendoMultiSelectTreeNodeTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var DEFAULT_POPUP_SETTINGS$1 = {
  animate: true
};
var hasChildren$1 = () => false;
var fetchChildren$1 = () => of([]);
var itemDisabled$1 = () => false;
var isNodeVisible$1 = () => true;
var DEFAULT_SIZE$12 = "medium";
var DEFAULT_ROUNDED$12 = "medium";
var DEFAULT_FILL_MODE$12 = "solid";
var stopPropagation = (event) => event.stopImmediatePropagation();
var DropDownTreeComponent = class _DropDownTreeComponent {
  injector;
  wrapper;
  popupService;
  navigationService;
  renderer;
  _zone;
  cdr;
  localization;
  adaptiveService;
  /**
   * @hidden
   */
  icon;
  /**
   * @hidden
   */
  svgIcon;
  /**
   * @hidden
   */
  touchEnabled = touchEnabled;
  /**
   * @hidden
   */
  animationDuration = animationDuration2;
  /**
   * @hidden
   */
  searchIcon = searchIcon;
  /**
   * @hidden
   */
  caretAltDownIcon = caretAltDownIcon;
  /**
   * @hidden
   */
  xIcon = xIcon;
  /**
   * @hidden
   */
  responsiveRendererComponent;
  /**
   * @hidden
   */
  get actionSheet() {
    return this.responsiveRendererComponent?.actionSheet;
  }
  /**
   * @hidden
   */
  get actionSheetSearchBar() {
    return this.responsiveRendererComponent?.actionSheetSearchBar;
  }
  hostClasses = true;
  get isReadonly() {
    return this.readonly ? "" : null;
  }
  get hostAriaInvalid() {
    return this.formControl?.invalid ? true : null;
  }
  get isDisabled() {
    return this.disabled || null;
  }
  get isLoading() {
    return this.loading;
  }
  get isBusy() {
    return this.loading ? "true" : null;
  }
  get hostAriaControls() {
    return this.isOpen ? this.treeViewId : void 0;
  }
  get id() {
    return this.focusableId;
  }
  direction;
  get hostTabIndex() {
    return this.tabindex;
  }
  role = "combobox";
  ariaHasPopup = "tree";
  get isAriaExpanded() {
    return this.isOpen;
  }
  get hostAriaAutocomplete() {
    return this.filterable ? "list" : null;
  }
  noDataTemplate;
  headerTemplate;
  footerTemplate;
  nodeTemplate;
  valueTemplate;
  popupTemplate;
  container;
  set treeview(treeview) {
    if (treeview) {
      if (this.isFocused && !this.filterable || this.touchEnabled) {
        treeview.focus();
      }
      treeview.animate = true;
      this._treeview = treeview;
    }
  }
  get treeview() {
    return this._treeview;
  }
  filterInput;
  /**
   * Fires each time the popup is about to open
   * ([see example]({% slug openstate_ddt %})).
   * This event is preventable. If you cancel it, the popup will remain closed.
   */
  open = new EventEmitter();
  /**
   * Fires after the popup has been opened.
   */
  opened = new EventEmitter();
  /**
   * Fires each time the popup is about to close
   * ([see example]({% slug openstate_ddt %})).
   * This event is preventable. If you cancel it, the popup will remain open.
   */
  close = new EventEmitter();
  /**
   * Fires after the popup has been closed.
   */
  closed = new EventEmitter();
  /**
   * Fires when the user expands a node in the popup TreeView.
   */
  nodeExpand = new EventEmitter();
  /**
   * Fires when the user collapses a node in the popup TreeView.
   */
  nodeCollapse = new EventEmitter();
  /**
   * Fires each time the user focuses the DropDownTree.
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the DropDownTree gets blurred.
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the value is changed
   * ([see example](slug:events_ddt)).
   */
  valueChange = new EventEmitter();
  /**
   * Fires when the value of the built-in filter input element changes.
   */
  filterChange = new EventEmitter();
  /**
   * Sets and gets the loading state of the DropDownTree.
   */
  loading;
  /**
   * If set to `true`, renders a button on hovering over the component.
   * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.
   */
  clearButton = true;
  /**
   * Sets the data of the DropDownTree.
   *
   * > The data has to be provided in an array-like list with objects.
   */
  set data(data) {
    this._nodes = data;
    this.setState();
  }
  get data() {
    return this._nodes;
  }
  /**
   * Sets the value of the DropDownTree.
   * It can either be of the primitive (string, numbers) or of the complex (objects) type.
   * To define the type, use the `valuePrimitive` option.
   *
   */
  set value(newValue) {
    this._value = newValue;
    this.setState();
  }
  get value() {
    return this._value;
  }
  /**
   * The fields of the data item that provide the text content of the nodes inside the
   * DropDownTree ([see example]({% slug databinding_ddt %})). If the `textField`
   * input is set to an array, each hierarchical level uses the field that corresponds
   * to the same index in the array, or the last item in the array.
   *
   * > The `textField` property can be set to point to a nested property value - e.g. `category.name`.
   */
  textField;
  /**
   * The fields of the data item that provide the value of the nodes inside the
   * DropDownTree ([see example]({% slug databinding_ddt %})). If the `valueField`
   * input is set to an array, each hierarchical level uses the field that corresponds
   * to the same index in the array, or the last item in the array.
   *
   * > The `valueField` property can be set to point to a nested property value - e.g. `category.id`.
   */
  valueField;
  /**
   * Sets the level in the data set where the value can be found when `valueField` is an Array.
   * The field serves to correctly allocate a data item used when the DropDownTree is initialized with a value.
   */
  valueDepth;
  /**
   * A function which determines if a specific node has child nodes.
   */
  hasChildren = hasChildren$1;
  /**
   * A function which provides the child nodes for a given parent node.
   */
  fetchChildren = fetchChildren$1;
  /**
   * The hint which is displayed when the component is empty.
   */
  placeholder = "";
  /**
   * Configures the popup of the DropDownTree.
   *
   * The available options are:
   * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
   * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped.
   * - `height: Number`&mdash;Sets the height of the popup container.
   * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
   * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
   */
  set popupSettings(settings) {
    this._popupSettings = Object.assign({}, DEFAULT_POPUP_SETTINGS$1, settings);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Keeps the current `dataItem` object in order to resolve selection.
   * Needs to be provided when `value` is bound in and `valuePrimitive` is set to true.
   */
  set dataItem(item) {
    this._dataItem = item;
    this.setState();
  }
  get dataItem() {
    return this._dataItem ? this._dataItem : this.value;
  }
  /**
   * Sets the height of the options list in the popup. By default, `listHeight` is 200px.
   *
   * > The `listHeight` property affects only the list of options and not the whole popup container.
   * > To set the height of the popup container, use `popupSettings.height`.
   *
   * > When using `adaptiveMode` and the screen size is `small` or `medium` the `listHeight` property is set to null.
   */
  set listHeight(_listHeight) {
    this._listHeight = _listHeight;
  }
  get listHeight() {
    if (this.isAdaptive) {
      return;
    }
    return this._listHeight;
  }
  _listHeight = 200;
  /**
   * Sets the disabled state of the component. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_ddt#toc-managing-the-dropdowntree-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Sets the read-only state of the component.
   *
   * @default false
   */
  readonly = false;
  /**
   * Specifies the type of the selected value
   * ([more information and example]({% slug valuebinding_ddt %}#toc-primitive-values)).
   * If set to `true`, the selected value has to be of a primitive value.
   */
  valuePrimitive = false;
  /**
   * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   */
  set tabindex(value) {
    const providedTabIndex = Number(value);
    const defaultTabIndex = 0;
    this._tabindex = !isNaN(providedTabIndex) ? providedTabIndex : defaultTabIndex;
  }
  get tabindex() {
    return this.disabled ? -1 : this._tabindex;
  }
  /**
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$12;
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass2("picker", this.size));
    if (size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("picker", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `full`
   * * `none`
   *
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED$12;
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    if (rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the fillMode of the component.
   *
   * The possible values are:
   * * `flat`
   * * `solid` (default)
   * * `outline`
   * * `none`
   *
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$12;
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("picker", this.fillMode));
    if (fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("picker", newFillMode));
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * A function that is executed for each data item and determines if a specific item is disabled.
   */
  itemDisabled = itemDisabled$1;
  /**
   * A function that is executed for each data item and determines if a specific node is expanded.
   */
  isNodeExpanded;
  /**
   * A callback which determines whether a tree node should be rendered as hidden. The utility .k-hidden class is used to hide the nodes.
   * Useful for custom filtering implementations.
   */
  isNodeVisible = isNodeVisible$1;
  /**
   * Indicates whether the child nodes will be fetched on node expand or will be initially prefetched.
   * @default true
   */
  loadOnDemand = true;
  /**
   * Renders the built-in input element for filtering the DropDownTree.
   * If set to `true`, the component emits the `filterChange` event, which can be used to [filter the DropDownTree manually]({% slug filtering_ddt %}#toc-manual-filtering).
   * A built-in filtering implementation is available to use with the [`kendoDropDownTreeHierarchyBinding`]({% slug api_dropdowns_dropdowntreehierarchybindingdirective %}) and [`kendoDropDownTreeFlatBinding`]({% slug api_dropdowns_dropdowntreeflatbindingdirective %}) directives.
   */
  filterable = false;
  /**
   * @hidden
   */
  filter = "";
  /**
   * @hidden
   *
   * Used by the kendo-label and kendo-floatinglabel to access and associate the focusable element with the provided label via aria-labelledby.
   */
  focusableId = `k-${guid()}`;
  set isFocused(isFocused) {
    this.renderer[isFocused ? "addClass" : "removeClass"](this.wrapper.nativeElement, "k-focus");
    this._isFocused = isFocused;
  }
  get isFocused() {
    return this._isFocused;
  }
  get width() {
    const wrapperWidth = this.wrapper.nativeElement.offsetWidth;
    const width = this.popupSettings.width || wrapperWidth;
    const minWidth = isNaN(wrapperWidth) ? wrapperWidth : `${wrapperWidth}px`;
    const maxWidth = isNaN(width) ? width : `${width}px`;
    return {
      min: minWidth,
      max: maxWidth
    };
  }
  get height() {
    const popupHeight = this.popupSettings.height;
    return isPresent7(popupHeight) ? `${popupHeight}px` : "auto";
  }
  /**
   * Returns the current open state. Returns `true` if the popup or actionSheet is open.
   */
  get isOpen() {
    return isTruthy2(isPresent7(this.popupRef) || this.isActionSheetExpanded);
  }
  get clearButtonVisiblity() {
    if (this.touchEnabled) {
      return "visible";
    }
  }
  get isFilterActive() {
    return this.filterInput && document.activeElement === this.filterInput.nativeElement;
  }
  popupRef;
  /**
   * @hidden
   */
  selectedKeys = [];
  /**
   * @hidden
   */
  selectBy;
  /**
   * @hidden
   */
  text;
  /**
   * @hidden
   */
  onFilterChange(text) {
    if (this.filterable) {
      this.filterChange.emit(text);
    }
  }
  /**
   * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.
   */
  adaptiveMode = "none";
  /**
   * Sets the title of the ActionSheet that is rendered instead of the Popup when using small screen devices.
   * By default the ActionSheet title uses the text provided for the label of the AutoComplete.
   */
  title = "";
  /**
   * Sets the subtitle of the ActionSheet that is rendered instead of the Popup when using small screen devices.
   * By default the ActionSheet subtitle uses the text provided for the `placeholder` of the AutoComplete.
  */
  subtitle = "";
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
  * @hidden
  */
  windowSize = "large";
  /**
   * @hidden
   */
  isActionSheetExpanded = false;
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  /**
   * @hidden
   *
   * Alias for `isNodeExpanded`. Used for compatibility with the `ExpandableComponent` interface.
   * Required for the expand-directive.
   */
  set isExpanded(callback) {
    this.isNodeExpanded = callback;
  }
  get isExpanded() {
    return this.isNodeExpanded;
  }
  /**
   * @hidden
   *
   * Alias for `nodeExpand`. Used for compatibility with the `ExpandableComponent` interface.
   * Required for the expand-directive.
   */
  get expand() {
    return this.nodeExpand;
  }
  /**
   * @hidden
   *
   * Alias for `nodeCollapse`. Used for compatibility with the `ExpandableComponent` interface.
   * Required for the expand-directive.
   */
  get collapse() {
    return this.nodeCollapse;
  }
  /**
   * @hidden
   *
   * Alias for `data`. Used for compatibility with the `DataBoundComponent` interface.
   * Required for the data-binding directives.
   */
  set nodes(nodes) {
    this.data = nodes;
  }
  get nodes() {
    return this.data;
  }
  /**
   * @hidden
   *
   * Alias for `fetchChildren`. Used for compatibility with the `DataBoundComponent` interface.
   * Required for the data-binding directives
   */
  set children(callback) {
    this.fetchChildren = callback;
  }
  get children() {
    return this.fetchChildren;
  }
  /**
   * @hidden
   *
   * Alias for `isNodeVisible`. Used for compatibility with the `DataBoundComponent` interface.
   * The `DataBoundComponent` interface is used in the data-binding directives.
   */
  set isVisible(callback) {
    this.isNodeVisible = callback;
  }
  get isVisible() {
    return this.isNodeVisible;
  }
  /**
   * @hidden
   */
  filterStateChange = new EventEmitter();
  /**
   * @hidden
   */
  allNodesHidden = false;
  /**
   * @hidden
   *
   * Used to associate the value label with the wrapper via aria-describedby.
   */
  valueLabelId = `k-${guid()}`;
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  treeViewId = `k-${guid()}`;
  _nodes;
  _value;
  _popupSettings = DEFAULT_POPUP_SETTINGS$1;
  _tabindex = 0;
  _isFocused = false;
  _dataItem;
  _treeview;
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  _searchableNodes = [];
  _typedValue = "";
  printableCharacters = new Subject();
  subs = new Subscription();
  touchstartDisposeHandler;
  // Keep an instance of the last focused node for when the popup close is prevented
  // in order to be able to properly restore the focus
  lastNodeOnFocus;
  constructor(injector, wrapper, popupService, navigationService, renderer, _zone, cdr, localization, adaptiveService) {
    this.injector = injector;
    this.wrapper = wrapper;
    this.popupService = popupService;
    this.navigationService = navigationService;
    this.renderer = renderer;
    this._zone = _zone;
    this.cdr = cdr;
    this.localization = localization;
    this.adaptiveService = adaptiveService;
    this.direction = localization.rtl ? "rtl" : "ltr";
    this.subscribeEvents();
    this.subscribeTouchEvents();
    this.subscribeFocusEvents();
  }
  ngOnInit() {
    this.subs.add(this.printableCharacters.pipe(tap((char) => {
      this._typedValue += char;
      const itemToFocus = this._searchableNodes.find((node) => {
        return node.text.toLowerCase().indexOf(this._typedValue) === 0;
      });
      this.treeview.focus(itemToFocus?.index);
    }), debounceTime(1e3)).subscribe(() => {
      this._typedValue = "";
    }));
    this.renderer.removeAttribute(this.wrapper.nativeElement, "tabindex");
    this.assignAriaDescribedBy();
    this.subs.add(this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
      this.cdr.markForCheck();
    }));
    this.setComponentClasses();
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    this.destroyPopup();
    this.unsubscribeEvents();
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    if (anyChanged(["textField", "valueField", "valuePrimitive"], changes, false)) {
      this.setState();
    }
    if (isChanged("value", changes, false)) {
      if (changes["value"] && !changes["dataItem"] && !this.valuePrimitive) {
        this.dataItem = this.value;
      }
    }
  }
  /**
   * @hidden
   */
  ngAfterContentChecked() {
    this.verifySettings();
    if (this.data?.length > 0 && this.popupRef) {
      this.allNodesHidden = this.areNodesHidden(this.data);
    }
  }
  ngAfterViewInit() {
    this.windowSize = this.adaptiveService.size;
    this.subs.add(this.renderer.listen(this.wrapper.nativeElement, "click", this.handleClick.bind(this)));
    this.subs.add(this.renderer.listen(this.wrapper.nativeElement, "keydown", this.handleKeydown.bind(this)));
    if (this.actionSheet && isDocumentAvailable()) {
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-height", "60vh");
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-max-height", "none");
    }
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (this.isAdaptiveModeEnabled && this.windowSize !== currentWindowSize) {
      if (this.isOpen) {
        this.togglePopup(false);
      }
      this.windowSize = currentWindowSize;
    }
    if (this.isOpen && !this.isActionSheetExpanded) {
      const popupWrapper = this.popupRef.popupElement;
      const {
        min,
        max
      } = this.width;
      popupWrapper.style.minWidth = min;
      popupWrapper.style.width = max;
    }
  }
  /**
   * @hidden
   *
   * Used by the kendo-floatinglabel component to determine if the floating label
   * should be rendered inside the input when the component is not focused.
   */
  isEmpty() {
    return !this.text && !this.placeholder;
  }
  /**
   * @hidden
   */
  togglePopup(open) {
    const isDisabled2 = this.disabled || this.readonly;
    const sameState = this.isOpen === open;
    if (isDisabled2 || sameState) {
      return;
    }
    const togglePrevented = this.triggerPopupEvents(open);
    if (!togglePrevented) {
      if (open) {
        this.createPopup();
      } else {
        this.destroyPopup();
      }
    }
  }
  /**
   * @hidden
   */
  handleFocus(event) {
    if (event.target !== this.wrapper.nativeElement) {
      return;
    }
    event.stopImmediatePropagation();
    if (!this.isFocused) {
      this.isFocused = true;
      if (hasObservers(this.onFocus)) {
        this._zone.run(() => {
          this.onFocus.emit();
        });
      }
    }
  }
  /**
   * @hidden
   */
  handleBlur(e) {
    if (!this.isActionSheetExpanded) {
      const relatedTarget = e && e.relatedTarget;
      if (this.wrapper.nativeElement.contains(relatedTarget) || this.isOpen && this.popupRef.popupElement.contains(relatedTarget)) {
        return;
      }
      this.isFocused = false;
      this.togglePopup(false);
      if (hasObservers(this.onBlur) || isUntouched2(this.wrapper.nativeElement) || this.formControl?.updateOn === "blur") {
        this._zone.run(() => {
          this.onBlur.emit();
          this.onTouchedCallback();
        });
      }
    }
  }
  /**
   * @hidden
   */
  handleKeydown(event, input) {
    if (this.disabled || this.readonly) {
      return;
    }
    if (event.keyCode === Keys.Tab && this.isActionSheetExpanded) {
      this.togglePopup(false);
      return;
    }
    if (!this.isFilterActive && isLetter(event.key) && !this.actionSheetSearchBar?.onFocus) {
      this.printableCharacters.next(event.key);
    }
    const eventData = event;
    this.navigationService.process({
      originalEvent: eventData,
      openOnSpace: !this.isOpen,
      closeOnSpace: this.isOpen && !input && !(event.target instanceof HTMLInputElement)
    });
  }
  /**
   * Focuses a specific item of the DropDownTree based on a provided index in the format of `1_1`.
   * The targeted item should be expanded in order for it to be focused.
   * If null or invalid index is provided the focus will be set on the first item.
   */
  focusItemAt(index) {
    if (this.treeview) {
      const lookup = this.treeview.itemLookup(index);
      const isItemDisabled = !isPresent7(lookup) || this.treeview.isDisabled(lookup.item.dataItem, lookup.item.index);
      if (!isItemDisabled) {
        this.treeview.focus(index);
      }
    }
  }
  /**
   * Focuses the DropDownTree.
   */
  focus() {
    if (!this.disabled) {
      this.wrapper.nativeElement.focus();
    }
  }
  /**
   * Blurs the DropDownTree.
   */
  blur() {
    if (!this.disabled) {
      this.wrapper.nativeElement.blur();
    }
  }
  /**
   * Resets the value of the DropDownTree.
   * If you use the `reset` method to clear the value of the component,
   * the model will not update automatically and the `valueChange` event will not be fired.
   */
  reset() {
    this.value = void 0;
    this.dataItem = void 0;
  }
  /**
   * Toggles the visibility of the popup or actionSheet.
   * ([see example]({% slug openstate_ddt %})).
   * If you use the `toggle` method to open or close the popup or actionSheet, the `open` and `close` events will not be fired.
   *
   * @param open - The state of the popup.
   */
  toggle(open) {
    Promise.resolve(null).then(() => {
      const shouldOpen = isPresent7(open) ? open : !isPresent7(this.popupRef);
      this.destroyPopup();
      if (shouldOpen) {
        this.createPopup();
      }
    });
  }
  /**
   * @hidden
   */
  get popupContainerClasses() {
    const containerClasses = ["k-dropdowntree-popup"];
    if (this.popupSettings.popupClass) {
      containerClasses.push(this.popupSettings.popupClass);
    }
    return containerClasses;
  }
  /**
   * @hidden
   */
  onSelectionChange({
    dataItem,
    index
  }) {
    this.valueDepth = index.split("_").length - 1;
    const valueField = this.getField(this.valueField, dataItem);
    const newValue = this.valuePrimitive ? getter(valueField)(dataItem) : dataItem;
    const shouldUpdateValue = newValue !== this.value;
    if (shouldUpdateValue) {
      this.value = newValue;
      this.dataItem = dataItem;
      this.emitValueChange(this.value);
    }
    this.togglePopup(false);
    this.focus();
  }
  /**
   * @hidden
   */
  messageFor(key) {
    return this.localization.get(key);
  }
  /**
   * @hidden
   */
  clearValue(event) {
    event.stopImmediatePropagation();
    this.focus();
    this.value = void 0;
    this.dataItem = void 0;
    this.clearState();
    this.valueChange.emit(void 0);
    this.emitValueChange();
  }
  get appendTo() {
    const {
      appendTo
    } = this.popupSettings;
    if (!appendTo || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  /**
   * @hidden
   */
  preventEventDefault(event) {
    event.preventDefault();
  }
  /**
   * @hidden
   */
  writeValue(value) {
    if (!isPresent7(value) && isPresent7(this.value)) {
      this.dataItem = null;
    }
    this.value = value === null ? void 0 : value;
    if (isPresent7(this.value) && !this.valuePrimitive) {
      this.dataItem = this.value;
    }
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onChangeCallback = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.disabled = isDisabled2;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  handleFilterInputChange(input) {
    const value = typeof input === "string" ? input : input.value;
    this.filter = value;
    this.filterChange.next(value);
    this.allNodesHidden = this.areNodesHidden(this.nodes);
    this._zone.onStable.pipe(take(1)).subscribe(() => {
      if (this.data.length === 0 || this.allNodesHidden || this.filter === "") {
        this.filterInput?.nativeElement.focus();
      }
    });
  }
  /**
   * @hidden
   */
  get selectButtonClasses() {
    return `${this.size ? getSizeClass2("button", this.size) : ""} ${this.fillMode ? "k-button-" + this.fillMode : ""} ${this.fillMode ? "k-button-" + this.fillMode + "-base" : ""}`;
  }
  /**
   * @hidden
   */
  get filterInputClasses() {
    return `${this.size ? getSizeClass2("input", this.size) : ""} ${this.fillMode ? "k-input-" + this.fillMode : ""} ${this.rounded ? getRoundedClass(this.rounded) : ""}`;
  }
  onTouchedCallback = noop6;
  onChangeCallback = noop6;
  verifySettings() {
    if (!isDevMode()) {
      return;
    }
    if (this.valuePrimitive === true && isPresent7(this.value) && typeof this.value === "object") {
      throw new Error(DropDownTreeMessages.primitive);
    }
    if (this.valuePrimitive === true && isPresent7(this.value) && typeof this.dataItem !== "object") {
      throw new Error(DropDownTreeMessages.dataItem);
    }
    if (this.valuePrimitive === false && isPresent7(this.value) && typeof this.value !== "object") {
      throw new Error(DropDownTreeMessages.object);
    }
    if (!isPresent7(this.valueField) || !isPresent7(this.textField)) {
      throw new Error(DropDownTreeMessages.textAndValue);
    }
    if ((isArray3(this.valueField) || isArray3(this.textField)) && isPresent7(this.value) && !isPresent7(this.valueDepth)) {
      throw new Error(DropDownTreeMessages.valueDepth);
    }
  }
  emitValueChange(value) {
    this.onChangeCallback(value);
    this.valueChange.emit(value);
  }
  getText(textField, dataItem) {
    if (isPresent7(dataItem) && isPresent7(textField)) {
      const field = this.getField(textField, dataItem);
      return getter(field)(dataItem);
    }
    return null;
  }
  /**
   * @hidden
   */
  onChildrenLoaded() {
    setTimeout(() => {
      if (this.popupRef) {
        this._searchableNodes = getSearchableItems(this.treeViewId, this.popupRef.popupElement);
      }
      if (this.isActionSheetExpanded) {
        this._searchableNodes = getSearchableItems(this.treeViewId, this.actionSheet.element.nativeElement);
      }
    });
  }
  /**
   * @hidden
   */
  onExpand() {
    this._searchableNodes = getSearchableItems(this.treeViewId, this.actionSheet.element.nativeElement);
    this.isActionSheetExpanded = true;
  }
  /**
   * @hidden
   */
  onCollapse() {
    this.isActionSheetExpanded = false;
  }
  /**
   * @hidden
   *
   * Determines the `valueField` and `textField` for a specific level in the data set
   *  @param field - the field value (string | string[])
   *  @param value - current value
   */
  getField(field, value) {
    const fieldsCount = field.length - 1;
    if (typeof field === "string") {
      return field;
    } else if (isPresent7(this.valueDepth)) {
      return fieldsCount < this.valueDepth ? field[fieldsCount] : field[this.valueDepth];
    } else if (value && typeof value === "object") {
      return field.find((item) => item in value);
    }
  }
  areNodesHidden(nodes) {
    return nodes.every((node, index) => !this.isVisible(node, String(index)));
  }
  triggerPopupEvents(open) {
    const eventArgs = new PreventableEvent5();
    if (open) {
      this.open.emit(eventArgs);
    } else {
      this.close.emit(eventArgs);
    }
    return eventArgs.isDefaultPrevented();
  }
  createPopup() {
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.openActionSheet();
      this.cdr.detectChanges();
      return;
    }
    const horizontalAlign = this.direction === "rtl" ? "right" : "left";
    const anchorPosition = {
      horizontal: horizontalAlign,
      vertical: "bottom"
    };
    const popupPosition = {
      horizontal: horizontalAlign,
      vertical: "top"
    };
    const appendToComponent = typeof this.popupSettings.appendTo === "string" && this.popupSettings.appendTo === "component";
    this.popupRef = this.popupService.open({
      anchor: this.wrapper,
      appendTo: this.appendTo,
      anchorAlign: anchorPosition,
      animate: this.popupSettings.animate,
      content: this.popupTemplate,
      popupAlign: popupPosition,
      positionMode: appendToComponent ? "fixed" : "absolute",
      popupClass: this.popupContainerClasses
    });
    const popupWrapper = this.popupRef.popupElement;
    const {
      min,
      max
    } = this.width;
    this.renderer.setStyle(popupWrapper, "minWidth", min);
    this.renderer.setStyle(popupWrapper, "width", max);
    this.renderer.setStyle(popupWrapper, "height", this.height);
    this.renderer.setAttribute(popupWrapper, "dir", this.direction);
    if (!this.appendTo) {
      this.renderer.setAttribute(popupWrapper, "role", "region");
      this.renderer.setAttribute(popupWrapper, "aria-label", this.messageFor("popupLabel"));
    }
    this.popupRef.popupOpen.subscribe(() => {
      this.allNodesHidden = this.areNodesHidden(this.data);
      this.popupRef.popupElement.addEventListener("click", (event) => stopPropagation(event));
      this.cdr.detectChanges();
      this.opened.emit();
      this._searchableNodes = getSearchableItems(this.treeViewId, this.popupRef.popupElement);
    });
    this.popupRef.popupClose.subscribe(() => {
      this.closed.emit();
    });
  }
  destroyPopup() {
    if (this.isActionSheetExpanded) {
      this.closeActionSheet();
    }
    if (this.popupRef) {
      this.popupRef.popupElement.removeEventListener("click", (event) => stopPropagation(event));
      this.popupRef.close();
      this.popupRef = null;
      if (this.filter !== "") {
        this.filter = "";
        this.allNodesHidden = false;
        if (hasObservers(this.filterChange)) {
          this._zone.run(() => {
            this.filterChange.emit("");
          });
        }
      }
    }
  }
  handleClick(e) {
    this.windowSize = this.adaptiveService.size;
    if (!this.isActionSheetExpanded) {
      if (this.popupRef && !this.popupRef.popupElement.contains(e.target) || !this.popupRef && !e.target.className.includes("k-treeview-leaf")) {
        this.togglePopup(!this.isOpen);
      }
    }
  }
  handleEscape() {
    this.togglePopup(false);
    this.focus();
  }
  setState() {
    if (isPresent7(this.value) && isPresent7(this.dataItem) && isPresent7(this.valueField)) {
      this.text = this.getText(this.textField, this.dataItem);
      const valueField = this.getField(this.valueField, this.dataItem);
      this.selectBy = valueField;
      this.selectedKeys = [getter(valueField)(this.dataItem)];
    } else {
      this.clearState();
    }
    this.cdr.markForCheck();
  }
  clearState() {
    this.text = void 0;
    this.selectedKeys = [];
  }
  subscribeEvents() {
    [this.navigationService.open.subscribe((event) => {
      event.originalEvent.preventDefault();
      this.togglePopup(true);
    }), this.navigationService.close.subscribe((event) => {
      event.originalEvent.preventDefault();
      this.togglePopup(false);
      this.focus();
    }), this.navigationService.enter.pipe(tap((event) => event.originalEvent.preventDefault())).subscribe((e) => {
      if (e.originalEvent.target === this.wrapper.nativeElement) {
        this.togglePopup(true);
      }
      if (!this.isOpen) {
        this.focus();
      }
    }), this.navigationService.esc.subscribe(() => this.handleEscape()), this.navigationService.tab.subscribe(() => {
      this.focus();
      if (this.isOpen) {
        this.treeview.blur();
        this.removeTreeViewFromTabOrder();
      }
    }), this.navigationService.down.subscribe((event) => {
      if (!this.treeview) {
        return;
      }
      event.originalEvent.preventDefault();
      if (!this.treeview.isActive) {
        this.treeview.focus();
      }
    }), this.navigationService.up.subscribe((event) => {
      if (!this.treeview) {
        return;
      }
      event.originalEvent.preventDefault();
      if (this.filterable && this.treeview["navigationService"]["activeIndex"] === "0") {
        if (this.isActionSheetExpanded) {
          this.actionSheetSearchBar.focus();
        } else {
          this.filterInput.nativeElement.focus();
        }
      }
    })].forEach((sub) => this.subs.add(sub));
  }
  subscribeTouchEvents() {
    if (!isDocumentAvailable() || !this.touchEnabled) {
      return;
    }
    this._zone.runOutsideAngular(() => (
      // Roll up DropDownTree on iOS when tapped outside
      this.touchstartDisposeHandler = this.renderer.listen(document, "touchstart", (e) => {
        const target = e.target;
        if (this.isFocused && !inDropDown(this.wrapper, target, this.popupRef)) {
          this._zone.run(() => {
            if (this.isOpen) {
              this.treeview.blur();
            }
            this.blur();
          });
        }
      })
    ));
  }
  subscribeFocusEvents() {
    if (isDocumentAvailable()) {
      this.handleFocus = this.handleFocus.bind(this);
      this.handleDocumentBlur = this.handleDocumentBlur.bind(this);
      this._zone.runOutsideAngular(() => {
        const useCapture = true;
        document.addEventListener("focus", this.handleFocus, useCapture);
        document.addEventListener("blur", this.handleDocumentBlur, useCapture);
      });
    }
  }
  unSubscribeFocusEvents() {
    if (isDocumentAvailable()) {
      const useCapture = true;
      document.removeEventListener("focus", this.handleFocus, useCapture);
      document.removeEventListener("blur", this.handleDocumentBlur, useCapture);
    }
  }
  unsubscribeEvents() {
    this.subs.unsubscribe();
    this.unSubscribeFocusEvents();
    if (this.touchstartDisposeHandler) {
      this.touchstartDisposeHandler();
    }
  }
  handleDocumentBlur(event) {
    if (event.target !== this.wrapper.nativeElement) {
      return;
    }
    event.stopImmediatePropagation();
    this.handleBlur(event);
  }
  assignAriaDescribedBy() {
    const currentValue = this.wrapper.nativeElement.getAttribute("aria-describedby") || "";
    const newValue = `${this.valueLabelId} ${currentValue.trim()}`.trim();
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-describedby", newValue);
  }
  setComponentClasses() {
    if (this.size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("picker", this.size));
    }
    if (this.rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("picker", this.fillMode));
    }
  }
  /**
   * Remove the `TreeView` from the tab order, otherwise a focus loop between the page elements will occur
   * and the user will not be able to tab to the rest of the browser elements
   */
  removeTreeViewFromTabOrder() {
    const nodes = this.treeview.element.nativeElement.querySelectorAll("li");
    nodes.forEach((item) => {
      if (item.getAttribute("tabindex") === "0") {
        this.lastNodeOnFocus = item;
        this.lastNodeOnFocus.setAttribute("tabindex", "-1");
      }
    });
  }
  closeActionSheet() {
    this.actionSheet.toggle(false);
    if (this.filterable) {
      this.actionSheetSearchBar.value = "";
      this.filterChange.emit("");
    }
    this.wrapper.nativeElement.focus();
    this.closed.emit();
  }
  openActionSheet() {
    this.windowSize = this.adaptiveService.size;
    this.isActionSheetExpanded = true;
    this.actionSheet.toggle(true);
    this.title = setActionSheetTitle(this.wrapper, this.title);
    this.cdr.detectChanges();
    updateActionSheetAdaptiveAppearance2(this.actionSheet, this.windowSize, this.renderer);
    this.cdr.detectChanges();
    this.opened.emit();
    this.removeTreeViewFromTabOrder();
    this.filterable && this.actionSheetSearchBar.focus();
  }
  static ɵfac = function DropDownTreeComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropDownTreeComponent)(ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(NavigationService3), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DropDownTreeComponent,
    selectors: [["kendo-dropdowntree"]],
    contentQueries: function DropDownTreeComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, NodeTemplateDirective2, 5);
        ɵɵcontentQuery(dirIndex, ValueTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.nodeTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.valueTemplate = _t.first);
      }
    },
    viewQuery: function DropDownTreeComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(ResponsiveRendererComponent, 5);
        ɵɵviewQuery(_c104, 7);
        ɵɵviewQuery(_c94, 7, ViewContainerRef);
        ɵɵviewQuery(_c233, 5);
        ɵɵviewQuery(_c242, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.responsiveRendererComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.treeview = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterInput = _t.first);
      }
    },
    hostVars: 22,
    hostBindings: function DropDownTreeComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("readonly", ctx.isReadonly)("aria-invalid", ctx.hostAriaInvalid)("aria-disabled", ctx.isDisabled)("aria-busy", ctx.isBusy)("aria-controls", ctx.hostAriaControls)("id", ctx.id)("dir", ctx.direction)("tabindex", ctx.hostTabIndex)("role", ctx.role)("aria-haspopup", ctx.ariaHasPopup)("aria-expanded", ctx.isAriaExpanded)("aria-autocomplete", ctx.hostAriaAutocomplete);
        ɵɵclassProp("k-dropdowntree", ctx.hostClasses)("k-picker", ctx.hostClasses)("k-disabled", ctx.isDisabled)("k-loading", ctx.isLoading)("k-readonly", ctx.readonly);
      }
    },
    inputs: {
      icon: "icon",
      svgIcon: "svgIcon",
      loading: "loading",
      clearButton: "clearButton",
      data: "data",
      value: "value",
      textField: "textField",
      valueField: "valueField",
      valueDepth: "valueDepth",
      hasChildren: "hasChildren",
      fetchChildren: "fetchChildren",
      placeholder: "placeholder",
      popupSettings: "popupSettings",
      dataItem: "dataItem",
      listHeight: "listHeight",
      disabled: "disabled",
      readonly: "readonly",
      valuePrimitive: "valuePrimitive",
      tabindex: "tabindex",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      itemDisabled: "itemDisabled",
      isNodeExpanded: "isNodeExpanded",
      isNodeVisible: "isNodeVisible",
      loadOnDemand: "loadOnDemand",
      filterable: "filterable",
      filter: "filter",
      focusableId: "focusableId",
      adaptiveMode: "adaptiveMode",
      title: "title",
      subtitle: "subtitle"
    },
    outputs: {
      open: "open",
      opened: "opened",
      close: "close",
      closed: "closed",
      nodeExpand: "nodeExpand",
      nodeCollapse: "nodeCollapse",
      onFocus: "focus",
      onBlur: "blur",
      valueChange: "valueChange",
      filterChange: "filterChange"
    },
    exportAs: ["kendoDropDownTree"],
    features: [ɵɵProvidersFeature([DataService, SelectionService2, NavigationService3, DisabledItemsService, LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.dropdowntree"
    }, {
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _DropDownTreeComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _DropDownTreeComponent)
    }, {
      provide: DataBoundComponent,
      useExisting: forwardRef(() => _DropDownTreeComponent)
    }, {
      provide: ExpandableComponent,
      useExisting: forwardRef(() => _DropDownTreeComponent)
    }]), ɵɵNgOnChangesFeature],
    decls: 15,
    vars: 15,
    consts: () => {
      let i18n_20;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_20 = goog.getMsg("NO DATA FOUND");
        i18n_20 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_20;
      } else {
        i18n_20 = $localize`:kendo.dropdowntree.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;
      }
      let i18n_21;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_21 = goog.getMsg("clear");
        i18n_21 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_21;
      } else {
        i18n_21 = $localize`:kendo.dropdowntree.clearTitle|The title of the clear button:clear`;
      }
      let i18n_22;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_22 = goog.getMsg("Select");
        i18n_22 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_22;
      } else {
        i18n_22 = $localize`:kendo.dropdowntree.selectButtonText|The text set as aria-label on the select button:Select`;
      }
      let i18n_23;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_23 = goog.getMsg("Filter");
        i18n_23 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_23;
      } else {
        i18n_23 = $localize`:kendo.dropdowntree.filterInputLabel|The text set as aria-label on the filter input:Filter`;
      }
      let i18n_24;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_24 = goog.getMsg("Options list");
        i18n_24 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_24;
      } else {
        i18n_24 = $localize`:kendo.dropdowntree.popupLabel|The label of the popup element that contains the list of options when its role is 'region':Options list`;
      }
      return [["popupTemplate", ""], ["container", ""], ["sharedPopupActionSheetTemplate", ""], ["filterInput", ""], ["treeview", ""], ["kendoDropDownTreeLocalizedMessages", "", "noDataText", i18n_20, "clearTitle", i18n_21, "selectButtonText", i18n_22, "filterInputLabel", i18n_23, "popupLabel", i18n_24], [1, "k-input-inner", 3, "click"], ["class", "k-input-value-text", 4, "ngIf"], ["class", "k-clear-value", "aria-hidden", "true", 3, "visibility", "click", 4, "ngIf"], ["class", "k-i-loading k-input-loading-icon k-icon", 4, "ngIf"], ["tabindex", "-1", "type", "button", "aria-hidden", "true", 1, "k-input-button", "k-button", "k-icon-button", 3, "ngClass"], ["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [3, "closePopup", "onExpand", "onCollapse", "textInputChange", "sharedPopupActionSheetTemplate", "isActionSheetExpanded", "title", "showTextInput", "subtitle"], [3, "resize", 4, "ngIf"], [1, "k-input-value-text"], [4, "ngIf"], [3, "ngIf"], [3, "templateContext"], ["aria-hidden", "true", 1, "k-clear-value", 3, "click"], ["name", "x", 3, "svgIcon"], [1, "k-i-loading", "k-input-loading-icon", "k-icon"], [4, "ngTemplateOutlet"], ["class", "k-list-filter", 4, "ngIf"], ["kendoTreeViewSelectable", "", 3, "size", "nodes", "maxHeight", "animate", "selectedKeys", "selectBy", "textField", "children", "hasChildren", "loadOnDemand", "isExpanded", "isDisabled", "nodeTemplate", "filter", "isVisible", "selectedKeysChange", "focusout", "keydown", "selectionChange", "expand", "collapse", "childrenLoaded", 4, "ngIf"], ["class", "k-no-data", 4, "ngIf"], [1, "k-list-filter"], [1, "k-textbox", "k-input", 3, "ngClass"], [1, "k-input-prefix"], ["name", "search", 1, "k-icon", 3, "svgIcon"], ["role", "textbox", 1, "k-input-inner", 3, "input", "keydown.arrowdown", "keydown.alt.arrowup", "keydown.escape", "filterInput", "value", "kendoEventsOutsideAngular", "scope"], ["kendoTreeViewSelectable", "", 3, "selectedKeysChange", "focusout", "keydown", "selectionChange", "expand", "collapse", "childrenLoaded", "size", "nodes", "animate", "selectedKeys", "selectBy", "textField", "children", "hasChildren", "loadOnDemand", "isExpanded", "isDisabled", "nodeTemplate", "filter", "isVisible"], [1, "k-no-data"], [3, "ngIf", "templateContext"], [3, "resize"]];
    },
    template: function DropDownTreeComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 5);
        ɵɵelementStart(1, "span", 6);
        ɵɵlistener("click", function DropDownTreeComponent_Template_span_click_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView($event.preventDefault());
        });
        ɵɵtemplate(2, DropDownTreeComponent_span_2_Template, 3, 2, "span", 7);
        ɵɵelementEnd();
        ɵɵtemplate(3, DropDownTreeComponent_span_3_Template, 2, 4, "span", 8)(4, DropDownTreeComponent_span_4_Template, 1, 0, "span", 9);
        ɵɵelementStart(5, "button", 10);
        ɵɵelement(6, "kendo-icon-wrapper", 11);
        ɵɵelementEnd();
        ɵɵtemplate(7, DropDownTreeComponent_ng_template_7_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        ɵɵelementContainer(9, null, 1);
        ɵɵelementStart(11, "responsive-renderer", 12);
        ɵɵlistener("closePopup", function DropDownTreeComponent_Template_responsive_renderer_closePopup_11_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.togglePopup(false));
        })("onExpand", function DropDownTreeComponent_Template_responsive_renderer_onExpand_11_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onExpand());
        })("onCollapse", function DropDownTreeComponent_Template_responsive_renderer_onCollapse_11_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onCollapse());
        })("textInputChange", function DropDownTreeComponent_Template_responsive_renderer_textInputChange_11_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFilterInputChange($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(12, DropDownTreeComponent_ng_template_12_Template, 5, 5, "ng-template", null, 2, ɵɵtemplateRefExtractor)(14, DropDownTreeComponent_kendo_resize_sensor_14_Template, 1, 0, "kendo-resize-sensor", 13);
      }
      if (rf & 2) {
        const sharedPopupActionSheetTemplate_r4 = ɵɵreference(13);
        ɵɵadvance();
        ɵɵattribute("id", ctx.valueLabelId);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.valueTemplate || ctx.text || ctx.placeholder);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.loading && !ctx.readonly && ctx.clearButton && (ctx.text == null ? null : ctx.text.length) && !ctx.disabled);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.loading);
        ɵɵadvance();
        ɵɵproperty("ngClass", ctx.selectButtonClasses);
        ɵɵattribute("aria-label", ctx.messageFor("selectButtonText"))("disabled", ctx.disabled ? "" : null);
        ɵɵadvance();
        ɵɵproperty("name", ctx.icon || "caret-alt-down")("svgIcon", ctx.svgIcon || ctx.caretAltDownIcon);
        ɵɵadvance(5);
        ɵɵproperty("sharedPopupActionSheetTemplate", sharedPopupActionSheetTemplate_r4)("isActionSheetExpanded", ctx.isActionSheetExpanded)("title", ctx.title)("showTextInput", ctx.filterable)("subtitle", ctx.subtitle);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.isOpen || ctx.isAdaptiveModeEnabled);
      }
    },
    dependencies: [LocalizedMessagesDirective3, NgIf, TemplateContextDirective, IconWrapperComponent, NgClass, NgTemplateOutlet, ResponsiveRendererComponent, FilterInputDirective, EventsOutsideAngularDirective, TreeViewComponent, SelectDirective, ResizeSensorComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropDownTreeComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoDropDownTree",
      providers: [DataService, SelectionService2, NavigationService3, DisabledItemsService, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.dropdowntree"
      }, {
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => DropDownTreeComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => DropDownTreeComponent)
      }, {
        provide: DataBoundComponent,
        useExisting: forwardRef(() => DropDownTreeComponent)
      }, {
        provide: ExpandableComponent,
        useExisting: forwardRef(() => DropDownTreeComponent)
      }],
      selector: "kendo-dropdowntree",
      template: `
        <ng-container kendoDropDownTreeLocalizedMessages
            i18n-noDataText="kendo.dropdowntree.noDataText|The text displayed in the popup when there are no items"
            noDataText="NO DATA FOUND"

            i18n-clearTitle="kendo.dropdowntree.clearTitle|The title of the clear button"
            clearTitle="clear"

            i18n-selectButtonText="kendo.dropdowntree.selectButtonText|The text set as aria-label on the select button"
            selectButtonText="Select"

            i18n-filterInputLabel="kendo.dropdowntree.filterInputLabel|The text set as aria-label on the filter input"
            filterInputLabel="Filter"

            i18n-popupLabel="kendo.dropdowntree.popupLabel|The label of the popup element that contains the list of options when its role is 'region'"
            popupLabel="Options list"
        >
        </ng-container>
        <span
            [attr.id]="valueLabelId"
            class="k-input-inner"
            (click)="$event.preventDefault()"
        >
            <span class="k-input-value-text" *ngIf="valueTemplate || text || placeholder">
                <ng-template *ngIf="valueTemplate"
                    [templateContext]="{
                        templateRef: valueTemplate.templateRef,
                        $implicit: dataItem
                    }">
                </ng-template>
                <ng-template [ngIf]="!valueTemplate"> {{ text || placeholder }} </ng-template>
            </span>
        </span>
        <span
            *ngIf="!loading && !readonly && clearButton && text?.length && !disabled"
            class="k-clear-value"
            [style.visibility]="clearButtonVisiblity"
            aria-hidden="true"
            [attr.title]="messageFor('clearTitle')"
            (click)="clearValue($event)"
        >
            <kendo-icon-wrapper
                name="x"
                [svgIcon]="xIcon"
            >
            </kendo-icon-wrapper>
        </span>
        <span *ngIf="loading" class="k-i-loading k-input-loading-icon k-icon"></span>
        <button
            tabindex="-1"
            type="button"
            aria-hidden="true"
            class="k-input-button k-button k-icon-button"
            [ngClass]="selectButtonClasses"
            [attr.aria-label]="messageFor('selectButtonText')"
            [attr.disabled]="disabled ? '' : null"
        >
            <kendo-icon-wrapper
                [name]="icon || 'caret-alt-down'"
                innerCssClass="k-button-icon"
                [svgIcon]="svgIcon || caretAltDownIcon"
            >
            </kendo-icon-wrapper>
        </button>
        <ng-template #popupTemplate>
            <ng-container *ngTemplateOutlet="sharedPopupActionSheetTemplate"></ng-container>
        </ng-template>
        <ng-container #container></ng-container>

        <!--adaptive rendering-->
        <responsive-renderer
            [sharedPopupActionSheetTemplate]="sharedPopupActionSheetTemplate"
            [isActionSheetExpanded]="isActionSheetExpanded"
            [title]="title"
            [showTextInput]="filterable"
            [subtitle]="subtitle"
            (closePopup)="togglePopup(false)"
            (onExpand)="onExpand()"
            (onCollapse)="onCollapse()"
            (textInputChange)="handleFilterInputChange($event)"
        >
        </responsive-renderer>
        <ng-template #sharedPopupActionSheetTemplate>
            <span
                *ngIf="filterable && !isActionSheetExpanded"
                class="k-list-filter"
            >
                <span
                    class="k-textbox k-input"
                    [ngClass]="filterInputClasses"
                >
                    <span class="k-input-prefix">
                        <kendo-icon-wrapper
                            class="k-icon"
                            name="search"
                            [svgIcon]="searchIcon"
                        >
                        </kendo-icon-wrapper>
                    </span>
                    <input
                        #filterInput
                        (input)="handleFilterInputChange($event.target)"
                        [filterInput]="filterable && !touchEnabled"
                        (keydown.arrowdown)="handleKeydown($event, filterInput)"
                        (keydown.alt.arrowup)="handleKeydown($event, filterInput)"
                        (keydown.escape)="handleKeydown($event, filterInput)"
                        [attr.aria-label]="messageFor('filterInputLabel')"
                        [value]="filter"
                        class="k-input-inner"
                        role="textbox"
                        [kendoEventsOutsideAngular]="{
                            blur: handleBlur
                        }"
                        [scope]="this"
                    >
                </span>
            </span>
            <!--header template-->
            <ng-template
                *ngIf="headerTemplate"
                [templateContext]="{
                    templateRef: headerTemplate?.templateRef
                }">
            </ng-template>
            <kendo-treeview
                #treeview
                [attr.id]="treeViewId"
                *ngIf="data.length !== 0 && !allNodesHidden"
                [size]="size"
                [nodes]="data"
                [style.maxHeight.px]="listHeight"
                [animate]="false"
                [(selectedKeys)]="selectedKeys"
                [selectBy]="selectBy"
                [textField]="textField"
                kendoTreeViewSelectable
                [children]="children"
                [hasChildren]="hasChildren"
                [loadOnDemand]="loadOnDemand"
                [isExpanded]="isNodeExpanded"
                [isDisabled]="itemDisabled"
                [nodeTemplate]="nodeTemplate"
                [filter]="filter"
                [isVisible]="isNodeVisible"
                (focusout)="handleBlur($event)"
                (keydown)="handleKeydown($event)"
                (selectionChange)="onSelectionChange($event)"
                (expand)="nodeExpand.emit($event)"
                (collapse)="nodeCollapse.emit($event)"
                (childrenLoaded)="onChildrenLoaded()"
            >
            </kendo-treeview>
            <!--footer template-->
            <ng-template
                *ngIf="footerTemplate"
                [templateContext]="{
                    templateRef: footerTemplate?.templateRef
                }">
            </ng-template>
            <!--no-data template-->
            <div class="k-no-data" *ngIf="data.length === 0 || allNodesHidden">
                <ng-template [ngIf]="noDataTemplate"
                    [templateContext]="{
                        templateRef: noDataTemplate?.templateRef
                    }">
                </ng-template>
                <ng-template [ngIf]="!noDataTemplate">
                    <div>{{ messageFor('noDataText') }}</div>
                </ng-template>
            </div>
        </ng-template>

        <kendo-resize-sensor *ngIf="isOpen || isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>
    `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: true,
      imports: [LocalizedMessagesDirective3, NgIf, TemplateContextDirective, IconWrapperComponent, NgClass, NgTemplateOutlet, ResponsiveRendererComponent, FilterInputDirective, EventsOutsideAngularDirective, TreeViewComponent, SelectDirective, ResizeSensorComponent]
    }]
  }], function() {
    return [{
      type: Injector
    }, {
      type: ElementRef
    }, {
      type: PopupService
    }, {
      type: NavigationService3
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: LocalizationService
    }, {
      type: AdaptiveService
    }];
  }, {
    icon: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }],
    responsiveRendererComponent: [{
      type: ViewChild,
      args: [ResponsiveRendererComponent]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-dropdowntree"]
    }, {
      type: HostBinding,
      args: ["class.k-picker"]
    }],
    isReadonly: [{
      type: HostBinding,
      args: ["attr.readonly"]
    }],
    hostAriaInvalid: [{
      type: HostBinding,
      args: ["attr.aria-invalid"]
    }],
    isDisabled: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }, {
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    isLoading: [{
      type: HostBinding,
      args: ["class.k-loading"]
    }],
    isBusy: [{
      type: HostBinding,
      args: ["attr.aria-busy"]
    }],
    hostAriaControls: [{
      type: HostBinding,
      args: ["attr.aria-controls"]
    }],
    id: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    hostTabIndex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    ariaHasPopup: [{
      type: HostBinding,
      args: ["attr.aria-haspopup"]
    }],
    isAriaExpanded: [{
      type: HostBinding,
      args: ["attr.aria-expanded"]
    }],
    hostAriaAutocomplete: [{
      type: HostBinding,
      args: ["attr.aria-autocomplete"]
    }],
    noDataTemplate: [{
      type: ContentChild,
      args: [NoDataTemplateDirective, {
        static: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective, {
        static: false
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective, {
        static: false
      }]
    }],
    nodeTemplate: [{
      type: ContentChild,
      args: [NodeTemplateDirective2, {
        static: false
      }]
    }],
    valueTemplate: [{
      type: ContentChild,
      args: [ValueTemplateDirective, {
        static: false
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        static: true
      }]
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    treeview: [{
      type: ViewChild,
      args: ["treeview", {
        static: false
      }]
    }],
    filterInput: [{
      type: ViewChild,
      args: ["filterInput", {
        static: false
      }]
    }],
    open: [{
      type: Output
    }],
    opened: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    closed: [{
      type: Output
    }],
    nodeExpand: [{
      type: Output
    }],
    nodeCollapse: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    valueChange: [{
      type: Output
    }],
    filterChange: [{
      type: Output
    }],
    loading: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    textField: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    valueDepth: [{
      type: Input
    }],
    hasChildren: [{
      type: Input
    }],
    fetchChildren: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    dataItem: [{
      type: Input
    }],
    listHeight: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    valuePrimitive: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    itemDisabled: [{
      type: Input
    }],
    isNodeExpanded: [{
      type: Input
    }],
    isNodeVisible: [{
      type: Input
    }],
    loadOnDemand: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    focusableId: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    subtitle: [{
      type: Input
    }]
  });
})();
var nodeIndex2 = (item) => (item || {}).key;
var buildTreeItem2 = (dataItem, valueField, currentLevelIndex) => {
  if (!isPresent7(dataItem)) {
    return null;
  }
  return {
    dataItem,
    key: valueFrom({
      dataItem,
      level: currentLevelIndex
    }, valueField) + "_" + currentLevelIndex
  };
};
var MultiSelectTreeLookupService = class _MultiSelectTreeLookupService {
  map = /* @__PURE__ */ new Map();
  reset() {
    this.map.clear();
  }
  registerChildren(index, children) {
    const item = this.item(index);
    if (!item) {
      return;
    }
    item.children = children;
  }
  item(index) {
    return this.map.get(index) || null;
  }
  registerItem(item, parent) {
    const currentLookup = {
      children: [],
      item,
      parent: this.item(nodeIndex2(parent))
    };
    this.map.set(item.key, currentLookup);
  }
  itemLookup(index) {
    const item = this.item(index);
    if (!item) {
      return null;
    }
    return {
      children: this.mapChildren(item.children),
      item: item.item,
      parent: item.parent
    };
  }
  mapChildren(children = []) {
    return children.map((c) => {
      const {
        item,
        parent,
        children: children2
      } = this.item(c.key);
      return {
        children: this.mapChildren(children2),
        item,
        parent
      };
    });
  }
  static ɵfac = function MultiSelectTreeLookupService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiSelectTreeLookupService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _MultiSelectTreeLookupService,
    factory: _MultiSelectTreeLookupService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiSelectTreeLookupService, [{
    type: Injectable
  }], null, null);
})();
var BaseCheckDirective = class _BaseCheckDirective {
  /**
   * @hidden
   * The flag is needed in order to determine how to construct the items map keys.
   * If `true`, then the key consists of the item's value and level (depth),
   * else the key consists of the item's value and 0 (no leveling required)
   */
  isHeterogeneous;
  addItem(item) {
    if (this.isItemChecked(item)) {
      return;
    }
    const level = getHierarchicalItemLevel(item.index);
    const key = this.getKey(item, level);
    const candidate = __spreadProps(__spreadValues({}, item), {
      level,
      key
    });
    this.checkedItems.push(candidate);
    this.checkedKeys.add(key);
  }
  removeItem(item) {
    if (!this.isItemChecked(item)) {
      return;
    }
    const level = getHierarchicalItemLevel(item.index);
    const key = this.getKey(item, level);
    const candidate = __spreadProps(__spreadValues({}, item), {
      level,
      key
    });
    this.checkedItems = this.checkedItems.filter((item2) => {
      const valueMatch = valueFrom(item2, this.valueField) === valueFrom(candidate, this.valueField);
      const levelMatch = item2.level === candidate.level;
      return this.isHeterogeneous ? !(valueMatch && levelMatch) : !valueMatch;
    });
    this.checkedKeys.delete(key);
  }
  isItemChecked(item) {
    const level = item.index.split("_").length - 1;
    item.level = level;
    const key = this.getKey(item, level);
    return this.checkedKeys.has(key);
  }
  updateItems() {
    this.checkedItems = this.checkedItems || [];
    this.checkedKeys = new Set(this.checkedItems.map((item) => item.key));
  }
  /**
   * Adds the item's depth to the item's value to allow duplicate values on different levels.
   *
   * @param item - The checked key.
   * @returns { string } - A string key consisting of the item's `valueField` value and its depth (depth is 0 if data is homogeneous).
   */
  getKey(item, level) {
    return valueFrom(item, this.valueField) + "_" + (this.isHeterogeneous ? level : 0);
  }
  static ɵfac = function BaseCheckDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BaseCheckDirective)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _BaseCheckDirective,
    inputs: {
      valueField: "valueField",
      checkedItems: "checkedItems",
      isHeterogeneous: "isHeterogeneous"
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseCheckDirective, [{
    type: Directive
  }], null, {
    valueField: [{
      type: Input
    }],
    checkedItems: [{
      type: Input
    }],
    isHeterogeneous: [{
      type: Input
    }]
  });
})();
var CheckDirective2 = class _CheckDirective extends BaseCheckDirective {
  treeView;
  /**
   * Specifies whether items should be checked on click,
   * and whether checking a node will also check the node children as well.
   * The `checkChildren` prop also enables or disables parent item checking (i.e. checking all child items automatically checks the parent).
   */
  checkable;
  /**
   * The item key/keys by which the data items will be compared.
   */
  valueField;
  /**
   * Defines the collection that will store the full checked items.
   */
  checkedItems;
  /**
   * Fires when the `checkedItems` collection was updated.
   */
  checkedItemsChange = new EventEmitter();
  /**
   * Holds a Set with just the checked item keys.
   *
   * Should be updated each time the `checkedItems` value or content is changed.
   * Can be used for efficient look-up of whether an item is checked or not (O(1) access time).
   */
  checkedKeys = /* @__PURE__ */ new Set();
  subscriptions = new Subscription();
  clickSubscription;
  constructor(treeView) {
    super();
    this.treeView = treeView;
    this.subscriptions.add(this.treeView.checkedChange.subscribe(this.handleCheckedChange.bind(this)));
    this.treeView.isChecked = this.getCheckedState.bind(this);
  }
  ngOnChanges(changes) {
    if (isPresent7(changes["checkable"])) {
      this.toggleCheckOnClick();
    }
    if (isPresent7(changes["checkedItems"])) {
      this.updateItems();
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.unsubscribeClick();
  }
  getCheckedState(dataItem, index) {
    if (this.isItemChecked({
      dataItem,
      index
    })) {
      return "checked";
    } else if (this.checkable.checkChildren && this.isItemIndeterminate(this.treeView.itemLookup(index))) {
      return "indeterminate";
    } else {
      return "none";
    }
  }
  handleCheckedChange(node) {
    this.checkNode(node);
    const checkParents = this.checkable.checkChildren;
    if (checkParents) {
      this.checkParents(node.parent);
    }
    this.checkedItemsChange.emit(this.checkedItems.slice());
  }
  toggleCheckOnClick() {
    this.unsubscribeClick();
    if (this.checkable.checkOnClick) {
      this.clickSubscription = this.treeView.nodeClick.pipe(filter((event) => event.type === "click")).subscribe((event) => {
        const lookup = this.treeView.itemLookup(event.item.index);
        this.handleCheckedChange(lookup);
      });
    }
  }
  unsubscribeClick() {
    if (this.clickSubscription) {
      this.clickSubscription.unsubscribe();
      this.clickSubscription = null;
    }
  }
  checkNode(lookup) {
    if (this.treeView.isDisabled(lookup.item.dataItem, lookup.item.index)) {
      return;
    }
    const target = lookup.item;
    const pendingCheck = [target];
    if (this.checkable.checkChildren) {
      const filter2 = (item) => this.treeView.isVisible(item.dataItem, item.index) && !this.treeView.isDisabled(item.dataItem, item.index);
      fetchDescendentNodes(lookup, filter2).forEach((lookup2) => pendingCheck.push(lookup2.item));
    }
    const shouldCheck = !this.isItemChecked(target);
    pendingCheck.forEach((item) => {
      if (shouldCheck) {
        this.addItem(item);
      } else {
        this.removeItem(item);
      }
    });
  }
  checkParents(parent) {
    let currentParent = parent;
    while (currentParent) {
      const allChildrenSelected = currentParent.children.every((item) => this.isItemChecked(item));
      if (allChildrenSelected) {
        this.addItem(currentParent.item);
      } else {
        this.removeItem(currentParent.item);
      }
      currentParent = currentParent.parent;
    }
  }
  isItemIndeterminate(lookup) {
    const children = lookup.children;
    if (!Array.isArray(children) || children.length === 0) {
      return false;
    }
    let index = 0;
    let child = children[index];
    while (isPresent7(child)) {
      if (this.isItemChecked(child.item) || this.isItemIndeterminate(child)) {
        return true;
      }
      index += 1;
      child = children[index];
    }
    return false;
  }
  static ɵfac = function CheckDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CheckDirective)(ɵɵdirectiveInject(TreeViewComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CheckDirective,
    selectors: [["", "kendoMultiSelectTreeCheckable", ""]],
    inputs: {
      checkable: "checkable",
      valueField: "valueField",
      checkedItems: "checkedItems"
    },
    outputs: {
      checkedItemsChange: "checkedItemsChange"
    },
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckDirective2, [{
    type: Directive,
    args: [{
      selector: "[kendoMultiSelectTreeCheckable]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TreeViewComponent
    }];
  }, {
    checkable: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    checkedItems: [{
      type: Input
    }],
    checkedItemsChange: [{
      type: Output
    }]
  });
})();
var CheckAllDirective = class _CheckAllDirective extends BaseCheckDirective {
  element;
  zone;
  cdr;
  renderer;
  lastAction;
  treeview;
  /**
   * Defines the collection that will store the full checked items.
   */
  checkedItems;
  /**
   * The item key/keys by which the data items will be compared.
   */
  valueField;
  focused;
  /**
   * Fires when the `checkedItems` collection was updated.
   */
  checkedItemsChange = new EventEmitter();
  /**
   * Holds a Set with just the checked item keys.
   *
   * Should be updated each time the `checkedItems` value or content is changed.
   * Can be used for efficient look-up of whether an item is checked or not (O(1) access time).
   */
  checkedKeys = /* @__PURE__ */ new Set();
  currentCheckedState;
  currentIndeterminateState;
  handleChange(event) {
    this.currentCheckedState = event.checked;
    this.currentIndeterminateState = this.isIndeterminate;
    this.treeview.nodes.map((_value, index) => {
      const itemIndex2 = String(index);
      const itemLookup = this.treeview.itemLookup(itemIndex2);
      this.checkNode(itemLookup);
    });
    this.checkedItemsChange.emit(this.checkedItems.slice());
  }
  get isIndeterminate() {
    const isIndeterminate = this.treeview.nodes.some((_node, index) => {
      const itemIndex2 = String(index);
      const itemLookup = this.treeview.itemLookup(itemIndex2);
      return this.someChecked(itemLookup);
    });
    return this.isChecked ? false : isIndeterminate;
  }
  get isChecked() {
    const isChecked2 = this.treeview.nodes.every((_node, index) => {
      const itemIndex2 = String(index);
      const itemLookup = this.treeview.itemLookup(itemIndex2);
      return this.allChecked(itemLookup);
    });
    return isChecked2;
  }
  constructor(element, zone, cdr, renderer) {
    super();
    this.element = element;
    this.zone = zone;
    this.cdr = cdr;
    this.renderer = renderer;
  }
  ngOnChanges(changes) {
    if (isPresent7(changes["checkedItems"])) {
      this.updateItems();
      this.renderer.setProperty(this.element.nativeElement, "checked", this.isChecked);
      this.renderer.setProperty(this.element.nativeElement, "indeterminate", this.isIndeterminate);
    }
  }
  ngOnInit() {
    if (this.focused) {
      this.nextTick(() => this.element.nativeElement.focus());
    }
  }
  nextTick(fn) {
    this.zone.runOutsideAngular(() => setTimeout(fn));
  }
  checkNode(itemLookup) {
    if (this.treeview.isDisabled(itemLookup.item.dataItem, itemLookup.item.index)) {
      return;
    }
    const pendingCheck = [];
    const filter2 = (item) => this.treeview.isVisible(item.dataItem, item.index) && !this.treeview.isDisabled(item.dataItem, item.index);
    pendingCheck.push(itemLookup.item);
    fetchDescendentNodes(itemLookup, filter2).forEach((lookup) => pendingCheck.push(lookup.item));
    pendingCheck.forEach((item) => {
      if (this.currentIndeterminateState) {
        if (this.lastAction === "check") {
          this.addItem(item);
        } else {
          this.removeItem(item);
        }
        return;
      }
      if (this.currentCheckedState) {
        this.addItem(item);
      } else {
        this.removeItem(item);
      }
    });
  }
  allChecked(lookup) {
    const children = lookup && lookup.children;
    if (!Array.isArray(children)) {
      return;
    }
    const childrenChecked = children.every((child) => {
      if (child.children.length) {
        return this.isItemChecked(child.item) && this.allChecked(child);
      }
      return this.isItemChecked(child.item);
    });
    return childrenChecked && this.isItemChecked(lookup.item);
  }
  someChecked(lookup) {
    const children = lookup && lookup.children;
    if (!Array.isArray(children)) {
      return;
    }
    const childrenChecked = children.some((child) => {
      if (child.children.length) {
        return this.isItemChecked(child.item) || this.someChecked(child);
      }
      return this.isItemChecked(child.item);
    });
    return childrenChecked || this.isItemChecked(lookup.item);
  }
  static ɵfac = function CheckAllDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CheckAllDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CheckAllDirective,
    selectors: [["", "checkAll", ""]],
    hostBindings: function CheckAllDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function CheckAllDirective_change_HostBindingHandler($event) {
          return ctx.handleChange($event.target);
        });
      }
    },
    inputs: {
      lastAction: "lastAction",
      treeview: "treeview",
      checkedItems: "checkedItems",
      valueField: "valueField",
      focused: [0, "checkAll", "focused"]
    },
    outputs: {
      checkedItemsChange: "checkedItemsChange"
    },
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckAllDirective, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "[checkAll]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }];
  }, {
    lastAction: [{
      type: Input
    }],
    treeview: [{
      type: Input
    }],
    checkedItems: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    focused: [{
      type: Input,
      args: ["checkAll"]
    }],
    checkedItemsChange: [{
      type: Output
    }],
    handleChange: [{
      type: HostListener,
      args: ["change", ["$event.target"]]
    }]
  });
})();
var DEFAULT_POPUP_SETTINGS = {
  animate: true
};
var DEFAULT_CHECKABLE_SETTINGS = {
  checkChildren: true,
  checkOnClick: true
};
var hasChildren2 = () => false;
var fetchChildren = () => of([]);
var itemDisabled = () => false;
var isNodeVisible = () => true;
var DEFAULT_SIZE3 = "medium";
var DEFAULT_ROUNDED2 = "medium";
var DEFAULT_FILL_MODE2 = "solid";
var MultiSelectTreeComponent = class _MultiSelectTreeComponent {
  injector;
  wrapper;
  popupService;
  renderer;
  navigationService;
  _zone;
  localization;
  cdr;
  lookup;
  adaptiveService;
  /**
   * @hidden
   */
  touchEnabled = touchEnabled;
  /**
   * @hidden
   */
  animationDuration = animationDuration2;
  /**
   * @hidden
   */
  searchIcon = searchIcon;
  /**
   * @hidden
   */
  xIcon = xIcon;
  hostClasses = true;
  get isDisabled() {
    return this.disabled || null;
  }
  treeViewId = `k-${guid()}`;
  get hostAriaAutocomplete() {
    return this.filterable ? "list" : null;
  }
  get isLoading() {
    return this.loading;
  }
  get hostAriaInvalid() {
    return this.formControl?.invalid ? true : null;
  }
  get isBusy() {
    return this.loading ? "true" : null;
  }
  get id() {
    return this.focusableId;
  }
  direction;
  get hostTabIndex() {
    return this.tabindex;
  }
  role = "combobox";
  ariaHasPopup = "tree";
  get isReadonly() {
    return this.readonly ? "" : null;
  }
  get ariaDescribedBy() {
    return this.tagListId;
  }
  get ariaActiveDescendant() {
    return this.focusedTagId;
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  /**
   * @hidden
   */
  onFilterChange(text) {
    if (this.filterable) {
      this.filterChange.emit(text);
    }
  }
  /**
   * @hidden
   */
  onExpand() {
    this._searchableNodes = getSearchableItems(this.treeViewId, this.actionSheet.element.nativeElement);
    this.isActionSheetExpanded = true;
  }
  /**
   * @hidden
   */
  onCollapse() {
    this.isActionSheetExpanded = false;
  }
  /**
   * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.
   */
  adaptiveMode = "none";
  /**
   * Sets the title of the ActionSheet that is rendered instead of the Popup when using small screen devices.
   * By default the ActionSheet title uses the text provided for the label of the AutoComplete.
   */
  title = "";
  /**
   * Sets the subtitle of the ActionSheet that is rendered instead of the Popup when using small screen devices.
   * By default the ActionSheet subtitle uses the text provided for the `placeholder` of the AutoComplete.
  */
  set subtitle(_subtitle) {
    this._subtitle = _subtitle;
  }
  get subtitle() {
    return this._subtitle || this.placeholder;
  }
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
  * @hidden
  */
  windowSize = "large";
  /**
   * @hidden
   */
  isActionSheetExpanded = false;
  /**
   * @hidden
   */
  handleKeydown(event, input) {
    if (event.target === this.filterInput?.nativeElement && (event.keyCode === Keys.ArrowLeft || event.keyCode === Keys.ArrowRight)) {
      return;
    }
    if (input) {
      event.stopImmediatePropagation();
    }
    const deleteTag = this.isWrapperActive && event.keyCode === Keys.Backspace && this.tags.length > 0;
    if (deleteTag) {
      this.handleBackspace();
      return;
    }
    if (this.disabled || this.readonly) {
      return;
    }
    if (!this.isFilterActive && isLetter(event.key) && !this.actionSheetSearchBar?.onFocus) {
      this.printableCharacters.next(event.key);
    }
    const eventData = event;
    const action = this.navigationService.process({
      originalEvent: eventData,
      openOnSpace: !this.isOpen,
      closeOnSpace: false
    });
    if (action === NavigationAction.Open) {
      eventData.preventDefault();
    }
    if (this.isOpen && action === NavigationAction.Enter) {
      const spaceKeyDownEvent = new KeyboardEvent("keydown", {
        "key": " ",
        "code": "Space",
        "keyCode": 32,
        "which": 32
      });
      this.treeview?.element.nativeElement.dispatchEvent(spaceKeyDownEvent);
    }
  }
  /**
   * @hidden
   */
  responsiveRendererComponent;
  /**
   * @hidden
   */
  get actionSheet() {
    return this.responsiveRendererComponent?.actionSheet;
  }
  /**
   * @hidden
   */
  get actionSheetSearchBar() {
    return this.responsiveRendererComponent?.actionSheetSearchBar;
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  headerTemplate;
  footerTemplate;
  nodeTemplate;
  noDataTemplate;
  tagTemplate;
  groupTagTemplate;
  popupTemplate;
  container;
  set treeview(treeview) {
    this._treeview = treeview;
    if (treeview) {
      if (this.isFocused && !this.filterable && !this.checkAll || this.touchEnabled) {
        treeview.focus();
      }
      Promise.resolve(null).then(() => this.treeview.animate = true);
    }
  }
  get treeview() {
    return this._treeview;
  }
  filterInput;
  checkAllInput;
  /**
   * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   */
  set tabindex(value) {
    const providedTabIndex = parseNumber3(value);
    const defaultTabIndex = 0;
    this._tabindex = !isNaN(providedTabIndex) ? providedTabIndex : defaultTabIndex;
  }
  get tabindex() {
    return this.disabled ? -1 : this._tabindex;
  }
  /**
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE3;
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass2("input", this.size));
    if (size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("input", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `full`
   * * `none`
   *
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED2;
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    if (rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the fillMode of the component.
   *
   * The possible values are:
   * * `flat`
   * * `solid` (default)
   * * `outline`
   * * `none`
   *
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE2;
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    if (fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", newFillMode));
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Configures the popup of the MultiSelectTree.
   *
   * The available options are:
   * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
   * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped.
   * - `height: Number`&mdash;Sets the height of the popup container.
   * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
   * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
   */
  set popupSettings(settings) {
    this._popupSettings = Object.assign({}, DEFAULT_POPUP_SETTINGS, settings);
    this.cdr.detectChanges();
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Defines the checkable settings of the MultiSelecTree nodes.
   * If no value is provided, the default [`CheckableSettings`]({% slug api_dropdowns_multiselecttreecheckablesettings %}) are applied.
   */
  set checkableSettings(settings) {
    this._checkableSettings = Object.assign({}, DEFAULT_CHECKABLE_SETTINGS, settings);
  }
  get checkableSettings() {
    return this._checkableSettings;
  }
  /**
   * Sets the data of the MultiSelectTree.
   *
   * > The data has to be provided in an array-like list with objects.
   */
  set data(data) {
    this._nodes = data;
    this.setState();
    if (this.isContentInit) {
      this.registerLookupItems(data);
    }
  }
  get data() {
    return this._nodes;
  }
  /**
   * Sets the value of the MultiSelectTree.
   * It can either be of the primitive (string, numbers) or of the complex (objects) type.
   * To define the type, use the `valuePrimitive` option.
   *
   */
  set value(value) {
    this._value = value ? value : [];
    this.setState();
  }
  get value() {
    return this._value;
  }
  /**
   * Keeps the current `dataItems` object in order to resolve selection.
   * Needs to be provided when when programmatically setting a `value` and `valuePrimitive` is set to `true`.
   */
  set dataItems(items) {
    this._dataItems = (items || []).map((dataItem, index) => {
      if (hasProps(dataItem, ["dataItem", "index", "level"])) {
        return dataItem;
      }
      const level = this.valueDepth[index] || 0;
      const key = valueFrom({
        dataItem,
        level
      }, this.valueField) + "_" + (this.isHeterogeneous ? this.valueDepth[index] : 0);
      return {
        dataItem,
        index: null,
        level,
        key
      };
    });
    this.setState();
  }
  get dataItems() {
    return this._dataItems || this.value.map((value, index) => {
      const level = this.valueDepth[index] || 0;
      const key = valueFrom({
        dataItem: value,
        level
      }, this.valueField) + "_" + (this.isHeterogeneous ? this.valueDepth[index] : 0);
      return {
        dataItem: value,
        index: null,
        level,
        key
      };
    });
  }
  /**
   * The fields of the data item that provide the text content of the nodes inside the
   * MultiSelectTree ([see example]({% slug databinding_multiselecttree %})). If the `textField`
   * input is set to an array, each hierarchical level uses the field that corresponds
   * to the same index in the array, or the last item in the array.
   *
   * > The `textField` property can be set to point to a nested property value - e.g. `category.name`.
   */
  textField;
  /**
   * The fields of the data item that provide the value of the nodes inside the
   * MultiSelectTree ([see example]({% slug databinding_multiselecttree %})). If the `valueField`
   * input is set to an array, each hierarchical level uses the field that corresponds
   * to the same index in the array, or the last item in the array.
   *
   * > The `valueField` property can be set to point to a nested property value - e.g. `category.id`.
   */
  valueField;
  /**
   * Sets the levels in the data set where the values can be found when `valueField` is an Array.
   * The field serves to correctly allocate a data item used when the MultiSelectTree is initialized with a value.
   */
  valueDepth = [];
  /**
   * Sets and gets the loading state of the MultiSelectTree.
   */
  loading;
  /**
   * The hint which is displayed when the component is empty.
   */
  placeholder = "";
  /**
   * Sets the height of the options list in the popup. By default, `listHeight` is 200px.
   *
   * > The `listHeight` property affects only the list of options and not the whole popup container.
   * > To set the height of the popup container, use `popupSettings.height`.
   *
   * > When using `adaptiveMode` and the screen size is `small` or `medium` the `listHeight` property is set to null.
   */
  set listHeight(_listHeight) {
    this._listHeight = _listHeight;
  }
  get listHeight() {
    if (this.isAdaptive) {
      return;
    }
    return this._listHeight;
  }
  _listHeight = 200;
  /**
   * Sets the disabled state of the component. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_multiselecttree#toc-managing-the-multiselecttree-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Sets the read-only state of the component.
   *
   * @default false
   */
  readonly = false;
  /**
   * Specifies the type of the selected value
   * ([more information and example]({% slug valuebinding_multiselecttree %}#toc-primitive-values)).
   * If set to `true`, the selected value has to be a primitive one.
   */
  valuePrimitive = false;
  /**
   * Indicates whether the child nodes will be fetched on node expand or will be initially prefetched.
   * @default false
   */
  loadOnDemand = false;
  /**
   * @hidden
   *
   * Used by the kendo-label and kendo-floatinglabel to access and associate the focusable element with the provided label via aria-labelledby.
   */
  focusableId = `k-${guid()}`;
  /**
   * If set to `true`, renders a button on hovering over the component.
   * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.
   * @default true
   */
  clearButton = true;
  /**
   * Renders the built-in input element for filtering the MultiSelectTree.
   * If set to `true`, the component emits the `filterChange` event, which can be used to [filter the MultiSelectTree manually]({% slug filtering_multiselecttree %}#toc-manual-filtering).
   * A built-in filtering implementation is available to use with the [`kendoMultiSelectTreeHierarchyBinding`]({% slug api_dropdowns_multiselecttreehierarchybindingdirective %}) and [`kendoMultiSelectTreeFlatBinding`]({% slug api_dropdowns_multiselecttreeflatbindingdirective %}) directives.
   * @default false
   */
  filterable = false;
  /**
   * If `checkАll` is set to `true` and the checkboxes are enabled, a tri-state checkbox appears above the embedded treeview.
   * Clicking the checkbox checks or unchecks all enabled items of the treeview that are loaded.
   * @default false
   */
  checkAll = false;
  /**
   * A function which determines if a specific node has child nodes.
   */
  hasChildren = hasChildren2;
  /**
   * A function which provides the child nodes for a given parent node.
   */
  fetchChildren = fetchChildren;
  /**
   * A function that is executed for each data item and determines if a specific node is expanded.
   */
  isNodeExpanded;
  /**
   * A callback which determines whether a tree node should be rendered as hidden. The utility .k-hidden class is used to hide the nodes.
   * Useful for custom filtering implementations.
   */
  isNodeVisible = isNodeVisible;
  /**
   * A function that is executed for each data item and determines if a specific item is disabled.
   */
  itemDisabled = itemDisabled;
  /**
   * A user-defined callback function which receives an array of selected data items and maps them to an array of tags.
   *
   * @param { Any[] } dataItems - The selected data items from the list.
   * @returns { Any[] } - The tags that will be rendered by the component.
   */
  tagMapper = (tags) => tags || [];
  /**
   * Fires each time the user focuses the MultiSelectTree.
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the MultiSelectTree gets blurred.
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the popup is about to open
   * ([see example]({% slug openstate_multiselecttree %})).
   * This event is preventable. If you cancel it, the popup will remain closed.
   */
  open = new EventEmitter();
  /**
   * Fires after the popup has been opened.
   */
  opened = new EventEmitter();
  /**
   * Fires each time the popup is about to close
   * ([see example]({% slug openstate_multiselecttree %})).
   * This event is preventable. If you cancel it, the popup will remain open.
   */
  close = new EventEmitter();
  /**
   * Fires after the popup has been closed.
   */
  closed = new EventEmitter();
  /**
   * Fires when the user expands a node in the popup TreeView.
   */
  nodeExpand = new EventEmitter();
  /**
   * Fires when the user collapses a node in the popup TreeView.
   */
  nodeCollapse = new EventEmitter();
  /**
   * Fires each time the value is changed
   * ([see example](slug:events_multiselecttree)).
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time a tag is about to be removed([see examples]({% slug summarytagmode_multiselect %}#toc-notifying-on-removing-group-tags)).
   * This event is preventable. If you cancel it, the tag will not be removed.
   */
  removeTag = new EventEmitter();
  /**
   * Fires when the value of the built-in filter input element changes.
   */
  filterChange = new EventEmitter();
  /**
   * @hidden
   */
  get focusedTagId() {
    if (!isPresent7(this.focusedTagIndex) || this.isOpen) {
      return null;
    }
    return this.tagPrefix + "-" + this.focusedTagIndex;
  }
  set isFocused(isFocused) {
    this.renderer[isFocused ? "addClass" : "removeClass"](this.wrapper.nativeElement, "k-focus");
    this._isFocused = isFocused;
  }
  get isFocused() {
    return this._isFocused;
  }
  /**
   * Returns the current open state. Returns `true` if the popup or actionSheet is open.
   */
  get isOpen() {
    return isTruthy2(isPresent7(this.popupRef) || this.isActionSheetExpanded);
  }
  get width() {
    const wrapperWidth = this.wrapper.nativeElement.offsetWidth;
    const width = this.popupSettings.width || wrapperWidth;
    const minWidth = isNaN(wrapperWidth) ? wrapperWidth : `${wrapperWidth}px`;
    const maxWidth = isNaN(width) ? width : `${width}px`;
    return {
      min: minWidth,
      max: maxWidth
    };
  }
  get height() {
    const popupHeight = this.popupSettings.height;
    return isPresent7(popupHeight) ? `${popupHeight}px` : "auto";
  }
  get appendTo() {
    const {
      appendTo
    } = this.popupSettings;
    if (!appendTo || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  /**
   * @hidden
   */
  get popupContainerClasses() {
    const containerClasses = ["k-multiselecttree-popup"];
    if (this.popupSettings.popupClass) {
      containerClasses.push(this.popupSettings.popupClass);
    }
    return containerClasses;
  }
  /**
   * @hidden
   *
   * Alias for `data`. Used for compatibility with the `DataBoundComponent` interface.
   * Required for the data-binding directives.
   */
  set nodes(nodes) {
    this.data = nodes;
  }
  get nodes() {
    return this.data;
  }
  /**
   * @hidden
   *
   * Alias for `fetchChildren`. Used for compatibility with the `DataBoundComponent` interface.
   * Required for the data-binding directives
   */
  set children(callback) {
    this.fetchChildren = callback;
  }
  get children() {
    return this.fetchChildren;
  }
  /**
   * @hidden
   *
   * Alias for `nodeExpand`. Used for compatibility with the `ExpandableComponent` interface.
   * Required for the expand-directive.
   */
  get expand() {
    return this.nodeExpand;
  }
  /**
   * @hidden
   *
   * Alias for `nodeCollapse`. Used for compatibility with the `ExpandableComponent` interface.
   * Required for the expand-directive.
   */
  get collapse() {
    return this.nodeCollapse;
  }
  /**
   * @hidden
   *
   * Alias for `isNodeExpanded`. Used for compatibility with the `ExpandableComponent` interface.
   * Required for the expand-directive.
   */
  set isExpanded(callback) {
    this.isNodeExpanded = callback;
  }
  get isExpanded() {
    return this.isNodeExpanded;
  }
  /**
   * @hidden
   *
   * Alias for `isNodeVisible`. Used for compatibility with the `DataBoundComponent` interface.
   * The `DataBoundComponent` interface is used in the data-binding directives.
   */
  set isVisible(callback) {
    this.isNodeVisible = callback;
  }
  get isVisible() {
    return this.isNodeVisible;
  }
  get isTagFocused() {
    return !this.isOpen && this.focusedTagIndex !== void 0;
  }
  get isTreeViewActive() {
    return this.treeview && this.treeview.isActive;
  }
  get isWrapperActive() {
    return document.activeElement === this.wrapper.nativeElement;
  }
  get isFilterActive() {
    return this.filterInput && document.activeElement === this.filterInput.nativeElement;
  }
  get isCheckAllActive() {
    return this.checkAllInput && document.activeElement === this.checkAllInput.nativeElement;
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (this.isAdaptiveModeEnabled && this.windowSize !== currentWindowSize) {
      if (this.isOpen) {
        this.togglePopup(false);
      }
      this.windowSize = currentWindowSize;
    }
    if (this.isOpen && !this.isActionSheetExpanded) {
      const popupWrapper = this.popupRef.popupElement;
      const {
        min,
        max
      } = this.width;
      popupWrapper.style.minWidth = min;
      popupWrapper.style.width = max;
    }
  }
  /**
   * @hidden
   */
  filterStateChange = new EventEmitter();
  /**
   * @hidden
   */
  filter = "";
  /**
   * @hidden
   */
  checkedItems = [];
  /**
   * @hidden
   * The flag is needed in order to determine how to construct the items map keys.
   * If `true`, then the key consists of the item's value and level (depth),
   * else the key consists of the item's value and 0 (no leveling required)
   */
  isHeterogeneous;
  /**
   * @hidden
   */
  showAfter = 0;
  /**
   * @hidden
   */
  allNodesHidden = false;
  tagListId = `k-${guid()}`;
  tagPrefix = "tag-" + guid();
  popupRef;
  tags;
  focusedTagIndex = void 0;
  disabledIndices;
  _subtitle;
  _nodes;
  _value = [];
  _tabindex = 0;
  _popupSettings = DEFAULT_POPUP_SETTINGS;
  _checkableSettings = DEFAULT_CHECKABLE_SETTINGS;
  _isFocused = false;
  _treeview;
  _dataItems;
  _tempValue;
  _initiallyCheckedItems = [];
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  _searchableNodes = [];
  _typedValue = "";
  printableCharacters = new Subject();
  subs = new Subscription();
  // Keep an instance of the last focused node for when the popup close is prevented
  // in order to be able to properly restore the focus
  lastNodeOnFocus;
  // Used as check to avoid unnecessary 'registerLookupItems()' calls upon initialization
  isContentInit;
  constructor(injector, wrapper, popupService, renderer, navigationService, _zone, localization, cdr, lookup, adaptiveService) {
    this.injector = injector;
    this.wrapper = wrapper;
    this.popupService = popupService;
    this.renderer = renderer;
    this.navigationService = navigationService;
    this._zone = _zone;
    this.localization = localization;
    this.cdr = cdr;
    this.lookup = lookup;
    this.adaptiveService = adaptiveService;
    this.direction = localization.rtl ? "rtl" : "ltr";
    this.subscribeEvents();
    this.subscribeFocusEvents();
  }
  ngOnInit() {
    this.subs.add(this.printableCharacters.pipe(tap((char) => {
      this._typedValue += char;
      const itemToFocus = this._searchableNodes.find((node) => {
        return node.text.toLowerCase().indexOf(this._typedValue) === 0;
      });
      this.treeview.focus(itemToFocus?.index);
    }), debounceTime(1e3)).subscribe(() => {
      this._typedValue = "";
    }));
    this.renderer.removeAttribute(this.wrapper.nativeElement, "tabindex");
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-expanded", String(this.isOpen));
    this.subs.add(this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
      this.cdr.markForCheck();
    }));
    this.setComponentClasses();
    this._initiallyCheckedItems = [...this.checkedItems];
  }
  ngAfterViewInit() {
    this.windowSize = this.adaptiveService.size;
    this.subs.add(this.renderer.listen(this.wrapper.nativeElement, "click", this.handleClick.bind(this)));
    this.subs.add(this.renderer.listen(this.wrapper.nativeElement, "keydown", this.handleKeydown.bind(this)));
    if (this.actionSheet && isDocumentAvailable()) {
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-height", "60vh");
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-max-height", "none");
    }
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    this.destroyPopup();
    this.unsubscribeEvents();
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    if (anyChanged(["textField", "valueField", "valuePrimitive"], changes, false)) {
      this.isHeterogeneous = this.valueField && isArray3(this.valueField);
      this.setState();
    }
    if (anyChanged(["valueDepth", "value", "dataItems"], changes, false)) {
      if (changes["value"] && !changes["dataItems"] && !this.valuePrimitive) {
        this.dataItems = this.value;
      } else {
        this.dataItems = this.dataItems.map((item, index) => __spreadProps(__spreadValues({}, item), {
          key: valueFrom({
            dataItem: item.dataItem,
            index: null,
            level: this.valueDepth[index] || 0
          }, this.valueField) + "_" + (this.isHeterogeneous ? this.valueDepth[index] : 0),
          level: this.valueDepth[index] || 0
        }));
      }
    }
    if (anyChanged(["data", "children", "hasChildren", "loadOnDemand", "valueField"], changes, true) && !this.loadOnDemand) {
      this.lookup.reset();
      this.registerLookupItems(this.data);
    }
  }
  /**
   * @hidden
   */
  ngAfterContentChecked() {
    this.verifySettings();
    if (this.data?.length > 0 && this.popupRef) {
      this.allNodesHidden = this.areNodesHidden(this.data);
    }
  }
  /**
   * @hidden
   */
  applyValue() {
    this.value = this._tempValue;
    this._initiallyCheckedItems = [...this.checkedItems];
    this.emitValueChange(this.value);
    this.setTags();
    this.toggle(false);
  }
  /**
   * @hidden
   */
  cancelValue() {
    this.checkedItems = [...this._initiallyCheckedItems];
    this.togglePopup(false);
  }
  ngAfterContentInit() {
    this.isContentInit = true;
    this.registerLookupItems(this.data);
  }
  /**
   * @hidden
   *
   * Used by the kendo-floatinglabel component to determine if the floating label
   * should be rendered inside the input when the component is not focused.
   */
  isEmpty() {
    return !this.placeholder && (!isPresent7(this.value) || this.value.length === 0);
  }
  /**
   * Focuses the MultiSelectTree.
   */
  focus() {
    if (!this.disabled) {
      this.wrapper.nativeElement.focus();
    }
  }
  /**
   * Blurs the MultiSelectTree.
   */
  blur() {
    if (!this.disabled) {
      this.wrapper.nativeElement.blur();
    }
  }
  /**
   * Focuses a specific item of the MultiSelectTree based on a provided index in the format of `1_1`.
   * The targeted item should be expanded in order for it to be focused.
   * If null or invalid index is provided the focus will be set on the first item.
   */
  focusItemAt(index) {
    if (this.treeview) {
      const lookup = this.treeview.itemLookup(index);
      const isItemDisabled = !isPresent7(lookup) || this.treeview.isDisabled(lookup.item.dataItem, lookup.item.index);
      if (!isItemDisabled) {
        this.treeview.focus(index);
      }
    }
  }
  /**
   * Resets the value of the MultiSelectTree.
   * If you use the `reset` method to clear the value of the component,
   * the model will not update automatically and the `valueChange` event will not be fired.
   */
  reset() {
    this.value = [];
    this.dataItems = [];
    this.valueDepth = [];
  }
  /**
   * Toggles the visibility of the popup or actionSheet
   * ([see example]({% slug openstate_multiselecttree %})).
   * If you use the `toggle` method to open or close the popup, the `open` and `close` events will not be fired.
   *
   * @param open - The state of the popup.
   */
  toggle(open) {
    Promise.resolve(null).then(() => {
      const shouldOpen = isPresent7(open) ? open : !isPresent7(this.popupRef);
      this.destroyPopup();
      if (shouldOpen) {
        this.createPopup();
      }
    });
  }
  /**
   * @hidden
   */
  handleFocus(event) {
    if (event.target !== this.wrapper.nativeElement) {
      return;
    }
    event.stopImmediatePropagation();
    if (!this.isFocused) {
      this.isFocused = true;
      if (hasObservers(this.onFocus)) {
        this._zone.run(() => {
          this.onFocus.emit();
        });
      }
      if (this.isOpen && this.treeview) {
        if (this.lastNodeOnFocus) {
          this.lastNodeOnFocus.setAttribute("tabindex", "0");
        }
        this.treeview.focus();
      }
    }
  }
  /**
   * @hidden
   */
  handleBlur(e) {
    if (!this.isActionSheetExpanded) {
      const relatedTarget = e && e.relatedTarget;
      if (this.wrapper.nativeElement.contains(relatedTarget) || this.isOpen && this.popupRef.popupElement.contains(relatedTarget)) {
        return;
      }
      this.isFocused = false;
      this.togglePopup(false);
      this.cdr.markForCheck();
      if (hasObservers(this.onBlur) || isUntouched2(this.wrapper.nativeElement) || this.formControl?.updateOn === "blur") {
        this._zone.run(() => {
          this.onBlur.emit();
          this.onTouchedCallback();
        });
      }
    }
  }
  /**
   * @hidden
   */
  handleNodeClick(node) {
    if (!this.isFocused) {
      const parent = node.originalEvent.target.parentElement.parentElement;
      this.lastNodeOnFocus = parent;
      this.focus();
    }
  }
  /**
   * @hidden
   */
  togglePopup(open) {
    const isDisabled2 = this.disabled || this.readonly;
    const sameState = this.isOpen === open;
    this._zone.run(() => {
      this.focusedTagIndex = void 0;
    });
    if (isDisabled2 || sameState) {
      return;
    }
    const togglePrevented = this.triggerPopupEvents(open);
    if (!togglePrevented) {
      if (open) {
        this.createPopup();
      } else {
        this.destroyPopup();
      }
    } else {
      this.removeTreeViewFromTabOrder();
    }
  }
  /**
   * @hidden
   */
  messageFor(key) {
    return this.localization.get(key);
  }
  lastAction = "check";
  /**
   * @hidden
   */
  handleCheckedItemsChange(items) {
    this.valueDepth = items.map((item) => item.level);
    this.lastAction = items.length > this.dataItems.length ? "check" : "uncheck";
    this.dataItems = items.slice();
    this.updateValue(this.dataItems);
  }
  /**
   * @hidden
   */
  handleRemoveTag({
    tag,
    index
  }) {
    if (this.disabled || this.readonly) {
      return;
    }
    const eventArgs = new RemoveTagEvent(tag);
    this.removeTag.emit(eventArgs);
    if (eventArgs.isDefaultPrevented()) {
      return;
    }
    if (tag instanceof Array) {
      this.dataItems = this.dataItems.filter((_item, i) => i < this.showAfter || this.disabledIndices.has(i));
      this.valueDepth = this.valueDepth.filter((_item, i) => i < this.showAfter || this.disabledIndices.has(i));
    } else if (this.loadOnDemand) {
      this.dataItems = this.dataItems.filter((_item, i) => i !== index || this.disabledIndices.has(i));
      this.valueDepth = this.valueDepth.filter((_item, i) => i !== index || this.disabledIndices.has(i));
    } else {
      const dataItem = this.dataItems.find((item) => item.tagPositionIndex === index);
      const itemKey = dataItem.key;
      const lookup = this.lookup.itemLookup(itemKey);
      const pendingCheck = [lookup.item];
      if (this.checkableSettings.checkChildren) {
        fetchDescendentNodes(lookup).forEach((lookup2) => pendingCheck.push(lookup2.item));
        pendingCheck.push(...this.removeParents(lookup.parent));
      }
      const keysToRemove = pendingCheck.map((item) => item.key);
      const valueDepthIndices = [];
      this.dataItems = this.dataItems.filter((_item, i) => {
        const shouldStay = !keysToRemove.includes(_item.key) || this.disabledIndices.has(i);
        if (!shouldStay) {
          valueDepthIndices.push(i);
        }
        return shouldStay;
      });
      this.valueDepth = this.valueDepth.filter((_item, i) => {
        return !valueDepthIndices.includes(i) || this.disabledIndices.has(i);
      });
    }
    this.updateValue(this.dataItems);
    if (!this.isFocused) {
      this.focus();
    }
  }
  /**
   * @hidden
   */
  handleTagMapperChange(showAfter) {
    this.showAfter = parseNumber3(showAfter);
    this.setTags();
  }
  /**
   * @hidden
   */
  clearAll(event) {
    event.stopImmediatePropagation();
    event.preventDefault();
    this.focus();
    this.value = this.value.filter((_item, index) => this.disabledIndices.has(index));
    this.dataItems = this.dataItems.filter((_item, index) => this.disabledIndices.has(index));
    this.valueDepth = this.valueDepth.filter((_depth, index) => this.disabledIndices.has(index));
    this.emitValueChange(this.value);
  }
  /**
   * @hidden
   */
  writeValue(value) {
    if (!this.valuePrimitive && isPresent7(value)) {
      this.dataItems = value;
    }
    if (!isPresent7(value) && isPresent7(this.value)) {
      this.dataItems = null;
    }
    this.value = value || [];
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onChangeCallback = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.disabled = isDisabled2;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  handleFilterInputChange(input) {
    this.filter = input.value;
    this.filterChange.next(input.value);
  }
  /**
   * @hidden
   */
  get filterInputClasses() {
    return `${this.size ? getSizeClass2("input", this.size) : ""} ${this.fillMode ? "k-input-" + this.fillMode : ""} ${this.rounded ? getRoundedClass(this.rounded) : ""}`;
  }
  /**
   * @hidden
   */
  get checkAllCheckboxClasses() {
    return `${this.size ? getSizeClass2("checkbox", this.size) : ""}`;
  }
  /**
   * @hidden
   */
  toggleCheckAll() {
    this.checkAllInput.nativeElement.focus();
    this.checkAllInput.nativeElement.click();
  }
  onTouchedCallback = noop6;
  onChangeCallback = noop6;
  verifySettings() {
    if (!isDevMode()) {
      return;
    }
    if (!isPresent7(this.valueField) || !isPresent7(this.textField)) {
      throw new Error(MultiSelectTreeMessages.textAndValue);
    }
    if (!isArray3(this.value)) {
      throw new Error(MultiSelectTreeMessages.array);
    }
    if (this.value.length > 0) {
      if (this.valuePrimitive && this.value.some((item) => isObject2(item))) {
        throw new Error(MultiSelectTreeMessages.primitive);
      }
      const isEveryDataItemObject = this.dataItems.every((item) => isObject2(item.dataItem));
      if (this.valuePrimitive && !isArray3(this.dataItems)) {
        throw new Error(MultiSelectTreeMessages.dataItems);
      }
      if (this.valuePrimitive && !isEveryDataItemObject) {
        throw new Error(MultiSelectTreeMessages.dataItems);
      }
      if (this.valuePrimitive && this.dataItems.length !== this.value.length) {
        throw new Error(MultiSelectTreeMessages.dataItemsLength);
      }
      if (!this.valuePrimitive && !isObjectArray(this.value)) {
        throw new Error(MultiSelectTreeMessages.object);
      }
      if ((isArray3(this.valueField) || isArray3(this.textField)) && !isArray3(this.valueDepth)) {
        throw new Error(MultiSelectTreeMessages.valueDepth);
      }
      if ((isArray3(this.valueField) || isArray3(this.textField)) && this.valueDepth.length === 0) {
        throw new Error(MultiSelectTreeMessages.valueDepth);
      }
      if ((isArray3(this.valueField) || isArray3(this.textField)) && this.valueDepth.length !== this.value.length) {
        throw new Error(MultiSelectTreeMessages.valueDepthLength);
      }
    }
  }
  areNodesHidden(nodes) {
    return nodes.every((node, index) => !this.isVisible(node, String(index)));
  }
  emitValueChange(value) {
    this.onChangeCallback(value);
    this.valueChange.emit(value);
  }
  triggerPopupEvents(open) {
    const eventArgs = new PreventableEvent5();
    if (hasObservers(this.open) || hasObservers(this.close)) {
      this._zone.run(() => {
        if (open) {
          this.open.emit(eventArgs);
        } else {
          this.close.emit(eventArgs);
        }
      });
    }
    return eventArgs.isDefaultPrevented();
  }
  createPopup() {
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.openActionSheet();
      this.cdr.detectChanges();
      return;
    }
    const horizontalAlign = this.direction === "rtl" ? "right" : "left";
    const anchorPosition = {
      horizontal: horizontalAlign,
      vertical: "bottom"
    };
    const popupPosition = {
      horizontal: horizontalAlign,
      vertical: "top"
    };
    const appendToComponent = typeof this.popupSettings.appendTo === "string" && this.popupSettings.appendTo === "component";
    this.popupRef = this.popupService.open({
      anchor: this.wrapper,
      appendTo: this.appendTo,
      anchorAlign: anchorPosition,
      animate: this.popupSettings.animate,
      content: this.popupTemplate,
      popupAlign: popupPosition,
      positionMode: appendToComponent ? "fixed" : "absolute",
      popupClass: this.popupContainerClasses
    });
    const popupWrapper = this.popupRef.popupElement;
    const {
      min,
      max
    } = this.width;
    if (!this.appendTo) {
      this.renderer.setAttribute(popupWrapper, "role", "region");
      this.renderer.setAttribute(popupWrapper, "aria-label", this.messageFor("popupLabel"));
    }
    popupWrapper.style.minWidth = min;
    popupWrapper.style.width = max;
    popupWrapper.style.height = this.height;
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-controls", this.treeViewId);
    this.renderer.setAttribute(popupWrapper, "dir", this.direction);
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-expanded", "true");
    this.popupRef.popupOpen.subscribe(() => {
      this.cdr.detectChanges();
      this.opened.emit();
      this._searchableNodes = getSearchableItems(this.treeViewId, this.popupRef.popupElement);
    });
    this.popupRef.popupClose.subscribe(() => {
      if (hasObservers(this.closed)) {
        this._zone.run(() => {
          this.closed.emit();
        });
      }
    });
  }
  destroyPopup() {
    if (this.isActionSheetExpanded) {
      this.closeActionSheet();
    }
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
      this.renderer.setAttribute(this.wrapper.nativeElement, "aria-expanded", "false");
      this.renderer.removeAttribute(this.wrapper.nativeElement, "aria-controls");
      if (this.filter !== "") {
        this.filter = "";
        this.allNodesHidden = false;
        if (hasObservers(this.filterChange)) {
          this._zone.run(() => {
            this.filterChange.emit("");
          });
        }
      }
    }
  }
  handleClick(e) {
    if (this.popupRef && this.popupRef.popupElement.contains(e.target) || this.isActionSheetExpanded) {
      return;
    }
    this.togglePopup(!this.isOpen);
  }
  subscribeEvents() {
    [this.navigationService.open.subscribe((event) => {
      event.originalEvent.preventDefault();
      this.togglePopup(true);
    }), this.navigationService.enter.pipe(tap((event) => event.originalEvent.preventDefault())).subscribe(() => this.togglePopup(true)), merge(this.navigationService.close, this.navigationService.esc).subscribe((event) => {
      event.originalEvent.preventDefault();
      this.focus();
      this.togglePopup(false);
    }), this.navigationService.tab.subscribe(this.handleTabKey.bind(this)), this.navigationService.up.subscribe(this.handleUpKey.bind(this)), this.navigationService.down.subscribe(this.handleDownKey.bind(this)), this.navigationService.left.pipe(filter(() => !this.isTreeViewActive)).subscribe(this.direction === "rtl" ? this.handleRightKey.bind(this) : this.handleLeftKey.bind(this)), this.navigationService.right.pipe(filter(() => !this.isTreeViewActive)).subscribe(this.direction === "rtl" ? this.handleLeftKey.bind(this) : this.handleRightKey.bind(this)), this.navigationService.home.pipe(filter(() => !this.isOpen)).subscribe(this.handleHome.bind(this)), this.navigationService.end.pipe(filter(() => !this.isOpen)).subscribe(this.handleEnd.bind(this)), this.navigationService.backspace.pipe(filter(() => this.isTagFocused)).subscribe(this.handleBackspace.bind(this)), this.navigationService.delete.pipe(filter(() => this.isTagFocused)).subscribe(this.handleDelete.bind(this))].forEach((sub) => this.subs.add(sub));
  }
  subscribeFocusEvents() {
    if (isDocumentAvailable()) {
      this.handleFocus = this.handleFocus.bind(this);
      this.handleDocumentBlur = this.handleDocumentBlur.bind(this);
      this._zone.runOutsideAngular(() => {
        const useCapture = true;
        document.addEventListener("focus", this.handleFocus, useCapture);
        document.addEventListener("blur", this.handleDocumentBlur, useCapture);
      });
    }
  }
  unSubscribeFocusEvents() {
    if (isDocumentAvailable()) {
      const useCapture = true;
      document.removeEventListener("focus", this.handleFocus, useCapture);
      document.removeEventListener("blur", this.handleDocumentBlur, useCapture);
    }
  }
  handleDocumentBlur(event) {
    if (event.target !== this.wrapper.nativeElement) {
      return;
    }
    event.stopImmediatePropagation();
    this.handleBlur(event);
  }
  handleTabKey() {
    if (!this.isActionSheetExpanded) {
      this.focus();
    }
    if (this.isOpen) {
      this.treeview.blur();
      this.removeTreeViewFromTabOrder();
    }
  }
  handleUpKey(event) {
    if (!this.treeview) {
      return;
    }
    event.originalEvent.preventDefault();
    if (this.isWrapperActive) {
      return;
    }
    const isFirstNodeActive = this.treeview["navigationService"]["activeIndex"] === "0";
    if (this.filterable && this.isFilterActive) {
      this.focus();
    } else if (this.checkAll && !this.isCheckAllActive && isFirstNodeActive) {
      this.checkAllInput.nativeElement.focus();
    } else if (this.isCheckAllActive || isFirstNodeActive) {
      if (this.filterable) {
        this.isActionSheetExpanded ? this.actionSheetSearchBar.focus() : this.filterInput.nativeElement.focus();
      } else {
        if (!this.isActionSheetExpanded) {
          this.focus();
        }
      }
    }
  }
  handleDownKey(event) {
    if (!this.treeview) {
      return;
    }
    event.originalEvent.preventDefault();
    if (this.filterable && this.isWrapperActive) {
      this.filterInput.nativeElement.focus();
    } else if (this.checkAll && (this.isWrapperActive || this.isFilterActive)) {
      this.checkAllInput.nativeElement.focus();
    } else if (!this.treeview.isActive) {
      this.treeview.focus();
    }
    this.focusedTagIndex = void 0;
  }
  handleRightKey(event) {
    event.originalEvent.preventDefault();
    const last2 = this.tags.length - 1;
    if (this.focusedTagIndex === last2) {
      this.focusedTagIndex = void 0;
    } else if (this.focusedTagIndex < last2) {
      this.focusedTagIndex++;
    } else if (!this.focusedTagIndex) {
      this.focusedTagIndex = 0;
    }
  }
  handleLeftKey(event) {
    event.originalEvent.preventDefault();
    if (this.focusedTagIndex === void 0 || this.focusedTagIndex < 0) {
      this.focusedTagIndex = this.tags.length - 1;
    } else if (this.focusedTagIndex !== 0) {
      this.focusedTagIndex--;
    }
  }
  handleEnd(event) {
    event.originalEvent.preventDefault();
    this.focusedTagIndex = this.tags.length - 1;
  }
  handleHome(event) {
    event.originalEvent.preventDefault();
    this.focusedTagIndex = 0;
  }
  handleBackspace() {
    if (this.focusedTagIndex !== void 0) {
      this.handleDelete();
    } else {
      const tag = this.tags[this.tags.length - 1];
      const index = this.tags.length - 1;
      this.handleRemoveTag({
        tag,
        index
      });
    }
  }
  handleDelete() {
    const tag = this.tags[this.focusedTagIndex];
    const index = this.focusedTagIndex;
    this.handleRemoveTag({
      tag,
      index
    });
    if (this.focusedTagIndex === this.tags.length) {
      this.focusedTagIndex = void 0;
    }
  }
  unsubscribeEvents() {
    this.subs.unsubscribe();
    this.unSubscribeFocusEvents();
  }
  /**
   * Remove the `TreeView` from the tab order, otherwise a focus loop between the page elements will occur
   * and the user will not be able to tab to the rest of the browser elements
   */
  removeTreeViewFromTabOrder() {
    const nodes = this.treeview.element.nativeElement.querySelectorAll("li");
    nodes.forEach((item) => {
      if (item.getAttribute("tabindex") === "0") {
        this.lastNodeOnFocus = item;
        this.lastNodeOnFocus.setAttribute("tabindex", "-1");
      }
    });
  }
  setState() {
    if (isPresent7(this.dataItems) && isPresent7(this.valueField)) {
      if (!this.isActionSheetExpanded) {
        this.setTags();
      }
      this.checkedItems = this.dataItems.slice();
    }
    this.cdr.markForCheck();
  }
  setTags() {
    const source = this.dataItems.map((item) => item.dataItem);
    this.tags = this.tagMapper(source);
    this.disabledIndices = this.disabledItemsMapper();
    const tagIndexMap = new Map(this.tags.map((tag, index) => [JSON.stringify(tag), index]));
    this.dataItems.forEach((item) => {
      const serializedDataItem = JSON.stringify(item.dataItem);
      item.tagPositionIndex = tagIndexMap.has(serializedDataItem) ? tagIndexMap.get(serializedDataItem) : null;
    });
  }
  updateValue(value) {
    const newValue = this.valuePrimitive ? value.map((item) => valueFrom(item, this.valueField)) : value.map((item) => item.dataItem);
    if (this.isActionSheetExpanded) {
      this._tempValue = newValue.slice();
    } else {
      this.value = newValue;
      this.emitValueChange(this.value);
    }
  }
  /**
   * @hidden
   */
  onChildrenLoaded() {
    setTimeout(() => {
      if (this.popupRef) {
        this._searchableNodes = getSearchableItems(this.treeViewId, this.popupRef.popupElement);
      }
      if (this.isActionSheetExpanded) {
        this._searchableNodes = getSearchableItems(this.treeViewId, this.actionSheet.element.nativeElement);
      }
    });
  }
  /**
   * @hidden
   *
   * Determines which of the provided tags should be disabled and stores their position indices
   */
  disabledItemsMapper() {
    return new Set(this.dataItems.reduce((indices, item, index) => {
      if (this.itemDisabled(item.dataItem, item.index)) {
        indices.push(index);
      }
      return indices;
    }, []));
  }
  setComponentClasses() {
    if (this.size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("input", this.size));
    }
    if (this.rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    }
  }
  removeParents(parent) {
    let currentParent = parent;
    const nodes = [];
    while (currentParent) {
      nodes.push(currentParent.item);
      currentParent = currentParent.parent;
    }
    return nodes;
  }
  /**
   * Creates an internal map of the available tree items to be used as a reference
   * to retrieve the item's children/parent and determine the checked sate
   */
  registerLookupItems(data, parentItem = null, levelIndex = 0) {
    if (!isPresent7(data) || data.length === 0) {
      return;
    }
    const parentIndex = nodeIndex2(parentItem);
    const treeItems = data.map((node) => buildTreeItem2(node, this.valueField, levelIndex));
    if (isPresent7(parentItem)) {
      this.lookup.registerChildren(parentIndex, treeItems);
    }
    treeItems.forEach((item) => {
      this.lookup.registerItem(item, parentItem);
      if (!this.loadOnDemand) {
        this.registerChildLookupItems(item, levelIndex);
      }
    });
  }
  registerChildLookupItems(item, levelIndex) {
    if (this.hasChildren(item.dataItem)) {
      this.children(item.dataItem).subscribe((children) => {
        const index = this.isHeterogeneous ? levelIndex + 1 : 0;
        this.registerLookupItems(children, item, index);
      });
    }
  }
  closeActionSheet() {
    this.wrapper.nativeElement.focus();
    this.actionSheet.toggle(false);
    this.renderer.removeAttribute(this.wrapper.nativeElement, "aria-controls");
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-expanded", "false");
    if (this.filterable) {
      this.actionSheetSearchBar.value = "";
      this.filterChange.emit("");
    }
    this.closed.emit();
  }
  openActionSheet() {
    this.windowSize = this.adaptiveService.size;
    this.actionSheet.toggle(true);
    this.title = setActionSheetTitle(this.wrapper, this.title);
    this.cdr.detectChanges();
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-controls", this.treeViewId);
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-expanded", "true");
    updateActionSheetAdaptiveAppearance2(this.actionSheet, this.windowSize, this.renderer);
    this.cdr.detectChanges();
    this.opened.emit();
    this.filterable && this.actionSheetSearchBar.focus();
  }
  static ɵfac = function MultiSelectTreeComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiSelectTreeComponent)(ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NavigationService3), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(MultiSelectTreeLookupService), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MultiSelectTreeComponent,
    selectors: [["kendo-multiselecttree"]],
    contentQueries: function MultiSelectTreeComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, NodeTemplateDirective2, 5);
        ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, TagTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, GroupTagTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.nodeTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tagTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupTagTemplate = _t.first);
      }
    },
    viewQuery: function MultiSelectTreeComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(ResponsiveRendererComponent, 5);
        ɵɵviewQuery(_c104, 7);
        ɵɵviewQuery(_c94, 7, ViewContainerRef);
        ɵɵviewQuery(_c233, 5);
        ɵɵviewQuery(_c242, 5);
        ɵɵviewQuery(_c262, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.responsiveRendererComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.treeview = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.checkAllInput = _t.first);
      }
    },
    hostVars: 22,
    hostBindings: function MultiSelectTreeComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-disabled", ctx.isDisabled)("aria-autocomplete", ctx.hostAriaAutocomplete)("aria-invalid", ctx.hostAriaInvalid)("aria-busy", ctx.isBusy)("id", ctx.id)("dir", ctx.direction)("tabindex", ctx.hostTabIndex)("role", ctx.role)("aria-haspopup", ctx.ariaHasPopup)("readonly", ctx.isReadonly)("aria-describedby", ctx.ariaDescribedBy)("aria-activedescendant", ctx.ariaActiveDescendant);
        ɵɵclassProp("k-multiselecttree", ctx.hostClasses)("k-input", ctx.hostClasses)("k-disabled", ctx.isDisabled)("k-loading", ctx.isLoading)("k-readonly", ctx.readonly);
      }
    },
    inputs: {
      adaptiveMode: "adaptiveMode",
      title: "title",
      subtitle: "subtitle",
      tabindex: "tabindex",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      popupSettings: "popupSettings",
      checkableSettings: "checkableSettings",
      data: "data",
      value: "value",
      dataItems: "dataItems",
      textField: "textField",
      valueField: "valueField",
      valueDepth: "valueDepth",
      loading: "loading",
      placeholder: "placeholder",
      listHeight: "listHeight",
      disabled: "disabled",
      readonly: "readonly",
      valuePrimitive: "valuePrimitive",
      loadOnDemand: "loadOnDemand",
      focusableId: "focusableId",
      clearButton: "clearButton",
      filterable: "filterable",
      checkAll: "checkAll",
      hasChildren: "hasChildren",
      fetchChildren: "fetchChildren",
      isNodeExpanded: "isNodeExpanded",
      isNodeVisible: "isNodeVisible",
      itemDisabled: "itemDisabled",
      tagMapper: "tagMapper"
    },
    outputs: {
      onFocus: "focus",
      onBlur: "blur",
      open: "open",
      opened: "opened",
      close: "close",
      closed: "closed",
      nodeExpand: "nodeExpand",
      nodeCollapse: "nodeCollapse",
      valueChange: "valueChange",
      removeTag: "removeTag",
      filterChange: "filterChange"
    },
    exportAs: ["kendoMultiSelectTree"],
    features: [ɵɵProvidersFeature([LocalizationService, NavigationService3, DataService, DisabledItemsService, SelectionService2, MultiSelectTreeLookupService, {
      provide: L10N_PREFIX,
      useValue: "kendo.multiselecttree"
    }, {
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _MultiSelectTreeComponent)
    }, {
      provide: DataBoundComponent,
      useExisting: forwardRef(() => _MultiSelectTreeComponent)
    }, {
      provide: ExpandableComponent,
      useExisting: forwardRef(() => _MultiSelectTreeComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _MultiSelectTreeComponent)
    }]), ɵɵNgOnChangesFeature],
    decls: 14,
    vars: 24,
    consts: () => {
      let i18n_25;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_25 = goog.getMsg("NO DATA FOUND");
        i18n_25 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_25;
      } else {
        i18n_25 = $localize`:kendo.multiselecttree.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;
      }
      let i18n_26;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_26 = goog.getMsg("clear");
        i18n_26 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_26;
      } else {
        i18n_26 = $localize`:kendo.multiselecttree.clearTitle|The title of the clear button:clear`;
      }
      let i18n_27;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_27 = goog.getMsg("Check all");
        i18n_27 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_27;
      } else {
        i18n_27 = $localize`:kendo.multiselecttree.checkAllText|The text displayed for the check-all checkbox:Check all`;
      }
      let i18n_28;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_28 = goog.getMsg("Filter");
        i18n_28 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_28;
      } else {
        i18n_28 = $localize`:kendo.multiselecttree.filterInputLabel|The text set as aria-label on the filter input:Filter`;
      }
      let i18n_29;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_29 = goog.getMsg("Options list");
        i18n_29 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_29;
      } else {
        i18n_29 = $localize`:kendo.multiselecttree.popupLabel|The label of the popup element that contains the list of options when its role is 'region':Options list`;
      }
      let i18n_30;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_30 = goog.getMsg("Apply");
        i18n_30 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_30;
      } else {
        i18n_30 = $localize`:kendo.multiselecttree.applyButton|The text of the Apply button in the action sheet:Apply`;
      }
      let i18n_31;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_31 = goog.getMsg("Cancel");
        i18n_31 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_31;
      } else {
        i18n_31 = $localize`:kendo.multiselecttree.cancelButton|The text of the Cancel button in the action sheet:Cancel`;
      }
      return [["popupTemplate", ""], ["container", ""], ["sharedPopupActionSheetTemplate", ""], ["treeview", ""], ["filterInput", ""], ["checkAllInput", ""], ["kendoMultiSelectTreeLocalizedMessages", "", "noDataText", i18n_25, "clearTitle", i18n_26, "checkAllText", i18n_27, "filterInputLabel", i18n_28, "popupLabel", i18n_29, "applyButton", i18n_30, "cancelButton", i18n_31], [1, "k-input-values", 3, "removeTag", "size", "rounded", "fillMode", "id", "tags", "focused", "textField", "valueField", "valueDepth", "disabled", "tagPrefix", "template", "groupTemplate", "disabledIndices"], [1, "k-input-inner"], ["class", "k-input-value-text", 4, "ngIf"], ["class", "k-clear-value", "role", "button", "tabindex", "-1", 3, "click", 4, "ngIf"], ["class", "k-icon k-i-loading k-input-loading-icon", 4, "ngIf"], [3, "closePopup", "onExpand", "onCollapse", "textInputChange", "onApply", "onCancel", "sharedPopupActionSheetTemplate", "isActionSheetExpanded", "title", "showTextInput", "showActionButtons", "subtitle"], [3, "resize", 4, "ngIf"], [1, "k-input-value-text"], ["role", "button", "tabindex", "-1", 1, "k-clear-value", 3, "click"], ["name", "x", 1, "k-icon", 3, "svgIcon"], [1, "k-icon", "k-i-loading", "k-input-loading-icon"], [4, "ngTemplateOutlet"], ["class", "k-list-filter", 4, "ngIf"], [4, "ngIf"], ["class", "k-check-all", 4, "ngIf"], ["kendoMultiSelectTreeCheckable", "", 3, "keydown", "nodeClick", "expand", "collapse", "checkedItemsChange", "childrenLoaded", "size", "nodes", "animate", "isHeterogeneous", "checkable", "checkedItems", "valueField", "textField", "children", "hasChildren", "isExpanded", "isDisabled", "nodeTemplate", "loadOnDemand", "filter", "isVisible", "kendoEventsOutsideAngular", "scope"], ["class", "k-no-data", 4, "ngIf"], [1, "k-list-filter"], [1, "k-textbox", "k-input", 3, "ngClass"], [1, "k-input-prefix"], ["name", "search", 1, "k-icon", 3, "svgIcon"], ["role", "searchbox", "tabindex", "0", "aria-disabled", "false", "aria-readonly", "false", 1, "k-input-inner", 3, "input", "keydown", "filterInput", "value", "kendoEventsOutsideAngular", "scope"], [3, "templateContext"], [1, "k-check-all"], [1, "k-checkbox-wrap"], ["type", "checkbox", "role", "checkbox", "tabindex", "0", "aria-disabled", "false", "aria-readonly", "false", 1, "k-checkbox", 3, "checkedItemsChange", "keydown", "checkAll", "ngClass", "treeview", "checkedItems", "valueField", "lastAction", "kendoEventsOutsideAngular", "scope"], [1, "k-checkbox-label", 3, "click", "mousedown"], [1, "k-no-data"], [3, "ngIf", "templateContext"], [3, "ngIf"], [3, "resize"]];
    },
    template: function MultiSelectTreeComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 6);
        ɵɵelementStart(1, "kendo-taglist", 7);
        ɵɵlistener("removeTag", function MultiSelectTreeComponent_Template_kendo_taglist_removeTag_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleRemoveTag($event));
        });
        ɵɵelementEnd();
        ɵɵelementStart(2, "span", 8);
        ɵɵtemplate(3, MultiSelectTreeComponent_span_3_Template, 2, 1, "span", 9);
        ɵɵelementEnd();
        ɵɵtemplate(4, MultiSelectTreeComponent_span_4_Template, 2, 2, "span", 10)(5, MultiSelectTreeComponent_span_5_Template, 1, 0, "span", 11)(6, MultiSelectTreeComponent_ng_template_6_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        ɵɵelementContainer(8, null, 1);
        ɵɵelementStart(10, "responsive-renderer", 12);
        ɵɵlistener("closePopup", function MultiSelectTreeComponent_Template_responsive_renderer_closePopup_10_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.togglePopup(false));
        })("onExpand", function MultiSelectTreeComponent_Template_responsive_renderer_onExpand_10_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onExpand());
        })("onCollapse", function MultiSelectTreeComponent_Template_responsive_renderer_onCollapse_10_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onCollapse());
        })("textInputChange", function MultiSelectTreeComponent_Template_responsive_renderer_textInputChange_10_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onFilterChange($event));
        })("onApply", function MultiSelectTreeComponent_Template_responsive_renderer_onApply_10_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.applyValue());
        })("onCancel", function MultiSelectTreeComponent_Template_responsive_renderer_onCancel_10_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.cancelValue());
        });
        ɵɵelementEnd();
        ɵɵtemplate(11, MultiSelectTreeComponent_ng_template_11_Template, 7, 28, "ng-template", null, 2, ɵɵtemplateRefExtractor)(13, MultiSelectTreeComponent_kendo_resize_sensor_13_Template, 1, 0, "kendo-resize-sensor", 13);
      }
      if (rf & 2) {
        const sharedPopupActionSheetTemplate_r4 = ɵɵreference(12);
        ɵɵadvance();
        ɵɵproperty("size", ctx.size)("rounded", ctx.rounded)("fillMode", ctx.fillMode)("id", ctx.tagListId)("tags", ctx.tags)("focused", ctx.focusedTagIndex)("textField", ctx.textField)("valueField", ctx.valueField)("valueDepth", ctx.valueDepth)("disabled", ctx.disabled)("tagPrefix", ctx.tagPrefix)("template", ctx.tagTemplate)("groupTemplate", ctx.groupTagTemplate)("disabledIndices", ctx.disabledIndices);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", !ctx.tags || !ctx.tags.length);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.disabled && !ctx.loading && !ctx.readonly && ctx.clearButton && (ctx.tags == null ? null : ctx.tags.length));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.loading);
        ɵɵadvance(5);
        ɵɵproperty("sharedPopupActionSheetTemplate", sharedPopupActionSheetTemplate_r4)("isActionSheetExpanded", ctx.isActionSheetExpanded)("title", ctx.title)("showTextInput", ctx.filterable)("showActionButtons", true)("subtitle", ctx.subtitle);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.isOpen || ctx.isAdaptiveModeEnabled);
      }
    },
    dependencies: [LocalizedMessagesDirective3, TagListComponent, NgIf, IconWrapperComponent, NgTemplateOutlet, ResponsiveRendererComponent, NgClass, FilterInputDirective, EventsOutsideAngularDirective, TemplateContextDirective, CheckAllDirective, TreeViewComponent, CheckDirective2, ResizeSensorComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiSelectTreeComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoMultiSelectTree",
      providers: [LocalizationService, NavigationService3, DataService, DisabledItemsService, SelectionService2, MultiSelectTreeLookupService, {
        provide: L10N_PREFIX,
        useValue: "kendo.multiselecttree"
      }, {
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => MultiSelectTreeComponent)
      }, {
        provide: DataBoundComponent,
        useExisting: forwardRef(() => MultiSelectTreeComponent)
      }, {
        provide: ExpandableComponent,
        useExisting: forwardRef(() => MultiSelectTreeComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => MultiSelectTreeComponent)
      }],
      selector: "kendo-multiselecttree",
      template: `
        <ng-container kendoMultiSelectTreeLocalizedMessages
            i18n-noDataText="kendo.multiselecttree.noDataText|The text displayed in the popup when there are no items"
            noDataText="NO DATA FOUND"

            i18n-clearTitle="kendo.multiselecttree.clearTitle|The title of the clear button"
            clearTitle="clear"

            i18n-checkAllText="kendo.multiselecttree.checkAllText|The text displayed for the check-all checkbox"
            checkAllText="Check all"

            i18n-filterInputLabel="kendo.multiselecttree.filterInputLabel|The text set as aria-label on the filter input"
            filterInputLabel="Filter"

            i18n-popupLabel="kendo.multiselecttree.popupLabel|The label of the popup element that contains the list of options when its role is 'region'"
            popupLabel="Options list"

            i18n-applyButton="kendo.multiselecttree.applyButton|The text of the Apply button in the action sheet"
            applyButton="Apply"

            i18n-cancelButton="kendo.multiselecttree.cancelButton|The text of the Cancel button in the action sheet"
            cancelButton="Cancel"
        >
        </ng-container>
        <kendo-taglist
            class="k-input-values"
            [size]="size"
            [rounded]="rounded"
            [fillMode]="fillMode"
            [id]="tagListId"
            [tags]="tags"
            [focused]="focusedTagIndex"
            [textField]="textField"
            [valueField]="valueField"
            [valueDepth]="valueDepth"
            [disabled]="disabled"
            [tagPrefix]="tagPrefix"
            [template]="tagTemplate"
            [groupTemplate]="groupTagTemplate"
            [disabledIndices]="disabledIndices"
            (removeTag)="handleRemoveTag($event)"
        >
        </kendo-taglist>
        <span class="k-input-inner">
            <span 
                *ngIf="!tags || !tags.length"
                class="k-input-value-text"
            >
                {{ placeholder }}
            </span>
        </span>
        <span
            *ngIf="!disabled && !loading && !readonly && clearButton && tags?.length"
            class="k-clear-value"
            [attr.title]="messageFor('clearTitle')"
            role="button"
            tabindex="-1"
            (click)="clearAll($event)"
        >
            <kendo-icon-wrapper
                class="k-icon"
                name="x"
                [svgIcon]="xIcon"
            >
            </kendo-icon-wrapper>
        </span>
        <span
            *ngIf="loading"
            class="k-icon k-i-loading k-input-loading-icon"
        >
        </span>
        <ng-template #popupTemplate>
            <ng-container *ngTemplateOutlet="sharedPopupActionSheetTemplate"></ng-container>
        </ng-template>
        <ng-container #container></ng-container>
        <!--adaptive rendering-->
        <responsive-renderer
            [sharedPopupActionSheetTemplate]="sharedPopupActionSheetTemplate"
            [isActionSheetExpanded]="isActionSheetExpanded"
            [title]="title"
            [showTextInput]="filterable"
            [showActionButtons]="true"
            [subtitle]="subtitle"
            (closePopup)="togglePopup(false)"
            (onExpand)="onExpand()"
            (onCollapse)="onCollapse()"
            (textInputChange)="onFilterChange($event)"
            (onApply)="applyValue()"
            (onCancel)="cancelValue()"
            >
        </responsive-renderer>
        <ng-template #sharedPopupActionSheetTemplate>
            <div
                *ngIf="filterable && !isActionSheetExpanded"
                class="k-list-filter"
                >
                <span
                    class="k-textbox k-input"
                    [ngClass]="filterInputClasses"
                >
                    <span class="k-input-prefix">
                        <kendo-icon-wrapper
                            class="k-icon"
                            name="search"
                            [svgIcon]="searchIcon"
                        >
                        </kendo-icon-wrapper>
                    </span>
                    <input
                        #filterInput
                        (input)="handleFilterInputChange($event.target)"
                        [filterInput]="filterable && !touchEnabled"
                        [attr.aria-label]="messageFor('filterInputLabel')"
                        (keydown)="handleKeydown($event, filterInput)"
                        [value]="filter"
                        class="k-input-inner"
                        role="searchbox"
                        tabindex="0"
                        aria-disabled="false"
                        aria-readonly="false"
                        [kendoEventsOutsideAngular]="{
                            blur: handleBlur
                        }"
                        [scope]="this"
                    >
                </span>
            </div>
            <!--header template-->
            <ng-template
                *ngIf="headerTemplate"
                [templateContext]="{
                    templateRef: headerTemplate?.templateRef
                }">
            </ng-template>
            <div *ngIf="checkAll" class="k-check-all">
                <span class="k-checkbox-wrap">
                    <input
                        #checkAllInput
                        [checkAll]="!filterable && !touchEnabled"
                        type="checkbox"
                        class="k-checkbox"
                        [ngClass]="checkAllCheckboxClasses"
                        role="checkbox"
                        tabindex="0"
                        aria-disabled="false"
                        aria-readonly="false"
                        [treeview]="treeview"
                        [checkedItems]="checkedItems"
                        [valueField]="valueField"
                        [lastAction]="lastAction"
                        (checkedItemsChange)="handleCheckedItemsChange($event)"
                        (keydown)="handleKeydown($event)"
                        [kendoEventsOutsideAngular]="{
                            blur: handleBlur
                        }"
                        [scope]="this"
                    >
                </span>
                <span
                    class="k-checkbox-label"
                    (click)="toggleCheckAll()"
                    (mousedown)="$event.preventDefault()"
                >
                    {{ messageFor('checkAllText') }}
                </span>
            </div>
            <kendo-treeview
                #treeview
                [size]="size"
                [attr.id]="treeViewId"
                [nodes]="data"
                [style.maxHeight.px]="listHeight"
                [animate]="false"
                kendoMultiSelectTreeCheckable
                [isHeterogeneous]="isHeterogeneous"
                [checkable]="checkableSettings"
                [checkedItems]="checkedItems"
                [valueField]="valueField"
                [textField]="textField"
                [children]="children"
                [hasChildren]="hasChildren"
                [isExpanded]="isNodeExpanded"
                [isDisabled]="itemDisabled"
                [nodeTemplate]="nodeTemplate"
                [loadOnDemand]="loadOnDemand"
                [filter]="filter"
                [isVisible]="isNodeVisible"
                (keydown)="handleKeydown($event)"
                (nodeClick)="handleNodeClick($event)"
                (expand)="nodeExpand.emit($event)"
                (collapse)="nodeCollapse.emit($event)"
                (checkedItemsChange)="handleCheckedItemsChange($event)"
                [kendoEventsOutsideAngular]="{
                    focusout: handleBlur
                }"
                [scope]="this"
                (childrenLoaded)="onChildrenLoaded()"
            >
            </kendo-treeview>
            <!--footer template-->
            <ng-template
                *ngIf="footerTemplate"
                [templateContext]="{
                    templateRef: footerTemplate?.templateRef
                }">
            </ng-template>
            <!--no-data template-->
            <div class="k-no-data" *ngIf="!data || data?.length === 0 || allNodesHidden">
                <ng-template [ngIf]="noDataTemplate"
                    [templateContext]="{
                        templateRef: noDataTemplate?.templateRef
                    }">
                </ng-template>
                <ng-template [ngIf]="!noDataTemplate">
                    <div>{{ messageFor('noDataText') }}</div>
                </ng-template>
            </div>
        </ng-template>

        <kendo-resize-sensor *ngIf="isOpen || isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>
    `,
      standalone: true,
      imports: [LocalizedMessagesDirective3, TagListComponent, NgIf, IconWrapperComponent, NgTemplateOutlet, ResponsiveRendererComponent, NgClass, FilterInputDirective, EventsOutsideAngularDirective, TemplateContextDirective, CheckAllDirective, TreeViewComponent, CheckDirective2, ResizeSensorComponent]
    }]
  }], function() {
    return [{
      type: Injector
    }, {
      type: ElementRef
    }, {
      type: PopupService
    }, {
      type: Renderer2
    }, {
      type: NavigationService3
    }, {
      type: NgZone
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: MultiSelectTreeLookupService
    }, {
      type: AdaptiveService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-multiselecttree"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    isDisabled: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }, {
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    hostAriaAutocomplete: [{
      type: HostBinding,
      args: ["attr.aria-autocomplete"]
    }],
    isLoading: [{
      type: HostBinding,
      args: ["class.k-loading"]
    }],
    hostAriaInvalid: [{
      type: HostBinding,
      args: ["attr.aria-invalid"]
    }],
    isBusy: [{
      type: HostBinding,
      args: ["attr.aria-busy"]
    }],
    id: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    hostTabIndex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    ariaHasPopup: [{
      type: HostBinding,
      args: ["attr.aria-haspopup"]
    }],
    isReadonly: [{
      type: HostBinding,
      args: ["attr.readonly"]
    }],
    ariaDescribedBy: [{
      type: HostBinding,
      args: ["attr.aria-describedby"]
    }],
    ariaActiveDescendant: [{
      type: HostBinding,
      args: ["attr.aria-activedescendant"]
    }],
    adaptiveMode: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    subtitle: [{
      type: Input
    }],
    responsiveRendererComponent: [{
      type: ViewChild,
      args: [ResponsiveRendererComponent]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective, {
        static: false
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective, {
        static: false
      }]
    }],
    nodeTemplate: [{
      type: ContentChild,
      args: [NodeTemplateDirective2, {
        static: false
      }]
    }],
    noDataTemplate: [{
      type: ContentChild,
      args: [NoDataTemplateDirective, {
        static: false
      }]
    }],
    tagTemplate: [{
      type: ContentChild,
      args: [TagTemplateDirective, {
        static: false
      }]
    }],
    groupTagTemplate: [{
      type: ContentChild,
      args: [GroupTagTemplateDirective, {
        static: false
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        static: true
      }]
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    treeview: [{
      type: ViewChild,
      args: ["treeview", {
        static: false
      }]
    }],
    filterInput: [{
      type: ViewChild,
      args: ["filterInput", {
        static: false
      }]
    }],
    checkAllInput: [{
      type: ViewChild,
      args: ["checkAllInput", {
        static: false
      }]
    }],
    tabindex: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    checkableSettings: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    dataItems: [{
      type: Input
    }],
    textField: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    valueDepth: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    listHeight: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    valuePrimitive: [{
      type: Input
    }],
    loadOnDemand: [{
      type: Input
    }],
    focusableId: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    checkAll: [{
      type: Input
    }],
    hasChildren: [{
      type: Input
    }],
    fetchChildren: [{
      type: Input
    }],
    isNodeExpanded: [{
      type: Input
    }],
    isNodeVisible: [{
      type: Input
    }],
    itemDisabled: [{
      type: Input
    }],
    tagMapper: [{
      type: Input
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    open: [{
      type: Output
    }],
    opened: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    closed: [{
      type: Output
    }],
    nodeExpand: [{
      type: Output
    }],
    nodeCollapse: [{
      type: Output
    }],
    valueChange: [{
      type: Output
    }],
    removeTag: [{
      type: Output
    }],
    filterChange: [{
      type: Output
    }]
  });
})();
var DropDownTreeFlatBindingDirective = class _DropDownTreeFlatBindingDirective extends FlatDataBindingDirective {
  dropDownTree;
  /**
   * The nodes which will be displayed by the DropDownTree.
   */
  set nodes(nodes) {
    this._nodes = nodes;
  }
  get nodes() {
    return this._nodes;
  }
  /**
   * Represents the unique field which identifies a node.
   */
  idField;
  /**
   * @hidden
   */
  set filter(term) {
    super.filter = term;
  }
  constructor(dropDownTree) {
    super(dropDownTree);
    this.dropDownTree = dropDownTree;
  }
  ngOnChanges(changes) {
    if (isChanged("nodes", changes, false)) {
      this.dropDownTree.nodes = changes["nodes"].currentValue;
      super.nodes = changes["nodes"].currentValue;
    }
    super.ngOnChanges(changes);
  }
  static ɵfac = function DropDownTreeFlatBindingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropDownTreeFlatBindingDirective)(ɵɵdirectiveInject(DataBoundComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DropDownTreeFlatBindingDirective,
    selectors: [["", "kendoDropDownTreeFlatBinding", ""]],
    inputs: {
      nodes: [0, "kendoDropDownTreeFlatBinding", "nodes"],
      idField: [0, "valueField", "idField"]
    },
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropDownTreeFlatBindingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownTreeFlatBinding]",
      standalone: true
    }]
  }], function() {
    return [{
      type: DataBoundComponent
    }];
  }, {
    nodes: [{
      type: Input,
      args: ["kendoDropDownTreeFlatBinding"]
    }],
    idField: [{
      type: Input,
      args: ["valueField"]
    }]
  });
})();
var DropDownTreeHierarchyBindingDirective = class _DropDownTreeHierarchyBindingDirective extends HierarchyBindingDirective {
  dropDownTree;
  /**
   * The nodes which will be displayed by the DropDownTree.
   */
  set nodes(nodes) {
    this._nodes = nodes;
  }
  get nodes() {
    return this._nodes;
  }
  /**
   * @hidden
   */
  set filter(term) {
    super.filter = term;
  }
  constructor(dropDownTree) {
    super(dropDownTree);
    this.dropDownTree = dropDownTree;
  }
  ngOnChanges(changes) {
    if (isChanged("nodes", changes, false)) {
      this.dropDownTree.nodes = changes["nodes"].currentValue;
      super.nodes = changes["nodes"].currentValue;
    }
    super.ngOnChanges(changes);
  }
  static ɵfac = function DropDownTreeHierarchyBindingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropDownTreeHierarchyBindingDirective)(ɵɵdirectiveInject(DataBoundComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DropDownTreeHierarchyBindingDirective,
    selectors: [["", "kendoDropDownTreeHierarchyBinding", ""]],
    inputs: {
      nodes: [0, "kendoDropDownTreeHierarchyBinding", "nodes"]
    },
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropDownTreeHierarchyBindingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownTreeHierarchyBinding]",
      standalone: true
    }]
  }], function() {
    return [{
      type: DataBoundComponent
    }];
  }, {
    nodes: [{
      type: Input,
      args: ["kendoDropDownTreeHierarchyBinding"]
    }]
  });
})();
var MultiSelectTreeFlatBindingDirective = class _MultiSelectTreeFlatBindingDirective extends FlatDataBindingDirective {
  multiSelectTree;
  /**
   * The nodes which will be displayed by the MultiSelectTree.
   */
  set nodes(nodes) {
    this._nodes = nodes;
  }
  get nodes() {
    return this._nodes;
  }
  /**
   * Represents the unique field which identifies a node.
   */
  idField;
  /**
   * @hidden
   */
  set filter(term) {
    super.filter = term;
  }
  constructor(multiSelectTree) {
    super(multiSelectTree);
    this.multiSelectTree = multiSelectTree;
  }
  ngOnChanges(changes) {
    if (isChanged("nodes", changes, false)) {
      this.multiSelectTree.nodes = changes["nodes"].currentValue;
      super.nodes = changes["nodes"].currentValue;
    }
    super.ngOnChanges(changes);
  }
  static ɵfac = function MultiSelectTreeFlatBindingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiSelectTreeFlatBindingDirective)(ɵɵdirectiveInject(DataBoundComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _MultiSelectTreeFlatBindingDirective,
    selectors: [["", "kendoMultiSelectTreeFlatBinding", ""]],
    inputs: {
      nodes: [0, "kendoMultiSelectTreeFlatBinding", "nodes"],
      idField: [0, "valueField", "idField"]
    },
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiSelectTreeFlatBindingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMultiSelectTreeFlatBinding]",
      standalone: true
    }]
  }], function() {
    return [{
      type: DataBoundComponent
    }];
  }, {
    nodes: [{
      type: Input,
      args: ["kendoMultiSelectTreeFlatBinding"]
    }],
    idField: [{
      type: Input,
      args: ["valueField"]
    }]
  });
})();
var MultiSelectTreeHierarchyBindingDirective = class _MultiSelectTreeHierarchyBindingDirective extends HierarchyBindingDirective {
  multiSelectTree;
  /**
   * The nodes which will be displayed by the MultiSelectTree.
   */
  set nodes(nodes) {
    this._nodes = nodes;
  }
  get nodes() {
    return this._nodes;
  }
  /**
   * @hidden
   */
  set filter(term) {
    super.filter = term;
  }
  constructor(multiSelectTree) {
    super(multiSelectTree);
    this.multiSelectTree = multiSelectTree;
  }
  ngOnChanges(changes) {
    if (isChanged("nodes", changes, false)) {
      this.multiSelectTree.nodes = changes["nodes"].currentValue;
      super.nodes = changes["nodes"].currentValue;
    }
    super.ngOnChanges(changes);
  }
  static ɵfac = function MultiSelectTreeHierarchyBindingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiSelectTreeHierarchyBindingDirective)(ɵɵdirectiveInject(DataBoundComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _MultiSelectTreeHierarchyBindingDirective,
    selectors: [["", "kendoMultiSelectTreeHierarchyBinding", ""]],
    inputs: {
      nodes: [0, "kendoMultiSelectTreeHierarchyBinding", "nodes"]
    },
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiSelectTreeHierarchyBindingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMultiSelectTreeHierarchyBinding]",
      standalone: true
    }]
  }], function() {
    return [{
      type: DataBoundComponent
    }];
  }, {
    nodes: [{
      type: Input,
      args: ["kendoMultiSelectTreeHierarchyBinding"]
    }]
  });
})();
var DropDownTreesExpandDirective = class _DropDownTreesExpandDirective extends ExpandDirective {
  dropDownTree;
  /**
   * @hidden
   *
   * Ensures a user-defined `isNodeExpanded` callback will not be overriden by the default directive setup.
   * Implemented as a value setter in the base directive, this just overrides the input name.
   */
  set isExpanded(value) {
    this.dropDownTree.isExpanded = value;
  }
  constructor(dropDownTree) {
    super(dropDownTree);
    this.dropDownTree = dropDownTree;
  }
  static ɵfac = function DropDownTreesExpandDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropDownTreesExpandDirective)(ɵɵdirectiveInject(ExpandableComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DropDownTreesExpandDirective,
    selectors: [["", "kendoDropDownTreeExpandable", ""], ["", "kendoMultiSelectTreeExpandable", ""]],
    inputs: {
      isExpanded: [0, "isNodeExpanded", "isExpanded"]
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropDownTreesExpandDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownTreeExpandable], [kendoMultiSelectTreeExpandable]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ExpandableComponent
    }];
  }, {
    isExpanded: [{
      type: Input,
      args: ["isNodeExpanded"]
    }]
  });
})();
var DEFAULT_FILTER_SETTINGS2 = {
  caseSensitive: false,
  operator: "startsWith"
};
var FilterDirective = class _FilterDirective {
  component;
  /**
   * The initial data that will be used as a source array for the filtering operations.
   */
  set data(data) {
    this._data = data || [];
  }
  get data() {
    return this._data;
  }
  /**
   * The configuration object which sets the behavior of the `kendoDropDownFilter` directive.
   * If no [DropDownFilterSettings]({% slug api_dropdowns_dropdownfiltersettings %}) object is provided to this input, the directive will use the default interface settings.
   */
  rawSettings;
  /**
   * @hidden
   *
   * Sets whether the filtering functionality is enabled on component init.
   */
  filterable = true;
  _data = [];
  filterChangeSubscription;
  constructor(component) {
    this.component = component;
  }
  ngOnInit() {
    this.component.filterable = this.filterable;
    this.filterChangeSubscription = this.component.filterChange.subscribe(this.handleFilterChange.bind(this));
  }
  ngOnDestroy() {
    if (isPresent7(this.filterChangeSubscription)) {
      this.filterChangeSubscription.unsubscribe();
    }
  }
  handleFilterChange(query) {
    this.component.data = this.data.filter((item) => this.matchesAnyField(item, query));
  }
  matchesAnyField(item, query) {
    const normalizedQuery = this.normalizeValue(query);
    const {
      fields
    } = this.filterSettings;
    if (fields.length === 0) {
      return this.checkItem(item, normalizedQuery);
    }
    return fields.some((field) => this.checkItem(getter2(item, field), normalizedQuery));
  }
  checkItem(target, query) {
    target = this.normalizeValue(target);
    if (this.filterSettings.operator === "contains") {
      return target.indexOf(query) !== -1;
    } else {
      return target.indexOf(query) === 0;
    }
  }
  normalizeValue(value) {
    const normalizedValue = isPresent7(value) ? value.toString() : "";
    return this.filterSettings.caseSensitive ? normalizedValue : normalizedValue.toLowerCase();
  }
  getFilterFields(providedFields) {
    if (!this.component.textField && !this.component.valueField) {
      return [];
    }
    if (isArray3(providedFields) && providedFields.length > 0) {
      return providedFields;
    } else {
      const textField = this.component.textField || this.component.valueField;
      return [textField];
    }
  }
  get filterSettings() {
    const settings = this.rawSettings;
    const providedFields = isPresent7(settings) && typeof settings === "object" ? settings.fields : [];
    return Object.assign({}, DEFAULT_FILTER_SETTINGS2, settings, {
      fields: this.getFilterFields(providedFields)
    });
  }
  static ɵfac = function FilterDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterDirective)(ɵɵdirectiveInject(FilterableComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterDirective,
    selectors: [["", "kendoDropDownFilter", ""]],
    inputs: {
      data: "data",
      rawSettings: [0, "kendoDropDownFilter", "rawSettings"],
      filterable: "filterable"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownFilter]",
      standalone: true
    }]
  }], function() {
    return [{
      type: FilterableComponent
    }];
  }, {
    data: [{
      type: Input
    }],
    rawSettings: [{
      type: Input,
      args: ["kendoDropDownFilter"]
    }],
    filterable: [{
      type: Input
    }]
  });
})();
var CustomMessagesComponent3 = class _CustomMessagesComponent extends Messages3 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function CustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CustomMessagesComponent,
    selectors: [["kendo-dropdownlist-messages"], ["kendo-combobox-messages"], ["kendo-multicolumncombobox-messages"], ["kendo-autocomplete-messages"], ["kendo-multiselect-messages"], ["kendo-dropdowntree-messages"], ["kendo-multiselecttree-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: Messages3,
      useExisting: forwardRef(() => _CustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function CustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CustomMessagesComponent3, [{
    type: Component,
    args: [{
      providers: [{
        provide: Messages3,
        useExisting: forwardRef(() => CustomMessagesComponent3)
      }],
      selector: "kendo-dropdownlist-messages,kendo-combobox-messages,kendo-multicolumncombobox-messages,kendo-autocomplete-messages,kendo-multiselect-messages,kendo-dropdowntree-messages,kendo-multiselecttree-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var SummaryTagDirective = class _SummaryTagDirective {
  multiSelectComponent;
  /**
   * A numeric value that indicates the number of selected data items after which the summary tag will appear.
   */
  showAfter = 0;
  constructor(multiSelectComponent) {
    this.multiSelectComponent = multiSelectComponent;
    this.createTagMapper();
  }
  ngOnChanges(changes) {
    if (isPresent7(changes.showAfter)) {
      this.createTagMapper();
      this.multiSelectComponent.onTagMapperChange();
    }
  }
  createTagMapper() {
    const showAfter = parseNumber3(this.showAfter);
    this.multiSelectComponent.tagMapper = (tags) => {
      if (tags.length > showAfter) {
        const result = tags.slice(0, showAfter);
        result.push(tags.slice(showAfter, tags.length));
        return result;
      } else {
        return tags;
      }
    };
  }
  static ɵfac = function SummaryTagDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SummaryTagDirective)(ɵɵdirectiveInject(MultiSelectComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SummaryTagDirective,
    selectors: [["", "kendoMultiSelectSummaryTag", ""]],
    inputs: {
      showAfter: [0, "kendoMultiSelectSummaryTag", "showAfter"]
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SummaryTagDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMultiSelectSummaryTag]",
      standalone: true
    }]
  }], function() {
    return [{
      type: MultiSelectComponent
    }];
  }, {
    showAfter: [{
      type: Input,
      args: ["kendoMultiSelectSummaryTag"]
    }]
  });
})();
var MultiSelectTreeSummaryTagDirective = class _MultiSelectTreeSummaryTagDirective {
  multiSelectTreeComponent;
  /**
   * A numeric value that indicates the number of selected data items after which the summary tag will appear.
   */
  showAfter = 0;
  constructor(multiSelectTreeComponent) {
    this.multiSelectTreeComponent = multiSelectTreeComponent;
    this.createTagMapper();
  }
  ngOnChanges(changes) {
    if (isPresent7(changes.showAfter)) {
      this.createTagMapper();
      this.multiSelectTreeComponent.handleTagMapperChange(this.showAfter);
    }
  }
  createTagMapper() {
    const showAfter = parseNumber3(this.showAfter);
    this.multiSelectTreeComponent.tagMapper = (tags) => {
      if (tags.length > showAfter) {
        return [...tags.slice(0, showAfter), tags.slice(showAfter)];
      } else {
        return tags;
      }
    };
  }
  static ɵfac = function MultiSelectTreeSummaryTagDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiSelectTreeSummaryTagDirective)(ɵɵdirectiveInject(MultiSelectTreeComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _MultiSelectTreeSummaryTagDirective,
    selectors: [["", "kendoMultiSelectTreeSummaryTag", ""]],
    inputs: {
      showAfter: [0, "kendoMultiSelectTreeSummaryTag", "showAfter"]
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiSelectTreeSummaryTagDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMultiSelectTreeSummaryTag]",
      standalone: true
    }]
  }], function() {
    return [{
      type: MultiSelectTreeComponent
    }];
  }, {
    showAfter: [{
      type: Input,
      args: ["kendoMultiSelectTreeSummaryTag"]
    }]
  });
})();
var KENDO_AUTOCOMPLETE = [AutoCompleteComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent];
var KENDO_COMBOBOX = [ComboBoxComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective];
var KENDO_MULTICOLUMNCOMBOBOX = [MultiColumnComboBoxComponent, ComboBoxColumnComponent, ColumnHeaderTemplateDirective, ColumnCellTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective];
var KENDO_DROPDOWNLIST = [DropDownListComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3];
var KENDO_MULTISELECT = [MultiSelectComponent, SummaryTagDirective, CustomItemTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent];
var KENDO_DROPDOWNTREE = [DropDownTreeComponent, DropDownTreeFlatBindingDirective, DropDownTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective2, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent3];
var KENDO_MULTISELECTTREE = [MultiSelectTreeComponent, MultiSelectTreeFlatBindingDirective, MultiSelectTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective2, MultiSelectTreeSummaryTagDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent3];
var KENDO_DROPDOWNS = [...KENDO_AUTOCOMPLETE, ...KENDO_COMBOBOX, ...KENDO_MULTICOLUMNCOMBOBOX, ...KENDO_DROPDOWNLIST, ...KENDO_MULTISELECT, ...KENDO_DROPDOWNTREE, ...KENDO_MULTISELECTTREE];
var DropDownTreesModule = class _DropDownTreesModule {
  static ɵfac = function DropDownTreesModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropDownTreesModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DropDownTreesModule,
    imports: [DropDownTreeComponent, DropDownTreeFlatBindingDirective, DropDownTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective2, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent3, MultiSelectTreeComponent, MultiSelectTreeFlatBindingDirective, MultiSelectTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective2, MultiSelectTreeSummaryTagDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent3],
    exports: [DropDownTreeComponent, DropDownTreeFlatBindingDirective, DropDownTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective2, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent3, MultiSelectTreeComponent, MultiSelectTreeFlatBindingDirective, MultiSelectTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective2, MultiSelectTreeSummaryTagDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent3]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService, AdaptiveService],
    imports: [DropDownTreeComponent, MultiSelectTreeComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropDownTreesModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_DROPDOWNTREE, ...KENDO_MULTISELECTTREE],
      exports: [...KENDO_DROPDOWNTREE, ...KENDO_MULTISELECTTREE],
      providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService, AdaptiveService]
    }]
  }], null, null);
})();
var DropDownsModule = class _DropDownsModule {
  static ɵfac = function DropDownsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropDownsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DropDownsModule,
    imports: [AutoCompleteComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ComboBoxComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective, MultiColumnComboBoxComponent, ComboBoxColumnComponent, ColumnHeaderTemplateDirective, ColumnCellTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective, DropDownListComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, MultiSelectComponent, SummaryTagDirective, CustomItemTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, DropDownTreeComponent, DropDownTreeFlatBindingDirective, DropDownTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective2, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent3, MultiSelectTreeComponent, MultiSelectTreeFlatBindingDirective, MultiSelectTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective2, MultiSelectTreeSummaryTagDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent3, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective],
    exports: [AutoCompleteComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ComboBoxComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective, MultiColumnComboBoxComponent, ComboBoxColumnComponent, ColumnHeaderTemplateDirective, ColumnCellTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective, DropDownListComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, MultiSelectComponent, SummaryTagDirective, CustomItemTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, DropDownTreeComponent, DropDownTreeFlatBindingDirective, DropDownTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective2, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent3, MultiSelectTreeComponent, MultiSelectTreeFlatBindingDirective, MultiSelectTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective2, MultiSelectTreeSummaryTagDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent3, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, ResizeBatchService, IconsService, DialogContainerService, DialogService, WindowService, WindowContainerService, AdaptiveService],
    imports: [AutoCompleteComponent, SeparatorComponent, ComboBoxComponent, SeparatorComponent, MultiColumnComboBoxComponent, SeparatorComponent, DropDownListComponent, MultiSelectComponent, SeparatorComponent, DropDownTreeComponent, MultiSelectTreeComponent, SeparatorComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropDownsModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_DROPDOWNS, ...KENDO_ADORNMENTS, ...KENDO_TOGGLEBUTTONTABSTOP],
      imports: [...KENDO_DROPDOWNS, ...KENDO_ADORNMENTS, ...KENDO_TOGGLEBUTTONTABSTOP],
      providers: [PopupService, ResizeBatchService, IconsService, DialogContainerService, DialogService, WindowService, WindowContainerService, AdaptiveService]
    }]
  }], null, null);
})();
var MultiSelectModule = class _MultiSelectModule {
  static ɵfac = function MultiSelectModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiSelectModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _MultiSelectModule,
    imports: [MultiSelectComponent, SummaryTagDirective, CustomItemTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent],
    exports: [MultiSelectComponent, SummaryTagDirective, CustomItemTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, ResizeBatchService, IconsService, AdaptiveService],
    imports: [MultiSelectComponent, SeparatorComponent, SeparatorComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiSelectModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_MULTISELECT, ...KENDO_ADORNMENTS],
      exports: [...KENDO_MULTISELECT, ...KENDO_ADORNMENTS],
      providers: [PopupService, ResizeBatchService, IconsService, AdaptiveService]
    }]
  }], null, null);
})();
var AutoCompleteModule = class _AutoCompleteModule {
  static ɵfac = function AutoCompleteModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AutoCompleteModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _AutoCompleteModule,
    imports: [AutoCompleteComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent],
    exports: [AutoCompleteComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, ResizeBatchService, IconsService, AdaptiveService],
    imports: [AutoCompleteComponent, SeparatorComponent, SeparatorComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AutoCompleteModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_AUTOCOMPLETE, ...KENDO_ADORNMENTS],
      exports: [...KENDO_AUTOCOMPLETE, ...KENDO_ADORNMENTS],
      providers: [PopupService, ResizeBatchService, IconsService, AdaptiveService]
    }]
  }], null, null);
})();
var ComboBoxModule = class _ComboBoxModule {
  static ɵfac = function ComboBoxModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ComboBoxModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ComboBoxModule,
    imports: [ComboBoxComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective, MultiColumnComboBoxComponent, ComboBoxColumnComponent, ColumnHeaderTemplateDirective, ColumnCellTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective],
    exports: [ComboBoxComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective, MultiColumnComboBoxComponent, ComboBoxColumnComponent, ColumnHeaderTemplateDirective, ColumnCellTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, ResizeBatchService, IconsService, AdaptiveService],
    imports: [ComboBoxComponent, SeparatorComponent, MultiColumnComboBoxComponent, SeparatorComponent, SeparatorComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ComboBoxModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_COMBOBOX, ...KENDO_MULTICOLUMNCOMBOBOX, ...KENDO_ADORNMENTS, ...KENDO_TOGGLEBUTTONTABSTOP],
      exports: [...KENDO_COMBOBOX, ...KENDO_MULTICOLUMNCOMBOBOX, ...KENDO_ADORNMENTS, ...KENDO_TOGGLEBUTTONTABSTOP],
      providers: [PopupService, ResizeBatchService, IconsService, AdaptiveService]
    }]
  }], null, null);
})();
var DropDownListModule = class _DropDownListModule {
  static ɵfac = function DropDownListModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropDownListModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DropDownListModule,
    imports: [DropDownListComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3],
    exports: [DropDownListComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent3]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, ResizeBatchService, IconsService, AdaptiveService],
    imports: [DropDownListComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropDownListModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_DROPDOWNLIST],
      exports: [...KENDO_DROPDOWNLIST],
      providers: [PopupService, ResizeBatchService, IconsService, AdaptiveService]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-angular-pager/fesm2022/progress-kendo-angular-pager.mjs
var _c07 = ["dropdownlist"];
var _c114 = ["select"];
var _c213 = ["numbers"];
var _c312 = (a0) => ({
  "k-selected": a0
});
function PagerNumericButtonsComponent_option_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "option", 9);
    ɵɵtext(1, "... ");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("selected", false);
    ɵɵattribute("aria-label", ctx_r1.pageLabel(ctx_r1.start - 1));
  }
}
function PagerNumericButtonsComponent_option_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "option", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const num_r3 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("value", num_r3.toString())("selected", num_r3 === ctx_r1.currentPage)("ngClass", ɵɵpureFunction1(6, _c312, ctx_r1.currentPage === num_r3));
    ɵɵattribute("aria-label", ctx_r1.pageLabel(num_r3))("aria-current", ctx_r1.currentPage === num_r3 ? "page" : void 0);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", num_r3, " ");
  }
}
function PagerNumericButtonsComponent_option_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "option", 11);
    ɵɵtext(1, "... ");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("selected", false);
    ɵɵattribute("aria-label", ctx_r1.pageLabel(ctx_r1.end + 1));
  }
}
function PagerNumericButtonsComponent_button_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 12);
    ɵɵlistener("click", function PagerNumericButtonsComponent_button_7_Template_button_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.changePage(ctx_r1.start - 2));
    });
    ɵɵtext(1, "...");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("size", ctx_r1.size);
    ɵɵattribute("aria-label", ctx_r1.pageLabel(ctx_r1.start - 1))("title", ctx_r1.pageLabel(ctx_r1.start - 1));
  }
}
function PagerNumericButtonsComponent_button_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 13);
    ɵɵlistener("click", function PagerNumericButtonsComponent_button_8_Template_button_click_0_listener() {
      const num_r6 = ɵɵrestoreView(_r5).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.changePage(num_r6 - 1));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const num_r6 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("size", ctx_r1.size)("selected", ctx_r1.currentPage === num_r6);
    ɵɵattribute("aria-label", ctx_r1.pageLabel(num_r6))("title", ctx_r1.pageLabel(num_r6))("aria-current", ctx_r1.currentPage === num_r6 ? "page" : void 0);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", num_r6, " ");
  }
}
function PagerNumericButtonsComponent_button_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 12);
    ɵɵlistener("click", function PagerNumericButtonsComponent_button_9_Template_button_click_0_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.changePage(ctx_r1.end));
    });
    ɵɵtext(1, "...");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("size", ctx_r1.size);
    ɵɵattribute("aria-label", ctx_r1.pageLabel(ctx_r1.end + 1))("title", ctx_r1.pageLabel(ctx_r1.end + 1));
  }
}
var _c412 = (a0) => ({
  "aria-label": a0
});
var _c512 = (a0, a1) => ({
  keydown: a0,
  focusout: a1
});
function PagerComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.template.first == null ? null : ctx_r0.template.first.templateRef)("ngTemplateOutletContext", ctx_r0.templateContext);
  }
}
function PagerComponent_ng_template_3_kendo_pager_prev_buttons_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-prev-buttons", 11);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r0.size);
  }
}
function PagerComponent_ng_template_3_kendo_pager_numeric_buttons_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-numeric-buttons", 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r0.size)("buttonCount", ctx_r0.buttonCount);
  }
}
function PagerComponent_ng_template_3_kendo_pager_input_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-input", 11);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r0.size);
  }
}
function PagerComponent_ng_template_3_kendo_pager_next_buttons_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-next-buttons", 11);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r0.size);
  }
}
function PagerComponent_ng_template_3_kendo_pager_page_sizes_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-page-sizes", 13);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r0.size)("pageSizes", ctx_r0._pageSizeValues);
  }
}
function PagerComponent_ng_template_3_kendo_pager_info_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-info");
  }
}
function PagerComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtemplate(1, PagerComponent_ng_template_3_kendo_pager_prev_buttons_1_Template, 1, 1, "kendo-pager-prev-buttons", 7)(2, PagerComponent_ng_template_3_kendo_pager_numeric_buttons_2_Template, 1, 2, "kendo-pager-numeric-buttons", 8)(3, PagerComponent_ng_template_3_kendo_pager_input_3_Template, 1, 1, "kendo-pager-input", 7)(4, PagerComponent_ng_template_3_kendo_pager_next_buttons_4_Template, 1, 1, "kendo-pager-next-buttons", 7);
    ɵɵelementEnd();
    ɵɵtemplate(5, PagerComponent_ng_template_3_kendo_pager_page_sizes_5_Template, 1, 2, "kendo-pager-page-sizes", 9)(6, PagerComponent_ng_template_3_kendo_pager_info_6_Template, 1, 0, "kendo-pager-info", 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.previousNext);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.type === "numeric" && ctx_r0.buttonCount > 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.type === "input");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.previousNext);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0._pageSizeValues.length);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.info);
  }
}
function PagerComponent_kendo_resize_sensor_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 14);
    ɵɵlistener("resize", function PagerComponent_kendo_resize_sensor_5_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.resizeHandler());
    });
    ɵɵelementEnd();
  }
}
var PreventableEvent6 = class {
  prevented = false;
  /**
   * Prevents the default action for a specified event.
   * In this way, the source component suppresses the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * If the event is prevented by any of its subscribers, returns `true`.
   *
   * @returns `true` if the default action was prevented. Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
};
var PageSizeChangeEvent = class extends PreventableEvent6 {
  /**
   * The newly selected page size.
   */
  newPageSize;
  /**
   * Constructs the event arguments for the `pageSizeChange` event.
   * @param newPageSize - The newly selected page size.
   * @hidden
   */
  constructor(newPageSize) {
    super();
    this.newPageSize = newPageSize;
  }
};
var Messages4 = class _Messages extends ComponentMessages {
  /**
   * The label of the pager. Follows the pattern **Page navigation, page {currentPage} of {totalPages}** by default.
   * Тhe default label text when the current page is 1, and the total number of pages is 10 will be
   * **Page navigation, page 1 of 10**.
   *
   * The message consists of several parts - the current page number, the total number of pages, and a localizable string.
   * To allow for reordering its parts, the `ariaLabel` input accepts a string with placeholders for the current page
   * and total number of pages. The `{currentPage}` and `{totalPages}` placeholders will be replaced
   * internally with the respective actual values.
   */
  ariaLabel;
  /**
   * The label for the **First page** button.
   */
  firstPage;
  /**
   * The label for the **Last page** button.
   */
  lastPage;
  /**
   * The label for the **Previous page** button.
   */
  previousPage;
  /**
   * The label for the **Next page** button.
   */
  nextPage;
  /**
   * The label displayed before the pager input.
   */
  page;
  /**
   * The title attribute of the page number input element.
   */
  pageNumberInputTitle;
  /**
   * The label displayed after the page-size selector.
   */
  itemsPerPage;
  /**
   * The label before the total-page number.
   */
  of;
  /**
   * The label after the total-page number.
   */
  items;
  /**
   * The text of the title and aria-label attributes applied to the page chooser.
   */
  selectPage;
  /**
   * The text of the aria-label attribute applied to the input element for entering the page number."
   */
  inputLabel;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMessages_BaseFactory;
    return function Messages_Factory(__ngFactoryType__) {
      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵɵgetInheritedFactory(_Messages)))(__ngFactoryType__ || _Messages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _Messages,
    selectors: [["kendoPagerMessages"]],
    inputs: {
      ariaLabel: "ariaLabel",
      firstPage: "firstPage",
      lastPage: "lastPage",
      previousPage: "previousPage",
      nextPage: "nextPage",
      page: "page",
      pageNumberInputTitle: "pageNumberInputTitle",
      itemsPerPage: "itemsPerPage",
      of: "of",
      items: "items",
      selectPage: "selectPage",
      inputLabel: "inputLabel"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Messages4, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendoPagerMessages"
    }]
  }], null, {
    ariaLabel: [{
      type: Input
    }],
    firstPage: [{
      type: Input
    }],
    lastPage: [{
      type: Input
    }],
    previousPage: [{
      type: Input
    }],
    nextPage: [{
      type: Input
    }],
    page: [{
      type: Input
    }],
    pageNumberInputTitle: [{
      type: Input
    }],
    itemsPerPage: [{
      type: Input
    }],
    of: [{
      type: Input
    }],
    items: [{
      type: Input
    }],
    selectPage: [{
      type: Input
    }],
    inputLabel: [{
      type: Input
    }]
  });
})();
var CustomMessagesComponent4 = class _CustomMessagesComponent extends Messages4 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function CustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CustomMessagesComponent,
    selectors: [["kendo-datapager-messages"], ["kendo-pager-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: Messages4,
      useExisting: forwardRef(() => _CustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function CustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CustomMessagesComponent4, [{
    type: Component,
    args: [{
      providers: [{
        provide: Messages4,
        useExisting: forwardRef(() => CustomMessagesComponent4)
      }],
      selector: "kendo-datapager-messages, kendo-pager-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var LocalizedMessagesDirective4 = class _LocalizedMessagesDirective extends Messages4 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedMessagesDirective,
    selectors: [["", "kendoPagerLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: Messages4,
      useExisting: forwardRef(() => _LocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedMessagesDirective4, [{
    type: Directive,
    args: [{
      providers: [{
        provide: Messages4,
        useExisting: forwardRef(() => LocalizedMessagesDirective4)
      }],
      selector: "[kendoPagerLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var PagerContextService = class {
  total;
  skip;
  pageSize;
  localization;
  changes = new Subject();
  pageChange = new Subject();
  pageSizeChange = new Subject();
  get currentPage() {
    return this.skip / this.pageSize;
  }
  notifyChanges(changes) {
    this.total = changes.total;
    this.pageSize = changes.pageSize;
    this.skip = changes.skip;
    this.changes.next(changes);
  }
  changePage(page) {
    this.pageChange.next({
      skip: page * this.pageSize,
      take: this.pageSize
    });
  }
  changePageSize(event) {
    this.pageSizeChange.next(event);
  }
  nextPage() {
    const nextPage = this.currentPage + 1;
    if (nextPage * this.pageSize < this.total) {
      this.changePage(nextPage);
    }
  }
  prevPage() {
    const prevPage = this.currentPage - 1;
    if (prevPage * this.pageSize >= 0) {
      this.changePage(prevPage);
    }
  }
};
var PagerElementComponent = class _PagerElementComponent {
  localization;
  pagerContext;
  cd;
  total;
  skip;
  pageSize;
  caretAltLeftIcon = caretAltLeftIcon;
  caretAltToLeftIcon = caretAltToLeftIcon;
  caretAltRightIcon = caretAltRightIcon;
  caretAltToRightIcon = caretAltToRightIcon;
  /**
   * @hidden
   *
   * @readonly
   * @type {number}
   * @memberOf PagerElementComponent
   */
  get currentPage() {
    return Math.floor((this.skip || 0) / this.pageSize) + 1;
  }
  /**
   * @hidden
   *
   * @readonly
   * @type {number}
   * @memberOf PagerElementComponent
   */
  get totalPages() {
    return Math.ceil((this.total || 0) / this.pageSize);
  }
  subscriptions;
  constructor(localization, pagerContext, cd) {
    this.localization = localization;
    this.pagerContext = pagerContext;
    this.cd = cd;
    this.total = pagerContext.total;
    this.skip = pagerContext.skip;
    this.pageSize = pagerContext.pageSize;
  }
  /**
   * @hidden
   *
   * @param {string} key
   * @returns {string}
   *
   * @memberOf PagerElementComponent
   */
  textFor(key) {
    const isPagerLocalization = this.localization.prefix === "kendo.pager";
    return this.localization.get(isPagerLocalization ? key : `pager${key[0].toLocaleUpperCase()}${key.slice(1)}`);
  }
  /**
   * @hidden
   *
   * @param {number} page
   *
   * @memberOf PagerElementComponent
   */
  changePage(page) {
    this.pagerContext.changePage(page);
    return false;
  }
  /**
   * @hidden
   *
   * @memberOf PagerElementComponent
   */
  ngOnInit() {
    this.subscriptions = this.pagerContext.changes.subscribe(this.onChanges.bind(this));
    this.subscriptions.add(this.localization.changes.subscribe(() => this.cd.markForCheck()));
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  get prevArrowIcons() {
    return !this.localization.rtl ? ["caret-alt-to-left", "caret-alt-left"] : ["caret-alt-to-right", "caret-alt-right"];
  }
  get prevArrowSVGIcons() {
    return !this.localization.rtl ? [this.caretAltToLeftIcon, this.caretAltLeftIcon] : [this.caretAltToRightIcon, this.caretAltRightIcon];
  }
  get nextArrowIcons() {
    return !this.localization.rtl ? ["caret-alt-right", "caret-alt-to-right"] : ["caret-alt-left", "caret-alt-to-left"];
  }
  get nextArrowSVGIcons() {
    return !this.localization.rtl ? [this.caretAltRightIcon, this.caretAltToRightIcon] : [this.caretAltLeftIcon, this.caretAltToLeftIcon];
  }
  static ɵfac = function PagerElementComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PagerElementComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(PagerContextService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PagerElementComponent,
    selectors: [["kendo-pager-element"]],
    standalone: false,
    decls: 0,
    vars: 0,
    template: function PagerElementComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerElementComponent, [{
    type: Component,
    args: [{
      selector: "kendo-pager-element",
      template: ``
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: PagerContextService
    }, {
      type: ChangeDetectorRef
    }];
  }, null);
})();
var DEFAULT_PAGE_SIZE_VALUES = [5, 10, 20].map((n) => ({
  text: String(n),
  value: n
}));
var focusableDirectiveSelector = "[kendoPagerFocusable]";
var getAllFocusableChildren2 = (parent) => {
  return parent.querySelectorAll(focusableDirectiveSelector);
};
var focusableSelector2 = ['a[href]:not([disabled]):not([aria-hidden="true"])', 'area[href]:not([disabled]):not([aria-hidden="true"])', 'input:not([disabled]):not([aria-hidden="true"])', 'select:not([disabled]):not([aria-hidden="true"])', 'textarea:not([disabled]):not([aria-hidden="true"])', 'button:not([aria-hidden="true"])', "iframe:not([disabled])", "object:not([disabled])", "embed:not([disabled])", '*[tabindex]:not([disabled]):not([aria-hidden="true"])', '*[contenteditable]:not([disabled]):not([contenteditable="false"])'].join(",");
var DEFAULT_SIZE4 = "medium";
var SIZES2 = {
  small: "sm",
  medium: "md",
  large: "lg"
};
var getStylingClasses3 = (componentType, stylingOption, previousValue, newValue) => {
  switch (stylingOption) {
    case "size":
      return {
        toRemove: `k-${componentType}-${SIZES2[previousValue]}`,
        toAdd: newValue !== "none" ? `k-${componentType}-${SIZES2[newValue]}` : ""
      };
    default:
      break;
  }
};
var replaceMessagePlaceholder2 = (message, name2, value) => message.replace(new RegExp(`{\\s*${name2}\\s*}`, "g"), value);
var PagerNavigationService = class {
  isNavigable = false;
  innerNavigationChange = new Subject();
  toggleInnerNavigation(value) {
    this.innerNavigationChange.next(value);
  }
  keepFocusWithinComponent(wrapper, target, event) {
    const [firstFocusable, lastFocusable] = this.getFirstAndLastFocusable(wrapper);
    const tabAfterLastFocusable = !event.shiftKey && target === lastFocusable;
    const shiftTabAfterFirstFocusable = event.shiftKey && target === firstFocusable;
    if (tabAfterLastFocusable) {
      event.preventDefault();
      firstFocusable.focus();
    }
    if (shiftTabAfterFirstFocusable) {
      event.preventDefault();
      lastFocusable.focus();
    }
  }
  getFirstAndLastFocusable(wrapper) {
    const all = getAllFocusableChildren2(wrapper);
    const firstFocusable = all.length > 0 ? all[0] : wrapper;
    const lastFocusable = all.length > 0 ? all[all.length - 1] : wrapper;
    return [isFocusable(firstFocusable) ? firstFocusable : firstFocusable.querySelector(focusableSelector2), isFocusable(lastFocusable) ? lastFocusable : lastFocusable.querySelector(focusableSelector2)];
  }
};
var PagerFocusableDirective = class _PagerFocusableDirective {
  navigationService;
  element;
  renderer;
  subscriptions = new Subscription();
  constructor(navigationService, element, renderer) {
    this.navigationService = navigationService;
    this.element = element;
    this.renderer = renderer;
  }
  ngOnInit() {
    if (!(this.nativeElement instanceof HTMLElement)) {
      return;
    }
    this.subscriptions.add(this.navigationService.innerNavigationChange.subscribe(this.innerNavigationChange.bind(this)));
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  get nativeElement() {
    return this.element.nativeElement;
  }
  innerNavigationChange(value) {
    if (!this.navigationService.isNavigable) {
      return;
    }
    const index = value ? "0" : "-1";
    if (this.nativeElement.matches(focusableSelector2)) {
      this.renderer.setAttribute(this.nativeElement, "tabindex", index);
    }
    const focusableElements = this.nativeElement.querySelectorAll(focusableSelector2);
    focusableElements.forEach((el) => {
      this.renderer.setAttribute(el, "tabindex", index);
    });
  }
  static ɵfac = function PagerFocusableDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PagerFocusableDirective)(ɵɵdirectiveInject(PagerNavigationService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PagerFocusableDirective,
    selectors: [["", "kendoPagerFocusable", ""]],
    exportAs: ["kendoPagerFocusable"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerFocusableDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoPagerFocusable]",
      exportAs: "kendoPagerFocusable",
      standalone: true
    }]
  }], function() {
    return [{
      type: PagerNavigationService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }];
  }, null);
})();
var PagerPrevButtonsComponent = class _PagerPrevButtonsComponent extends PagerElementComponent {
  constructor(localization, pagerContext, cd) {
    super(localization, pagerContext, cd);
  }
  /**
   * Specifies the padding of the buttons.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  size = DEFAULT_SIZE4;
  /**
   * @hidden
   *
   * @readonly
   * @type {boolean}
   * @memberOf PagerPrevButtonsComponent
   */
  get disabled() {
    return this.currentPage === 1 || !this.total;
  }
  onChanges({
    total,
    skip: skip2,
    pageSize
  }) {
    this.total = total;
    this.skip = skip2;
    this.pageSize = pageSize;
    this.cd.markForCheck();
  }
  static ɵfac = function PagerPrevButtonsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PagerPrevButtonsComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(PagerContextService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PagerPrevButtonsComponent,
    selectors: [["kendo-datapager-prev-buttons"], ["kendo-pager-prev-buttons"]],
    inputs: {
      size: "size"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 16,
    consts: [["type", "button", "kendoButton", "", "kendoPagerFocusable", "", "fillMode", "flat", "rounded", "none", 1, "k-pager-nav", "k-pager-first", 3, "click", "icon", "svgIcon", "size", "title"], ["type", "button", "kendoButton", "", "kendoPagerFocusable", "", "fillMode", "flat", "rounded", "none", 1, "k-pager-nav", 3, "click", "icon", "svgIcon", "size", "title"]],
    template: function PagerPrevButtonsComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "button", 0);
        ɵɵlistener("click", function PagerPrevButtonsComponent_Template_button_click_0_listener() {
          return ctx.currentPage !== 1 ? ctx.changePage(0) : false;
        });
        ɵɵelementEnd();
        ɵɵelementStart(1, "button", 1);
        ɵɵlistener("click", function PagerPrevButtonsComponent_Template_button_click_1_listener() {
          return ctx.currentPage !== 1 ? ctx.changePage(ctx.currentPage - 2) : false;
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassProp("k-disabled", ctx.disabled);
        ɵɵproperty("icon", ctx.prevArrowIcons[0])("svgIcon", ctx.prevArrowSVGIcons[0])("size", ctx.size)("title", ctx.textFor("firstPage"));
        ɵɵattribute("aria-disabled", ctx.disabled)("aria-label", ctx.textFor("firstPage"));
        ɵɵadvance();
        ɵɵclassProp("k-disabled", ctx.disabled);
        ɵɵproperty("icon", ctx.prevArrowIcons[1])("svgIcon", ctx.prevArrowSVGIcons[1])("size", ctx.size)("title", ctx.textFor("previousPage"));
        ɵɵattribute("aria-disabled", ctx.disabled)("aria-label", ctx.textFor("previousPage"));
      }
    },
    dependencies: [ButtonComponent, PagerFocusableDirective],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerPrevButtonsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-datapager-prev-buttons, kendo-pager-prev-buttons",
      template: `
        <button
            type="button" kendoButton
            kendoPagerFocusable
            class="k-pager-nav k-pager-first"
            [attr.aria-disabled]="disabled"
            [class.k-disabled]="disabled"
            [icon]="prevArrowIcons[0]"
            [svgIcon]="prevArrowSVGIcons[0]"
            fillMode="flat"
            rounded="none"
            [size]="size"
            [title]="textFor('firstPage')"
            [attr.aria-label]="textFor('firstPage')"
            (click)="currentPage !== 1 ? changePage(0) : false">
        </button>
        <button
            type="button" kendoButton
            kendoPagerFocusable
            class="k-pager-nav"
            [attr.aria-disabled]="disabled"
            [class.k-disabled]="disabled"
            [icon]="prevArrowIcons[1]"
            [svgIcon]="prevArrowSVGIcons[1]"
            fillMode="flat"
            rounded="none"
            [size]="size"
            [title]="textFor('previousPage')"
            [attr.aria-label]="textFor('previousPage')"
            (click)="currentPage !== 1 ? changePage(currentPage-2) : false">
        </button>
    `,
      standalone: true,
      imports: [ButtonComponent, PagerFocusableDirective]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: PagerContextService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    size: [{
      type: Input
    }]
  });
})();
var PagerPageSizesComponent = class _PagerPageSizesComponent extends PagerElementComponent {
  pagerContext;
  element;
  ngZone;
  dropDownList;
  /**
   * The page sizes collection. Can contain numbers and [PageSizeItem]({% slug api_pager_pagesizeitem %}) objects.
   *
   * @example
   *
   * ```ts-preview
   * _@Component({
   *    selector: 'my-app',
   *    template: `
   *        <div *ngFor="let item of pagedData" style="border: 1px solid black; padding: 10px;">
   *            <span>{{item.ProductID}}. </span>
   *            <span>{{item.ProductName}}</span>
   *        </div>
   *        <kendo-pager
   *             [skip]="skip"
   *             [pageSize]="pageSize"
   *             [total]="total"
   *             (pageChange)="onPageChange($event)">
   *           <ng-template kendoPagerTemplate>
   *               <kendo-pager-page-sizes [pageSizes]="pagesizes"></kendo-pager-page-sizes>
   *           </ng-template>
   *        </kendo-pager>
   *    `
   * })
   * class AppComponent {
   *    public data: any[] = products;
   *    public pagedData = [];
   *    public skip = 0;
   *    public pageSize = 2;
   *    public total = products.length;
   *    public pagesizes = [{text: 'One', value: 1}, {text: 'Two', value: 2}, {text: 'All', value : 'all'}];
   *
   *    public ngOnInit() {
   *        this.pageData();
   *    }
   *
   *    public onPageChange(e) {
   *        this.skip = e.skip;
   *        this.pageSize = e.take;
   *        this.pageData();
   *    }
   *
   *    private pageData() {
   *        this.pagedData = this.data.slice(this.skip, this.skip + this.pageSize);
   *    }
   * }
   *
   * const products = [{
   *   'ProductID' : 1,
   *   'ProductName' : "Chai",
   *   'SupplierID' : 1,
   *   'CategoryID' : 1,
   *   'QuantityPerUnit' : "10 boxes x 20 bags",
   *   'UnitPrice' : 18.0000,
   *   'UnitsInStock' : 39,
   *   'UnitsOnOrder' : 0,
   *   'ReorderLevel' : 10,
   *   'Discontinued' : false
   *
   * }, {
   *   'ProductID' : 2,
   *   'ProductName' : "Chang",
   *   'SupplierID' : 1,
   *   'CategoryID' : 1,
   *   'QuantityPerUnit' : "24 - 12 oz bottles",
   *   'UnitPrice' : 19.0000,
   *   'UnitsInStock' : 17,
   *   'UnitsOnOrder' : 40,
   *   'ReorderLevel' : 25,
   *   'Discontinued' : false
   * }, {
   *   'ProductID' : 3,
   *   'ProductName' : "Aniseed Syrup",
   *   'SupplierID' : 1,
   *   'CategoryID' : 2,
   *   'QuantityPerUnit' : "12 - 550 ml bottles",
   *   'UnitPrice' : 10.0000,
   *   'UnitsInStock' : 13,
   *   'UnitsOnOrder' : 70,
   *   'ReorderLevel' : 25,
   *   'Discontinued' : false
   * }, {
   *   'ProductID' : 4,
   *   'ProductName' : "Chef Anton\'s Cajun Seasoning",
   *   'SupplierID' : 2,
   *  'CategoryID' : 2,
   *   'QuantityPerUnit' : "48 - 6 oz jars",
   *   'UnitPrice' : 22.0000,
   *   'UnitsInStock' : 53,
   *   'UnitsOnOrder' : 0,
   *   'ReorderLevel' : 0,
   *   'Discontinued' : false
   * }, {
   *   'ProductID' : 5,
   *   'ProductName' : "Chef Anton\'s Gumbo Mix",
   *   'SupplierID' : 2,
   *   'CategoryID' : 2,
   *   'QuantityPerUnit' : "36 boxes",
   *   'UnitPrice' : 21.3500,
   *   'UnitsInStock' : 0,
   *   'UnitsOnOrder' : 0,
   *   'ReorderLevel' : 0,
   *   'Discontinued' : true
   * }, {
   *   'ProductID' : 6,
   *   'ProductName' : "Grandma\'s Boysenberry Spread",
   *   'SupplierID' : 3,
   *   'CategoryID' : 2,
   *   'QuantityPerUnit' : "12 - 8 oz jars",
   *   'UnitPrice' : 25.0000,
   *   'UnitsInStock' : 120,
   *   'UnitsOnOrder' : 0,
   *   'ReorderLevel' : 25,
   *   'Discontinued' : false
   * }];
   * ```
   *
   */
  set pageSizes(pageSizes) {
    let normalizedItems = [];
    if (Array.isArray(pageSizes)) {
      pageSizes.forEach((item) => {
        if (typeof item === "number") {
          normalizedItems.push({
            text: item.toString(),
            value: item
          });
        } else {
          normalizedItems.push(item);
        }
      });
    } else {
      normalizedItems = DEFAULT_PAGE_SIZE_VALUES;
    }
    if (this.pageSize && !normalizedItems.some((item) => item.value === this.pageSize)) {
      normalizedItems = [{
        text: this.pageSize.toString(),
        value: this.pageSize
      }, ...normalizedItems];
    }
    this._pageSizes = normalizedItems;
  }
  /**
   * Specifies the padding of the dropdown.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  size = DEFAULT_SIZE4;
  /**
   * @hidden
   *
   * @readonly
   */
  get classes() {
    return true;
  }
  _pageSizes = [];
  constructor(localization, cd, pagerContext, element, ngZone) {
    super(localization, pagerContext, cd);
    this.pagerContext = pagerContext;
    this.element = element;
    this.ngZone = ngZone;
  }
  ngAfterViewInit() {
    this.ngZone.runOutsideAngular(() => {
      this.element.nativeElement.addEventListener("keydown", this.keyDownHandler.bind(this), true);
    });
  }
  ngOnDestroy() {
    this.element.nativeElement.removeEventListener("keydown", this.keyDownHandler);
  }
  /**
   * @hidden
   */
  pageSizeChange(value, dropdownlist) {
    const event = new PageSizeChangeEvent(value);
    this.pagerContext.changePageSize(event);
    if (event.isDefaultPrevented()) {
      dropdownlist.writeValue(this.pageSize);
    }
  }
  onChanges({
    total,
    skip: skip2,
    pageSize
  }) {
    this.total = total;
    this.skip = skip2;
    this.pageSize = typeof pageSize === "number" ? pageSize : this.total;
    this.cd.markForCheck();
  }
  keyDownHandler(ev) {
    if (ev.keyCode === Keys.Escape && this.dropDownList.isOpen) {
      ev.stopPropagation();
      this.dropDownList.toggle(false);
    }
  }
  static ɵfac = function PagerPageSizesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PagerPageSizesComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PagerContextService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PagerPageSizesComponent,
    selectors: [["kendo-datapager-page-sizes"], ["kendo-pager-page-sizes"]],
    viewQuery: function PagerPageSizesComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c07, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropDownList = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function PagerPageSizesComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-pager-sizes", ctx.classes);
      }
    },
    inputs: {
      pageSizes: "pageSizes",
      size: "size"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 3,
    vars: 6,
    consts: [["dropdownlist", ""], ["kendoPagerFocusable", "", "textField", "text", "valueField", "value", 3, "valueChange", "size", "data", "valuePrimitive", "value"]],
    template: function PagerPageSizesComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "kendo-dropdownlist", 1, 0);
        ɵɵlistener("valueChange", function PagerPageSizesComponent_Template_kendo_dropdownlist_valueChange_0_listener($event) {
          ɵɵrestoreView(_r1);
          const dropdownlist_r2 = ɵɵreference(1);
          return ɵɵresetView(ctx.pageSizeChange($event, dropdownlist_r2));
        });
        ɵɵelementEnd();
        ɵɵtext(2);
      }
      if (rf & 2) {
        ɵɵproperty("size", ctx.size)("data", ctx._pageSizes)("valuePrimitive", true)("value", ctx.pageSize);
        ɵɵattribute("aria-label", ctx.textFor("itemsPerPage"));
        ɵɵadvance(2);
        ɵɵtextInterpolate1(" ", ctx.textFor("itemsPerPage"), " ");
      }
    },
    dependencies: [DropDownListComponent, PagerFocusableDirective],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerPageSizesComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-datapager-page-sizes, kendo-pager-page-sizes",
      template: `
        <kendo-dropdownlist kendoPagerFocusable
            #dropdownlist
            [size]="size"
            [data]="_pageSizes"
            textField="text"
            valueField="value"
            [valuePrimitive]="true"
            [value]="pageSize"
            (valueChange)="pageSizeChange($event, dropdownlist)"
            [attr.aria-label]="textFor('itemsPerPage')"></kendo-dropdownlist>
        {{ textFor('itemsPerPage') }}
    `,
      standalone: true,
      imports: [DropDownListComponent, PagerFocusableDirective]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: PagerContextService
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, {
    dropDownList: [{
      type: ViewChild,
      args: ["dropdownlist", {
        static: true
      }]
    }],
    pageSizes: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    classes: [{
      type: HostBinding,
      args: ["class.k-pager-sizes"]
    }]
  });
})();
var PagerTemplateDirective = class _PagerTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PagerTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PagerTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PagerTemplateDirective,
    selectors: [["", "kendoDataPagerTemplate", ""], ["", "kendoPagerTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDataPagerTemplate], [kendoPagerTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var PagerNumericButtonsComponent = class _PagerNumericButtonsComponent extends PagerElementComponent {
  pagerContext;
  renderer;
  selectElement;
  numbersElement;
  /**
   * The count of the displayed buttons.
   *
   * @type {number}
   * @memberOf PagerNumericButtonsComponent
   */
  buttonCount;
  /**
   * Specifies the padding of the numeric buttons.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE4;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * @hidden
   *
   * @readonly
   * @type {number[]}
   * @memberOf PagerNumericButtonsComponent
   */
  get buttons() {
    const result = [];
    for (let idx2 = this.start; idx2 <= this.end; idx2++) {
      result.push(idx2);
    }
    return result;
  }
  /**
   * @hidden
   */
  get end() {
    return Math.min(this.start + this.buttonCount - 1, this.totalPages);
  }
  /**
   * @hidden
   */
  get start() {
    const page = this.currentPage;
    const buttonCount = this.buttonCount;
    if (page > buttonCount) {
      const reminder = page % buttonCount;
      return reminder === 0 ? page - buttonCount + 1 : page - reminder + 1;
    }
    return 1;
  }
  constructor(localization, cd, pagerContext, renderer) {
    super(localization, pagerContext, cd);
    this.pagerContext = pagerContext;
    this.renderer = renderer;
  }
  _size = DEFAULT_SIZE4;
  ngAfterViewInit() {
    this.handleClasses(this.size, "size");
  }
  /**
   * @hidden
   */
  pageLabel(num) {
    const pageText = this.textFor("page");
    if (pageText) {
      return pageText + " " + num;
    }
    return num.toString();
  }
  /**
   * @hidden
   */
  onSelectChange(e) {
    const target = e.target;
    const valueAsNumber = Number(target.value);
    if (!Number.isNaN(valueAsNumber)) {
      this.changePage(valueAsNumber - 1);
    } else {
      if (target.value === "previousButtons") {
        this.changePage(this.start - 2);
      } else {
        this.changePage(this.end);
      }
    }
  }
  onChanges({
    total,
    skip: skip2,
    pageSize
  }) {
    this.total = total;
    this.skip = skip2;
    this.pageSize = pageSize;
    this.cd.markForCheck();
  }
  get pageChooserLabel() {
    return this.textFor("selectPage");
  }
  handleClasses(value, input) {
    const elem = this.selectElement?.nativeElement;
    const classes = getStylingClasses3("picker", input, this[input], value);
    if (!elem) {
      return;
    }
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  static ɵfac = function PagerNumericButtonsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PagerNumericButtonsComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PagerContextService), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PagerNumericButtonsComponent,
    selectors: [["kendo-datapager-numeric-buttons"], ["kendo-pager-numeric-buttons"]],
    viewQuery: function PagerNumericButtonsComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c114, 5, ElementRef);
        ɵɵviewQuery(_c213, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.selectElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.numbersElement = _t.first);
      }
    },
    inputs: {
      buttonCount: "buttonCount",
      size: "size"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 10,
    vars: 8,
    consts: [["select", ""], ["numbers", ""], ["kendoPagerFocusable", "", 1, "k-hidden", "k-dropdown-list", "k-dropdown", "k-picker", "k-picker-solid", "k-rounded-md", 3, "change"], ["value", "previousButtons", 3, "selected", 4, "ngIf"], [3, "value", "selected", "ngClass", 4, "ngFor", "ngForOf"], ["value", "nextButtons", 3, "selected", 4, "ngIf"], [1, "k-pager-numbers"], ["type", "button", "kendoPagerFocusable", "", "kendoButton", "", "fillMode", "flat", "themeColor", "primary", "rounded", "none", 3, "size", "click", 4, "ngIf"], ["type", "button", "kendoPagerFocusable", "", "kendoButton", "", "fillMode", "flat", "themeColor", "primary", "rounded", "none", 3, "size", "selected", "click", 4, "ngFor", "ngForOf"], ["value", "previousButtons", 3, "selected"], [3, "value", "selected", "ngClass"], ["value", "nextButtons", 3, "selected"], ["type", "button", "kendoPagerFocusable", "", "kendoButton", "", "fillMode", "flat", "themeColor", "primary", "rounded", "none", 3, "click", "size"], ["type", "button", "kendoPagerFocusable", "", "kendoButton", "", "fillMode", "flat", "themeColor", "primary", "rounded", "none", 3, "click", "size", "selected"]],
    template: function PagerNumericButtonsComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "select", 2, 0);
        ɵɵlistener("change", function PagerNumericButtonsComponent_Template_select_change_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onSelectChange($event));
        });
        ɵɵtemplate(2, PagerNumericButtonsComponent_option_2_Template, 2, 2, "option", 3)(3, PagerNumericButtonsComponent_option_3_Template, 2, 8, "option", 4)(4, PagerNumericButtonsComponent_option_4_Template, 2, 2, "option", 5);
        ɵɵelementEnd();
        ɵɵelementStart(5, "div", 6, 1);
        ɵɵtemplate(7, PagerNumericButtonsComponent_button_7_Template, 2, 3, "button", 7)(8, PagerNumericButtonsComponent_button_8_Template, 2, 6, "button", 8)(9, PagerNumericButtonsComponent_button_9_Template, 2, 3, "button", 7);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵattribute("title", ctx.pageChooserLabel)("aria-label", ctx.pageChooserLabel);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.start > 1);
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.buttons);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.end < ctx.totalPages);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.start > 1);
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.buttons);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.end < ctx.totalPages);
      }
    },
    dependencies: [PagerFocusableDirective, NgIf, NgForOf, NgClass, ButtonComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerNumericButtonsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-datapager-numeric-buttons, kendo-pager-numeric-buttons",
      template: `
        <select kendoPagerFocusable #select
            class="k-hidden k-dropdown-list k-dropdown k-picker k-picker-solid k-rounded-md"
            [attr.title]="pageChooserLabel"
            [attr.aria-label]="pageChooserLabel"
            (change)="onSelectChange($event)">
            <option *ngIf="start > 1"
                value="previousButtons"
                [selected]="false"
                [attr.aria-label]="pageLabel(start - 1)">...
            </option>
            <option *ngFor="let num of buttons"
                [value]="num.toString()"
                [selected]="num === currentPage"
                [attr.aria-label]="pageLabel(num)"
                [attr.aria-current]="currentPage === num ? 'page' : undefined"
                [ngClass]="{'k-selected':currentPage === num}">
                {{num}}
            </option>
            <option *ngIf="end < totalPages"
                value="nextButtons"
                [selected]="false"
                [attr.aria-label]="pageLabel(end + 1)">...
            </option>
        </select>
        <div class="k-pager-numbers" #numbers>
            <button *ngIf="start > 1"
                type="button"
                kendoPagerFocusable
                kendoButton
                [size]="size"
                fillMode="flat"
                themeColor="primary"
                rounded="none"
                [attr.aria-label]="pageLabel(start - 1)"
                [attr.title]="pageLabel(start - 1)"
                (click)="changePage(start - 2)">...</button>
            <button *ngFor="let num of buttons"
                type="button"
                kendoPagerFocusable
                kendoButton
                [size]="size"
                fillMode="flat"
                themeColor="primary"
                rounded="none"
                [attr.aria-label]="pageLabel(num)"
                [attr.title]="pageLabel(num)"
                [attr.aria-current]="currentPage === num ? 'page' : undefined"
                [selected]="currentPage === num"
                (click)="changePage(num - 1)">
                {{num}}
            </button>
            <button *ngIf="end < totalPages"
                type="button"
                kendoPagerFocusable
                kendoButton
                [size]="size"
                fillMode="flat"
                themeColor="primary"
                rounded="none"
                [attr.aria-label]="pageLabel(end + 1)"
                [attr.title]="pageLabel(end + 1)"
                (click)="changePage(end)">...</button>
        </div>
    `,
      standalone: true,
      imports: [PagerFocusableDirective, NgIf, NgForOf, NgClass, ButtonComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: PagerContextService
    }, {
      type: Renderer2
    }];
  }, {
    selectElement: [{
      type: ViewChild,
      args: ["select", {
        read: ElementRef
      }]
    }],
    numbersElement: [{
      type: ViewChild,
      args: ["numbers", {
        read: ElementRef
      }]
    }],
    buttonCount: [{
      type: Input
    }],
    size: [{
      type: Input
    }]
  });
})();
var PagerNextButtonsComponent = class _PagerNextButtonsComponent extends PagerElementComponent {
  /**
   * @hidden
   *
   * @readonly
   * @type {boolean}
   * @memberOf PagerNextButtonsComponent
   */
  get disabled() {
    return this.currentPage === this.totalPages || !this.total;
  }
  /**
   * Specifies the padding of the buttons.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  size = DEFAULT_SIZE4;
  constructor(localization, pagerContext, cd) {
    super(localization, pagerContext, cd);
  }
  onChanges({
    total,
    skip: skip2,
    pageSize
  }) {
    this.total = total;
    this.skip = skip2;
    this.pageSize = pageSize;
    this.cd.markForCheck();
  }
  static ɵfac = function PagerNextButtonsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PagerNextButtonsComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(PagerContextService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PagerNextButtonsComponent,
    selectors: [["kendo-datapager-next-buttons"], ["kendo-pager-next-buttons"]],
    inputs: {
      size: "size"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 16,
    consts: [["kendoButton", "", "kendoPagerFocusable", "", "type", "button", "fillMode", "flat", "rounded", "none", 1, "k-pager-nav", 3, "click", "size", "icon", "svgIcon", "title"], ["kendoButton", "", "kendoPagerFocusable", "", "type", "button", "fillMode", "flat", "rounded", "none", 1, "k-pager-nav", "k-pager-last", 3, "click", "size", "icon", "svgIcon", "title"]],
    template: function PagerNextButtonsComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "button", 0);
        ɵɵlistener("click", function PagerNextButtonsComponent_Template_button_click_0_listener() {
          return ctx.currentPage !== ctx.totalPages ? ctx.changePage(ctx.currentPage) : false;
        });
        ɵɵelementEnd();
        ɵɵelementStart(1, "button", 1);
        ɵɵlistener("click", function PagerNextButtonsComponent_Template_button_click_1_listener() {
          return ctx.currentPage !== ctx.totalPages ? ctx.changePage(ctx.totalPages - 1) : false;
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassProp("k-disabled", ctx.disabled);
        ɵɵproperty("size", ctx.size)("icon", ctx.nextArrowIcons[0])("svgIcon", ctx.nextArrowSVGIcons[0])("title", ctx.textFor("nextPage"));
        ɵɵattribute("aria-disabled", ctx.disabled)("aria-label", ctx.textFor("nextPage"));
        ɵɵadvance();
        ɵɵclassProp("k-disabled", ctx.disabled);
        ɵɵproperty("size", ctx.size)("icon", ctx.nextArrowIcons[1])("svgIcon", ctx.nextArrowSVGIcons[1])("title", ctx.textFor("lastPage"));
        ɵɵattribute("aria-disabled", ctx.disabled)("aria-label", ctx.textFor("lastPage"));
      }
    },
    dependencies: [ButtonComponent, PagerFocusableDirective],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerNextButtonsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-datapager-next-buttons, kendo-pager-next-buttons",
      template: `
        <button kendoButton kendoPagerFocusable
            type="button"
            [size]="size"
            [icon]="nextArrowIcons[0]"
            [svgIcon]="nextArrowSVGIcons[0]"
            fillMode="flat"
            rounded="none"
            class="k-pager-nav"
            [attr.aria-disabled]="disabled"
            [class.k-disabled]="disabled"
            [title]="textFor('nextPage')"
            [attr.aria-label]="textFor('nextPage')"
            (click)="currentPage !== totalPages ? changePage(currentPage) : false">
        </button>
        <button kendoButton kendoPagerFocusable
            type="button"
            [size]="size"
            [icon]="nextArrowIcons[1]"
            [svgIcon]="nextArrowSVGIcons[1]"
            fillMode="flat"
            rounded="none"
            class="k-pager-nav k-pager-last"
            [attr.aria-disabled]="disabled"
            [class.k-disabled]="disabled"
            [title]="textFor('lastPage')"
            [attr.aria-label]="textFor('lastPage')"
            (click)="currentPage !== totalPages ? changePage(totalPages-1) : false">
        </button>
    `,
      standalone: true,
      imports: [ButtonComponent, PagerFocusableDirective]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: PagerContextService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    size: [{
      type: Input
    }]
  });
})();
var PagerInputComponent = class _PagerInputComponent extends PagerElementComponent {
  pagerContext;
  zone;
  renderer;
  numericInput;
  /**
   * Specifies the padding of the internal numeric input element.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  size = DEFAULT_SIZE4;
  constructor(localization, pagerContext, zone, cd, renderer) {
    super(localization, pagerContext, cd);
    this.pagerContext = pagerContext;
    this.zone = zone;
    this.renderer = renderer;
  }
  onChanges({
    total,
    skip: skip2,
    pageSize
  }) {
    this.total = total;
    this.skip = skip2;
    this.pageSize = pageSize;
    this.cd.markForCheck();
  }
  /**
   * @hidden
   *
   * @param {string} value
   *
   * @memberOf PagerInputComponent
   */
  handleKeyDown = (event) => {
    const incomingValue = this.numericInput.value || this.current;
    if (event.keyCode === Keys.Enter) {
      event.preventDefault();
      if (incomingValue !== this.current) {
        this.zone.run(() => {
          this.changePage(incomingValue - 1);
        });
      }
    }
  };
  /**
   * @hidden
   *
   * @param {string} value
   *
   * @memberOf PagerInputComponent
   */
  handleBlur = () => {
    const inputValue = this.numericInput.value;
    if (!inputValue) {
      this.numericInput.writeValue(this.current);
      return;
    }
    if (inputValue !== this.current) {
      this.zone.run(() => {
        this.changePage(inputValue - 1);
      });
    }
  };
  /**
   * @hidden
   */
  get current() {
    return this.hasPages ? this.currentPage : 0;
  }
  /**
   * @hidden
   */
  get hasPages() {
    return this.totalPages !== 0;
  }
  static ɵfac = function PagerInputComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PagerInputComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(PagerContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PagerInputComponent,
    selectors: [["kendo-datapager-input"], ["kendo-pager-input"]],
    viewQuery: function PagerInputComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(NumericTextBoxComponent, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.numericInput = _t.first);
      }
    },
    inputs: {
      size: "size"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 4,
    vars: 19,
    consts: [[1, "k-pager-input"], ["kendoPagerFocusable", "", "format", "n0", 3, "spinners", "decimals", "size", "disabled", "value", "min", "max", "autoCorrect", "inputAttributes", "title", "kendoEventsOutsideAngular"]],
    template: function PagerInputComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "span", 0);
        ɵɵtext(1);
        ɵɵelement(2, "kendo-numerictextbox", 1);
        ɵɵtext(3);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵtextInterpolate1(" ", ctx.textFor("page"), " ");
        ɵɵadvance();
        ɵɵproperty("spinners", false)("decimals", 0)("size", ctx.size)("disabled", !ctx.hasPages)("value", ctx.current)("min", ctx.hasPages ? 1 : 0)("max", ctx.totalPages)("autoCorrect", true)("inputAttributes", ɵɵpureFunction1(14, _c412, ctx.textFor("inputLabel")))("title", ctx.textFor("pageNumberInputTitle"))("kendoEventsOutsideAngular", ɵɵpureFunction2(16, _c512, ctx.handleKeyDown, ctx.handleBlur));
        ɵɵadvance();
        ɵɵtextInterpolate2(" ", ctx.textFor("of"), " ", ctx.totalPages, " ");
      }
    },
    dependencies: [NumericTextBoxComponent, PagerFocusableDirective, EventsOutsideAngularDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerInputComponent, [{
    type: Component,
    args: [{
      selector: "kendo-datapager-input, kendo-pager-input",
      template: `
     <span class="k-pager-input">
        {{textFor('page')}}
        <kendo-numerictextbox kendoPagerFocusable
            [spinners]="false"
            [decimals]="0"
            format="n0"
            [size]="size"
            [disabled]="!hasPages"
            [value]="current"
            [min]="hasPages ? 1 : 0"
            [max]="totalPages"
            [autoCorrect]="true"
            [inputAttributes]="{
                'aria-label': textFor('inputLabel')
            }"
            [title]="textFor('pageNumberInputTitle')"
            [kendoEventsOutsideAngular]="{
                keydown: handleKeyDown,
                focusout: handleBlur
            }">
        </kendo-numerictextbox>
        {{textFor('of')}} {{totalPages}}
     </span>
    `,
      standalone: true,
      imports: [NgClass, NumericTextBoxComponent, PagerFocusableDirective, EventsOutsideAngularDirective]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: PagerContextService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }];
  }, {
    numericInput: [{
      type: ViewChild,
      args: [NumericTextBoxComponent, {
        static: true
      }]
    }],
    size: [{
      type: Input
    }]
  });
})();
var PagerInfoComponent = class _PagerInfoComponent extends PagerElementComponent {
  /**
   * @hidden
   *
   * @readonly
   * @type {number}
   * @memberOf PagerInfoComponent
   */
  get maxItems() {
    return Math.min(this.currentPage * this.pageSize, this.total);
  }
  /**
   * @hidden
   *
   * @readonly
   * @type {number}
   * @memberOf PagerInfoComponent
   */
  get currentPageText() {
    return this.total ? (this.currentPage - 1) * this.pageSize + 1 : 0;
  }
  /**
   * @hidden
   *
   * @readonly
   * @type {boolean}
   * @memberOf PagerInfoComponent
   */
  hostClass = true;
  constructor(localization, cd, pagerContext) {
    super(localization, pagerContext, cd);
  }
  onChanges({
    total,
    skip: skip2,
    pageSize
  }) {
    this.total = total;
    this.skip = skip2;
    this.pageSize = pageSize;
    this.cd.markForCheck();
  }
  static ɵfac = function PagerInfoComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PagerInfoComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PagerContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PagerInfoComponent,
    selectors: [["kendo-datapager-info"], ["kendo-pager-info"]],
    hostVars: 2,
    hostBindings: function PagerInfoComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-pager-info", ctx.hostClass);
      }
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 1,
    vars: 5,
    template: function PagerInfoComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtext(0);
      }
      if (rf & 2) {
        ɵɵtextInterpolate5("", ctx.currentPageText, " - ", ctx.maxItems, " ", ctx.textFor("of"), " ", ctx.total, " ", ctx.textFor("items"), "");
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerInfoComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-datapager-info, kendo-pager-info",
      template: `{{currentPageText}} - {{maxItems}} {{textFor('of')}} {{total}} {{textFor('items')}}`,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: PagerContextService
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-pager-info"]
    }]
  });
})();
var packageMetadata8 = {
  name: "@progress/kendo-angular-pager",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 1745303990,
  version: "18.5.2",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var RESPONSIVE_BREAKPOINT_MEDIUM = 600;
var RESPONSIVE_BREAKPOINT_LARGE = 768;
var PagerComponent = class _PagerComponent {
  pagerContext;
  element;
  localization;
  renderer;
  ngZone;
  navigationService;
  template;
  /**
   * @hidden
   */
  externalTemplate;
  /**
   * Represents the total number of data items in the collection.
   *
   * @default 0
   */
  total = 0;
  /**
   * Defines the number of data items to be skipped.
   *
   * @default 0
   */
  skip = 0;
  /**
   * Defines the number of data items per page.
   */
  pageSize;
  /**
   * Sets the maximum numeric buttons count before the buttons are collapsed.
   *
   * @default 10
   */
  buttonCount = 10;
  /**
   * Toggles the information about the current page and the total number of records.
   *
   * @default true
   */
  info = true;
  /**
   * Defines the type of the pager.
   *
   * @default 'numeric'
   */
  type = "numeric";
  /**
   * Shows a dropdown for selecting the page size.
   * When set to `true`, the dropdown will contain the default list of options - 5, 10, 20.
   * To customize the list of options, set `pageSizeValues` to an array of the desired values.
   * The array can contain numbers and [PageSizeItem]({% slug api_pager_pagesizeitem %}) objects.
   */
  set pageSizeValues(value) {
    if (typeof value === "boolean") {
      this._pageSizeValues = value ? DEFAULT_PAGE_SIZE_VALUES : [];
    } else {
      this._pageSizeValues = value;
    }
  }
  /**
   * Toggles the **Previous** and **Next** buttons.
   *
   * @default true
   */
  previousNext = true;
  /**
   * If set to `true`, the user can use dedicated shortcuts to interact with the Pager ([see example]({% slug keyboard_navigation_pager %})).
   * By default, navigation is disabled and the Pager content is accessible in the normal tab sequence.
   * @default false
   */
  set navigable(value) {
    this._navigable = value;
    this.navigationService.isNavigable = value;
  }
  get navigable() {
    return this._navigable;
  }
  /**
   * Specifies the padding of all Pager elements.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE4;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * @hidden
   * Toggles the Pager responsive functionality.
   *
   * @default true
   */
  responsive = true;
  /**
   * Fires when the current page of the Pager is changed ([see example](slug:overview_pager)).
   * You have to handle the event yourself and page the data.
   */
  pageChange = new EventEmitter();
  /**
   * Fires when the page size of the Pager is changed.
   * You have to handle the event yourself and page the data.
   * If the event is prevented, the page size will remain unchanged ([see example]({% slug pager_events %})).
   */
  pageSizeChange = new EventEmitter();
  pagerClass = true;
  widgetRole = "application";
  roleDescription = "pager";
  keyShortcuts = "Enter ArrowRight ArrowLeft";
  get hostTabindex() {
    return this.navigable ? "0" : "-1";
  }
  get dir() {
    return this.direction;
  }
  /**
   * @hidden
   */
  focusHandler(ev) {
    const isInnerNavigationEnabled = ev.target !== this.element.nativeElement;
    this.navigationService.toggleInnerNavigation(isInnerNavigationEnabled);
  }
  get totalPages() {
    return Math.ceil((this.total || 0) / this.pageSize);
  }
  get currentPage() {
    return Math.floor((this.skip || 0) / this.pageSize) + 1;
  }
  get templateContext() {
    const context = this._templateContext;
    context.totalPages = this.totalPages;
    context.total = this.total;
    context.skip = this.skip;
    context.pageSize = this.pageSize;
    context.currentPage = this.currentPage;
    return context;
  }
  subscriptions = new Subscription();
  _templateContext = {};
  _pageSizeValues = DEFAULT_PAGE_SIZE_VALUES;
  direction;
  isInnerNavigationEnabled = false;
  _navigable = false;
  _size = DEFAULT_SIZE4;
  constructor(pagerContext, element, localization, renderer, ngZone, navigationService) {
    this.pagerContext = pagerContext;
    this.element = element;
    this.localization = localization;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.navigationService = navigationService;
    validatePackage(packageMetadata8);
    this.direction = localization.rtl ? "rtl" : "ltr";
    if (!navigationService) {
      this.navigationService = inject(PagerNavigationService);
    }
    if (!pagerContext) {
      this.pagerContext = inject(PagerContextService);
    }
    this.pagerContext.localization = localization;
  }
  ngOnInit() {
    this.subscriptions.add(this.pagerContext.pageChange.subscribe(this.changePage.bind(this)));
    this.subscriptions.add(this.pagerContext.pageSizeChange.subscribe(this.changePageSize.bind(this)));
    this.subscriptions.add(this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    }));
    this.subscriptions.add(this.navigationService.innerNavigationChange.subscribe(this.innerNavigationChange.bind(this)));
    if (this.navigable) {
      const wrapper = this.element.nativeElement;
      this.ngZone.runOutsideAngular(() => {
        this.subscriptions.add(this.renderer.listen(wrapper, "keydown", this.keyDownHandler.bind(this)));
      });
    }
  }
  ngAfterViewInit() {
    this.responsive && this.resizeHandler();
    this.renderer.setAttribute(this.element.nativeElement, "aria-label", this.ariaLabel);
    this.subscriptions.add(this.template.changes.subscribe(() => {
      this.responsive && this.resizeHandler();
    }));
    this.handleClasses(this.size, "size");
  }
  ngOnChanges(changes) {
    if (anyChanged(["pageSize", "skip", "total"], changes, false)) {
      this.pagerContext.notifyChanges({
        pageSize: this.pageSize,
        skip: this.skip,
        total: this.total
      });
      this.renderer.setAttribute(this.element.nativeElement, "aria-label", this.ariaLabel);
    }
    if (changes["responsive"]) {
      this.responsive && this.resizeHandler();
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  /**
   * @hidden
   */
  changePage(event) {
    this.pageChange.emit(event);
  }
  /**
   * @hidden
   */
  changePageSize(event) {
    this.pageSizeChange.emit(event);
    if (!event.isDefaultPrevented()) {
      if (event.newPageSize === "all") {
        this.pageChange.emit({
          skip: 0,
          take: this.total
        });
      } else {
        this.pageChange.emit({
          skip: 0,
          take: event.newPageSize
        });
      }
    }
  }
  /**
   * @hidden
   */
  onPageSizeChange(event) {
    this.pageSizeChange.emit(event);
    if (!event.isDefaultPrevented()) {
      this.pageChange.emit({
        skip: this.skip,
        take: event.newPageSize
      });
    }
  }
  /**
   * @hidden
   */
  resizeHandler = () => {
    if (this.template?.first && !this.responsive) {
      return;
    }
    const width = this.element.nativeElement.offsetWidth;
    this.ngZone.runOutsideAngular(() => {
      setTimeout(() => {
        const numericButtonsElement = this.element.nativeElement.querySelector("kendo-datapager-numeric-buttons, kendo-pager-numeric-buttons");
        const pagerInfoElement = this.element.nativeElement.querySelector(".k-pager-info");
        const pagerPageSizes = this.element.nativeElement.querySelector(".k-pager-sizes");
        if (numericButtonsElement) {
          const selectElement = numericButtonsElement.querySelector("select");
          const numbersElement = numericButtonsElement.querySelector(".k-pager-numbers");
          if (width < RESPONSIVE_BREAKPOINT_MEDIUM) {
            this.renderer.removeClass(selectElement, "k-hidden");
            this.renderer.addClass(numbersElement, "k-hidden");
          } else {
            this.renderer.addClass(selectElement, "k-hidden");
            this.renderer.removeClass(numbersElement, "k-hidden");
          }
        }
        if (pagerInfoElement) {
          if (width < RESPONSIVE_BREAKPOINT_LARGE) {
            this.renderer.addClass(pagerInfoElement, "k-hidden");
          } else {
            this.renderer.removeClass(pagerInfoElement, "k-hidden");
          }
        }
        if (pagerPageSizes) {
          if (width < RESPONSIVE_BREAKPOINT_MEDIUM) {
            this.renderer.addClass(pagerPageSizes, "k-hidden");
          } else {
            this.renderer.removeClass(pagerPageSizes, "k-hidden");
          }
        }
      });
    });
  };
  get ariaLabel() {
    const localizationMsg = this.localization.get("ariaLabel") || "";
    return replaceMessagePlaceholder2(replaceMessagePlaceholder2(localizationMsg, "currentPage", this.currentPage.toString()), "totalPages", this.totalPages.toString());
  }
  keyDownHandler(e) {
    const target = e.target;
    const wrapper = this.element.nativeElement;
    const isArrowLeftOrPageUp = e.keyCode === Keys.ArrowLeft || e.keyCode === Keys.PageUp;
    const isArrowRightOrPageDown = e.keyCode === Keys.ArrowRight || e.keyCode === Keys.PageDown;
    const isEnter = e.keyCode === Keys.Enter;
    const isHome = e.keyCode === Keys.Home;
    const isEnd = e.keyCode === Keys.End;
    const isEsc = e.keyCode === Keys.Escape;
    const isTab = e.keyCode === Keys.Tab;
    const isFirstPage = this.currentPage === 1;
    const isLastPage = this.currentPage === this.totalPages;
    this.ngZone.run(() => {
      if (isHome) {
        if (e.target !== wrapper) {
          return;
        }
        e.preventDefault();
        !isFirstPage && this.pagerContext.changePage(0);
      } else if (isEnd) {
        e.preventDefault();
        if (e.target !== wrapper) {
          return;
        }
        !isLastPage && this.pagerContext.changePage(this.totalPages - 1);
      } else if (this.isInnerNavigationEnabled) {
        if (isEsc) {
          this.navigationService.toggleInnerNavigation(false);
          wrapper.focus();
        } else if (isTab) {
          this.navigationService.keepFocusWithinComponent(wrapper, target, e);
        }
      } else {
        if (e.target !== wrapper) {
          return;
        }
        if (isArrowLeftOrPageUp) {
          e.preventDefault();
          !isFirstPage && this.pagerContext.prevPage();
        } else if (isArrowRightOrPageDown) {
          e.preventDefault();
          !isLastPage && this.pagerContext.nextPage();
        } else if (isEnter) {
          e.preventDefault();
          const [firstFocusable] = this.navigationService.getFirstAndLastFocusable(wrapper);
          this.navigationService.toggleInnerNavigation(true);
          firstFocusable?.focus();
        }
      }
    });
  }
  innerNavigationChange(value) {
    this.isInnerNavigationEnabled = value;
  }
  handleClasses(value, input) {
    const elem = this.element.nativeElement;
    const classes = getStylingClasses3("pager", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  static ɵfac = function PagerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PagerComponent)(ɵɵdirectiveInject(PagerContextService, 12), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(PagerNavigationService, 12));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PagerComponent,
    selectors: [["kendo-datapager"], ["kendo-pager"]],
    contentQueries: function PagerComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PagerTemplateDirective, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t);
      }
    },
    hostVars: 7,
    hostBindings: function PagerComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("focusin", function PagerComponent_focusin_HostBindingHandler($event) {
          return ctx.focusHandler($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("role", ctx.widgetRole)("aria-roledescription", ctx.roleDescription)("aria-keyshortcuts", ctx.keyShortcuts)("tabindex", ctx.hostTabindex)("dir", ctx.dir);
        ɵɵclassProp("k-pager", ctx.pagerClass);
      }
    },
    inputs: {
      externalTemplate: "externalTemplate",
      total: "total",
      skip: "skip",
      pageSize: "pageSize",
      buttonCount: "buttonCount",
      info: "info",
      type: "type",
      pageSizeValues: "pageSizeValues",
      previousNext: "previousNext",
      navigable: "navigable",
      size: "size",
      responsive: "responsive"
    },
    outputs: {
      pageChange: "pageChange",
      pageSizeChange: "pageSizeChange"
    },
    exportAs: ["kendoDataPager", "kendoPager"],
    features: [ɵɵProvidersFeature([LocalizationService, PagerContextService, PagerNavigationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.pager"
    }]), ɵɵNgOnChangesFeature],
    decls: 6,
    vars: 4,
    consts: () => {
      let i18n_0;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_0 = goog.getMsg("Go to the first page");
        i18n_0 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_0;
      } else {
        i18n_0 = $localize`:kendo.pager.firstPage|The label for the first page button in the Pager:Go to the first page`;
      }
      let i18n_1;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_1 = goog.getMsg("Go to the previous page");
        i18n_1 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_1;
      } else {
        i18n_1 = $localize`:kendo.pager.previousPage|The label for the previous page button in the Pager:Go to the previous page`;
      }
      let i18n_2;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_2 = goog.getMsg("Go to the next page");
        i18n_2 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_2;
      } else {
        i18n_2 = $localize`:kendo.pager.nextPage|The label for the next page button in the Pager:Go to the next page`;
      }
      let i18n_3;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_3 = goog.getMsg("Go to the last page");
        i18n_3 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_3;
      } else {
        i18n_3 = $localize`:kendo.pager.lastPage|The label for the last page button in the Pager:Go to the last page`;
      }
      let i18n_4;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_4 = goog.getMsg("Page");
        i18n_4 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_4;
      } else {
        i18n_4 = $localize`:kendo.pager.page|The label before the current page number in the Pager:Page`;
      }
      let i18n_5;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_5 = goog.getMsg("of");
        i18n_5 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_5;
      } else {
        i18n_5 = $localize`:kendo.pager.of|The label before the total pages number in the Pager:of`;
      }
      let i18n_6;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_6 = goog.getMsg("Page Number");
        i18n_6 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_6;
      } else {
        i18n_6 = $localize`:kendo.pager.pageNumberInputTitle|The label for the pager input in the Pager:Page Number`;
      }
      let i18n_7;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_7 = goog.getMsg("items");
        i18n_7 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_7;
      } else {
        i18n_7 = $localize`:kendo.pager.items|The label after the total pages number in the Pager:items`;
      }
      let i18n_8;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_8 = goog.getMsg("items per page");
        i18n_8 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_8;
      } else {
        i18n_8 = $localize`:kendo.pager.itemsPerPage|The label for the page size chooser in the Pager:items per page`;
      }
      let i18n_9;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_9 = goog.getMsg("Select page");
        i18n_9 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_9;
      } else {
        i18n_9 = $localize`:kendo.pager.selectPage|The text of the title and aria-label attributes applied to the page chooser in the Pager:Select page`;
      }
      let i18n_10;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_10 = goog.getMsg("Type a page number");
        i18n_10 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_10;
      } else {
        i18n_10 = $localize`:kendo.pager.inputLabel|The text of the aria-label attribute applied to the input element for entering the page number.:Type a page number`;
      }
      let i18n_11;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_11 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ 'Page navigation, page {currentPage} of {totalPages}' }}"
          }
        });
        i18n_11 = MSG_C__USERS_THOUS_DOWNLOADS_PORTFOLIO_ANGULAR_PORTI_PORTFOLIO_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_11;
      } else {
        i18n_11 = $localize`:kendo.pager.ariaLabel|The value of the aria-label attribute of the Pager:${"�0�"}:INTERPOLATION:`;
      }
      return [["default", ""], ["ariaLabel", i18n_11], ["kendoPagerLocalizedMessages", "", "firstPage", i18n_0, "previousPage", i18n_1, "nextPage", i18n_2, "lastPage", i18n_3, "page", i18n_4, "of", i18n_5, "pageNumberInputTitle", i18n_6, "items", i18n_7, "itemsPerPage", i18n_8, "selectPage", i18n_9, "inputLabel", i18n_10, 6, "ariaLabel"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf", "ngIfElse"], [3, "resize", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-pager-numbers-wrap"], [3, "size", 4, "ngIf"], [3, "size", "buttonCount", 4, "ngIf"], [3, "size", "pageSizes", 4, "ngIf"], [4, "ngIf"], [3, "size"], [3, "size", "buttonCount"], [3, "size", "pageSizes"], [3, "resize"]];
    },
    template: function PagerComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainerStart(0, 2);
        ɵɵi18nAttributes(1, 1);
        ɵɵelementContainerEnd();
        ɵɵtemplate(2, PagerComponent_ng_container_2_Template, 1, 2, "ng-container", 3)(3, PagerComponent_ng_template_3_Template, 7, 6, "ng-template", null, 0, ɵɵtemplateRefExtractor)(5, PagerComponent_kendo_resize_sensor_5_Template, 1, 0, "kendo-resize-sensor", 4);
      }
      if (rf & 2) {
        const default_r3 = ɵɵreference(4);
        ɵɵi18nExp("Page navigation, page {currentPage} of {totalPages}");
        ɵɵi18nApply(1);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.template.first == null ? null : ctx.template.first.templateRef)("ngIfElse", default_r3);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.responsive);
      }
    },
    dependencies: [LocalizedMessagesDirective4, NgIf, NgTemplateOutlet, PagerPrevButtonsComponent, PagerNumericButtonsComponent, PagerInputComponent, PagerNextButtonsComponent, PagerPageSizesComponent, PagerInfoComponent, ResizeSensorComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerComponent, [{
    type: Component,
    args: [{
      selector: "kendo-datapager, kendo-pager",
      exportAs: "kendoDataPager, kendoPager",
      providers: [LocalizationService, PagerContextService, PagerNavigationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.pager"
      }],
      template: `
        <ng-container kendoPagerLocalizedMessages
            i18n-ariaLabel="kendo.pager.ariaLabel|The value of the aria-label attribute of the Pager"
            ariaLabel="{{ 'Page navigation, page {currentPage} of {totalPages}' }}"

            i18n-firstPage="kendo.pager.firstPage|The label for the first page button in the Pager"
            firstPage="Go to the first page"

            i18n-previousPage="kendo.pager.previousPage|The label for the previous page button in the Pager"
            previousPage="Go to the previous page"

            i18n-nextPage="kendo.pager.nextPage|The label for the next page button in the Pager"
            nextPage="Go to the next page"

            i18n-lastPage="kendo.pager.lastPage|The label for the last page button in the Pager"
            lastPage="Go to the last page"

            i18n-page="kendo.pager.page|The label before the current page number in the Pager"
            page="Page"

            i18n-of="kendo.pager.of|The label before the total pages number in the Pager"
            of="of"

            i18n-pageNumberInputTitle="kendo.pager.pageNumberInputTitle|The label for the pager input in the Pager"
            pageNumberInputTitle="Page Number"

            i18n-items="kendo.pager.items|The label after the total pages number in the Pager"
            items="items"

            i18n-itemsPerPage="kendo.pager.itemsPerPage|The label for the page size chooser in the Pager"
            itemsPerPage="items per page"

            i18n-selectPage="kendo.pager.selectPage|The text of the title and aria-label attributes applied to the page chooser in the Pager"
            selectPage="Select page"

            i18n-inputLabel="kendo.pager.inputLabel|The text of the aria-label attribute applied to the input element for entering the page number."
            inputLabel="Type a page number"
         >
        </ng-container>
        <ng-container
            *ngIf="template.first?.templateRef; else default"
            [ngTemplateOutlet]="template.first?.templateRef"
            [ngTemplateOutletContext]="templateContext">
        </ng-container>
        <ng-template #default>
            <div class="k-pager-numbers-wrap">
                <kendo-pager-prev-buttons [size]="size" *ngIf="previousNext"></kendo-pager-prev-buttons>
                <kendo-pager-numeric-buttons
                    [size]="size"
                    *ngIf="type === 'numeric' && buttonCount > 0"
                    [buttonCount]="buttonCount">
                </kendo-pager-numeric-buttons>
                <kendo-pager-input [size]="size" *ngIf="type === 'input'"></kendo-pager-input>
                <kendo-pager-next-buttons [size]="size" *ngIf="previousNext"></kendo-pager-next-buttons>
            </div>
            <kendo-pager-page-sizes *ngIf="_pageSizeValues.length"
                [size]="size"
                [pageSizes]="_pageSizeValues">
            </kendo-pager-page-sizes>
            <kendo-pager-info *ngIf="info">
            </kendo-pager-info>
        </ng-template>
        <kendo-resize-sensor *ngIf="responsive" (resize)="resizeHandler()"></kendo-resize-sensor>
  `,
      standalone: true,
      imports: [LocalizedMessagesDirective4, NgIf, NgTemplateOutlet, PagerPrevButtonsComponent, PagerNumericButtonsComponent, PagerInputComponent, PagerNextButtonsComponent, PagerPageSizesComponent, PagerInfoComponent, ResizeSensorComponent]
    }]
  }], function() {
    return [{
      type: PagerContextService,
      decorators: [{
        type: Optional
      }, {
        type: SkipSelf
      }]
    }, {
      type: ElementRef
    }, {
      type: LocalizationService
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: PagerNavigationService,
      decorators: [{
        type: Optional
      }, {
        type: SkipSelf
      }]
    }];
  }, {
    template: [{
      type: ContentChildren,
      args: [PagerTemplateDirective]
    }],
    externalTemplate: [{
      type: Input
    }],
    total: [{
      type: Input
    }],
    skip: [{
      type: Input
    }],
    pageSize: [{
      type: Input
    }],
    buttonCount: [{
      type: Input
    }],
    info: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    pageSizeValues: [{
      type: Input
    }],
    previousNext: [{
      type: Input
    }],
    navigable: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    responsive: [{
      type: Input
    }],
    pageChange: [{
      type: Output
    }],
    pageSizeChange: [{
      type: Output
    }],
    pagerClass: [{
      type: HostBinding,
      args: ["class.k-pager"]
    }],
    widgetRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    roleDescription: [{
      type: HostBinding,
      args: ["attr.aria-roledescription"]
    }],
    keyShortcuts: [{
      type: HostBinding,
      args: ["attr.aria-keyshortcuts"]
    }],
    hostTabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    focusHandler: [{
      type: HostListener,
      args: ["focusin", ["$event"]]
    }]
  });
})();
var PagerSpacerComponent = class _PagerSpacerComponent {
  hostClass = true;
  get sizedClass() {
    return isPresent(this.width);
  }
  get flexBasisStyle() {
    return this.width;
  }
  /**
   * Specifies the width of the PagerSpacer.
   * Accepts the [string values of the CSS `flex-basis` property](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-basis).
   *
   * If not set, the PagerSpacer will take all the available space.
   */
  width;
  static ɵfac = function PagerSpacerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PagerSpacerComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PagerSpacerComponent,
    selectors: [["kendo-pager-spacer"]],
    hostVars: 6,
    hostBindings: function PagerSpacerComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("flex-basis", ctx.flexBasisStyle);
        ɵɵclassProp("k-spacer", ctx.hostClass)("k-spacer-sized", ctx.sizedClass);
      }
    },
    inputs: {
      width: "width"
    },
    decls: 0,
    vars: 0,
    template: function PagerSpacerComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerSpacerComponent, [{
    type: Component,
    args: [{
      selector: "kendo-pager-spacer",
      template: ``,
      standalone: true
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-spacer"]
    }],
    sizedClass: [{
      type: HostBinding,
      args: ["class.k-spacer-sized"]
    }],
    flexBasisStyle: [{
      type: HostBinding,
      args: ["style.flexBasis"]
    }],
    width: [{
      type: Input
    }]
  });
})();
var KENDO_PAGER = [CustomMessagesComponent4, PagerFocusableDirective, PagerInfoComponent, PagerInputComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerPageSizesComponent, PagerPrevButtonsComponent, PagerTemplateDirective, PagerComponent, PagerSpacerComponent];
var PagerModule = class _PagerModule {
  static ɵfac = function PagerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PagerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PagerModule,
    imports: [CustomMessagesComponent4, PagerFocusableDirective, PagerInfoComponent, PagerInputComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerPageSizesComponent, PagerPrevButtonsComponent, PagerTemplateDirective, PagerComponent, PagerSpacerComponent],
    exports: [CustomMessagesComponent4, PagerFocusableDirective, PagerInfoComponent, PagerInputComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerPageSizesComponent, PagerPrevButtonsComponent, PagerTemplateDirective, PagerComponent, PagerSpacerComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, PopupService, ResizeBatchService],
    imports: [PagerInputComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerPageSizesComponent, PagerPrevButtonsComponent, PagerComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_PAGER],
      imports: [...KENDO_PAGER],
      providers: [IconsService, PopupService, ResizeBatchService]
    }]
  }], null, null);
})();

export {
  DragTargetContainerDirective,
  DropTargetContainerDirective,
  AdaptiveService,
  ActionSheetTemplateDirective,
  ActionSheetComponent,
  toString,
  localeData,
  IntlService,
  DatePipe,
  Inflate,
  Deflate,
  exportPDF,
  drawDOM,
  DialogActionsComponent,
  DialogRef,
  DialogContentBase,
  DialogContainerService,
  DialogService,
  WindowContainerService,
  WindowService,
  NumericTextBoxComponent,
  NumericTextBoxCustomMessagesComponent,
  CheckBoxComponent,
  TextBoxComponent,
  ErrorComponent,
  HintComponent2 as HintComponent,
  FormFieldComponent,
  RadioButtonComponent,
  KENDO_TEXTBOX,
  KENDO_NUMERICTEXTBOX,
  KENDO_CHECKBOX,
  KENDO_FORMFIELD,
  AutoCompleteComponent,
  DropDownListComponent,
  PageSizeChangeEvent,
  CustomMessagesComponent4 as CustomMessagesComponent,
  LocalizedMessagesDirective4 as LocalizedMessagesDirective,
  PagerContextService,
  PagerNavigationService,
  PagerFocusableDirective,
  PagerPrevButtonsComponent,
  PagerPageSizesComponent,
  PagerTemplateDirective,
  PagerNumericButtonsComponent,
  PagerNextButtonsComponent,
  PagerInputComponent,
  PagerInfoComponent,
  PagerComponent,
  PagerSpacerComponent,
  KENDO_PAGER,
  PagerModule
};
//# sourceMappingURL=chunk-VS5HC2CB.js.map
